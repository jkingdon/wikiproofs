__NEWSECTIONLINK__
{{header
 | title    = Tearoom
 | subtitle =
 | left     = 
 | right    = 
 | shortcut = [[WP:TEA]]
 | notes    = The tearoom is Wikiproof's central discussion page. Feel free to [{{fullurl:Wikiproofs:Tearoom|action=edit&section=new}} start a new topic] or join an existing discussion.
}}[[Image:Meissen-teacup pinkrose01.jpg|thumb|right|Cup of tea about to be converted into a conjecture by skilled mathematicians]]

== Example discussion ==

Please sign your post with four tildes.--[[User:GrafZahl|GrafZahl]]&nbsp;([[User talk:GrafZahl|talk]]) 22:15, 5 June 2009 (UTC)

[[Category:Wikiproofs|Tearoom]]

== better error message for failed export? ==

I thought I would see whether I could make any progress on finishing [[Principia Mathematica propositional logic]]. A little experimentation seemed to show that if an export fails because the page is missing a <code>thm</code> for one of the <code>stmt</code> in the interface, the error message fails to tell the user which <code>stmt</code> was unproved. Would it be easy to add this to the error message? [[User:Kingdon|Kingdon]] 23:48, 3 January 2010 (UTC)

:What was the error message you were getting? You may also want to try the command line version of JHilbert [http://www.mathi.uni-heidelberg.de/~alex/jhilbert/downloads.html] with different debug level settings.--[[User:GrafZahl|GrafZahl]]&nbsp;([[User talk:GrafZahl|talk]]) 08:22, 6 January 2010 (UTC)

::The easiest way to reproduce this is to go to [[Nicod's reduction of Principia Mathematica]], remove the line "thm (.Add () () (q .→ (p .∨ q)) (" (and the next three lines which go with it), and click preview. The error is:
 export (PRINCIPIA Interface:Principia_Mathematica_propositional_logic () . Unable to export parameter 
 PRINCIPIA(Interface:Principia_Mathematica_propositional_logic)[]+.: Parameter mismatch: object not found
::I would have hoped for something like "export failed: statement Add is not proven". It might turn out that downloading JHilbert and the pages in question is indeed going to be the easiest way to work, but part of what excited me about wikiproofs was the possibility of skipping that step. [[User:Kingdon|Kingdon]] 02:40, 7 January 2010 (UTC)

:::Should be fixed now. The trouble with the current state of affairs is that JHilbert is the outgrowth of command line utilities and the logging/reporting facilities of JHilbert in command line mode vs. server mode are still quite conflated. I'm working on a rewrite but with all my RL stuff things are going very slowly atm.--[[User:GrafZahl|GrafZahl]]&nbsp;([[User talk:GrafZahl|talk]]) 06:41, 7 January 2010 (UTC)

::::Thanks, looks much better.  Don't get too stressed about it; there probably would have been workarounds to this problem. [[User:Kingdon|Kingdon]] 15:18, 7 January 2010 (UTC)

== doubled names ==

If I look at [[Interface:Nicod axioms]], the rendered page contains:
 def (¬¬ p) (p | p))
In case it helps, the HTML for the doubled ¬ is:
 <nowiki><span class="beginexp">¬</span><span class="def">¬</span></nowiki>

Clicking on "edit" shows only a single character:
 def ((¬ p) (p | p))

I believe this started happening within the last day or so.

One other thing (which might not be related, or even a bug at all). Uncommenting both commented out lines at [[Sandbox]] shows an error
 def (.¬.¬ p Variable not found Variable not found: (cause unknown)

:Seems like the last update introduced some sort of bug (a <code>beginexp</code> is an opening parenthesis, nothing else). Maybe I can look into it over the weekend.--[[User:GrafZahl|GrafZahl]]&nbsp;([[User talk:GrafZahl|talk]]) 10:45, 8 January 2010 (UTC)

::The name doubling bug is fixed now. The "variable not found" message is not a bug. You must define all variable names anew for each module: variable names are always local. This makes sense as variables usually have very simple (one or two letter) identifiers and you wouldn't want them to clash due to kind mismatches over several modules.--[[User:GrafZahl|GrafZahl]]&nbsp;([[User talk:GrafZahl|talk]]) 14:37, 9 January 2010 (UTC)

:::Ah, thanks for noticing that.  The only connection between the two is that the doubling bug affected the text of the error message (the existence of the message was, as you point out, unrelated). [[User:Kingdon|Kingdon]] 02:08, 10 January 2010 (UTC)

== Similar-looking characters ==

When copying formulas from other web sites, one is sometimes nailed by similar-looking characters. The two which have come up so far are:

* metamath uses ⋀ (U+22C0 N-ARY LOGICAL AND) for its ordinary conjunction character, we use ∧ (U+2227 LOGICAL AND).  It is easy to make the case that metamath is just wrong on this one, and at least in my font the two are moderately different from each other.

* We use ⋅ (U+22C5 DOT OPERATOR) for multiplication (at least, that's the one at the bottom of the edit screen). On wikipedia, at least on [[w:Peano arithmetic]], they use · (U+00B7 MIDDLE DOT). These look extremely similar, and I don't really see how we can expect contributors to try to keep them straight.

Is there a mediawiki feature to map all U+00B7 to U+22C5? I'm thinking of the feature of [http://eo.wikipedia.org eo.wikipedia.org] which maps "cx" to "ĉ" (U+0109 LATIN SMALL LETTER C WITH CIRCUMFLEX) although I'm not sure that particular behavior is exactly what we want (I haven't gotten desperate enough to actually read any mediawiki documentation, so I have no idea how many choices there are).

It turns out to be pretty handy to copy-paste short formulas from one website to another, and modulo some parentheses and such it tends to work fairly well (even with ↔, ∀, ∃, etc), except for the problem characters above. [[User:Kingdon|Kingdon]] 02:37, 23 February 2010 (UTC)

:Metamath also uses U+00B7 MIDDLE DOT (for example in [http://us.metamath.org/mpeuni/sqr2irr.html sqr2irr]).  Perhaps the solution to that one is just to switch. Dunno. [[User:Kingdon|Kingdon]] 02:48, 23 February 2010 (UTC)

::I've switched the dot in [[MediaWiki:Edittools]] for now. On my system, the characters ⋀ and ∧ look markedly different on the rendered webpage, but only moderately different in the editor window (which uses a fixed-width font). Raph and I already discussed this problem some months ago. The correct solution is probably to define equivalence classes of similar-looking characters within JHilbert. That won't happen too soon, though, as there are other, more pressing problems. Meanwhile, it seems sensible to install an equivalence mapping in MediaWiki if it's not too dear. Do you have any idea how the Esperanto Wikipedia people implement their "cx" mapping? Some extension, or some Javascript?--[[User:GrafZahl|GrafZahl]]&nbsp;([[User talk:GrafZahl|talk]]) 09:33, 23 February 2010 (UTC)

:::The Esperanto wikipedia doesn't rely on javascript; it works without it (and, obviously, doesn't map any characters until the page is submitted).  I don't think it is what we want, though, as the character gets mapped back to "cx" for editing.  I'm not sure I like the JHilbert solution, as it would lead to pages containing a mixture of different symbols and the reader would be expected to figure out which ones are equivalent (particular in a case like the conjunction, where the wrong symbol really does look wrong, at least to my eyes). None of this is particularly high priority, though (especially since the dot seems managed for now), so I wouldn't lose any sleep over it. [[User:Kingdon|Kingdon]] 13:58, 23 February 2010 (UTC)

::::Now this is odd. The cx and friends replacement is hard-coded in <code>./languages/classes/LanguageEo.php</code> of the MediaWiki source. So this is not an easy way to maintain character mappings. The original JHilbert plan was to create equivalence classes only for characters that can be expected to be rendered equally by common fonts (such as the two dots), i.e. roughly the same class of cases where you would apply it to host/domain names for security reasons. For merely similar looking characters, one could implement canonical mappings. This would effectively eliminate non-canonical characters from JHilbert text (but not all Wiki text). Not sure if that's what we really want, so, as you suggest, let's wait and see for now.--[[User:GrafZahl|GrafZahl]]&nbsp;([[User talk:GrafZahl|talk]]) 15:24, 23 February 2010 (UTC)

== Add ≠ to edit tools ==

I propose to add ≠ (U+2260 NOT EQUAL TO) to [[MediaWiki:Edittools]], just to the right of ∃. [[User:Kingdon|Kingdon]] 16:46, 3 March 2010 (UTC)

:Done.--[[User:GrafZahl|GrafZahl]]&nbsp;([[User talk:GrafZahl|talk]]) 17:59, 3 March 2010 (UTC)

::Thanks, looks good. [[User:Kingdon|Kingdon]] 19:38, 3 March 2010 (UTC)

== Kind verification and coercion ==

I'm concerned about something and want to make sure it gets attention.

In [[Interface:First-order_logic]], subst is introduced, then in [[First-order_logic]] defined:

<pre>
term (formula (subst object object formula))
def ((subst y x φ) (((x = y) → φ) ∧ (∃ x ((x = y) ∧ φ))))
</pre>

But in [[Basic_arithmetic]] it is being invoked quite a bit with terms of kind "nat", rather than "object".

Is kind verification not working? If not, I think there is serious risk of unsoundness.

Also, I realize I don't understand enough about the kind system in JHilbert to know whether terms of one kind can be implicitly coerced into another. In set.mm, then answer is "yes," due to this rule:

<pre>
  cv $a class x $.
</pre>

In old Ghilbert, all such syntactical productions need to have explicit s-expression counterparts. Thus, you saw an awful lot of (cv x) for variables that appear in class contexts. The idea was that such things would go away when presenting theorems in the typeset syntax, but it was still awkward and painful to deal with. Thus, getting rid of that was one of the explicit motivations to switch from distinct variables to free variables in the new Ghilbert (thus, the new distinction between var and tvar, for binding and term variables respectively).

So, does JHilbert do implicit coercion from one kind to another? If so, how is it controlled to make sure it's sound? If not, I'm pretty sure there's some serious wrongness going on in the first order logic area here. {{unsigned|17:53, 3 March 2010|Raph}}

:In JHilbert "coercion" (one form of <code>kindbind</code>) is mutual, meaning that in effect, there is only one kind with two or more names. (I'm pretty sure the old Ghilbert already had this functionality.) In particular, you should not bind <code>set</code> and <code>class</code> as then, all classes would be sets (which means you still need <code>term (class (cv set))</code> or a similar construct).

:You can use <code>kindbind</code> in two ways. The first one is to create a new name for an already existing kind. The second one, available in interfaces only, is to declare two already existing kinds imported via <code>param</code> to be equivalent. Of course, both can be dangerous in their way. The first one in a purely semantic manner: if you declare <code>nat</code> to be another name for <code>object</code> and your universe of discourse is not actually the natural numbers, you'll confuse the hell out of your users. The second one can break things badly if you bind things together that don't belong together, such as <code>formula</code> and <code>object</code>. That's why it's only available in interfaces.

:--[[User:GrafZahl|GrafZahl]]&nbsp;([[User talk:GrafZahl|talk]]) 18:56, 3 March 2010 (UTC)

::Okay, but I'm pretty sure what I'm talking about is completely separate from kindbind. You ''cannot'' alias the kinds for binding variables and terms (set and class in the set.mm universe). If you did, then ∃ (1) ((1) = (2)) would be not only a well-formed expression, but actually a theorem. So I'm pretty confused now what kinds of protection JHilbert has against this. [Fyi, new Ghilbert has very cut-down kindbind, which cannot be used to unify two existing kinds, but only to introduce a new name for an existing kind, which is useful when exporting from an "adapter". This seems obviously sound to me but I am worried it's too restrictive.]

::Also, nowhere in the interfaces or proof files referenced above did I find any actual invocation of kindbind. From what I can tell, the term was defined with one vector of kind args, and instantiated with another. [[User:Raph|Raph]] 19:24, 3 March 2010 (UTC)

:::I also answered this at [[Talk:First-order logic]] (a few days ago), but the kindbind is in [[Interface:Peano axioms]] (which is imported by [[Basic arithmetic]]). [[User:Kingdon|Kingdon]] 19:36, 3 March 2010 (UTC)

::::Ah, sorry to have missed the response there (I do try to follow Recent Changes but sometimes miss things). I'm 99% sure that kindbind is invalid, that your axiomatization of Peano is unsound, and that in particular I can prove the above nonsensical theorem. I'd be happy to be convinced otherwise, but my strong sense is that it needs to be fixed, and I'm not at all sure how to do it in the JHilbert world without adding explicit (cv x) terms. [[User:Raph|Raph]] 19:47, 3 March 2010 (UTC)

:::::I think I understand (somewhat) now. If I'm right, object versus nat is a red herring, and the real problem is the attempt to make object do the work of two things which need to be separated.  In peano.mm in the metamath distribution, these are "term" and "var" (and "tvar $a term v $." is the equivalent of cv, basically). In set.mm it is basically class versus set (although set.mm has enough other complications that it perhaps isn't the clearest example). In [http://levien.com/garden/ghnew/peano/], the new ghilbert features (var vs. tvar) handle this. I think I should probably try to fix this for now with explicit cv (unless var and tvar can be implemented pretty fast). It is quite painful for readability (all the n's and m's in <code>((n · (succ m)) = (n + (n · m))))</code> need to be <code>(cv n)</code> and <code>(cv m)</code>, right?).  But the only other choice I can think of is a big disclaimer at the top of [[First-order logic]] and friends saying "this is broken until JHilbert gets more features". [[User:Kingdon|Kingdon]] 21:03, 3 March 2010 (UTC)