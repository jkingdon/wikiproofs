{{interfaces
| imports = [[Interface:Symmetric point]]
| exports = [[Interface:Midpoint]]
}}

This is part of a series of modules which prove a variety of geometrical theorems starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

This page proves various results involving the midpoint of a line segment. We don't yet prove the existence of a midpoint (that's in the next chapter).

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Symmetric point|geometry results so far]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (START Interface:Symmetric_point (CLASSICAL FIRSTORDER) ())

var (point A B C D E F M P Q R S X Y Z)
var (point A′ B′ C′ D′ E′ M′ P′ Q′ R′ S′ X′ Y′)
var (variable a a′ b b′ c c′ d d′ e e′ f p p′ x x′ y y′ z)
</jh>

== Midpoint builder ==
This is the proposition that equals can be substituted for equals, in the context of <code>is-midpoint-of</code>. It follows directly from the builders for betweenness and line segment congruence.<ref>not in Narboux</ref>
<jh>
thm (MidpointBuilder () () ((((M = M′) ∧ (A = A′)) ∧ (B = B′)) →
  ((M is-midpoint-of A B) ↔ (M′ is-midpoint-of A′ B′))) (
        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        composeConjunction

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionLeftElimination
        composeConjunction

        A A′ M M′ B B′ BetweennessBuilder
        applySyllogism

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        composeConjunction

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        composeConjunction

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionLeftElimination
        composeConjunction

        A A′ M M′ M M′ B B′ CongruenceBuilder
        applySyllogism

        buildConjunctionInConsequent
))
</jh>

== Midpoint is unique ==
The midpoint of a line segment is unique.<ref>l7_17 in Narboux</ref>

[[File:Proof of midpoint uniqueness.svg|thumb|right]]
To prove it, start with a line segment <code>P P′</code> which has two midpoints <code>A</code> and <code>B</code>. Our aim is to show that <code>A = B</code>. First construct <code>B′</code>, the symmetric point of <code>B</code> through the point <code>A</code>. Because reflecting through a symmetric point preserves distances, the line segments <code>P B′</code> and <code>B′ P′</code> are congruent to <code>P B</code> and <code>B P′</code>.

Applying <code>BetweennessTwoDistanceUniqueness</code> gives us <code>B = B′</code>. And since <code>B B′</code> is an empty line segment and <code>A</code> is one of its midpoints, then <code>A = B</code>.

To formalize this proof, first we construct the point <code>B′</code>.
<jh>
thm (MidpointUniqueness-bprime ((b′ A) (b′ B) (b′ P) (b′ P′)) ()
  (((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) → 
  (∃ b′ (((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B (value b′))))) (
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ImplicationReflexivity
        b′ A B SymmetricPoint
        introduceRightConjunctToConsequent

        moveLeftConjunctIntoThereExistsInConsequent
))
</jh>

Because reflecting about the point <code>A</code> preserves distances, <code>P B ≡ P′ B′</code>.
<jh>
thm (MidpointUniqueness-p-b-pprime-bprime ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (P B ≡ P′ B′)) (
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionLeftElimination

        composeConjunction

        A P P′ B B′ SymmetricPointDistance
        applySyllogism

        swapCongruenceInConsequent
))
</jh>

Similarly, <code>P′ B ≡ P B′</code>.
<jh>
thm (MidpointUniqueness-pprime-b-p-bprime ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (P′ B ≡ P B′)) (
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionLeftElimination

        A B B′ MidpointSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        A P P′ B′ B SymmetricPointDistance
        applySyllogism
))

thm (MidpointUniqueness-b-bprime ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (B = B′)) (
</jh>
In this case <code>BetweennessTwoDistanceUniqueness</code> expands to <code>between P B P′ ∧ P B ≡ P B′ ∧ P′ B ≡ P′ B′ → B = B′</code>. First is <code>between P B P′</code>.
<jh>
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
Next is <code>P B ≡ P B′</code>, which we prove via <code>P B ≡ P′ B</code> and <code>P′ B ≡ P B′</code>.
<jh>
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        commuteCongruenceRightInConsequent

        A P P′ B B′ MidpointUniqueness-pprime-b-p-bprime

        composeConjunction
        P B P′ B P B′ CongruenceTransitivity
        applySyllogism

        composeConjunction
</jh>
Last is <code>P′ B ≡ P′ B′</code>, which we prove via <code>P′ B ≡ P B</code> and <code>P B ≡ P′ B′</code>.
<jh>
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        commuteCongruenceRightInConsequent
        swapCongruenceInConsequent

        A P P′ B B′ MidpointUniqueness-p-b-pprime-bprime

        composeConjunction
        P′ B P B P′ B′ CongruenceTransitivity
        applySyllogism

        composeConjunction

        P B P′ B′ BetweennessTwoDistanceUniqueness
        applySyllogism
))
</jh>

Because <code>A</code> is between two points which end up being equal (<code>B</code> and <code>B′</code>), we can conclude that <code>A = B</code>.
<jh>
thm (MidpointUniqueness-a-b-b ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (A is-midpoint-of B B)) (
        A P P′ B B′ MidpointUniqueness-b-bprime

        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionLeftElimination
        composeConjunction

        A EqualityReflexivity
        B EqualityReflexivity
        A A B B B B′ MidpointBuilder
        detach2of3
        detach1of2
        eliminateBiconditionalForwardInConsequent
        import

        applySyllogism
))

thm (MidpointUniqueness-a-b ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (A = B)) (
        A P P′ B B′ MidpointUniqueness-a-b-b
        A B MidpointIndivisibility
        applySyllogism
))

thm (MidpointUniqueness ( (b′ A) (b′ B) (b′ P) (b′ P′)) ()
  (((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) → (A = B)) (
        A P P′ B b′ MidpointUniqueness-bprime

        A P P′ B (value b′) MidpointUniqueness-a-b
        b′ addThereExists
        applySyllogism

        removeThereExistsInConsequent
))
</jh>

== The equidistant point is the midpoint ==
A point which is equidistant to the two distinct endpoints of a line segment, and on the same line as them, is the midpoint of that line segment. In symbols, <code>collinear A M B ∧ M A ≡ M B → A = B ∨ M is-midpoint-of A B</code>.<ref>l7_20 in Narboux</ref>

There are three cases based on <code>collinear A M B</code>. The first is <code>between A M B</code> which trivially satisfies the definition of midpoint.
<jh>
thm (EquidistantMidpoint-a-m-b () ()
  ((between A M B) → ((M A ≡ M B) →
    ((A = B) ∨ (M is-midpoint-of A B)))) (
        M A M B CongruenceLeftCommutativity
        eliminateBiconditionalReverse
        (between A M B) conjoinLL

        (M is-midpoint-of A B) (A = B) DisjunctionLeftIntroduction
        applySyllogism

        export
))
</jh>

The second case is <code>between M B A</code>. Because <code>B</code> and <code>A</code> are the same distance from <code>M</code>, they must be the same point. To formalize this, apply inner three segment to <code>between M B A</code> and <code>between M B B</code>, which produces <code>B A ≡ B B</code>.
<jh>
thm (EquidistantMidpoint-m-b-a () ()
  ((between M B A) → ((M A ≡ M B) →
    ((A = B) ∨ (M is-midpoint-of A B)))) (
</jh>
Inner three segment needs two betweenness relationships, <code>between A B M</code>
<jh>
        (between M B A) (M A ≡ M B) ConjunctionRightElimination
        swapBetweennessInConsequent
</jh>
and <code>between B B M</code>,
<jh>
        B M BetweenAAB
        introduceRightConjunctToConsequent
</jh>
and two congruences, <code>A M ≡ B M</code>
<jh>
        (between M B A) (M A ≡ M B) ConjunctionLeftElimination
        commuteCongruenceInConsequent
        composeConjunction
</jh>
and <code>B M ≡ B M</code>.
<jh>
        B M CongruenceReflexivity
        introduceRightConjunctToConsequent
</jh>
The conclusion is <code>A B ≡ B B</code>,
<jh>
        A B M B B M InnerThreeSegment
        applySyllogism
</jh>
which in turn implies our result.
<jh>
        A B B CongruenceIdentity
        applySyllogism

        (A = B) (M is-midpoint-of A B) DisjunctionRightIntroduction
        applySyllogism

        export
))
</jh>

The third case is <code>between B A M</code>. Because <code>A</code> and <code>B</code> can be interchanged, it can be proven from the <code>between M B A</code> case. 
<jh>
thm (EquidistantMidpoint-b-a-m () ()
  ((between B A M) → ((M A ≡ M B) →
    ((A = B) ∨ (M is-midpoint-of A B)))) (
</jh>
When invoked with <code>A</code> and <code>B</code> switched, <code>EquidistantMidpoint-m-b-a</code> is <code>between M A B → (M B ≡ M A → B = A ∨ M is-midpoint-of B A)</code>. Rearranging we are done.
<jh>
        M A B EquidistantMidpoint-m-b-a

        M A B BetweennessSymmetry

        M B M A CongruenceSymmetry

        B A EqualitySymmetry
        M B A MidpointSymmetry
        buildDisjunction

        buildImplication

        buildImplication

        eliminateBiconditionalReverse
        applyModusPonens
))
</jh>

Combining the cases finishes the proof.
<jh>
thm (EquidistantMidpoint () ()
  (((collinear A M B) ∧ (M A ≡ M B)) →
    ((A = B) ∨ (M is-midpoint-of A B))) (
        A M B EquidistantMidpoint-a-m-b
        M B A EquidistantMidpoint-m-b-a
        composeDisjunction

        B A M EquidistantMidpoint-b-a-m
        composeDisjunction

        import
))
</jh>

== Diagonals bisect each other ==
[[File:Proof of lemma l7 21 in Narboux.svg|220px|The proof constructs P′ and shows that P = P′]]
Given a "parallelogram" (that is, a quadrilateral with opposite sides congruent; we haven't yet developed any theory of parallel lines), the diagonals bisect each other.

First we construct a point <code>p′</code> which is like <code>P</code> but as far from <code>D</code> as <code>P</code> is from <code>B</code>. That is, <code>B D P ≅ D B P′</code>
<jh>
thm (ParallelogramDiagonals-pprime
  ((p′ A) (p′ B) (p′ C) (p′ D) (p′ P)) ()
  (((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) →
    (∃ p′ (((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) ∧
      (B D P ≅ D B (value p′))))) (
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
          (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
          (collinear A P C)) ∧ (collinear B P D))
          ImplicationReflexivity
</jh>
Next, we construct <code>p′</code>, starting with <code>collinear B D P</code>.
<jh>
        (((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C))
          (collinear B P D)
          ConjunctionLeftElimination

        B P D Collinearity23
        eliminateBiconditionalReverse
        applySyllogism
</jh>
The other thing for the construction is <code>B D ≡ D B</code>.
<jh>
        B D CongruenceABBA
        introduceRightConjunctToConsequent
</jh>
This lets us conclude <code>∃ p′ B D P ≡ D B p′</code>.
<jh>
        B D P D B p′ CollinearityConstructDegenerateTriangle
        applySyllogism
</jh>
Now we just need to repeat the formulas from the antecedent and move them inside the quantifier.
<jh>
        composeConjunction
        moveLeftConjunctIntoThereExistsInConsequent
))
</jh>

The point <code>P′</code> is on the line <code>B D</code>. The proof is by <code>CollinearityDegenerateTriangle</code>, which in this case is <code>collinear B D P ∧ B D P ≅ D B P′ → collinear D B P′</code>.
<jh>
thm (ParallelogramDiagonals-d-b-pprime () ()
  ((((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) ∧
      (B D P ≅ D B P′)) →
    (collinear D B P′)
  ) (
</jh>
<code>collinear B D P</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        B P D Collinearity23
        eliminateBiconditionalReverse
        applySyllogism
</jh>
<code>B D P ≅ D B P′</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionLeftElimination
        composeConjunction

        B D P D B P′ CollinearityDegenerateTriangle
        applySyllogism
))

</jh>
Next is <code>P A ≡ P′ C</code>, which we prove by five segment on baselines <code>B D P</code> and <code>D B P′</code> and points <code>A</code> and <code>C</code>.
<jh>
thm (ParallelogramDiagonals-p-a-pprime-c () ()
  ((((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) ∧
      (B D P ≅ D B P′)) →
    (P A ≡ P′ C)
  ) (
</jh>
For five segment, we first need <code>B ≠ D</code>.
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
Next is <code>collinear B D P</code>.
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        B P D Collinearity23
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Next is <code>B D P ≅ D B P′</code>.
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionLeftElimination
        composeConjunction
</jh>
Now we just need two congruences, the first of which is <code>B A ≡ D C</code>,
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        commuteCongruenceInConsequent
        composeConjunction
</jh>
and the second of which is <code>D A ≡ B C</code>.
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        swapCongruenceInConsequent
        composeConjunction
</jh>
Applying five segment we are done.
<jh>
        B D P D B P′ A C FiveSegment
        applySyllogism
))

</jh>
In a very similar manner we prove <code>P C ≡ P′ A</code>, with 
baselines <code>B D P</code> and <code>D B P′</code> and points <code>C</code> and <code>A</code>.
<jh>
thm (ParallelogramDiagonals-p-c-pprime-a () ()
  ((((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) ∧
      (B D P ≅ D B P′)) →
    (P C ≡ P′ A)
  ) (
</jh>
<code>B ≠ D</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
<code>collinear B D P</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        B P D Collinearity23
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
<code>B D P ≅ D B P′</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionLeftElimination
        composeConjunction
</jh>
<code>B C ≡ D A</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
<code>D C ≡ B A</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        swapCongruenceInConsequent
        commuteCongruenceInConsequent
        composeConjunction
</jh>
Applying five segment we are done.
<jh>
        B D P D B P′ C A FiveSegment
        applySyllogism
))

</jh>
Those two congruences suffice to provide <code>A P C ≅ C P′ A</code>.
<jh>
thm (ParallelogramDiagonals-a-p-c-c-pprime-a () ()
  ((((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) ∧
      (B D P ≅ D B P′)) →
    (A P C ≅ C P′ A)
  ) (
</jh>
<code>A P ≡ C P′</code>:
<jh>
        A B C D P P′ ParallelogramDiagonals-p-a-pprime-c
        commuteCongruenceInConsequent
</jh>
<code>A C ≡ C A</code>:
<jh>
        A C CongruenceABBA
        introduceRightConjunctToConsequent
</jh>
<code>P C ≡ P′ A</code>:
<jh>
        A B C D P P′ ParallelogramDiagonals-p-c-pprime-a
        composeConjunction
))
</jh>

We're ready for <code>P = P′</code>. The proof is by <code>LineIntersection</code>, which in this case expands to <code>¬ collinear A C B ∧ B ≠ D ∧ collinear A C P ∧ collinear A C P′ ∧ collinear B D P ∧ collinear B D P′ → P = P′</code>.
<jh>
thm (ParallelogramDiagonals-p-pprime () ()
  ((((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) ∧
      (B D P ≅ D B P′)) →
    (P = P′)
  ) (
</jh>
<code>¬ collinear A C B</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        A B C Collinearity23
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
<code>B ≠ D</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
<code>collinear A C P</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        A P C Collinearity23
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Next is <code>collinear A C P′</code>. Because <code>A</code>, <code>P</code>, and <code>C</code> are collinear and <code>A P C ≅ C P′ A</code> we can conclude <code>P′</code> is also collinear with them.
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        A B C D P P′ ParallelogramDiagonals-a-p-c-c-pprime-a

        composeConjunction

        A P C C P′ A CollinearityDegenerateTriangle
        applySyllogism

        A C P′ CollinearityRotation
        eliminateBiconditionalForward
        applySyllogism

        composeConjunction
</jh>
<code>collinear B D P</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        B P D Collinearity23
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
<code>collinear B D P′</code>:
<jh>
        A B C D P P′ ParallelogramDiagonals-d-b-pprime

        D B P′ Collinearity12
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
We are ready to apply <code>LineIntersection</code>.
<jh>
        A C B D P P′ LineIntersection
        applySyllogism
))
</jh>

Now that we have <code>P = P′</code> we are mostly there. The next step is showing <code>P is-midpoint-of A C</code>

<jh>
thm (ParallelogramDiagonals-p-a-c () ()
  ((((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) ∧
      (B D P ≅ D B P′)) →
    (P is-midpoint-of A C)
  ) (
</jh>
To apply <code>EquidistantMidpoint</code> we first will need <code>A ≠ C</code>. We derive it from <code>¬ collinear A B C<code>, by means of <code>A = C → collinear A B C</code>
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        A B CollinearityABA

        A EqualityReflexivity
        B EqualityReflexivity
        A A B B A C CollinearityBuilder
        detach2of3
        detach1of2

        detachImplicationBiconditional

        (A = C) (collinear A B C) Transposition
        eliminateBiconditionalReverse
        applySyllogism

        applySyllogism
</jh>
Next we need <code>collinear A P C</code>.
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
Next is <code>P A ≡ P C</code>, which follows from <code>P A ≡ P′ C</code> and a substitution.
<jh>
        A B C D P P′ ParallelogramDiagonals-p-a-pprime-c

        A B C D P P′ ParallelogramDiagonals-p-pprime

        P EqualityReflexivity
        A EqualityReflexivity
        C EqualityReflexivity
        P P A A P P′ C C CongruenceBuilder
        detach2of2
        detach2of3
        detach1of2

        applySyllogism

        eliminateBiconditionalReverseInConsequent
        applyModusPonensInConsequent

        composeConjunction
</jh>
Now we apply <code>EquidistantMidpoint</code>, which first gives us <code>A = C ∨ P is-midpoint-of A C</code>,
<jh>
        A P C EquidistantMidpoint
        applySyllogism
</jh>
and then <code>P is-midpoint-of A C</code>.
<jh>
        (A = C) (P is-midpoint-of A C) DisjunctionImplication
        eliminateBiconditionalReverse
        applySyllogism

        applyModusPonensInConsequent
))
</jh>

Now we are ready to combine this with the construction of <code>P′</code> to produce our result.
<jh>
#thm (ParallelogramDiagonals () ()
#  (((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
#      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
#      (collinear A P C)) ∧ (collinear B P D)) →
#    ((P is-midpoint-of A C) ∧ (P is-midpoint-of B D))) (
#))
</jh>

== Export ==
We now export to [[Interface:Midpoint]].
<jh>
#export (RESULTS Interface:Midpoint (CLASSICAL FIRSTORDER) ())
</jh>

Also, since this is currently the last proof module for geometry, we export to [[Interface:Basic geometry]].
<jh>
export (GEOMETRY Interface:Basic_geometry (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>
* Tarski, Alfred; Givant, Steven (1999), "Tarski's system of geometry", The Bulletin of Symbolic Logic 5 (2): 175–214, doi:10.2307/421089, MR1791303, ISSN 1079-8986

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]
