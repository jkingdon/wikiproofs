{{interfaces
| imports = [[Interface:Symmetric point]]
| exports = [[Interface:Midpoint]]
}}

This is part of a series of modules which prove a variety of geometrical theorems starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

This page proves various results involving the midpoint of a line segment. We don't yet prove the existence of a midpoint (that's in the next chapter).

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Symmetric point|geometry results so far]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (START Interface:Symmetric_point (CLASSICAL FIRSTORDER) ())

var (point A B C D E F M P Q R S X Y Z)
var (point A′ B′ C′ D′ E′ M′ P′ Q′ R′ S′ X′ Y′)
var (variable a a′ b b′ c c′ d d′ e e′ f p p′ q r r′ x x′ y y′ z)
</jh>

== Midpoint builder ==
This is the proposition that equals can be substituted for equals, in the context of <code>is-midpoint-of</code>. It follows directly from the builders for betweenness and line segment congruence.<ref>not in Narboux</ref>
<jh>
thm (MidpointBuilder () () ((((M = M′) ∧ (A = A′)) ∧ (B = B′)) →
  ((M is-midpoint-of A B) ↔ (M′ is-midpoint-of A′ B′))) (
        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        composeConjunction

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionLeftElimination
        composeConjunction

        A A′ M M′ B B′ BetweennessBuilder
        applySyllogism

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        composeConjunction

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        composeConjunction

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionLeftElimination
        composeConjunction

        A A′ M M′ M M′ B B′ CongruenceBuilder
        applySyllogism

        buildConjunctionInConsequent
))
</jh>

== Midpoint is unique ==
The midpoint of a line segment is unique.<ref>l7_17 in Narboux</ref>

[[File:Proof of midpoint uniqueness.svg|thumb|right]]
To prove it, start with a line segment <code>P P′</code> which has two midpoints <code>A</code> and <code>B</code>. Our aim is to show that <code>A = B</code>. First construct <code>B′</code>, the symmetric point of <code>B</code> through the point <code>A</code>. Because reflecting through a symmetric point preserves distances, the line segments <code>P B′</code> and <code>B′ P′</code> are congruent to <code>P B</code> and <code>B P′</code>.

Applying <code>BetweennessTwoDistanceUniqueness</code> gives us <code>B = B′</code>. And since <code>B B′</code> is an empty line segment and <code>A</code> is one of its midpoints, then <code>A = B</code>.

To formalize this proof, first we construct the point <code>B′</code>.
<jh>
thm (MidpointUniqueness-bprime ((b′ A) (b′ B) (b′ P) (b′ P′)) ()
  (((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) → 
  (∃ b′ (((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B (value b′))))) (
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ImplicationReflexivity
        b′ A B SymmetricPoint
        introduceRightConjunctToConsequent

        moveLeftConjunctIntoThereExistsInConsequent
))
</jh>

Because reflecting about the point <code>A</code> preserves distances, <code>P B ≡ P′ B′</code>.
<jh>
thm (MidpointUniqueness-p-b-pprime-bprime ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (P B ≡ P′ B′)) (
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionLeftElimination

        composeConjunction

        A P P′ B B′ SymmetricPointDistance
        applySyllogism

        swapCongruenceInConsequent
))
</jh>

Similarly, <code>P′ B ≡ P B′</code>.
<jh>
thm (MidpointUniqueness-pprime-b-p-bprime ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (P′ B ≡ P B′)) (
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionLeftElimination

        A B B′ MidpointSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        A P P′ B′ B SymmetricPointDistance
        applySyllogism
))

thm (MidpointUniqueness-b-bprime ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (B = B′)) (
</jh>
In this case <code>BetweennessTwoDistanceUniqueness</code> expands to <code>between P B P′ ∧ P B ≡ P B′ ∧ P′ B ≡ P′ B′ → B = B′</code>. First is <code>between P B P′</code>.
<jh>
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
Next is <code>P B ≡ P B′</code>, which we prove via <code>P B ≡ P′ B</code> and <code>P′ B ≡ P B′</code>.
<jh>
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        commuteCongruenceRightInConsequent

        A P P′ B B′ MidpointUniqueness-pprime-b-p-bprime

        composeConjunction
        P B P′ B P B′ CongruenceTransitivity
        applySyllogism

        composeConjunction
</jh>
Last is <code>P′ B ≡ P′ B′</code>, which we prove via <code>P′ B ≡ P B</code> and <code>P B ≡ P′ B′</code>.
<jh>
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        commuteCongruenceRightInConsequent
        swapCongruenceInConsequent

        A P P′ B B′ MidpointUniqueness-p-b-pprime-bprime

        composeConjunction
        P′ B P B P′ B′ CongruenceTransitivity
        applySyllogism

        composeConjunction

        P B P′ B′ BetweennessTwoDistanceUniqueness
        applySyllogism
))
</jh>

Because <code>A</code> is between two points which end up being equal (<code>B</code> and <code>B′</code>), we can conclude that <code>A = B</code>.
<jh>
thm (MidpointUniqueness-a-b-b ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (A is-midpoint-of B B)) (
        A P P′ B B′ MidpointUniqueness-b-bprime

        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionLeftElimination
        composeConjunction

        A EqualityReflexivity
        B EqualityReflexivity
        A A B B B B′ MidpointBuilder
        detach2of3
        detach1of2
        eliminateBiconditionalForwardInConsequent
        import

        applySyllogism
))

thm (MidpointUniqueness-a-b ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (A = B)) (
        A P P′ B B′ MidpointUniqueness-a-b-b
        A B MidpointIndivisibility
        applySyllogism
))

thm (MidpointUniqueness ( (b′ A) (b′ B) (b′ P) (b′ P′)) ()
  (((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) → (A = B)) (
        A P P′ B b′ MidpointUniqueness-bprime

        A P P′ B (value b′) MidpointUniqueness-a-b
        b′ addThereExists
        applySyllogism

        removeThereExistsInConsequent
))
</jh>

== The equidistant point is the midpoint ==
A point which is equidistant to the two distinct endpoints of a line segment, and on the same line as them, is the midpoint of that line segment. In symbols, <code>collinear A M B ∧ M A ≡ M B → A = B ∨ M is-midpoint-of A B</code>.<ref>l7_20 in Narboux</ref>

There are three cases based on <code>collinear A M B</code>. The first is <code>between A M B</code> which trivially satisfies the definition of midpoint.
<jh>
thm (EquidistantMidpoint-a-m-b () ()
  ((between A M B) → ((M A ≡ M B) →
    ((A = B) ∨ (M is-midpoint-of A B)))) (
        M A M B CongruenceLeftCommutativity
        eliminateBiconditionalReverse
        (between A M B) conjoinLL

        (M is-midpoint-of A B) (A = B) DisjunctionLeftIntroduction
        applySyllogism

        export
))
</jh>

The second case is <code>between M B A</code>. Because <code>B</code> and <code>A</code> are the same distance from <code>M</code>, they must be the same point. To formalize this, apply inner three segment to <code>between M B A</code> and <code>between M B B</code>, which produces <code>B A ≡ B B</code>.
<jh>
thm (EquidistantMidpoint-m-b-a () ()
  ((between M B A) → ((M A ≡ M B) →
    ((A = B) ∨ (M is-midpoint-of A B)))) (
</jh>
Inner three segment needs two betweenness relationships, <code>between A B M</code>
<jh>
        (between M B A) (M A ≡ M B) ConjunctionRightElimination
        swapBetweennessInConsequent
</jh>
and <code>between B B M</code>,
<jh>
        B M BetweenAAB
        introduceRightConjunctToConsequent
</jh>
and two congruences, <code>A M ≡ B M</code>
<jh>
        (between M B A) (M A ≡ M B) ConjunctionLeftElimination
        commuteCongruenceInConsequent
        composeConjunction
</jh>
and <code>B M ≡ B M</code>.
<jh>
        B M CongruenceReflexivity
        introduceRightConjunctToConsequent
</jh>
The conclusion is <code>A B ≡ B B</code>,
<jh>
        A B M B B M InnerThreeSegment
        applySyllogism
</jh>
which in turn implies our result.
<jh>
        A B B CongruenceIdentity
        applySyllogism

        (A = B) (M is-midpoint-of A B) DisjunctionRightIntroduction
        applySyllogism

        export
))
</jh>

The third case is <code>between B A M</code>. Because <code>A</code> and <code>B</code> can be interchanged, it can be proven from the <code>between M B A</code> case. 
<jh>
thm (EquidistantMidpoint-b-a-m () ()
  ((between B A M) → ((M A ≡ M B) →
    ((A = B) ∨ (M is-midpoint-of A B)))) (
</jh>
When invoked with <code>A</code> and <code>B</code> switched, <code>EquidistantMidpoint-m-b-a</code> is <code>between M A B → (M B ≡ M A → B = A ∨ M is-midpoint-of B A)</code>. Rearranging we are done.
<jh>
        M A B EquidistantMidpoint-m-b-a

        M A B BetweennessSymmetry

        M B M A CongruenceSymmetry

        B A EqualitySymmetry
        M B A MidpointSymmetry
        buildDisjunction

        buildImplication

        buildImplication

        eliminateBiconditionalReverse
        applyModusPonens
))
</jh>

Combining the cases finishes the proof.
<jh>
thm (EquidistantMidpoint () ()
  (((collinear A M B) ∧ (M A ≡ M B)) →
    ((A = B) ∨ (M is-midpoint-of A B))) (
        A M B EquidistantMidpoint-a-m-b
        M B A EquidistantMidpoint-m-b-a
        composeDisjunction

        B A M EquidistantMidpoint-b-a-m
        composeDisjunction

        import
))
</jh>

== Diagonals bisect each other ==
[[File:Proof of lemma l7 21 in Narboux.svg|220px|The proof constructs P′ and shows that P = P′]]
Given a "parallelogram" (that is, a quadrilateral with opposite sides congruent; we haven't yet developed any theory of parallel lines), the diagonals bisect each other.

First we construct a point <code>p′</code> which is like <code>P</code> but as far from <code>D</code> as <code>P</code> is from <code>B</code>. That is, <code>B D P ≅ D B P′</code>
<jh>
thm (ParallelogramDiagonals-pprime
  ((p′ A) (p′ B) (p′ C) (p′ D) (p′ P)) ()
  (((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) →
    (∃ p′ (((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) ∧
      (B D P ≅ D B (value p′))))) (
</jh>
Next, we construct <code>p′</code>, starting with <code>collinear B D P</code>.
<jh>
        (((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C))
          (collinear B P D)
          ConjunctionLeftElimination

        B P D Collinearity23
        eliminateBiconditionalReverse
        applySyllogism
</jh>
The other thing for the construction is <code>B D ≡ D B</code>.
<jh>
        B D CongruenceABBA
        introduceRightConjunctToConsequent
</jh>
This lets us conclude <code>∃ p′ B D P ≡ D B p′</code>.
<jh>
        B D P D B p′ CollinearityConstructDegenerateTriangle
        applySyllogism
</jh>
Now we just need to repeat the formulas from the antecedent and move them inside the quantifier.
<jh>
        repeatAntecedentThereExists
))
</jh>

The point <code>P′</code> is on the line <code>B D</code>. The proof is by <code>CollinearityDegenerateTriangle</code>, which in this case is <code>collinear B D P ∧ B D P ≅ D B P′ → collinear D B P′</code>.
<jh>
thm (ParallelogramDiagonals-d-b-pprime () ()
  ((((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) ∧
      (B D P ≅ D B P′)) →
    (collinear D B P′)
  ) (
</jh>
<code>collinear B D P</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        B P D Collinearity23
        eliminateBiconditionalReverse
        applySyllogism
</jh>
<code>B D P ≅ D B P′</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionLeftElimination
        composeConjunction

        B D P D B P′ CollinearityDegenerateTriangle
        applySyllogism
))

</jh>
Next is <code>P A ≡ P′ C</code>, which we prove by five segment on baselines <code>B D P</code> and <code>D B P′</code> and points <code>A</code> and <code>C</code>.
<jh>
thm (ParallelogramDiagonals-p-a-pprime-c () ()
  ((((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) ∧
      (B D P ≅ D B P′)) →
    (P A ≡ P′ C)
  ) (
</jh>
For five segment, we first need <code>B ≠ D</code>.
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
Next is <code>collinear B D P</code>.
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        B P D Collinearity23
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Next is <code>B D P ≅ D B P′</code>.
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionLeftElimination
        composeConjunction
</jh>
Now we just need two congruences, the first of which is <code>B A ≡ D C</code>,
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        commuteCongruenceInConsequent
        composeConjunction
</jh>
and the second of which is <code>D A ≡ B C</code>.
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        swapCongruenceInConsequent
        composeConjunction
</jh>
Applying five segment we are done.
<jh>
        B D P D B P′ A C FiveSegment
        applySyllogism
))

</jh>
In a very similar manner we prove <code>P C ≡ P′ A</code>, with 
baselines <code>B D P</code> and <code>D B P′</code> and points <code>C</code> and <code>A</code>.
<jh>
thm (ParallelogramDiagonals-p-c-pprime-a () ()
  ((((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) ∧
      (B D P ≅ D B P′)) →
    (P C ≡ P′ A)
  ) (
</jh>
<code>B ≠ D</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
<code>collinear B D P</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        B P D Collinearity23
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
<code>B D P ≅ D B P′</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionLeftElimination
        composeConjunction
</jh>
<code>B C ≡ D A</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
<code>D C ≡ B A</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        swapCongruenceInConsequent
        commuteCongruenceInConsequent
        composeConjunction
</jh>
Applying five segment we are done.
<jh>
        B D P D B P′ C A FiveSegment
        applySyllogism
))

</jh>
Those two congruences suffice to provide <code>A P C ≅ C P′ A</code>.
<jh>
thm (ParallelogramDiagonals-a-p-c-c-pprime-a () ()
  ((((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) ∧
      (B D P ≅ D B P′)) →
    (A P C ≅ C P′ A)
  ) (
</jh>
<code>A P ≡ C P′</code>:
<jh>
        A B C D P P′ ParallelogramDiagonals-p-a-pprime-c
        commuteCongruenceInConsequent
</jh>
<code>A C ≡ C A</code>:
<jh>
        A C CongruenceABBA
        introduceRightConjunctToConsequent
</jh>
<code>P C ≡ P′ A</code>:
<jh>
        A B C D P P′ ParallelogramDiagonals-p-c-pprime-a
        composeConjunction
))
</jh>

We're ready for <code>P = P′</code>. The proof is by <code>LineIntersection</code>, which in this case expands to <code>¬ collinear A C B ∧ B ≠ D ∧ collinear A C P ∧ collinear A C P′ ∧ collinear B D P ∧ collinear B D P′ → P = P′</code>.
<jh>
thm (ParallelogramDiagonals-p-pprime () ()
  ((((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) ∧
      (B D P ≅ D B P′)) →
    (P = P′)
  ) (
</jh>
<code>¬ collinear A C B</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        A B C Collinearity23
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
<code>B ≠ D</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
<code>collinear A C P</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        A P C Collinearity23
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Next is <code>collinear A C P′</code>. Because <code>A</code>, <code>P</code>, and <code>C</code> are collinear and <code>A P C ≅ C P′ A</code> we can conclude <code>P′</code> is also collinear with them.
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        A B C D P P′ ParallelogramDiagonals-a-p-c-c-pprime-a

        composeConjunction

        A P C C P′ A CollinearityDegenerateTriangle
        applySyllogism

        A C P′ CollinearityRotation
        eliminateBiconditionalForward
        applySyllogism

        composeConjunction
</jh>
<code>collinear B D P</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        B P D Collinearity23
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
<code>collinear B D P′</code>:
<jh>
        A B C D P P′ ParallelogramDiagonals-d-b-pprime

        D B P′ Collinearity12
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
We are ready to apply <code>LineIntersection</code>.
<jh>
        A C B D P P′ LineIntersection
        applySyllogism
))
</jh>

Now that we have <code>P = P′</code> we are mostly there. The next step is showing <code>P is-midpoint-of A C</code>

<jh>
thm (ParallelogramDiagonals-p-a-c () ()
  ((((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) ∧
      (B D P ≅ D B P′)) →
    (P is-midpoint-of A C)
  ) (
</jh>
We'll be applying <code>EquidistantMidpoint</code>, and first will need <code>A ≠ C</code>. We derive it from <code>¬ collinear A B C<code>, by means of <code>A = C → collinear A B C</code>
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        A B CollinearityABA

        A EqualityReflexivity
        B EqualityReflexivity
        A A B B A C CollinearityBuilder
        detach2of3
        detach1of2

        detachImplicationBiconditional

        (A = C) (collinear A B C) Transposition
        eliminateBiconditionalReverse
        applyModusPonens

        applySyllogism
</jh>
Next we need <code>collinear A P C</code>.
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
Next is <code>P A ≡ P C</code>, which follows from <code>P A ≡ P′ C</code> and a substitution.
<jh>
        A B C D P P′ ParallelogramDiagonals-p-a-pprime-c

        A B C D P P′ ParallelogramDiagonals-p-pprime

        P EqualityReflexivity
        A EqualityReflexivity
        C EqualityReflexivity
        P P A A P P′ C C CongruenceBuilder
        detach2of2
        detach2of3
        detach1of2

        applySyllogism

        eliminateBiconditionalForwardInConsequent
        applyModusPonensInConsequent

        composeConjunction
</jh>
Now we apply <code>EquidistantMidpoint</code>, which first gives us <code>A = C ∨ P is-midpoint-of A C</code>,
<jh>
        A P C EquidistantMidpoint
        applySyllogism
</jh>
and then <code>P is-midpoint-of A C</code>.
<jh>
        (A = C) (P is-midpoint-of A C) DisjunctionImplication
        eliminateBiconditionalReverse
        applySyllogism

        applyModusPonensInConsequent
))
</jh>

The proof of <code>P is-midpoint-of B D</code> is similar.
<jh>
thm (ParallelogramDiagonals-p-b-d () ()
  ((((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) ∧
      (B D P ≅ D B P′)) →
    (P is-midpoint-of B D)
  ) (
</jh>
We'll be applying <code>EquidistantMidpoint</code>, and first will need <code>B ≠ D</code>.
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
Next is <code>collinear B P D</code>. We start with <code>collinear D B P′</code>,
<jh>
        A B C D P P′ ParallelogramDiagonals-d-b-pprime
</jh>
substitute <code>P</code> for <code>P′</code>,
<jh>
        A B C D P P′ ParallelogramDiagonals-p-pprime

        D EqualityReflexivity
        B EqualityReflexivity
        D D B B P P′ CollinearityBuilder
        detach2of3
        detach1of2

        applySyllogism

        eliminateBiconditionalForwardInConsequent
        applyModusPonensInConsequent
</jh>
and rotate.
<jh>
        D B P CollinearityRotation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next is <code>P B ≡ P D</code>. We start with <code>B P ≡ D P′</code>,
<jh>
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C)) ∧ (collinear B P D))
          (B D P ≅ D B P′)
          ConjunctionLeftElimination
        B D P D B P′ Congruence13
        applySyllogism
</jh>
substitute <code>P<code> for <code>P′</code>,
<jh>
        A B C D P P′ ParallelogramDiagonals-p-pprime

        P EqualityReflexivity
        D EqualityReflexivity
        B EqualityReflexivity
        B B P P D D P P′ CongruenceBuilder
        detach1of4
        detach2of3
        detach1of2

        applySyllogism

        eliminateBiconditionalForwardInConsequent
        applyModusPonensInConsequent
</jh>
and commute the points on each side of the congruence.
<jh>
        commuteCongruenceInConsequent

        composeConjunction
</jh>
Now we apply <code>EquidistantMidpoint</code>, which first gives us <code>B = D ∨ P is-midpoint-of B D</code>,
<jh>
        B P D EquidistantMidpoint
        applySyllogism
</jh>
and then <code>P is-midpoint-of B D</code>.
<jh>
        (B = D) (P is-midpoint-of B D) DisjunctionImplication
        eliminateBiconditionalReverse
        applySyllogism

        applyModusPonensInConsequent
))
</jh>

Now we are ready to combine this with the construction of <code>P′</code> to produce our result.
<jh>
thm (ParallelogramDiagonals
  ((p′ A) (p′ B) (p′ C) (p′ D) (p′ P)) ()
  (((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) →
    ((P is-midpoint-of A C) ∧ (P is-midpoint-of B D))) (
        A B C D P p′ ParallelogramDiagonals-pprime

        A B C D P (value p′) ParallelogramDiagonals-p-a-c
        A B C D P (value p′) ParallelogramDiagonals-p-b-d
        composeConjunction
        p′ addThereExists

        applySyllogism

        removeThereExistsInConsequent
))
</jh>

== Joining the midpoints ==
[[File:Lemma l7_22 in Narboux.svg|thumb|right]]
This one may be hard to describe in a single sentence. The theorem is that given the configuration shown in the diagram, the point <code>C</code> is on the line segment connecting the midpoints <code>M1</code> and <code>M2</code>. In symbols, <code>between A1 C A2 ∧ between B1 C B2 ∧ C A1 ≡ C B1 ∧ C A2 ≡ C B2 ∧ M1 is-midpoint-of A1 B1 ∧ M2 is-midpoint-of A2 B2 → between M1 C M2<code>.<ref>l7_22 in Narboux</ref>

The proof starts by assuming, without loss of generality, that <code>C A1 ≤ C A2</code>.<ref>l7_22_aux in Narboux</ref>

For now, we omit the (lengthy) proof here, as we don't yet need it.

== Existence of the midpoint (given a point equidistant) ==
If there is a point equidistant from the endpoints of a line segment, there exists a midpoint of the line segment. In symbols, <code>C A ≡ C B → ∃ x x is-midpoint-of A B<code>. <ref>l7_25 in Narboux</ref> In a future chapter, we will be able to remove the hypothesis and just prove that the midpoint always exists, but this result is one of the steps on the way towards that proof.

First, we take care of a trivial case, in which <code>A</code>, <code>B</code>, and <code>C</code> are collinear. This case has two cases, the first of which is <code>A = B</code>.
<jh>
thm (MidpointExistsGivenEquidistant-a-b ((x A) (x B)) ()
  ((((collinear A B C) ∧ (C A ≡ C B)) ∧ (A = B)) → (∃ x ((value x) is-midpoint-of A B))) (
</jh>
We start with <code>A is-midpoint-of A A</code>.
<jh>
        A MidpointReflexivity
</jh>
This in turn implies <code>∃ x x is-midpoint-of A A<code> via the substitution <code>x = A → (x is-midpoint-of A A ↔ A is-midpoint-of A A)</code>.
<jh>
        A EqualityReflexivity
        A EqualityReflexivity
        (value x) A A A A A MidpointBuilder
        detach2of2
        detach2of2

        makeSubstExplicit
        eliminateBiconditionalForward
        applyModusPonens

        introduceThereExistsFromObject
</jh>
We apply the substitution <code>A = B → (∃ x x is-midpoint-of A A ↔ ∃ x x is-midpoint-of A B)</code>.
<jh>
        (value x) EqualityReflexivity
        A EqualityReflexivity
        (value x) (value x) A A A B MidpointBuilder
        detach2of3
        detach1of2
        x buildThereExistsInConsequent

        detachImplicationBiconditional
</jh>
That gives us <code>A = B → ∃ x x is-midpoint-of A B</code> so we just need to introduce an antecedent to be done.
<jh>
        ((collinear A B C) ∧ (C A ≡ C B)) introduceAntecedent
        import
))
</jh>

The other collinear case is <code>C is-midpoint-of A B</code>, which is even simpler (<code>C</code> is the desired midpoint).
<jh>
thm (MidpointExistsGivenEquidistant-c-a-b ((x A) (x B) (x C)) ()
  ((((collinear A B C) ∧ (C A ≡ C B)) ∧ (C is-midpoint-of A B))
    → (∃ x ((value x) is-midpoint-of A B))) (
        A EqualityReflexivity
        B EqualityReflexivity
        (value x) C A A B B MidpointBuilder
        detach2of2
        detach2of2

        makeSubstExplicit
        eliminateBiconditionalForward

        C x ((value x) is-midpoint-of A B) ThereExistsIntroductionFromObject
        applySyllogism

        ((collinear A B C) ∧ (C A ≡ C B)) introduceAntecedent
        import
))
</jh>

Now we are ready for the collinear case itself.
<jh>
thm (MidpointExistsGivenEquidistant-collinear ((x A) (x B) (x C)) ()
  (((collinear A B C) ∧ (C A ≡ C B)) → (∃ x ((value x) is-midpoint-of A B))) (
</jh>
The first step is <code>A = B ∨ C is-midpoint-of A B<code>.
<jh>
        A B C Collinearity23
        eliminateBiconditionalReverse
        (C A ≡ C B) conjoinRR

        A C B EquidistantMidpoint
        applySyllogism
</jh>
The <code>A = B</code> case is <code>collinear A B C ∧ C A ≡ C B ∧ A = B → ∃ x x is-midpoint-of A B</code>.
<jh>
        A B C x MidpointExistsGivenEquidistant-a-b
        export
</jh>
The <code>C is-midpoint-of A B<code> case is <code>collinear A B C ∧ C A ≡ C B ∧ C is-midpoint-of A B → ∃ x x is-midpoint-of A B</code>.
<jh>
        A B C x MidpointExistsGivenEquidistant-c-a-b
        export

        composeConjunction
</jh>
We combine the cases, to get <code>collinear A B C ∧ C A ≡ C B → (A = B ∨ C is-midpoint-of A B → ∃ x x is-midpoint-of A B).
<jh>
        (A = B)
          (∃ x ((value x) is-midpoint-of A B))
          (C is-midpoint-of A B)
          DisjunctionComposition
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Detaching <code>A = B ∨ C is-midpoint-of A B</code> we are done.
<jh>
        applyModusPonensInConsequent
))
</jh>

[[File:Proof of lemma l7_25 in Narboux.svg|construction of <code>P</code>, <code>Q</code>, <code>R</code>, and <code>X</code>]]
We have already handled the case in which <code>A</code>, <code>B</code>, and <code>C</code> are collinear, so assume they are non-collinear for the rest of the proof. Next extend line segment <code>C A</code> to a distinct point <code>P</code> and extend line segment <code>C B<code> by the same distance to a point <code>Q</code>. Let <code>R</code> be the intersection of <code>A Q</code> and <code>B P</code>. Then let <code>X</code> be the intersection of <code>A B</code> and <code>C R</code>.

Our plan is to show that <code>X</code> is the midpoint of <code>A B</code>. To do so, we'll prove <code>A R ≡ B R</code>, so <code>EquidistantLine</code> will give us <code>A X ≡ B X</code>.

We first construct <code>P</code> and <code>Q</code>.
<jh>
thm (MidpointExistsGivenEquidistant-p ((p A) (p B) (p C)) ()
  (((¬ (collinear A B C)) ∧ (C A ≡ C B)) →
    (∃ p (((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
      ((between C A (value p)) ∧ (A ≠ (value p)))))
  ) (
        p C A PointConstructionDifferent
        ((¬ (collinear A B C)) ∧ (C A ≡ C B)) introduceAntecedent
        repeatAntecedentThereExists
))

thm (MidpointExistsGivenEquidistant-q ((q C) (q B) (q A) (q P)) ()
  ((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧ ((between C A P) ∧ (A ≠ P))) →
  (∃ q
    (((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
      (((between C A P) ∧ (A ≠ P)) ∧
      ((between C B (value q)) ∧ (B (value q) ≡ A P))))
      )) (
        q C B A P SegmentConstruction
        (((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
          ((between C A P) ∧ (A ≠ P)))
          introduceAntecedent
        repeatAntecedentThereExists
</jh>
For no especially good reason, for the rest of the proof we parenthesize the formula differently. We could rewrite the rest of the proof, but at least for now it will be less work to just regroup here.
<jh>
        ((¬ (collinear A B C)) ∧ (C A ≡ C B))
          ((between C A P) ∧ (A ≠ P))
          ((between C B (value q)) ∧ (B (value q) ≡ A P))
          ConjunctionAssociativity
        eliminateBiconditionalReverse
        q addThereExists
        applySyllogism
))

thm (MidpointExistsGivenEquidistant-r ((r A) (r B) (r C) (r P) (r Q)) ()
  ((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
    (((between C A P) ∧ (A ≠ P)) ∧
    ((between C B Q) ∧ (B Q ≡ A P)))
    ) →
    (∃ r
      ((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
        (((between C A P) ∧ (A ≠ P)) ∧
          ((between C B Q) ∧ (B Q ≡ A P)))) ∧
        ((between A (value r) Q) ∧ (between B (value r) P)))
    )) (
        (((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
          (((between C A P) ∧ (A ≠ P)) ∧
          ((between C B Q) ∧ (B Q ≡ A P))))
        ImplicationReflexivity
</jh>
To construct <code>r</code>, we first need <code>between P A C</code>,
<jh>
        ((¬ (collinear A B C)) ∧ (C A ≡ C B))
          (((between C A P) ∧ (A ≠ P)) ∧
            ((between C B Q) ∧ (B Q ≡ A P)))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        swapBetweennessInConsequent
</jh>
and then <code>between Q B C</code>. Applying <code>Pasch<code> then gives us
<code>∃ r (between A r Q ∧ between B r P)</code>.
<jh>
        ((¬ (collinear A B C)) ∧ (C A ≡ C B))
          (((between C A P) ∧ (A ≠ P)) ∧
            ((between C B Q) ∧ (B Q ≡ A P)))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        swapBetweennessInConsequent

        composeConjunction

        P A C Q B r Pasch
        applySyllogism
</jh>
Moving the quantifier to the start of the consequent we are done.
<jh>
        composeConjunction

        r
          (((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
            ((between C B Q) ∧ (B Q ≡ A P))))
          ((between A (value r) Q) ∧ (between B (value r) P))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        applySyllogism
))

thm (MidpointExistsGivenEquidistant-x ((x A) (x B) (x C) (x P) (x Q) (x R)) ()
  (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
    (((between C A P) ∧ (A ≠ P)) ∧
      ((between C B Q) ∧ (B Q ≡ A P)))) ∧
    ((between A R Q) ∧ (between B R P))) →
    (∃ x
      (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
        (((between C A P) ∧ (A ≠ P)) ∧
          ((between C B Q) ∧ (B Q ≡ A P)))) ∧
        ((between A R Q) ∧ (between B R P))) ∧
        ((between A (value x) B) ∧ (between R (value x) C)))
    )) (
        ((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
          (((between C A P) ∧ (A ≠ P)) ∧
            ((between C B Q) ∧ (B Q ≡ A P)))) ∧
          ((between A R Q) ∧ (between B R P)))
        ImplicationReflexivity
</jh>
To construct <code>x</code> we need <code>between C A P</code>
<jh>
        (((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
          (((between C A P) ∧ (A ≠ P)) ∧
            ((between C B Q) ∧ (B Q ≡ A P))))
          ((between A R Q) ∧ (between B R P))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
and <code>between B R P</code>. Now we apply <code>Pasch</code> to get <code>∃ x (between A x B ∧ between R x C)</code>.
<jh>
        (((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
          (((between C A P) ∧ (A ≠ P)) ∧
            ((between C B Q) ∧ (B Q ≡ A P))))
          ((between A R Q) ∧ (between B R P))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction

        C A P B R x Pasch
        applySyllogism
</jh>
Moving <code>∃ x</code> to the start of the consequent we are done.
<jh>
        composeConjunction

        x
          ((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P)))
          ((between A (value x) B) ∧ (between R (value x) C))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

[[File:Proof of lemma l7_25 in Narboux.svg|P B ≡ Q A]]
The next step is showing that <code>P B ≡ Q A</code>. This by outer five segment on baselines <code>C A P</code> and <code>C B Q</code> and points <code>B</code> and <code>A</code>.
<jh>
thm (MidpointExistsGivenEquidistant-p-b-q-a () () (
  (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
    (((between C A P) ∧ (A ≠ P)) ∧
      ((between C B Q) ∧ (B Q ≡ A P)))) ∧
    ((between A R Q) ∧ (between B R P))) ∧
    ((between A X B) ∧ (between R X C))) →
  (P B ≡ Q A)
  ) (
</jh>
The first thing we need for outer five segment is <code>C ≠ A<code>, which follows from <code>¬ collinear A B C</code>
<jh>
        ((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
          (((between C A P) ∧ (A ≠ P)) ∧
            ((between C B Q) ∧ (B Q ≡ A P)))) ∧
          ((between A R Q) ∧ (between B R P)))
          ((between A X B) ∧ (between R X C))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        A B CollinearityABA

        A EqualityReflexivity
        B EqualityReflexivity
        A A B B C A CollinearityBuilder
        detach2of3
        detach1of2

        detachImplicationBiconditionalRight
        introduceTransposition

        applySyllogism
</jh>
The first baseline is <code>between C A P</code>.
<jh>
        ((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
          (((between C A P) ∧ (A ≠ P)) ∧
            ((between C B Q) ∧ (B Q ≡ A P)))) ∧
          ((between A R Q) ∧ (between B R P)))
          ((between A X B) ∧ (between R X C))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
The second baseline is <code>between C B Q</code>.
<jh>
        ((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
          (((between C A P) ∧ (A ≠ P)) ∧
            ((between C B Q) ∧ (B Q ≡ A P)))) ∧
          ((between A R Q) ∧ (between B R P)))
          ((between A X B) ∧ (between R X C))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
The first baseline congruence is <code>C A ≡ C B</code>.
<jh>
        ((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
          (((between C A P) ∧ (A ≠ P)) ∧
            ((between C B Q) ∧ (B Q ≡ A P)))) ∧
          ((between A R Q) ∧ (between B R P)))
          ((between A X B) ∧ (between R X C))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
The other baseline congruence is <code>A P ≡ B Q</code>
<jh>
        ((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
          (((between C A P) ∧ (A ≠ P)) ∧
            ((between C B Q) ∧ (B Q ≡ A P)))) ∧
          ((between A R Q) ∧ (between B R P)))
          ((between A X B) ∧ (between R X C))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        swapCongruenceInConsequent

        composeConjunction
</jh>
The first congruence for the points is <code>C B ≡ C A</code>.
<jh>
        ((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
          (((between C A P) ∧ (A ≠ P)) ∧
            ((between C B Q) ∧ (B Q ≡ A P)))) ∧
          ((between A R Q) ∧ (between B R P)))
          ((between A X B) ∧ (between R X C))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        swapCongruenceInConsequent

        composeConjunction
</jh>
The other congruence for the points is <code>A B ≡ B A</code>.
<jh>
        A B CongruenceABBA
        introduceRightConjunctToConsequent

        C A P C B Q B A OuterFiveSegment
        applySyllogism
))
</jh>

Now we construct a point <code>r′</code> which is at a point along the line segment <code>A Q</code> corresponding to where <code>R</code> is along <code>B P</code>. We'll be trying to show that <code>r′<code> in fact equals <code>R</code>, but first we need to construct it.
<jh>
thm (MidpointExistsGivenEquidistant-rprime
  ((A r′) (B r′) (C r′) (P r′) (Q r′) (R r′) (X r′)) () (
  (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
    (((between C A P) ∧ (A ≠ P)) ∧
      ((between C B Q) ∧ (B Q ≡ A P)))) ∧
    ((between A R Q) ∧ (between B R P))) ∧
    ((between A X B) ∧ (between R X C))) →
  (∃ r′ ((((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
      (((between C A P) ∧ (A ≠ P)) ∧
        ((between C B Q) ∧ (B Q ≡ A P)))) ∧
      ((between A R Q) ∧ (between B R P))) ∧
      ((between A X B) ∧ (between R X C))) ∧
    ((between A (value r′) Q) ∧ (B R P ≅ A (value r′) Q)))
  )) (
</jh>
We construct <code>r′</code> using <code>InnerDegenerateTriangle</code>. To do so, first we need <code>between B R P</code>,
<jh>
        ((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
          (((between C A P) ∧ (A ≠ P)) ∧
            ((between C B Q) ∧ (B Q ≡ A P)))) ∧
          ((between A R Q) ∧ (between B R P)))
          ((between A X B) ∧ (between R X C))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
and then <code>B P ≡ A Q</code>.
<jh>
        A B C P Q R X MidpointExistsGivenEquidistant-p-b-q-a
        commuteCongruenceInConsequent
        composeConjunction

        B R P A Q r′ InnerDegenerateTriangle
        applySyllogism

        repeatAntecedentThereExists
))
</jh>

We next prove <code>R A ≡ R′ B</code> via inner five segment with baselines <code>B R P</code> and <code>A R′ Q</code> and points <code>A</code> and <code>B</code>.

Because we will re-use the same baselines a little later, it is convenient to move the portion of the proof regarding the baselines into a lemma.
<jh>
thm (MidpointExistsGivenEquidistant-b-r-p-a-rprime-q
  () () (
  ((((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
    (((between C A P) ∧ (A ≠ P)) ∧
      ((between C B Q) ∧ (B Q ≡ A P)))) ∧
    ((between A R Q) ∧ (between B R P))) ∧
    ((between A X B) ∧ (between R X C))) ∧
    ((between A R′ Q) ∧ (B R P ≅ A R′ Q))) →
    ((((between B R P) ∧ (between A R′ Q)) ∧ (B P ≡ A Q)) ∧ (R P ≡ R′ Q))
  ) (
</jh>
<code>between B R P</code>:
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
<code>between A R′ Q</code>:
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        composeConjunction
</jh>
The first baseline congruence is <code>B P ≡ A Q</code>.
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination

        A B C P Q R X MidpointExistsGivenEquidistant-p-b-q-a
        applySyllogism

        commuteCongruenceInConsequent
        composeConjunction
</jh>
The second baseline congruence is <code>R P ≡ R′ Q</code>, which follows from <code>B R P ≅ A R′ Q</code>.
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        B R P A R′ Q Congruence23
        applySyllogism
        composeConjunction
))

thm (MidpointExistsGivenEquidistant-r-a-rprime-b
  () () (
  ((((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
    (((between C A P) ∧ (A ≠ P)) ∧
      ((between C B Q) ∧ (B Q ≡ A P)))) ∧
    ((between A R Q) ∧ (between B R P))) ∧
    ((between A X B) ∧ (between R X C))) ∧
    ((between A R′ Q) ∧ (B R P ≅ A R′ Q))) →
    (R A ≡ R′ B)
  ) (
</jh>
We've already proved what we need for the baselines:
<jh>
        A B C P Q R X R′ MidpointExistsGivenEquidistant-b-r-p-a-rprime-q
</jh>
The first point congruence is <code>B A ≡ A B</code>.
<jh>
        B A CongruenceABBA
        introduceRightConjunctToConsequent
</jh>
The second point congruence is <code>P A ≡ Q B</code>.
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        swapCongruenceInConsequent
        commuteCongruenceInConsequent
        composeConjunction

        B R P A R′ Q A B InnerFiveSegment
        applySyllogism
))
</jh>

Next we apply inner five segment with baselines <code>B R P</code> and <code>A R′ Q</code> and points <code>Q</code> and <code>P</code> to give <code>Q R ≡ P R′</code>.
<jh>
thm (MidpointExistsGivenEquidistant-q-r-p-rprime
  () () (
  ((((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
    (((between C A P) ∧ (A ≠ P)) ∧
      ((between C B Q) ∧ (B Q ≡ A P)))) ∧
    ((between A R Q) ∧ (between B R P))) ∧
    ((between A X B) ∧ (between R X C))) ∧
    ((between A R′ Q) ∧ (B R P ≅ A R′ Q))) →
    (Q R ≡ P R′)
  ) (
</jh>
We've already proved what we need for the baselines:
<jh>
        A B C P Q R X R′ MidpointExistsGivenEquidistant-b-r-p-a-rprime-q
</jh>
The first congruence for the non-baseline points is <code>B Q ≡ A P</code>.
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        composeConjunction
</jh>
The other congruence for the non-baseline points is <code>P Q ≡ Q P</code>.
<jh>
        P Q CongruenceABBA
        introduceRightConjunctToConsequent
</jh>
Inner five segment then gives us <code>R Q ≡ R′ P</code>, which only needs to be commuted.
<jh>
        B R P A R′ Q Q P InnerFiveSegment
        applySyllogism
        commuteCongruenceInConsequent
))
</jh>

[[File:Proof of lemma l7_25 in Narboux.svg|Proving collinear B R′ P gets us close to R = R′]]
The last two congruences gives us what we need for <code>A R Q ≅ B R′ P</code>, which in turn implies <code>collinear B R′ P<code>.  Looking at the diagram it should be clear that <code>R′</code> has little hope of remaining different from <code>R</code>, although we are still a few steps from proving that <code>R = R′</code>.

<jh>
thm (MidpointExistsGivenEquidistant-a-r-q-b-rprime-p
  () () (
  ((((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
    (((between C A P) ∧ (A ≠ P)) ∧
      ((between C B Q) ∧ (B Q ≡ A P)))) ∧
    ((between A R Q) ∧ (between B R P))) ∧
    ((between A X B) ∧ (between R X C))) ∧
    ((between A R′ Q) ∧ (B R P ≅ A R′ Q))) →
    (A R Q ≅ B R′ P)
  ) (
</jh>
<code>A R ≡ B R′</code>:
<jh>
        A B C P Q R X R′ MidpointExistsGivenEquidistant-r-a-rprime-b
        commuteCongruenceInConsequent

</jh>
<code>A Q ≡ B P</code>:
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination

        A B C P Q R X MidpointExistsGivenEquidistant-p-b-q-a
        swapCongruenceInConsequent
        commuteCongruenceInConsequent
        applySyllogism
        composeConjunction

</jh>
<code>R Q ≡ R′ P</code>:
<jh>
        A B C P Q R X R′ MidpointExistsGivenEquidistant-q-r-p-rprime
        commuteCongruenceInConsequent
        composeConjunction
))

thm (MidpointExistsGivenEquidistant-b-rprime-p
  () () (
  ((((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
    (((between C A P) ∧ (A ≠ P)) ∧
      ((between C B Q) ∧ (B Q ≡ A P)))) ∧
    ((between A R Q) ∧ (between B R P))) ∧
    ((between A X B) ∧ (between R X C))) ∧
    ((between A R′ Q) ∧ (B R P ≅ A R′ Q))) →
    (collinear B R′ P)
  ) (
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        A R Q BetweennessCollinearity
        applySyllogism

        A B C P Q R X R′ MidpointExistsGivenEquidistant-a-r-q-b-rprime-p
        composeConjunction

        A R Q B R′ P CollinearityDegenerateTriangle
        applySyllogism
))
</jh>

We're getting closer to proving <code>R = R′</code> via <code>LineIntersection</code> (which says that the intersection of two lines is unique, if we rule out some degenerate cases). Next we need <code>B ≠ P</code>.
<jh>
thm (MidpointExistsGivenEquidistant-b-p
  () () (
  ((((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
    (((between C A P) ∧ (A ≠ P)) ∧
      ((between C B Q) ∧ (B Q ≡ A P)))) ∧
    ((between A R Q) ∧ (between B R P))) ∧
    ((between A X B) ∧ (between R X C))) ∧
    ((between A R′ Q) ∧ (B R P ≅ A R′ Q))) →
    (B ≠ P)
  ) (
</jh>
At the end of the proof we'll need <code>¬ collinear A B C<code>.
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
Sooner than that we'll need <code>collinear A P C<code>, which follows from <code>between C A P</code>.
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        C A P BetweennessCollinearity
        applySyllogism

        C A P CollinearityRotation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
We take the substitution <code>B = P → (collinear A B C ↔ collinear A P C)</code>,
<jh>
        A EqualityReflexivity
        C EqualityReflexivity
        A A B P C C CollinearityBuilder
        detach2of2
        detach1of2
</jh>
detach the <code>collinear A P C</code>,
<jh>
        eliminateBiconditionalForwardInConsequent
        applyComm
        applySyllogism
</jh>
transpose to <code>¬ collinear A B C → B ≠ P</code>,
<jh>
        (B = P) (collinear A B C) Transposition
        eliminateBiconditionalReverse
        applySyllogism
</jh>
and detach <code>¬ collinear A B C</code>.
<jh>
        applyModusPonensInConsequent
))
</jh>

The last thing we need to be ready to apply <code>LineIntersection</code> is <code>¬ collinear A Q B</code>. We will show <code>collinear A Q B → collinear A B C</code> by <code>CollinearityOuterTransitivity</code> on <code>B Q C</code> and <code>B Q A</code>. Here our proof seems to be streamlined from Narboux's, which applies <code>CollinearityOuterTransitivity</code> four times, not just one (TODO: re-check this statement when we're done with MidpointExistsGivenEquidistant).

The first part is <code>B ≠ Q</code>.

<jh>
thm (MidpointExistsGivenEquidistant-b-q
  () () (
  ((((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
    (((between C A P) ∧ (A ≠ P)) ∧
      ((between C B Q) ∧ (B Q ≡ A P)))) ∧
    ((between A R Q) ∧ (between B R P))) ∧
    ((between A X B) ∧ (between R X C))) ∧
    ((between A R′ Q) ∧ (B R P ≅ A R′ Q))) →
    (B ≠ Q)
  ) (
</jh>
We pick out <code>A ≠ P</code> for later use,
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
and do the same for <code>B Q ≡ A P</code>
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
Then we take <code>B = Q ∧ B Q ≡ A P → A = P</code> and detach the <code>B Q ≡ A P</code>.
<jh>
        B Q A P CongruenceIdentityFromEquality
        export
        applyComm
        applySyllogism
</jh>
Transposing and detaching <code>A ≠ P</code> gives us <code>B ≠ Q</code>.
<jh>
        (B = Q) (A = P) Transposition
        eliminateBiconditionalReverse
        applySyllogism
        applyModusPonensInConsequent
))

thm (MidpointExistsGivenEquidistant-a-q-b
  () () (
  ((((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
    (((between C A P) ∧ (A ≠ P)) ∧
      ((between C B Q) ∧ (B Q ≡ A P)))) ∧
    ((between A R Q) ∧ (between B R P))) ∧
    ((between A X B) ∧ (between R X C))) ∧
    ((between A R′ Q) ∧ (B R P ≅ A R′ Q))) →
    (¬ (collinear A Q B))
  ) (
</jh>
We'll start with putting several things on the proof stack which we'll use later in the proof. The first one is <code>¬ collinear B C A</code>
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        A B C CollinearityRotation
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next is <code>collinear B Q C</code>.
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        C B Q BetweennessCollinearity
        applySyllogism

        C B Q CollinearityRotation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next is <code>B ≠ Q</code>.
<jh>
        A B C P Q R X R′ MidpointExistsGivenEquidistant-b-q
</jh>
Now we take <code>B ≠ Q ∧ collinear B Q C ∧ collinear B Q A → collinear B C A</code> and detach the first two conjuncts.
<jh>
        B Q C A CollinearityOuterTransitivity
        export
        export
        applySyllogism
        applyModusPonensInConsequent
</jh>
Transposing and detaching gives us <code>¬ collinear B Q A</code>.
<jh>
        (collinear B Q A) (collinear B C A) Transposition
        eliminateBiconditionalReverse
        applySyllogism

        applyModusPonensInConsequent
</jh>
We just need to rearrange that into <code>¬ collinear A Q B</code>
<jh>
        B Q A Collinearity13
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

It is now time for <code>R = R′</code>.
<jh>
thm (MidpointExistsGivenEquidistant-r-rprime
  () () (
  ((((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
    (((between C A P) ∧ (A ≠ P)) ∧
      ((between C B Q) ∧ (B Q ≡ A P)))) ∧
    ((between A R Q) ∧ (between B R P))) ∧
    ((between A X B) ∧ (between R X C))) ∧
    ((between A R′ Q) ∧ (B R P ≅ A R′ Q))) →
    (R = R′)
  ) (
</jh>
The proof is via <code>LineIntersection</code> on the lines <code>A Q</code> and <code>B P</code>. First we need <code>¬ collinear A Q B</code>.
<jh>
        A B C P Q R X R′ MidpointExistsGivenEquidistant-a-q-b
</jh>
<code>B ≠ P</code>:
<jh>
        A B C P Q R X R′ MidpointExistsGivenEquidistant-b-p
        composeConjunction
</jh>
<code>collinear A Q R</code>:
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        A R Q BetweennessCollinearity
        applySyllogism

        A R Q Collinearity23
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
<code>collinear A Q R′</code>:
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        A R′ Q BetweennessCollinearity
        applySyllogism

        A R′ Q Collinearity23
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
<code>collinear B P R</code>:
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        B R P BetweennessCollinearity
        applySyllogism

        B R P Collinearity23
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
<code>collinear B P R′</code>:
<jh>
        A B C P Q R X R′ MidpointExistsGivenEquidistant-b-rprime-p

        B R′ P Collinearity23
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Applying <code>LineIntersection</code> we are done.
<jh>
        A Q B P R R′ LineIntersection
        applySyllogism
))
</jh>

Now that we have <code>R = R′</code> we are in the home stretch. <code>A R ≡ R B</code> is next.
<jh>
thm (MidpointExistsGivenEquidistant-a-r-r-b
  () () (
  ((((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
    (((between C A P) ∧ (A ≠ P)) ∧
      ((between C B Q) ∧ (B Q ≡ A P)))) ∧
    ((between A R Q) ∧ (between B R P))) ∧
    ((between A X B) ∧ (between R X C))) ∧
    ((between A R′ Q) ∧ (B R P ≅ A R′ Q))) →
    (A R ≡ R B)
  ) (
</jh>
First we put <code>B R ≡ A R′</code> on the stack for use a bit later.
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        B R P A R′ Q Congruence12
        applySyllogism
</jh>
Next is <code>R = R′</code>.
<jh>
        A B C P Q R X R′ MidpointExistsGivenEquidistant-r-rprime
</jh>
<code>R = R′ → (B R ≡ A R ↔ B R ≡ A R′)</code>:
<jh>
        R EqualityReflexivity
        A EqualityReflexivity
        B EqualityReflexivity
        B B R R A A R R′ CongruenceBuilder
        detach1of4
        detach2of3
        detach1of2
</jh>
Combining those pieces we get <code>B R ≡ A R</code>,
<jh>
        applySyllogism
        eliminateBiconditionalForwardInConsequent
        applyModusPonensInConsequent
</jh>
which we rearrange to <code>A R ≡ R B</code>.
<jh>
        swapCongruenceInConsequent
        commuteCongruenceRightInConsequent
))
</jh>

[[File:Proof of lemma l7_25 in Narboux.svg|since <code>C</code> and <code>R</code> are equidistant from <code>A</code> and <code>B</code>, so is <code>X</code>]]
We're almost ready to apply <code>EquidistantLine</code>. We still need <code>C ≠ R</code>, though. If <code>C</code> were equal to <code>R</code>, then <code>between R X C</code> would imply that <code>C = X</code>, and <code>between A X B</code> would imply <code>collinear A B C</code>, which is a contradiction.
<jh>
thm (MidpointExistsGivenEquidistant-c-r
  () () (
  ((((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
    (((between C A P) ∧ (A ≠ P)) ∧
      ((between C B Q) ∧ (B Q ≡ A P)))) ∧
    ((between A R Q) ∧ (between B R P))) ∧
    ((between A X B) ∧ (between R X C))) ∧
    ((between A R′ Q) ∧ (B R P ≅ A R′ Q))) →
    (C ≠ R)
  ) (
</jh>
At the end of the proof we'll need <code>¬ collinear A B C</code>.
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
We start with <code>between C X R</code>.
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        swapBetweennessInConsequent
</jh>
Next is <code>between C X R → (C = R → C = X)</code>, which follows from <code>C = R ∧ between C X R → C = X</code> and some rearrangement.
<jh>
        C R X IndivisibilityFromEquality
        export
        applyComm
</jh>
Combining those we get <code>C = R → C = X</code>.
<jh>
        applySyllogism
</jh>
Leaving that on the stack for a while, we go to <code>between A X B</code>.
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
<code>C = X → (between A C B ↔ between A X B)</code>:
<jh>
        A EqualityReflexivity
        B EqualityReflexivity
        A A C X B B BetweennessBuilder
        detach2of2
        detach1of2
</jh>
Now we detach the <code>between A X B</code>.
<jh>
        eliminateBiconditionalForwardInConsequent
        applyComm
        applySyllogism
</jh>
We have <code>C = X</code> implies <code>between A C B</code>, which in implies <code>collinear A B C</code>.
<jh>
        import

        A C B BetweennessCollinearity

        A C B Collinearity23
        eliminateBiconditionalReverse
        applySyllogism

        applySyllogism
        export
</jh>
Combining this with <code>C = R → C = X</code> gives us <code>C = R → collinear A B C</code>.
<jh>
        applySyllogismInConsequent
</jh>
Now we pick up <code>¬ collinear A B C</code> from the proof stack and conclude <code>C ≠ R</code>.
<jh>
        introduceTranspositionInConsequent
        applyModusPonensInConsequent
))
</jh>

We're now ready to conclude <code>X is-midpoint-of A B</code>.
<jh>
thm (MidpointExistsGivenEquidistant-x-midpoint
  () () (
  ((((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
    (((between C A P) ∧ (A ≠ P)) ∧
      ((between C B Q) ∧ (B Q ≡ A P)))) ∧
    ((between A R Q) ∧ (between B R P))) ∧
    ((between A X B) ∧ (between R X C))) ∧
    ((between A R′ Q) ∧ (B R P ≅ A R′ Q))) →
    (X is-midpoint-of A B)
  ) (
</jh>
The first half of <code>X is-midpoint-of A B</code> is <code>between A X B</code>, which is true by construction.
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
The other half is <code>A X ≡ X B</code>. We will conclude <code>X A ≡ X B</code> by <code>EquidistantLine</code> (noting that each of <code>C</code> and <code>R</code> are equidistant from <code>A</code> and <code>B</code>, and <code>X</code> is on the same line). First we need  <code>C ≠ R</code>.
<jh>
        A B C P Q R X R′ MidpointExistsGivenEquidistant-c-r
</jh>
Next is <code>collinear C R X</code>
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        R X C BetweennessCollinearity
        applySyllogism

        C R X CollinearityRotation
        eliminateBiconditionalForward
        applySyllogism

        composeConjunction
</jh>
Now we just need equidistance to the two known points, first <code>C A ≡ C B</code>,
<jh>
        (((((¬ (collinear A B C)) ∧ (C A ≡ C B)) ∧
            (((between C A P) ∧ (A ≠ P)) ∧
              ((between C B Q) ∧ (B Q ≡ A P)))) ∧
            ((between A R Q) ∧ (between B R P))) ∧
            ((between A X B) ∧ (between R X C)))
          ((between A R′ Q) ∧ (B R P ≅ A R′ Q))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
and then <code>R A ≡ R B</code>.
<jh>
        A B C P Q R X R′ MidpointExistsGivenEquidistant-a-r-r-b
        commuteCongruenceLeftInConsequent

        composeConjunction
</jh>
Applying <code>EquidistantLine</code> gives us <code>X A ≡ X B</code> which we commute to <code>A X ≡ X B</code>, and that's all we need for <code>X is-midpoint-of A B</code>.
<jh>
        C R X A B EquidistantLine
        applySyllogism
        commuteCongruenceLeftInConsequent

        composeConjunction
))
</jh>

A bit of logic finishes the proof.
<jh>
thm (MidpointExistsGivenEquidistant-noncollinear
  ((x A) (x B) (x C)

   (p A) (p B) (p C) (q A) (q B) (q C) (p q)
   (r A) (r B) (r C) (r p) (r q)
   (x p) (x q) (x r)
   (r′ A) (r′ B) (r′ C) (r′ p) (r′ q) (r′ r) (r′ x)
   ) ()
  (((¬ (collinear A B C)) ∧ (C A ≡ C B)) → (∃ x ((value x) is-midpoint-of A B))) (
        A B C p MidpointExistsGivenEquidistant-p

        A B C (value p) q MidpointExistsGivenEquidistant-q
        p addThereExists
        applySyllogism

        A B C (value p) (value q) r MidpointExistsGivenEquidistant-r
        q addThereExists
        p addThereExists
        applySyllogism

        A B C (value p) (value q) (value r) x MidpointExistsGivenEquidistant-x
        r addThereExists
        q addThereExists
        p addThereExists
        applySyllogism

        A B C (value p) (value q) (value r) (value x) r′ MidpointExistsGivenEquidistant-rprime
        x addThereExists
        r addThereExists
        q addThereExists
        p addThereExists
        applySyllogism

        A B C (value p) (value q) (value r) (value x) (value r′)
          MidpointExistsGivenEquidistant-x-midpoint
        r′ addThereExists
        removeThereExistsInConsequent
        x addThereExists
        r addThereExists
        q addThereExists
        p addThereExists
        applySyllogism

        removeThereExistsInConsequent
        removeThereExistsInConsequent
        removeThereExistsInConsequent
))

thm (MidpointExistsGivenEquidistant ((x A) (x B) (x C)) ()
  ((C A ≡ C B) → (∃ x ((value x) is-midpoint-of A B))) (
        A B C x MidpointExistsGivenEquidistant-collinear
        export

        A B C x MidpointExistsGivenEquidistant-noncollinear
        export

        eliminateCases
))
</jh>

== Export ==
We now export to [[Interface:Midpoint]].
<jh>
export (RESULTS Interface:Midpoint (CLASSICAL FIRSTORDER) ())
</jh>

Also, we export to [[Interface:Basic geometry]] since it hasn't yet been updated for anything after this point.
<jh>
export (GEOMETRY Interface:Basic_geometry (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>
* Tarski, Alfred; Givant, Steven (1999), "Tarski's system of geometry", The Bulletin of Symbolic Logic 5 (2): 175–214, doi:10.2307/421089, MR1791303, ISSN 1079-8986

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]