{{interfaces
| imports = [[Interface:Symmetric point]]
| exports = [[Interface:Midpoint]]
}}

This is part of a series of modules which prove a variety of geometrical theorems starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

This page proves various results involving the midpoint of a line segment. We don't yet prove the existence of a midpoint (that's in the next chapter).

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Symmetric point|geometry results so far]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (START Interface:Symmetric_point (CLASSICAL FIRSTORDER) ())

var (point A B C D E F M P Q R S X Y Z)
var (point A′ B′ C′ D′ E′ M′ P′ Q′ R′ S′ X′ Y′)
var (variable a a′ b b′ c c′ d d′ e e′ f p p′ x x′ y y′ z)
</jh>

== Midpoint builder ==
This is the proposition that equals can be substituted for equals, in the context of <code>is-midpoint-of</code>. It follows directly from the builders for betweenness and line segment congruence.<ref>not in Narboux</ref>
<jh>
thm (MidpointBuilder () () ((((M = M′) ∧ (A = A′)) ∧ (B = B′)) →
  ((M is-midpoint-of A B) ↔ (M′ is-midpoint-of A′ B′))) (
        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        composeConjunction

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionLeftElimination
        composeConjunction

        A A′ M M′ B B′ BetweennessBuilder
        applySyllogism

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        composeConjunction

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        composeConjunction

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionLeftElimination
        composeConjunction

        A A′ M M′ M M′ B B′ CongruenceBuilder
        applySyllogism

        buildConjunctionInConsequent
))
</jh>

== Midpoint is unique ==
The midpoint of a line segment is unique.<ref>l7_17 in Narboux</ref>

[[File:Proof of midpoint uniqueness.svg|thumb|right]]
To prove it, start with a line segment <code>P P′</code> which has two midpoints <code>A</code> and <code>B</code>. Our aim is to show that <code>A = B</code>. First construct <code>B′</code>, the symmetric point of <code>B</code> through the point <code>A</code>. Because reflecting through a symmetric point preserves distances, the line segments <code>P B′</code> and <code>B′ P′</code> are congruent to <code>P B</code> and <code>B P′</code>.

Applying <code>BetweennessTwoDistanceUniqueness</code> gives us <code>B = B′</code>. And since <code>B B′</code> is an empty line segment and <code>A</code> is one of its midpoints, then <code>A = B</code>.

To formalize this proof, first we construct the point <code>B′</code>.
<jh>
thm (MidpointUniqueness-bprime ((b′ A) (b′ B) (b′ P) (b′ P′)) ()
  (((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) → 
  (∃ b′ (((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B (value b′))))) (
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ImplicationReflexivity
        b′ A B SymmetricPoint
        introduceRightConjunctToConsequent

        b′
          ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B (value b′))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward

        applySyllogism
))
</jh>

Because reflecting about the point <code>A</code> preserves distances, <code>P B ≡ P′ B′</code>.
<jh>
thm (MidpointUniqueness-p-b-pprime-bprime ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (P B ≡ P′ B′)) (
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionLeftElimination

        composeConjunction

        A P P′ B B′ SymmetricPointDistance
        applySyllogism

        swapCongruenceInConsequent
))
</jh>

Similarly, <code>P′ B ≡ P B′</code>.
<jh>
thm (MidpointUniqueness-pprime-b-p-bprime ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (P′ B ≡ P B′)) (
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionLeftElimination

        A B B′ MidpointSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        A P P′ B′ B SymmetricPointDistance
        applySyllogism
))

thm (MidpointUniqueness-b-bprime ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (B = B′)) (
</jh>
In this case <code>BetweennessTwoDistanceUniqueness</code> expands to <code>between P B P′ ∧ P B ≡ P B′ ∧ P′ B ≡ P′ B′ → B = B′</code>. First is <code>between P B P′</code>.
<jh>
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
Next is <code>P B ≡ P B′</code>, which we prove via <code>P B ≡ P′ B</code> and <code>P′ B ≡ P B′</code>.
<jh>
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        commuteCongruenceRightInConsequent

        A P P′ B B′ MidpointUniqueness-pprime-b-p-bprime

        composeConjunction
        P B P′ B P B′ CongruenceTransitivity
        applySyllogism

        composeConjunction
</jh>
Last is <code>P′ B ≡ P′ B′</code>, which we prove via <code>P′ B ≡ P B</code> and <code>P B ≡ P′ B′</code>.
<jh>
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        commuteCongruenceRightInConsequent
        swapCongruenceInConsequent

        A P P′ B B′ MidpointUniqueness-p-b-pprime-bprime

        composeConjunction
        P′ B P B P′ B′ CongruenceTransitivity
        applySyllogism

        composeConjunction

        P B P′ B′ BetweennessTwoDistanceUniqueness
        applySyllogism
))
</jh>

Because <code>A</code> is between two points which end up being equal (<code>B</code> and <code>B′</code>), we can conclude that <code>A = B</code>.
<jh>
thm (MidpointUniqueness-a-b-b ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (A is-midpoint-of B B)) (
        A P P′ B B′ MidpointUniqueness-b-bprime

        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionLeftElimination
        composeConjunction

        A EqualityReflexivity
        B EqualityReflexivity
        A A B B B B′ MidpointBuilder
        detach2of3
        detach1of2
        eliminateBiconditionalForwardInConsequent
        import

        applySyllogism
))

thm (MidpointUniqueness-a-b ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (A = B)) (
        A P P′ B B′ MidpointUniqueness-a-b-b
        A B MidpointIndivisibility
        applySyllogism
))

thm (MidpointUniqueness ( (b′ A) (b′ B) (b′ P) (b′ P′)) ()
  (((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) → (A = B)) (
        A P P′ B b′ MidpointUniqueness-bprime

        A P P′ B (value b′) MidpointUniqueness-a-b
        b′ addThereExists
        applySyllogism

        removeThereExistsInConsequent
))
</jh>

== The equidistant point is the midpoint ==
A point which is equidistant to the two distinct endpoints of a line segment, and on the same line as them, is the midpoint of that line segment. In symbols, <code>collinear A M B ∧ M A ≡ M B → A = B ∨ M is-midpoint-of A B</code>.<ref>l7_20 in Narboux</ref>

There are three cases based on <code>collinear A M B</code>. The first is <code>between A M B</code> which trivially satisfies the definition of midpoint.
<jh>
thm (EquidistantMidpoint-a-m-b () ()
  ((between A M B) → ((M A ≡ M B) →
    ((A = B) ∨ (M is-midpoint-of A B)))) (
        M A M B CongruenceLeftCommutativity
        eliminateBiconditionalReverse
        (between A M B) conjoinLL

        (M is-midpoint-of A B) (A = B) DisjunctionLeftIntroduction
        applySyllogism

        export
))
</jh>

The second case is <code>between M B A</code>. Because <code>B</code> and <code>A</code> are the same distance from <code>M</code>, they must be the same point. To formalize this, apply inner three segment to <code>between M B A</code> and <code>between M B B</code>, which produces <code>B A ≡ B B</code>.
<jh>
thm (EquidistantMidpoint-m-b-a () ()
  ((between M B A) → ((M A ≡ M B) →
    ((A = B) ∨ (M is-midpoint-of A B)))) (
</jh>
Inner three segment needs two betweenness relationships, <code>between A B M</code>
<jh>
        (between M B A) (M A ≡ M B) ConjunctionRightElimination
        swapBetweennessInConsequent
</jh>
and <code>between B B M</code>,
<jh>
        B M BetweenAAB
        introduceRightConjunctToConsequent
</jh>
and two congruences, <code>A M ≡ B M</code>
<jh>
        (between M B A) (M A ≡ M B) ConjunctionLeftElimination
        commuteCongruenceInConsequent
        composeConjunction
</jh>
and <code>B M ≡ B M</code>.
<jh>
        B M CongruenceReflexivity
        introduceRightConjunctToConsequent
</jh>
The conclusion is <code>A B ≡ B B</code>,
<jh>
        A B M B B M InnerThreeSegment
        applySyllogism
</jh>
which in turn implies our result.
<jh>
        A B B CongruenceIdentity
        applySyllogism

        (A = B) (M is-midpoint-of A B) DisjunctionRightIntroduction
        applySyllogism

        export
))
</jh>

The third case is <code>between B A M</code>. Because <code>A</code> and <code>B</code> can be interchanged, it can be proven from the <code>between M B A</code> case. 
<jh>
thm (EquidistantMidpoint-b-a-m () ()
  ((between B A M) → ((M A ≡ M B) →
    ((A = B) ∨ (M is-midpoint-of A B)))) (
</jh>
When invoked with <code>A</code> and <code>B</code> switched, <code>EquidistantMidpoint-m-b-a</code> is <code>between M A B → (M B ≡ M A → B = A ∨ M is-midpoint-of B A)</code>. Rearranging we are done.
<jh>
        M A B EquidistantMidpoint-m-b-a

        M A B BetweennessSymmetry

        M B M A CongruenceSymmetry

        B A EqualitySymmetry
        M B A MidpointSymmetry
        buildDisjunction

        buildImplication

        buildImplication

        eliminateBiconditionalReverse
        applyModusPonens
))
</jh>

Combining the cases finishes the proof.
<jh>
thm (EquidistantMidpoint () ()
  (((collinear A M B) ∧ (M A ≡ M B)) →
    ((A = B) ∨ (M is-midpoint-of A B))) (
        A M B EquidistantMidpoint-a-m-b
        M B A EquidistantMidpoint-m-b-a
        composeDisjunction

        B A M EquidistantMidpoint-b-a-m
        composeDisjunction

        import
))
</jh>

== Diagonals bisect each other ==
[[File:Proof of lemma l7_20 in Narboux.svg|220px|The proof constructs P′ and shows that P = P′]]
Given a "parallelogram" (that is, a quadrilateral with opposite sides congruent; we haven't yet developed any theory of parallel lines), the diagonals bisect each other.

First we construct a point <code>p′</code> which is like <code>P</code> but as far from <code>D</code> as <code>P</code> is from <code>B</code>. That is, <code>B D P ≅ D B P′</code>
<jh>
thm (ParallelogramDiagonals-pprime
  ((p′ A) (p′ B) (p′ C) (p′ D) (p′ P)) ()
  (((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) →
    (∃ p′ (((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
      (collinear A P C)) ∧ (collinear B P D)) ∧
      (B D P ≅ D B (value p′))))) (
        ((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
          (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
          (collinear A P C)) ∧ (collinear B P D))
          ImplicationReflexivity
</jh>
Next, we construct <code>p′</code>, starting with <code>collinear B D P</code>.
<jh>
        (((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
            (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
            (collinear A P C))
          (collinear B P D)
          ConjunctionLeftElimination

        B P D Collinearity23
        eliminateBiconditionalReverse
        applySyllogism
</jh>
The other thing for the construction is <code>B D ≡ D B</code>.
<jh>
        B D CongruenceABBA
        introduceRightConjunctToConsequent
</jh>
This lets us conclude <code>∃ p′ B D P ≡ D B p′</code>.
<jh>
        B D P D B p′ CollinearityConstructDegenerateTriangle
        applySyllogism
</jh>
Now we just need to repeat the formulas from the antecedent and move them inside the quantifier.
<jh>
        composeConjunction
        todo: predicate logic
))

#thm (ParallelogramDiagonals () ()
#  (((((((¬ (collinear A B C)) ∧ (B ≠ D)) ∧
#      (A B ≡ C D)) ∧ (B C ≡ D A)) ∧
#      (collinear A P C)) ∧ (collinear B P D)) →
#    ((P is-midpoint-of A C) ∧ (P is-midpoint-of B D))) (
#))
</jh>

== Export ==
We now export to [[Interface:Midpoint]].
<jh>
#export (RESULTS Interface:Midpoint (CLASSICAL FIRSTORDER) ())
</jh>

Also, since this is currently the last proof module for geometry, we export to [[Interface:Basic geometry]].
<jh>
export (GEOMETRY Interface:Basic_geometry (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>
* Tarski, Alfred; Givant, Steven (1999), "Tarski's system of geometry", The Bulletin of Symbolic Logic 5 (2): 175–214, doi:10.2307/421089, MR1791303, ISSN 1079-8986

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]
