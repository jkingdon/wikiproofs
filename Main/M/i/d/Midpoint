{{interfaces
| imports = [[Interface:Symmetric point]]
| exports = [[Interface:Midpoint]]
}}

This is part of a series of modules which prove a variety of geometrical theorems starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

This page proves various results involving the midpoint of a line segment. We don't yet prove the existence of a midpoint (that's in the next chapter).

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Line segment inequality|geometry results so far]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (START Interface:Line_segment_inequality (CLASSICAL FIRSTORDER) ())

var (point A B C D E F M P Q R S X Y Z)
var (point A′ B′ C′ D′ E′ M′ P′ Q′ R′ S′ X′ Y′)
var (point P1 P2)
var (variable a b c c′ d d′ e e′ f p p′ x x′ y y′ z)
</jh>

== Midpoint builder ==
This is the proposition that equals can be substituted for equals, in the context of <code>is-midpoint-of</code>. It follows directly from the builders for betweenness and line segment congruence.<ref>not in Narboux</ref>
<jh>
thm (MidpointBuilder () () ((((M = M′) ∧ (A = A′)) ∧ (B = B′)) →
  ((M is-midpoint-of A B) ↔ (M′ is-midpoint-of A′ B′))) (
        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        composeConjunction

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionLeftElimination
        composeConjunction

        A A′ M M′ B B′ BetweennessBuilder
        applySyllogism

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        composeConjunction

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        composeConjunction

        ((M = M′) ∧ (A = A′)) (B = B′) ConjunctionLeftElimination
        composeConjunction

        A A′ M M′ M M′ B B′ CongruenceBuilder
        buildConjunctionInConsequent
))

== Midpoint is unique ==
The midpoint of a line segment is unique.<ref>l7_17 in Narboux</ref>

[[File:Proof of midpoint uniqueness.svg|thumb|right]]
To prove it, start with a line segment <code>P P′</code> which has two midpoints <code>A</code> and <code>B</code>. Our aim is to show that <code>A = B</code>. First construct <code>B′</code>, the symmetric point of <code>B</code> through the point <code>A</code>. Because reflecting through a symmetric point preserves distances, the line segments <code>P B′</code> and <code>B′ P′</code> are congruent to <code>P B</code> and <code>B P′</code>.

Applying <code>BetweennessTwoDistanceUniqueness</code> gives us <code>B = B′</code>. And since <code>B B′</code> is an empty line segment and <code>A</code> is one of its midpoints, then <code>A = B</code>.

To formalize this proof, first we construct the point <code>B′</code>.
<jh>
thm (MidpointUniqueness-bprime ((b′ A) (b′ B)) ()
  (((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) → 
  (∃ b′ (((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B (value b′))))) (
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ImplicationReflexivity
        b′ A P SymmetricPoint
        introduceRightConjunctToConsequent

        b′
          ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B (value b′))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward

        applySyllogism
))
</jh>

Because reflecting about the point <code>A</code> preserves distances, <code>P B ≡ P′ B′</code>.
<jh>
thm (MidpointUniqueness-p-b-pprime-bprime ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (P B ≡ P′ B′)) (
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionLeftElimination

        composeConjunction

        A P P′ B B′ SymmetricPointDistance
        applySyllogism

        swapCongruenceInConsequent
))

Similarly, <code>P′ B ≡ P B′</code>.
<jh>
thm (MidpointUniqueness-pprime-b-p-bprime ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (P′ B ≡ P B′)) (
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionLeftElimination

        A B B′ MidpointSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        A P P′ B′ B SymmetricPointDistance
        applySyllogism
))

thm (MidpointUniqueness-b-bprime ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (B = B′)) (
</jh>
In this case <code>BetweennessTwoDistanceUniqueness</code> expands to <code>between P B P′ ∧ P B ≡ P B′ ∧ P′ B ≡ P′ B′ → B = B′</code>. First is <code>between P B P′</code>.
<jh>
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
Next is <code>P B ≡ P B′</code>, which we prove via <code>P B ≡ P′ B</code> and <code>P′ B ≡ P B′</code>.
<jh>
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        commuteCongruenceRightInConsequent

        A P P′ B B′ MidpointUniqueness-pprime-b-p-bprime

        composeConjunction
        P B P′ B P B′ CongruenceTransitivity
        applySyllogism

        composeConjunction
</jh>
Last is <code>P′ B ≡ P′ B′</code>, which we prove via <code>P′ B ≡ P B</code> and <code>P B ≡ P′ B′</code>.
<jh>
        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        commuteCongruenceRightInConsequent
        swapCongruenceInConsequent

        A P P′ B B′ MidpointUniqueness-p-b-pprime-bprime

        composeConjunction
        P′ B P B P′ B′ CongruenceTransitivity
        applySyllogism

        composeConjunction

        P B P′ BetweennessTwoDistanceUniqueness
        applySyllogism
))
</jh>

Because <code>A</code> is between two points which end up being equal (<code>B</code> and <code>B′</code>), we can conclude that <code>A = B</code>.
<jh>
thm (MidpointUniqueness-a-b-b ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (A is-midpoint-of B B)) (
        A P P′ B B′ MidpointUniqueness-b-bprime

        ((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′))
          (A is-midpoint-of B B′)
          ConjunctionLeftElimination
        composeConjunction

        A A EqualityReflexivity
        B B EqualityReflexivity
        A A B B B B′ MidpointBuilder
        detach2of3
        deatch1of2
        import

        applySyllogism
))

thm (MidpointUniqueness-a-b ((b′ A) (b′ B)) ()
  ((((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) ∧ (A is-midpoint-of B B′)) → (A = B)) (
        A P P′ B B′ MidpointUniqueness-a-b-b
        A B MidpointIndivisibility
        applySyllogism
))

thm (MidpointUniqueness ( (b′ A) (b′ B)) ()
  (((A is-midpoint-of P P′) ∧ (B is-midpoint-of P P′)) → (A = B)) (
        A P P′ B b′ MidpointUniqueness-bprime

        A P P′ B (value b′) MidpointUniqueness-a-b
        b′ addThereExists
        applySyllogism

        removeThereExistsFromConsequent
))
</jh>

== Export ==
We now export to [[Interface:Midpoint]].
<jh>
#export (RESULTS Interface:Midpoint (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>
* Tarski, Alfred; Givant, Steven (1999), "Tarski's system of geometry", The Bulletin of Symbolic Logic 5 (2): 175–214, doi:10.2307/421089, MR1791303, ISSN 1079-8986

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]
