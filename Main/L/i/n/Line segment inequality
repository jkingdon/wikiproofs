{{interfaces
| imports = [[Interface:Connectivity for betweenness]]
| exports = [[Interface:Line segment inequality]]
}}

This is part of a series of modules which prove a variety of geometrical theorems starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

This file contains several corollaries to outer connectivity for betweenness (which was proved in [[Connectivity for betweenness]]), a few lemmas, and results relating to line segments being shorter than others.

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Connectivity for betweenness|geometry results so far]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (START Interface:Connectivity_for_betweenness (CLASSICAL FIRSTORDER) ())

var (point A B C D E F P Q R A′ B′ C′ D′ E′ B″ C″)
var (variable c c′ d d′ e e′ f p)
</jh>

== Corollaries of outer connectivity for betweenness ==

=== Middle connectivity ===
This one is just like outer connectivity except that the consequent is <code>between B C D ∨ between B D C</code> instead of <code>between A C D ∨ between A D C</code>.<ref>Lemma l5_2 in Narboux</ref>

<jh>
thm (BetweennessMiddleConnectivity-bcd () ()
  (((((A ≠ B) ∧ (between A B C)) ∧ (between A B D)) ∧ (between A C D)) → (between B C D)) (
        (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          (between A C D)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          (between A C D)
          ConjunctionLeftElimination

        composeConjunction

        A B C D BetweennessInnerTransitivityFlipped
        applySyllogism
))

thm (BetweennessMiddleConnectivity-bdc () ()
  (((((A ≠ B) ∧ (between A B C)) ∧ (between A B D)) ∧ (between A D C)) →
  (between B D C)) (
        (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          (between A D C)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          (between A D C)
          ConjunctionLeftElimination

        composeConjunction

        A B D C BetweennessInnerTransitivityFlipped
        applySyllogism
))

thm (BetweennessMiddleConnectivity () () ((((A ≠ B) ∧ (between A B C)) ∧ (between A B D)) → ((between B C D) ∨ (between B D C))) (
        A B C D BetweennessOuterConnectivity

        A B C D BetweennessMiddleConnectivity-bcd

        (between B C D) (between B D C) DisjunctionRightIntroduction
        applySyllogism
        export

        A B C D BetweennessMiddleConnectivity-bdc

        (between B D C) (between B C D) DisjunctionLeftIntroduction
        applySyllogism
        export

        composeConjunction

        (between A C D)
          ((between B C D) ∨ (between B D C))
          (between A D C)
          DisjunctionComposition
        eliminateBiconditionalReverse
        applySyllogism

        applyModusPonensInConsequent
))
</jh>

=== Inner connectivity ===
In this section we prove <code>between A B D ∧ between A C D → between A B C ∨ between A C B</code>.<ref>l5_3 in Narboux</ref><ref>Axiom 17 on page 186 of Tarski and Givant (1999)</ref> The proof is in terms of outer connectivity.
<jh>
thm (BetweennessInnerConnectivity-1 ((e A) (e B) (e C) (e D)) ()
  (((between A B D) ∧ (between A C D)) → (∃ e (((between A B D) ∧ (between A C D)) ∧ ((between D A (value e)) ∧ (A ≠ (value e)))))) (
        ((between A B D) ∧ (between A C D)) ImplicationReflexivity
</jh>
We extend the line segment <code>D A</code> to a distinct point <code>e</code>.
<jh>
        e D A PointConstructionDifferent
</jh>
That gives us <code>∃ e (between D A e ∧ A ≠ e)</code>.
<jh>
        introduceRightConjunctToConsequent

        e
          ((between A B D) ∧ (between A C D))
          ((between D A (value e)) ∧ (A ≠ (value e)))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        applySyllogism
))

thm (BetweennessInnerConnectivity-eab () ()
  ((((between A B D) ∧ (between A C D)) ∧ ((between D A E) ∧ (A ≠ E))) → (between E A B)) (
        ((between A B D) ∧ (between A C D)) ((between D A E) ∧ (A ≠ E)) ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        D A E BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        ((between A B D) ∧ (between A C D)) ((between D A E) ∧ (A ≠ E)) ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        composeConjunction

        E A D B BetweennessInnerTransitivity
        applySyllogism
))

thm (BetweennessInnerConnectivity-eac () ()
  ((((between A B D) ∧ (between A C D)) ∧ ((between D A E) ∧ (A ≠ E))) → (between E A C)) (
        ((between A B D) ∧ (between A C D)) ((between D A E) ∧ (A ≠ E)) ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        D A E BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        ((between A B D) ∧ (between A C D)) ((between D A E) ∧ (A ≠ E)) ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        composeConjunction

        E A D C BetweennessInnerTransitivity
        applySyllogism
))

thm (BetweennessInnerConnectivity-abc-acb () ()
  ((((between A B D) ∧ (between A C D)) ∧ ((between D A E) ∧ (A ≠ E))) → ((between A B C) ∨ (between A C B))) (
</jh>
To apply middle transitivity, we first need <code>E ≠ A</code>.
<jh>
        ((between A B D) ∧ (between A C D)) ((between D A E) ∧ (A ≠ E)) ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        A E EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Then we need <code>between E A B</code> and <code>between E A C</code>.
<jh>
        A B D C E BetweennessInnerConnectivity-eab
        composeConjunction

        A B D C E BetweennessInnerConnectivity-eac
        composeConjunction

        E A B C BetweennessMiddleConnectivity
        applySyllogism
))

thm (BetweennessInnerConnectivity ( (e A) (e B) (e C) (e D)) ()
  (((between A B D) ∧ (between A C D)) → ((between A B C) ∨ (between A C B))) (
        A B D C e BetweennessInnerConnectivity-1

        A B D C (value e) BetweennessInnerConnectivity-abc-acb
        e addThereExists
        applySyllogism

        removeThereExistsInConsequent
))
</jh>

== Line segment inequality ==
Here we define a formula <code>A B ≤ C D</code> to mean that the line segment <code>A B</code> is shorter than or the same length as <code>C D</code>

=== Definition ===
We define <code>A B ≤ C D</code> to mean that there is a point <code>e</code> in the line segment <code>C D</code> which cuts off a portion of <code>C D</code> which is congruent to <code>A B</code>.<ref>Definition le in Narboux</ref>
<jh>
def ((≤ A B C D) (∃ e ((between C (value e) D) ∧ (A B ≡ C (value e)))))
</jh>

We define <code>≥</code> as just <code>≤</code> with the two sides interchanged.<ref>Definition ge in Narboux</ref>
<jh>
def ((≥ A B C D) (C D ≤ A B))
</jh>

Here we restate that definition as a theorem. As with most such definitions, the proof is just a matter of applying a change of variable, in this case based on <code>e′ = e → (between C e′ D ∧ A B ≡ C e′ ↔ between C e D ∧ A B ≡ C e)</code>.
<jh>
thm (LessEqualCutoff
  ((e A) (e B) (e C) (e D)  (e′ e A) (e′ e B) (e′ e C) (e′ e D)) ()
  ((A B ≤ C D) ↔ (∃ e ((between C (value e) D) ∧ (A B ≡ C (value e))))) (
        C EqualityReflexivity
        D EqualityReflexivity
        C C (value e′) (value e) D D BetweennessBuilder
        detach2of2
        detach1of2

        A EqualityReflexivity
        B EqualityReflexivity
        C EqualityReflexivity
        A A B B C C (value e′) (value e) CongruenceBuilder
        detach2of3
        detach2of3
        detach1of2

        buildConjunctionInConsequent

        ChangeVariableThereExists
))
</jh>

=== An alternate definition ===
We could just as well define <code>A B ≤ C D</code> to mean that it is possible to extend <code>A B</code> to a point to produce a line segment which is congruent to <code>C D</code>. In this section we prove that this definition is equivalent to the one in the previous section.

We first tackle the forward implication. From the definition of <code>A B ≤ C D</code>, there is a point <code>E</code> between <code>C</code> and <code>D</code> such that <code>A B ≡ C E</code>. We then extend the line segment <code>A B</code> to a point <code>F</code> such that <code>C E D ≅ A B F</code>. This gives us the two things we need: <code>between A B F</code> from <code>BetweennessDegenerateTriangle</code> and <code>C D ≡ A F</code> directly from <code>C E D ≅ A B F</code>.<ref>lemma l5_5_1 in Narboux</ref>
<jh>
thm (LessEqualExtensionForward-ced-abf ((f A) (f B) (f C) (f D) (f E)) ()
  (((between C E D) ∧ (A B ≡ C E)) → (∃ f (C E D ≅ A B (value f)))) (
        C E D BetweennessCollinearity
        A B C E CongruenceSymmetry
        eliminateBiconditionalReverse
        conjoin

        C E D A B f CollinearityConstructDegenerateTriangle
        applySyllogism
))

thm (LessEqualExtensionForward-ced-ced-abf
  ((f A) (f B) (f C) (f D) (f E)) ()
  (((between C E D) ∧ (A B ≡ C E)) → (∃ f ((between C E D) ∧ (C E D ≅ A B (value f))))) (
        (between C E D) (A B ≡ C E) ConjunctionRightElimination
        C E D A B f LessEqualExtensionForward-ced-abf
        composeConjunction

        f (between C E D) (C E D ≅ A B (value f)) ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        applySyllogism
))

thm (LessEqualExtensionForward-abf-afcd () ()
  (((between C E D) ∧ (C E D ≅ A B F)) → ((between A B F) ∧ (A F ≡ C D))) (
        C E D A B F BetweennessDegenerateTriangle

        (between C E D) (C E D ≅ A B F) ConjunctionLeftElimination

        C E D A B F Congruence13
        applySyllogism

        C D A F CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
))

thm (LessEqualExtensionForward
  ((f A) (f B) (f C) (f D)  (e f A) (e B) (e C) (e D)) ()
  ((A B ≤ C D) → (∃ f ((between A B (value f)) ∧ (A (value f) ≡ C D)))) (
        A B C D e LessEqualCutoff
        eliminateBiconditionalReverse

        C (value e) D A B f LessEqualExtensionForward-ced-ced-abf
        e addThereExists
        applySyllogism

        C (value e) D A B (value f) LessEqualExtensionForward-abf-afcd
        f addThereExists
        e addThereExists
        applySyllogism

        removeThereExistsInConsequent
))
</jh>

The proof of the reverse direction is fairly similar. We are given a point <code>f</code> for which <code>between A B f</code> and <code>A f ≡ C D</code>. Applying <code>InnerDegenerateTriangle</code> to those two formulas gives us a point <code>e</code> such that <code>A B f ≅ C e D</code>. It then follows that <code>between C e D</code> and <code>A B ≡ C e</code>, which are the two things we need for the definition of <code>≤</code>.<ref>l5_5_2 in Narboux</ref>
<jh>
thm (LessEqualExtensionReverse
  ((f A) (f B) (f C) (f D)  (e f A) (e B) (e C) (e D)) ()
  ((∃ f ((between A B (value f)) ∧ (A (value f) ≡ C D))) → (A B ≤ C D)) (
        A B (value f) C D e InnerDegenerateTriangle
        f addThereExists
</jh>
At this point we have <code>∃ f ∃ e (between C e D ∧ A B f ≅ C e D)</code>. To satisfy <code>LessEqualCutoff</code> we need <code>∃ e (between C e D ∧ A B ≡ C e)</code>.
<jh>
        A B (value f) C (value e) D Congruence12
        (between C (value e) D) conjoinLL
        e addThereExists
        f addThereExists
        applySyllogism

        removeThereExistsInConsequent

        A B C D e LessEqualCutoff
        eliminateBiconditionalForward
        applySyllogism
))

thm (LessEqualExtension
  ((f A) (f B) (f C) (f D)) ()
  ((A B ≤ C D) ↔ (∃ f ((between A B (value f)) ∧ (A (value f) ≡ C D)))) (
        A B C D f LessEqualExtensionForward
        f A B C D LessEqualExtensionReverse
        introduceBiconditionalFromImplications
))
</jh>

=== Concluding inequality from the inequality of congruent segments ===
Here we prove <code>A B ≤ C D ∧ A B ≡ A′ B′ ∧ C D ≡ C′ D′ → A′ B′ ≤ C′ D′</code>. By <code>LessEqualCutoff</code>, there is a point <code>e</code> on the line segment <code>C D</code> such that <code>A B ≡ C e</code>. We apply <code>InnerDegenerateTriangle</code> to <code>C e D</code> and <code>C′ D′</code> to construct a point <code>e′</code> such that <code>C e D ≅ C′ e′ D′</code>. But this point is on <code>C′ D′</code>, and <code>A′ B′ ≡ C′ e′</code>, so it suffices to prove that <code>A′ B′ ≤ C′ D′</code>, as desired.<ref>l5_6 in Narboux</ref>

Our first lemma constructs the point <code>e</code> and rearranges the quantifiers a little bit.
<jh>
thm (LessEqualCongruence-1
  ((e A) (e B) (e C) (e D) (e A′) (e B′) (e C′) (e D′)) ()
  ((((A B ≤ C D) ∧ (A B ≡ A′ B′)) ∧ (C D ≡ C′ D′))
    → (∃ e ((((between C (value e) D) ∧ (A B ≡ C (value e))) ∧ (A B ≡ A′ B′)) ∧ (C D ≡ C′ D′)))) (
        A B C D e LessEqualCutoff
        eliminateBiconditionalReverse

        (A B ≡ A′ B′) conjoinRR
        (C D ≡ C′ D′) conjoinRR

        e
          ((between C (value e) D) ∧ (A B ≡ C (value e)))
          (A B ≡ A′ B′)
          ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        (C D ≡ C′ D′) conjoinRR
        applySyllogism

        e
          (((between C (value e) D) ∧ (A B ≡ C (value e))) ∧ (A B ≡ A′ B′))
          (C D ≡ C′ D′)
          ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applySyllogism
))

</jh>
In the next lemma, we construct the point <code>e′</code>, apply transitivity to <code>A B ≡ C E</code> and <code>A B ≡ A′ B′</code>, and rearrange the quantifiers a bit.
<jh>
thm (LessEqualCongruence-2
  ((e′ A′) (e′ B′) (e′ C) (e′ E) (e′ D) (e′ C′) (e′ D′)) ()
  (((((between C E D) ∧ (A B ≡ C E)) ∧ (A B ≡ A′ B′)) ∧ (C D ≡ C′ D′)) →
  (∃ e′ (((between C′ (value e′) D′) ∧ (C E D ≅ C′ (value e′) D′)) ∧ (A′ B′ ≡ C E)))) (
</jh>
We first construct <code>e′</code>.
<jh>
        (((between C E D) ∧ (A B ≡ C E)) ∧ (A B ≡ A′ B′)) (C D ≡ C′ D′) ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        (((between C E D) ∧ (A B ≡ C E)) ∧ (A B ≡ A′ B′)) (C D ≡ C′ D′) ConjunctionLeftElimination

        composeConjunction

        C E D C′ D′ e′ InnerDegenerateTriangle
        applySyllogism

</jh>
Next is <code>A′ B′ ≡ A B</code>.
<jh>
        (((between C E D) ∧ (A B ≡ C E)) ∧ (A B ≡ A′ B′)) (C D ≡ C′ D′) ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        A B A′ B′ CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Then we show <code>A B ≡ C E</code> and apply transitivity to get <code>A′ B′ ≡ C E</code>.
<jh>
        (((between C E D) ∧ (A B ≡ C E)) ∧ (A B ≡ A′ B′)) (C D ≡ C′ D′) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction

        A′ B′ A B C E CongruenceTransitivity
        applySyllogism
</jh>
Finally we can combine the two pieces.
<jh>
        composeConjunction

        e′
          ((between C′ (value e′) D′) ∧ (C E D ≅ C′ (value e′) D′))
          (A′ B′ ≡ C E)
          ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applySyllogism
))

thm (LessEqualCongruence-3 () ()
  ((((between C′ E′ D′) ∧ (C E D ≅ C′ E′ D′)) ∧ (A′ B′ ≡ C E)) →
    ((between C′ E′ D′) ∧ (A′ B′ ≡ C′ E′))) (
</jh>
The easy part is <code>between C′ E′ D′</code>, as it is already in the antecedent.
<jh>
        ((between C′ E′ D′) ∧ (C E D ≅ C′ E′ D′))
          (A′ B′ ≡ C E)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
</jh>
We then pick out <code>A′ B′ ≡ C E</code> which we'll need shortly.
<jh>
        ((between C′ E′ D′) ∧ (C E D ≅ C′ E′ D′))
          (A′ B′ ≡ C E)
          ConjunctionLeftElimination
</jh>
From the congruence in the antecedent, we get <code>C E ≡ C′ E′</code>.
<jh>
        ((between C′ E′ D′) ∧ (C E D ≅ C′ E′ D′))
          (A′ B′ ≡ C E)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        C E D C′ E′ D′ Congruence12
        applySyllogism
</jh>
And then we combine the two previous results to get <code>A′ B′ ≡ C′ D′</code>.
<jh>
        composeConjunction

        A′ B′ C E C′ E′ CongruenceTransitivity
        applySyllogism

        composeConjunction
))

thm (LessEqualCongruence
  ( (e e′ A) (e e′ B) (e e′ C) (e e′ D) (e e′ A′) (e e′ B′) (e e′ C′) (e e′ D′)) ()
  ((((A B ≤ C D) ∧ (A B ≡ A′ B′)) ∧ (C D ≡ C′ D′))
    → (A′ B′ ≤ C′ D′)) (
        A B C D A′ B′ C′ D′ e LessEqualCongruence-1

        C (value e) D A B A′ B′ C′ D′ e′ LessEqualCongruence-2
        e addThereExists
        applySyllogism

        C′ (value e′) D′ C (value e) D A′ B′ LessEqualCongruence-3
        e′ addThereExists
        e addThereExists
        applySyllogism

        removeThereExistsInConsequent
        A′ B′ C′ D′ e′ LessEqualCutoff
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

=== Reflexivity ===
Line segment inequality is reflexive.<ref>le_reflexivity in Narboux</ref>
<jh>
thm (LessEqualReflexivity ( (e A) (e B)) () (A B ≤ A B) (
</jh>
We start with <code>between A B B ∧ A B ≡ A B</code>.
<jh>
        A B BetweenABB
        A B CongruenceReflexivity
        introduceConjunction
</jh>
Next is a substitution, <code>e = B → (between A e B ∧ A B ≡ A e ↔ between A B B ∧ A B ≡ A B)</code>.
<jh>
        A EqualityReflexivity
        B EqualityReflexivity
        A A (value e) B B B BetweennessBuilder
        detach2of2
        detach1of2

        A EqualityReflexivity
        B EqualityReflexivity
        A EqualityReflexivity
        A A B B A A (value e) B CongruenceBuilder
        detach2of3
        detach2of3
        detach1of2

        buildConjunctionInConsequent
</jh>
We turn that into <code>∃ e (between A e B ∧ A B ≡ A e)</code>,
<jh>
        makeSubstExplicit
        eliminateBiconditionalForward
        applyModusPonens
        introduceThereExistsFromObject
</jh>
which in turn produces <code>A B ≤ A B</code>.
<jh>
        A B A B e LessEqualCutoff
        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

=== Transitivity ===
[[File:Line segment inequality transitivity.svg|thumb|right|Proof of transitivity]]
Here we prove transitivity of <code>≤</code>.<ref>le_transitivity in Narboux</ref>
<jh>
var (variable ab bc ac)
var (point A0 A1 B0 B1 C0 C1)

thm (LessEqualTransitivity
  ( (ab bc ac A0) (ab bc ac A1) (ab bc ac B0) (ab bc ac B1) (ab bc ac C0) (ab bc ac C1)) ()
  (((A0 A1 ≤ B0 B1) ∧ (B0 B1 ≤ C0 C1)) → (A0 A1 ≤ C0 C1)) (
        A0 A1 B0 B1 ab LessEqualCutoff
        B0 B1 C0 C1 bc LessEqualCutoff
        buildConjunction
        eliminateBiconditionalReverse

        ab
          bc
          ((between B0 (value ab) B1) ∧ (A0 A1 ≡ B0 (value ab)))
          ((between C0 (value bc) C1) ∧ (B0 B1 ≡ C0 (value bc)))
          ThereExistsScattering
        eliminateBiconditionalForward
        applySyllogism
</jh>
So far we have <code>∃ ab ∃ bc ((between B0 ab B1 ∧ A0 A1 ≡ B0 ab) ∧ (between C0 bc C1 ∧ B0 B1 ≡ C0 bc))</code>. We now construct a point <code>ac</code> such that <code>between C0 ac bc ∧ B0 ab B1 ≅ C0 ac bc</code>
<jh>
        ((between B0 (value ab) B1) ∧ (A0 A1 ≡ B0 (value ab)))
          ((between C0 (value bc) C1) ∧ (B0 B1 ≡ C0 (value bc)))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        ((between B0 (value ab) B1) ∧ (A0 A1 ≡ B0 (value ab)))
          ((between C0 (value bc) C1) ∧ (B0 B1 ≡ C0 (value bc)))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction

        B0 (value ab) B1 C0 (value bc) ac InnerDegenerateTriangle
        applySyllogism
</jh>
The next step is to move a copy of the antecedent, <code>(between B0 ab B1 ∧ A0 A1 ≡ B0 ab) ∧ (between C0 bc C1 ∧ B0 B1 ≡ C0 bc)</code> into the quantifier.
<jh>
        (((between B0 (value ab) B1) ∧ (A0 A1 ≡ B0 (value ab))) ∧
          ((between C0 (value bc) C1) ∧ (B0 B1 ≡ C0 (value bc))))
          ImplicationReflexivity
        composeConjunction

        ac
          ((between C0 (value ac) (value bc)) ∧ (B0 (value ab) B1 ≅ C0 (value ac) (value bc)))
          (((between B0 (value ab) B1) ∧ (A0 A1 ≡ B0 (value ab))) ∧
            ((between C0 (value bc) C1) ∧ (B0 B1 ≡ C0 (value bc))))
          ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applySyllogism

</jh>
We can now add on the other two quantifiers and combine with the previous result.
<jh>
        bc addThereExists
        ab addThereExists
        applySyllogism
</jh>
We need to prove <code>between C0 ac C1 ∧ A0 A1 ≡ C0 ac</code>. The first conjunct follows from <code>between C0 ac bc</code> and <code>between C0 bc C1</code>.
<jh>
        ((between C0 (value ac) (value bc)) ∧
          (B0 (value ab) B1 ≅ C0 (value ac) (value bc)))
          (((between B0 (value ab) B1) ∧ (A0 A1 ≡ B0 (value ab))) ∧
            ((between C0 (value bc) C1) ∧ (B0 B1 ≡ C0 (value bc))))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        ((between C0 (value ac) (value bc)) ∧
          (B0 (value ab) B1 ≅ C0 (value ac) (value bc)))
          (((between B0 (value ab) B1) ∧ (A0 A1 ≡ B0 (value ab))) ∧
            ((between C0 (value bc) C1) ∧ (B0 B1 ≡ C0 (value bc))))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction

        C0 (value ac) (value bc) C1 BetweennessMiddleTransitivityFlipped
        applySyllogism
</jh>
The other conjunct, <code>A0 A1 ≡ C0 ac</code>, follows from <code>A0 A1 ≡ B0 ab</code> and <code>B0 ab ≡ C0 ac</code> (which follows from <code>B0 ab B1 ≅ C0 ac bc</code>).
<jh>
        ((between C0 (value ac) (value bc)) ∧
          (B0 (value ab) B1 ≅ C0 (value ac) (value bc)))
          (((between B0 (value ab) B1) ∧ (A0 A1 ≡ B0 (value ab))) ∧
            ((between C0 (value bc) C1) ∧ (B0 B1 ≡ C0 (value bc))))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        ((between C0 (value ac) (value bc)) ∧
          (B0 (value ab) B1 ≅ C0 (value ac) (value bc)))
          (((between B0 (value ab) B1) ∧ (A0 A1 ≡ B0 (value ab))) ∧
            ((between C0 (value bc) C1) ∧ (B0 B1 ≡ C0 (value bc))))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        B0 (value ab) B1 C0 (value ac) (value bc) Congruence12
        applySyllogism

        composeConjunction

        A0 A1 B0 (value ab) C0 (value ac) CongruenceTransitivity
        applySyllogism
</jh>
We can now combine <code>between C0 ac C1</code> and <code>A0 A1 ≡ C0 ac</code>, and then hook it up with the quantifiers and apply <code>LessEqualCutoff</code>.
<jh>
        composeConjunction

        ac addThereExists
        bc addThereExists
        ab addThereExists
        applySyllogism

        removeThereExistsInConsequent
        removeThereExistsInConsequent

        A0 A1 C0 C1 ac LessEqualCutoff
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

== Two crucial lemmas ==
The two lemmas in this section are presented in Narboux (2007).<ref>Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, section 5.1, pages 147–148</ref> According to Narboux they are missing from the book by Schwabhäuser, Szmielew and Tarski.

=== between A B C ∧ A B ≡ A C → B = C === 

Our first of the two results from Narboux is <code>between A B C ∧ A B ≡ A C → B = C</code>, which says there cannot be two distinct points on a line which are the same distance of a given point (on the same side of that point). First we prove <code>A B C ≅ A C B</code>. To do so, we need  <code>A B ≡ A C</code>, <code>A C ≡ A B</code>, and <code>B C ≡ C B</code>.<ref>between_cong in Narboux</ref>
<jh>
thm (BetweennessOneDistanceUniqueness-abc-acb () ()
  (((between A B C) ∧ (A B ≡ A C)) → (A B C ≅ A C B)) (
        (between A B C) (A B ≡ A C) ConjunctionLeftElimination

        (between A B C) (A B ≡ A C) ConjunctionLeftElimination
        A B A C CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        B C CongruenceABBA
        introduceRightConjunctToConsequent
))

thm (BetweennessOneDistanceUniqueness () ()
  (((between A B C) ∧ (A B ≡ A C)) → (B = C)) (
</jh>
Now we derive <code>between A C B</code> (from <code>between A B C</code> and <code>A B C ≅ A C B</code>).
<jh>
        (between A B C) (A B ≡ A C) ConjunctionRightElimination
        A B C BetweennessOneDistanceUniqueness-abc-acb
        composeConjunction

        A B C A C B BetweennessDegenerateTriangle
        applySyllogism
</jh>
Well, <code>between B C A</code> is the form we'll need it in.
<jh>
        A C B BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
We also need <code>between C B A</code>.
<jh>
        (between A B C) (A B ≡ A C) ConjunctionRightElimination

        A B C BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Combining those gives us <code>B = C</code>.
<jh>
        B C A BetweennessEquality
        applySyllogism
))
</jh>

=== A similar result ===
Narboux's second crucial lemma is a similar result in which neither of the two points to be found equal are the endpoint of the line segment, but where they both are on the same line segment.  In symbols, <code>between A D B ∧ between A E B ∧ A D ≡ A E → D = E</code>.<ref>between_cong_2 in Narboux</ref>
<jh>
thm (SameSegmentOneDistanceUniqueness () ()
  ((((between A D B) ∧ (between A E B)) ∧ (A D ≡ A E)) → (D = E)) (
</jh>
At the end of the proof we'll need a copy of <code>A D ≡ A E</code>, so stick it on the proof stack now.
<jh>
        ((between A D B) ∧ (between A E B)) (A D ≡ A E) ConjunctionLeftElimination
</jh>
Next we use inner connectivity to show that <code>between A D E ∨  between A E D</code>.
<jh>
        ((between A D B) ∧ (between A E B)) (A D ≡ A E) ConjunctionRightElimination
        A D B E BetweennessInnerConnectivity
        applySyllogism
</jh>
Then we note that <code>between A D E ∧ A D ≡ A E</code> implies <code>D = E</code> (by the previous lemma).
<jh>
        A D E BetweennessOneDistanceUniqueness
        export
</jh>
The similar result for <code>between A E D</code> and a little rearranging gives <code>between A D B ∧ between A E B ∧ A D ≡ A E → (A D ≡ A E → D = E)</code>
<jh>
        A D A E CongruenceSymmetry
        eliminateBiconditionalReverse

        (between A E D) conjoinLL

        A E D BetweennessOneDistanceUniqueness
        applySyllogism

        E D EqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism

        export

        composeDisjunction

        applySyllogism
</jh>
Now we just need to remove the extra <code>A D ≡ A E</code> and we are done.
<jh>
        applyModusPonensInConsequent
))
</jh>

== Antisymmetry ==
Here we prove antisymmetry of <code>≤</code>, that is, <code>A0 A1 ≤ B0 B1 ∧ B0 B1 ≤ A0 A1 → A0 A1 ≡ B0 B1</code>. The proof begins by expanding the definition of <code>B0 B1 ≤ A0 A1</code> according to <code>LessEqualExtension</code> (to construct a point <code>c</code> such that <code>between B0 B1 c ∧ B0 c ≡ A0 A1</code>.  We then expand the definition of <code>A0 A1 ≤ B0 B1</code> according to <code>LessEqualCutoff</code> to construct a point <code>d</code> such that <code>between B0 d B1 ∧ B0 d ≡ A0 A1</code>. We now can conclude <code>B0 c ≡ B0 d</code> by congruence transitivity and <code>between B0 d c</code> by betweenness transitivity. These two things together let us apply <code>BetweennessOneDistanceUniqueness</code> to conclude that <code>d = c</code>. Substituting via that equality, we have both <code>between B0 B1 c</code> and <code>between B0 c B1</code>, so <code>c = B1</code>. And substituting that into <code>B0 c ≡ A0 A1</code>, we know that <code>B0 B1 ≡ A0 A1</code>, which is what we seek.<ref>le_anti_symmetry in Narboux</ref>

First, a lemma, which is just <code>BetweennessEquality</code> flipped left to right.
<jh>
thm (BetweennessEquality23 () () (((between A B C) ∧ (between A C B)) → (B = C)) (
        A B C BetweennessSymmetry
        A C B BetweennessSymmetry
        buildConjunction
        eliminateBiconditionalReverse

        C B A BetweennessEquality
        applySyllogism

        C B EqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

Returning to antisymmetry, the first part of the proof constructs the points <code>c</code> and <code>d</code> and puts everything inside quantifiers.
<jh>
thm (LessEqualAntisymmetry-1 ((c d A0) (c d A1) (c d B0) (c d B1)) ()
  (((A0 A1 ≤ B0 B1) ∧ (B0 B1 ≤ A0 A1)) →
    (∃ c (∃ d (
      ((between B0 B1 (value c)) ∧ (B0 (value c) ≡ A0 A1)) ∧
      ((between B0 (value d) B1) ∧ (B0 (value d) ≡ A0 A1))
  )))) (
        (A0 A1 ≤ B0 B1) (B0 B1 ≤ A0 A1) ConjunctionCommutativity
        eliminateBiconditionalReverse

        B0 B1 A0 A1 c LessEqualExtension

        A0 A1 B0 B1 d LessEqualCutoff
        A0 A1 B0 (value d) CongruenceSymmetry
        (between B0 (value d) B1) buildConjunctionLL
        d buildThereExists
        applyBiconditionalTransitivity

        buildConjunction
        eliminateBiconditionalReverse
        applySyllogism

        c
          d
          ((between B0 B1 (value c)) ∧ (B0 (value c) ≡ A0 A1))
          ((between B0 (value d) B1) ∧ (B0 (value d) ≡ A0 A1))
          ThereExistsScattering
        eliminateBiconditionalForward

        applySyllogism
))
</jh>

The next part of the proof makes the inferences sketched out in the informal proof above, as far as <code>D = C</code>.
<jh>
thm (LessEqualAntisymmetry-dc () () (
  (((between B0 B1 C) ∧ (B0 C ≡ A0 A1)) ∧
    ((between B0 D B1) ∧ (B0 D ≡ A0 A1))) →
  (D = C)
  ) (
</jh>
First is <code>between B0 D C</code> by betweenness transitivity. 
<jh>
        ((between B0 B1 C) ∧ (B0 C ≡ A0 A1))
          ((between B0 D B1) ∧ (B0 D ≡ A0 A1))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        
        ((between B0 B1 C) ∧ (B0 C ≡ A0 A1))
          ((between B0 D B1) ∧ (B0 D ≡ A0 A1))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        composeConjunction

        B0 D B1 C BetweennessMiddleTransitivityFlipped
        applySyllogism
</jh>
Second is <code>B0 D ≡ B0 C</code> by congruence transitivity.
<jh>
        ((between B0 B1 C) ∧ (B0 C ≡ A0 A1))
          ((between B0 D B1) ∧ (B0 D ≡ A0 A1))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        ((between B0 B1 C) ∧ (B0 C ≡ A0 A1))
          ((between B0 D B1) ∧ (B0 D ≡ A0 A1))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        B0 C A0 A1 CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        B0 D A0 A1 B0 C CongruenceTransitivity
        applySyllogism

        composeConjunction
</jh>
Combining those two and applying <code>BetweennessOneDistanceUniqueness</code> we get <code>D = C</code>.
<jh>
        B0 D C BetweennessOneDistanceUniqueness
        applySyllogism
))
</jh>

The next step applies a substitution and a few more steps to get <code>B1 = C</code>.
<jh>
thm (LessEqualAntisymmetry-b1-c () () (
  (((between B0 B1 C) ∧ (B0 C ≡ A0 A1)) ∧
    ((between B0 D B1) ∧ (B0 D ≡ A0 A1))) →
  (B1 = C)
  ) (
</jh>
First is <code>between B0 B1 C</code>
<jh>
        ((between B0 B1 C) ∧ (B0 C ≡ A0 A1))
          ((between B0 D B1) ∧ (B0 D ≡ A0 A1))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
</jh>
Second is <code>between B0 C B1</code>, which involves a substitution from <code>between B0 D B1</code>. The substitution is <code>D = C → (between B0 D B1 ↔ between B0 C B1)</code>
<jh>
        B0 B1 C A0 A1 D LessEqualAntisymmetry-dc

        ((between B0 B1 C) ∧ (B0 C ≡ A0 A1))
          ((between B0 D B1) ∧ (B0 D ≡ A0 A1))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        composeConjunction

        B0 EqualityReflexivity
        B1 EqualityReflexivity
        B0 B0 D C B1 B1 BetweennessBuilder
        detach2of2
        detach1of2

        eliminateBiconditionalReverseInConsequent
        import

        applySyllogism
</jh>
Combining <code>between B0 B1 C</code> and <code>between B0 C B1</code>, we conclude <code>B1 = C</code>.
<jh>
        composeConjunction

        B0 B1 C BetweennessEquality23
        applySyllogism
))
</jh>

We only need substitute <code>B1 = C</code> into <code>B0 C ≡ A0 A1</code> to get <code>B0 B1 ≡ A0 A1</code>, which we flip to get <code>A0 A1 = B0 B1</code>
<jh>
thm (LessEqualAntisymmetry-a0-a1-b0-b1 () () (
  (((between B0 B1 C) ∧ (B0 C ≡ A0 A1)) ∧
    ((between B0 D B1) ∧ (B0 D ≡ A0 A1))) →
  (A0 A1 ≡ B0 B1)
  ) (
</jh>
First we pick out <code>B0 C ≡ A0 A1</code> and leave it on the proof stack.
<jh>
        ((between B0 B1 C) ∧ (B0 C ≡ A0 A1))
          ((between B0 D B1) ∧ (B0 D ≡ A0 A1))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

</jh>
Then we put <code>B1 C</code> on the proof stack, which we'll use in a minute.
<jh>
        B0 B1 C A0 A1 D LessEqualAntisymmetry-b1-c
</jh>
Next is the substitution <code>B1 = C → (B0 B1 ≡ A0 A1 ↔ B0 C ≡ A0 A1)</code>
<jh>
        B0 EqualityReflexivity
        A0 EqualityReflexivity
        A1 EqualityReflexivity
        B0 B0 B1 C A0 A0 A1 A1 CongruenceBuilder
        detach2of2
        detach2of2
        detach1of2
</jh>
We combine those two results and eliminate one direction of the biconditional so that the consequent is now <code>B0 C ≡ A0 A1 → B0 B1 ≡ A0 A1</code>.
<jh>
        applySyllogism
        eliminateBiconditionalForwardInConsequent
</jh>
That's enough to get us <code>B0 B1 ≡ A0 A1</code>,
<jh>
        applyModusPonensInConsequent
</jh>
which we then flip.
<jh>
        B0 B1 A0 A1 CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

We now combine the results to prove antisymmetry.
<jh>
thm (LessEqualAntisymmetry ( (c d A0) (c d A1) (c d B0) (c d B1)) ()
  (((A0 A1 ≤ B0 B1) ∧ (B0 B1 ≤ A0 A1)) →
    (A0 A1 ≡ B0 B1)) (
        A0 A1 B0 B1 c d LessEqualAntisymmetry-1

        B0 B1 (value c) A0 A1 (value d) LessEqualAntisymmetry-a0-a1-b0-b1
        d addThereExists
        c addThereExists
        applySyllogism

        removeThereExistsInConsequent
        removeThereExistsInConsequent
))
</jh>

== Constructing a line segment along a ray ==
Starting at a point <code>Q</code>, we can construct a line segment <code>Q x</code> congruent to a given line segment <code>B C</code> and in the direction of a point <code>A</code>. In symbols, <code>∃ p ((between Q A p ∨ between Q p A) ∧ Q p ≡ B C)</code>. Narboux requires that <code>A</code> and <code>Q</code> are distinct but this restriction is unnecessary (although the theorem is more interesting, and the constructed point is unique, only if they are distinct).<ref>segment_construction_2 in Narboux</ref>

<jh>
thm (InnerSegmentConstruction
  ((p Q) (p A) (p B) (p C)  (d p A) (d Q) (d B) (d C)) ()
  (∃ p (((between Q A (value p)) ∨ (between Q (value p) A)) ∧ (Q (value p) ≡ B C))) (
</jh>
We begin by extending <code>A Q</code> to a distinct point <code>d</code>. This is slightly streamlined from Narboux's proof, which extends <code>A Q</code> by a distance of <code>A Q</code> (and then deduces <code>Q ≠ d</code> from that).
<jh>
        d A Q PointConstructionDifferent
</jh>
Now we extend <code>d Q</code> to a point <code>p</code> such that <code>Q p ≡ B C</code>.
<jh>
        p (value d) Q B C SegmentConstruction
        d generalize

        combineThereExistsForAll

        p
          ((between A Q (value d)) ∧ (Q ≠ (value d)))
          ((between (value d) Q (value p)) ∧ (Q (value p) ≡ B C))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        d addThereExists
        applyModusPonens
</jh>
At this point we have <code>∃ d ∃ p ((between A Q d ∧ Q ≠ d) ∧ (between d Q p ∧ Q p ≡ B C))</code>. First we tackle the <code>between Q A p ∨ between Q p A</code> part, which in turn follows from <code>d ≠ Q ∧ between d Q A ∧ between d Q p</code>. We start with <code>d ≠ Q</code>.
<jh>
        ((between A Q (value d)) ∧ (Q ≠ (value d)))
          ((between (value d) Q (value p)) ∧ (Q (value p) ≡ B C))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        Q (value d) EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next is <code>between d Q A</code>.
<jh>
        ((between A Q (value d)) ∧ (Q ≠ (value d)))
          ((between (value d) Q (value p)) ∧ (Q (value p) ≡ B C))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        A Q (value d) BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Next is <code>between d Q p</code>.
<jh>
        ((between A Q (value d)) ∧ (Q ≠ (value d)))
          ((between (value d) Q (value p)) ∧ (Q (value p) ≡ B C))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
We're ready to turn that into <code>between Q A p ∨ between Q p A</code>.
<jh>
        (value d) Q A (value p) BetweennessMiddleConnectivity
        applySyllogism
</jh>
Now we turn to the other side of the conclusion, <code>Q p ≡ B C</code>.
<jh>
        ((between A Q (value d)) ∧ (Q ≠ (value d)))
          ((between (value d) Q (value p)) ∧ (Q (value p) ≡ B C))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Adding the quantifiers, and removing <code>∃ d</code> (which is no longer needed), finishes the job.
<jh>
        p addThereExists
        d addThereExists
        applyModusPonens

        removeThereExists
))
</jh>

== Any line segment is longer than or congruent to an empty line segment ==
Here we prove <code>A A ≤ B C</code>.<ref>le_trivial in Narboux</ref>
<jh>
thm (ZeroSmallest ( (e A) (e B) (e C)) () (A A ≤ B C) (
</jh>
We start by proving <code>between B B C ∧ A A ≡ B B</code>.
<jh>
        B C BetweenAAB
        A B CongruenceTrivialIdentity
        introduceConjunction
</jh>
Then we apply a substitution, <code>e = B → (between B e C ∧ A A ≡ B e ↔ between B B C ∧ A A ≡ B B)</code>.
<jh>
        B EqualityReflexivity
        C EqualityReflexivity
        B B (value e) B C C BetweennessBuilder
        detach2of2
        detach1of2

        A EqualityReflexivity
        B EqualityReflexivity
        A EqualityReflexivity
        A A A A B B (value e) B CongruenceBuilder
        detach1of4
        detach2of3
        detach1of2

        buildConjunctionInConsequent
</jh>
This is readily turned into <code>∃ e (between B e C ∧ A A ≡ B e)</code>,
<jh>
        makeSubstExplicit
        eliminateBiconditionalForward
        applyModusPonens

        introduceThereExistsFromObject
</jh>
which is equivalent to <code>A A ≤ B C</code>.
<jh>
        A A B C e LessEqualCutoff
        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

== Builder for ≤ ==
The builder for <code>≤</code> follows readily from the builders for quantifiers, logical connectives, etc.
<jh>
var (point x0 y0 x1 y1 x2 y2 x3 y3)
thm (LessEqualBuilder
  ( (e x0) (e y0) (e x1) (e y1) (e x2) (e y2) (e x3) (e y3)) () (
  ((((x0 = y0) ∧ (x1 = y1)) ∧ (x2 = y2)) ∧ (x3 = y3))
  → ((x0 x1 ≤ x2 x3) ↔ (y0 y1 ≤ y2 y3))) (
</jh>
We'll base this on <code>LessEqualCutoff</code>, which says that <code>x0 x1 ≤ x2 x3</code> is equivalent to <code>∃ e (between x2 e x3 ∧ x0 x1 ≡ x2 e)</code>.

We start with <code>x0 = y0 ∧ x1 = y1 ∧ x2 = y2 ∧ x3 = y3 → (between x2 e x3 ↔ between y2 e y3)</code>.
<jh>
        (((x0 = y0) ∧ (x1 = y1)) ∧ (x2 = y2))
          (x3 = y3)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        (value e) EqualityReflexivity
        introduceRightConjunctToConsequent

        (((x0 = y0) ∧ (x1 = y1)) ∧ (x2 = y2))
          (x3 = y3)
          ConjunctionLeftElimination
        composeConjunction

        x2 y2 (value e) (value e) x3 y3 BetweennessBuilder
        applySyllogism
</jh>
Next is <code>x0 x1 ≡ x2 e ↔ y0 y1 ≡ y2 e</code>.
<jh>
        (((x0 = y0) ∧ (x1 = y1)) ∧ (x2 = y2))
          (x3 = y3)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        (((x0 = y0) ∧ (x1 = y1)) ∧ (x2 = y2))
          (x3 = y3)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        composeConjunction

        (((x0 = y0) ∧ (x1 = y1)) ∧ (x2 = y2))
          (x3 = y3)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        composeConjunction

        (value e) EqualityReflexivity
        introduceRightConjunctToConsequent

        x0 y0 x1 y1 x2 y2 (value e) (value e) CongruenceBuilder
        applySyllogism
</jh>
We combine those two with a conjunction, deal with the quantifier, and fold the definitions.
<jh>
        buildConjunctionInConsequent
        e buildThereExistsInConsequent

        x0 x1 x2 x3 e LessEqualCutoff
        y0 y1 y2 y3 e LessEqualCutoff
        buildBiconditional
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

== Totality ==
Given two line segments, one of the two must be longer than or congruent to the other.<ref>le_cases in Narboux</ref>

Narboux's proof requires two cases, <code>A0 = A1</code> and <code>A0 ≠ A1</code>, but since our version of <code>InnerSegmentConstruction</code> does not require <code>A0 ≠ A1</code>, our proof does not.

<jh>
thm (LessEqualTotality ( (e A0) (e A1) (e B0) (e B1)) ()
  ((A0 A1 ≤ B0 B1) ∨ (B0 B1 ≤ A0 A1)) (
        e A0 A1 B0 B1 InnerSegmentConstruction

        (between A0 A1 (value e))
          (between A0 (value e) A1)
          (A0 (value e) ≡ B0 B1)
          ConjunctionRightDistribution
        eliminateBiconditionalReverse
        e addThereExists
        applyModusPonens
</jh>
That gives us <code>∃ e ((between A0 A1 e ∧ A0 e ≡ B0 B1) ∨ (between A0 e A1 ∧ A0 e ≡ B0 B1))</code>. We associate the quantifier so that it covers each disjunct separately.
<jh>
        e
          ((between A0 A1 (value e)) ∧ (A0 (value e) ≡ B0 B1))
          ((between A0 (value e) A1) ∧ (A0 (value e) ≡ B0 B1))
          ThereExistsDisjunction
        eliminateBiconditionalReverse
        applyModusPonens
</jh>
The left disjunct is now <code>∃ e (between A0 A1 e ∧ A0 e ≡ B0 B1)</code>, which is just <code>A0 A1 ≤ B0 B1</code>.
<jh>
        A0 A1 B0 B1 e LessEqualExtension
        eliminateBiconditionalForward
</jh>
Similarly, the right disjunct <code>∃ e (between A0 e A1 ∧ A0 e ≡ B0 B1)</code> is <code>B0 B1 ≤ A0 A1</code> (once we flip <code>A0 e ≡ B0 B1</code> to <code>B0 B1 ≡ A0 e</code>).
<jh>
        A0 (value e) B0 B1 CongruenceSymmetry
        eliminateBiconditionalReverse
        (between A0 (value e) A1) conjoinLL
        e addThereExists

        B0 B1 A0 A1 e LessEqualCutoff
        eliminateBiconditionalForward
        applySyllogism
</jh>
Combining these two we are done.
<jh>
        disjoin
        applyModusPonens
))
</jh>

== A segment which is smaller than or congruent to an empty segment ==
A segment which is smaller than or congruent to an empty segment is itself empty. The proof simply notes that <code>C C ≤ A B</code> is always true and <code>A B ≤ C C</code> is our antecedent. Thus <code>A B ≡ C C</code> by antisymmetry, which in turn implies <code>A = B</code> by <code>CongruenceIdentity</code>.<ref>le_zero in Narboux</ref>
<jh>
thm (LessEqualZero () () ((A B ≤ C C) → (A = B)) (
        C A B ZeroSmallest
        (C C ≤ A B) (A B ≤ C C) ConjunctionLeftIntroduction
        applyModusPonens

        A B C C LessEqualAntisymmetry
        applySyllogism

        A B C CongruenceIdentity
        applySyllogism
))
</jh>

== Strict inequality ==
Following Narboux, we define <code><</code> and <code>></code> in terms of <code>≤</code> and line segment congruence.
<jh>
def ((< A B C D) ((A B ≤ C D) ∧ (¬ (A B ≡ C D))))
def ((> A B C D) (C D < A B))
</jh>

== Export ==
Before we export, there is one detail to attend to. Because we are halfway through changing <code>CongruenceIdentityFromEquality</code> from the exported version to the imported version, we need to prove <code>CongruenceIdentityFromEquality</code> as a synonym of <code>CongruenceIdentityFromEqualityImported</code>.
<jh>
var (point x y z w)
thm (CongruenceIdentityFromEquality () () (((x = y) ∧ (x y ≡ z w)) → (z = w)) (
        x y z w CongruenceIdentityFromEqualityImported
))
</jh>

We now export to [[Interface:Line segment inequality]].
<jh>
export (RESULTS Interface:Line_segment_inequality (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>
* Tarski, Alfred; Givant, Steven (1999), "Tarski's system of geometry", The Bulletin of Symbolic Logic 5 (2): 175–214, doi:10.2307/421089, MR1791303, ISSN 1079-8986

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]