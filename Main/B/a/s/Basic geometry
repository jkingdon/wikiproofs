{{interfaces
| imports = [[Interface:Tarski's geometry axioms]]
| exports = [[Interface:Basic geometry]]
}}

Here we prove a variety of basic geometrical theorems involving collinearity, midpoints, perpendiculars, and the like, starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Tarski's geometry axioms|geometry axioms]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (AXIOMS Interface:Tarski's_geometry_axioms (CLASSICAL FIRSTORDER) ())

var (point x y z w u v A B C D E P Q A′ B′ C′ D′ B″ C″)
var (point x′ y′ z′ w′ u′)
var (variable a b b′ c d′ q q′ ww ww′ b″ c″)
</jh>

== Congruence ==
A line segment is congruent to itself.<ref>Lemma cong_reflexivity in Narboux</ref>
<jh>
thm (CongruenceReflexivity () () (x y ≡ x y) (
        y x CongruenceReflexivityAxiom
        y x CongruenceReflexivityAxiom
        introduceConjunction

        y x x y x y CongruenceTransitivityAxiom

        applyModusPonens
))
</jh>

Congruence is symmetrical.<ref>Lemma cong_symmetry in Narboux</ref> The biconditionalized version is not in Narboux, but fits our usual conventions and the nature of JHilbert.
<jh>
thm (CongruenceSymmetryImplication () () ((x y ≡ z w) → (z w ≡ x y)) (
        x y CongruenceReflexivity
        x y z w x y CongruenceTransitivityAxiom
        detach2of2
))

thm (CongruenceSymmetry () () ((x y ≡ z w) ↔ (z w ≡ x y)) (
        x y z w CongruenceSymmetryImplication
        z w x y CongruenceSymmetryImplication
        introduceBiconditionalFromImplications
))
</jh>

Congruence is transitive.<ref>Lemma cong_transitivity in Narboux</ref>
<jh>
thm (CongruenceTransitivity () () (((x y ≡ z w) ∧ (z w ≡ u v)) → (x y ≡ u v)) (
        x y z w CongruenceSymmetry
        eliminateBiconditionalReverse
        (z w ≡ u v) conjoinRR

        z w x y u v CongruenceTransitivityAxiom

        applySyllogism
))
</jh>

We can commute the endpoints of the first line segment.<ref>Lemma cong_left_commutativity in Narboux</ref>
<jh>
thm (CongruenceLeftCommutativityImplication () () ((x y ≡ z w) → (y x ≡ z w)) (
        x y CongruenceReflexivityAxiom
        x y y x z w CongruenceTransitivityAxiom
        detach1of2
))

thm (CongruenceLeftCommutativity () () ((x y ≡ z w) ↔ (y x ≡ z w)) (
        x y z w CongruenceLeftCommutativityImplication
        y x z w CongruenceLeftCommutativityImplication
        introduceBiconditionalFromImplications
))
</jh>

Likewise for the second line segment.<ref>Lemma cong_right_commutativity in Narboux, biconditionalized</ref>
<jh>
thm (CongruenceRightCommutativity () () ((x y ≡ z w) ↔ (x y ≡ w z)) (
        x y z w CongruenceSymmetry

        z w x y CongruenceLeftCommutativity
        applyBiconditionalTransitivity

        w z x y CongruenceSymmetry
        applyBiconditionalTransitivity
))
</jh>

A line segment with the same point as both of its endpoints is congruent to another such segment. To prove this, start with the line segment x x. Extend x y beyond y to another point a such that y a ≡ x x. Then we show that a must equal y.<ref>Lemma cong_trivial_identity in Narboux</ref>
<jh>
thm (CongruenceTrivialIdentity ((a x) (a y)) () (y y ≡ x x) (
        a x y x x SegmentConstruction
</jh>
Now we have <code>∃ a (between x y a ∧ y a ≡ x x)</code>. We drop the between part.
<jh>
        (between x y (value a)) (y (value a) ≡ x x) ConjunctionLeftElimination
        a addThereExists
        applyModusPonens
</jh>
Here we combine <code>y a ≡ x x → y = a</code> with our previous result and rearrange a bit to get <code>∃ a (y = a ∧ y a ≡ x x)</code>.
<jh>
        y (value a) x CongruenceIdentity
        (y (value a) ≡ x x) ImplicationReflexivity
        composeConjunction
        a addThereExists
        applyModusPonens
</jh>
Now we just need a substitution.  The substitution is <code>y = a → (y y ≡ x x ↔ y a ≡ x x)</code>.
<jh>
        x EqualityReflexivity
        x EqualityReflexivity
        y EqualityReflexivity
        y y y (value a) x x x x CongruenceBuilder
        detach1of4
        detach2of2
        detach2of2
</jh>
Taking the reverse implication and combining with the previous result gives us <code>∃ a y y ≡ x x</code>.
<jh>
        eliminateBiconditionalForwardInConsequent
        import
        a addThereExists
        applyModusPonens
</jh>
The quantifier is no longer needed, and removing it finishes the proof.
<jh>
        removeThereExists
))
</jh>

Here is a version of <code>CongruenceIdentity</code> with left and right sides swapped.<ref>Lemma cong_reverse_identity in Narboux</ref>
<jh>
thm (CongruenceIdentityLeft () () ((x x ≡ y z) → (y = z)) (
        x x y z CongruenceSymmetry
        eliminateBiconditionalReverse

        y z x CongruenceIdentity
        applySyllogism
))
</jh>

Congruence is unaffected by exchanging the endpoints of both line segments.<ref>Lemma cong_commutativity in Narboux</ref>
<jh>
thm (CongruenceCommutativity () () ((x y ≡ z w) ↔ (y x ≡ w z)) (
        x y z w CongruenceLeftCommutativity
        y x z w CongruenceRightCommutativity
        applyBiconditionalTransitivity
))
</jh>

The next lemma is a convenience form of <code>CongruenceIdentity</code>.<ref>not in Narboux</ref>
<jh>
thm (CongruenceIdentityFromEquality () () ((x = y) → ((x y ≡ z w) → (z = w))) (
</jh>
This is just a substitution away from <code>CongruenceIdentityLeft</code>.  The substitution is <code>x = y → (x x ≡ z w ↔ x y ≡ z w)</code>.
<jh>
        z EqualityReflexivity
        w EqualityReflexivity
        x EqualityReflexivity
        x x x y z z w w CongruenceBuilder
        detach1of4
        detach2of2
        detach2of2

        eliminateBiconditionalForwardInConsequent

        x z w CongruenceIdentityLeft
        (x = y) introduceAntecedent
        applySyllogismInConsequent
))
</jh>

== Outer three segment ==
The next theorem, <code>between x y z ∧ between x′ y′ z′ ∧ x y ≡ x′ y′ ∧ y z ≡ y′ z′ → x z ≡ x′ z′</code>, is basically a degenerate case of the five segment axiom.<ref>Lemma l2_11 in Narboux</ref><ref>Axiom 23 in Givant and Tarski, 1999</ref> We call it ''outer'' three segment because we are given congruences for the inner line segments, and conclude a congruence for the outer segments. We will later prove an inner variant in which which the reverse is true.

There are two cases. If <code>x ≠ y</code>, then applying five segments to x y z and x yields the desired result (the additional two antecedents are fulfilled because one becomes <code>x x ≡ x′ x′</code> and the other <code>y x ≡ y′ x′</code>). If <code>x = y</code>, then <code>x z ≡ x′ z′</code> follows from <code>y z ≡ y′ z′</code> (and <code>x′ = y′</code>, which follows from <code>x y ≡ x′ y′</code>).

We first prove the <code>x = y</code> case as a lemma.
<jh>
thm (ThreeSegmentXEqualsY () () ((x = y) → (((((between x y z) ∧ (between x′ y′ z′)) ∧ (x y ≡ x′ y′)) ∧ (y z ≡ y′ z′)) → (x z ≡ x′ z′))) (
</jh>
We start with <code>x = y → (x y ≡ x′ y′ → x′ = y′)</code>
<jh>
        x y x′ y′ CongruenceIdentityFromEquality
</jh>
Using <code>x′ = y′</code> for something takes this form: <code>x = y → (x′ = y′ → (y z ≡ y′ z′ → x z ≡ x′ z′))</code>.
<jh>
        z EqualityReflexivity
        z′ EqualityReflexivity
        x y z z x′ y′ z′ z′ CongruenceBuilder
        detach2of2
        detach2of3
        eliminateBiconditionalForwardInConsequent
        export
</jh>
We combine those to get <code>x = y → (x y ≡ x′ y′ → (y z ≡ y′ z′ → x z ≡ x′ z′))</code>.
<jh>
        applySyllogismInConsequent
</jh>
Adding two more antecedents and importing several times gives us the complete <code>x = y</code> case.
<jh>
        (between x′ y′ z′) introduceAntecedentInConsequent
        (between x y z) introduceAntecedentInConsequent
        importInConsequent
        importInConsequent
        importInConsequent
))
</jh>
Now, the <code>x ≠ y</code> case.
<jh>
thm (ThreeSegmentXNotEqualY () () ((x ≠ y) → (((((between x y z) ∧ (between x′ y′ z′)) ∧ (x y ≡ x′ y′)) ∧ (y z ≡ y′ z′)) → (x z ≡ x′ z′))) (
</jh>
Applying the five segment axiom gives us <code>x ≠ y ∧ between x y z ∧ between x′ y′ z′ ∧ x y ≡ x′ y′ ∧ y z ≡ y′ z′ ∧ x x ≡ x′ x′ ∧ y x ≡ y′ x′ → z x ≡ z′ x′</code>. First we detach <code>x x ≡ x′ x′</code>
<jh>
        x x′ CongruenceTrivialIdentity
        x y z x′ y′ z′ x x′ OuterFiveSegment
        detach2of3
</jh>
Next we commute <code>z x ≡ z′ x′</code> to <code>x z ≡ x′ z′</code>.
<jh>
        z x z′ x′ CongruenceCommutativity eliminateBiconditionalReverse
        applySyllogism
</jh>
We are still facing <code>x ≠ y ∧ between x y z ∧ between x′ y′ z′ ∧ x y ≡ x′ y′ ∧ y z ≡ y′ z′ ∧ y x ≡ y′ x′ → x z ≡ x′ z′</code>. We need to remove the <code>y x ≡ y′ x′</code> (because it is redundant with <code>x y ≡ x′ y′</code>).

We get most of the way with <code>x y ≡ x′ y′ ∧ y z ≡ y′ z′ → (x y ≡ x′ y′ ∧ y z ≡ y′ z′) ∧ y x ≡ y′ x′</code>:
<jh>
        ((x y ≡ x′ y′) ∧ (y z ≡ y′ z′)) ImplicationReflexivity

        (x y ≡ x′ y′) (y z ≡ y′ z′) ConjunctionRightElimination
        x y x′ y′ CongruenceCommutativity eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Now we just add the rest of the antecedents and combine to finish the <code>x ≠ y</code> case.
<jh>
        (x z ≡ x′ z′) addCommonConsequent
        exportInAntecedent
        exportInAntecedent
        exportInConsequent
        (between x′ y′ z′) addCommonAntecedent
        (between x y z) addCommonAntecedent
        (x ≠ y) addCommonAntecedent

        importInAntecedent
        importInAntecedent
        importInAntecedent
        importInAntecedent
        importInAntecedent

        applyModusPonens

        importInConsequent
        importInConsequent
        importInConsequent
))

thm (OuterThreeSegment () ()
  (((((between x y z) ∧ (between x′ y′ z′)) ∧ (x y ≡ x′ y′)) ∧ (y z ≡ y′ z′)) → (x z ≡ x′ z′)) (
        x y z x′ y′ z′ ThreeSegmentXEqualsY
        x y z x′ y′ z′ ThreeSegmentXNotEqualY
        eliminateCases
))
</jh>

== Uniqueness of segment construction ==
Here we prove that the segment constructed by the segment construction axiom is unique. We state this as <code>Q ≠ A ∧ between Q A x ∧ A x ≡ B C ∧ between Q A y ∧ A y ≡ B C → x = y</code>. The proof is first that <code>A x ≡ A y</code> (because both are congruent to <code>B C</code>), and between that and <code>Q A ≡ Q A</code> we can apply <code>OuterThreeSegment</code> to <code>Q A x</code> and <code>Q A y</code> to get <code>Q x ≡ Q y</code>. Then we will apply <code>OuterFiveSegment</code> with the lines <code>Q A x</code> and <code>Q A x</code> and the points <code>x</code> and <code>y</code>. The four congruences we need are <code>Q A ≡ Q A</code>, <code>A x ≡ A x</code>, <code>Q x ≡ Q y</code>, and <code>A x ≡ A y</code>, and then <code>OuterFiveSegment</code> gives us <code>x x ≡ x y</code>. This congruence yields <code>x = y</code> by <code>CongruenceIdentityLeft</code>.<ref>construction_unicity in Narboux</ref>

The only real difficulty in formalizing this is juggling all those conjunctions and multiple antecedents. The first lemma shows <code>A x ≡ A y</code>.
<jh>
thm (SegmentConstructionUniquenessAxAy () () ((((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) ∧ (A y ≡ B C)) → (A x ≡ A y)) (
</jh>
First we extract the two pieces we care about, first showing that big long antecedent implies <code>A x ≡ B C</code>,
<jh>
        ((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) (A y ≡ B C) ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
</jh>
And then that it implies <code>A y ≡ B C</code>.
<jh>
        ((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) (A y ≡ B C) ConjunctionLeftElimination
</jh>
We apply symmetry to turn that into <code>B C ≡ A y</code>.
<jh>
        A y B C CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
We combine the two to get <code>A x ≡ B C ∧ B C ≡ A y</code>, and apply transitivity to finish.
<jh>
        composeConjunction

        A x B C A y CongruenceTransitivity
        applySyllogism
))
</jh>
The next lemma shows <code>Q x ≡ Q y</code>.
<jh>
thm (SegmentConstructionUniquenessQxQy () () ((((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) ∧ (A y ≡ B C)) → (Q x ≡ Q y)) (
</jh>
To apply <code>OuterThreeSegment</code> we need four things. The first is <code>between Q A x</code>.
<jh>
        ((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) (A y ≡ B C) ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
</jh>
The second is <code>between Q A y</code>.
<jh>
        ((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) (A y ≡ B C) ConjunctionRightElimination
        eliminateLeftConjunctionInConsequent

        composeConjunction
</jh>
The third is <code>Q A ≡ Q A</code>.
<jh>
        Q A CongruenceReflexivity
        (((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) ∧ (A y ≡ B C)) introduceAntecedent

        composeConjunction
</jh>
The fourth is <code>A x ≡ A y</code>.
<jh>
        Q A x B C y SegmentConstructionUniquenessAxAy

        composeConjunction
</jh>
Applying <code>OuterThreeSegment</code> we are done.
<jh>
        Q A x Q A y OuterThreeSegment
        applySyllogism
))
</jh>

The next lemma gets us most of the way. It shows <code>x x ≡ x y</code>.
<jh>
thm (SegmentConstructionUniquenessxxxy () () ((((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) ∧ (A y ≡ B C)) → (x x ≡ x y)) (
</jh>
We'll be applying <code>OuterFiveSegment</code> which has seven antecedents. The first two we can do together, <code>Q ≠ A ∧ between Q A x</code>.
<jh>
        ((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) (A y ≡ B C) ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
</jh>
The next is <code>between Q A x</code>.
<jh>
        ((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) (A y ≡ B C) ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        composeConjunction
</jh>
We now need four congruences. The first is <code>Q A ≡ Q A</code>.
<jh>
        Q A CongruenceReflexivity
        (((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) ∧ (A y ≡ B C)) introduceAntecedent

        composeConjunction
</jh>
The second congruence is <code>A x ≡ A x</code>.
<jh>
        A x CongruenceReflexivity
        (((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) ∧ (A y ≡ B C)) introduceAntecedent

        composeConjunction
</jh>
The third congruence is <code>Q x ≡ Q y</code>.
<jh>
        Q A x B C y SegmentConstructionUniquenessQxQy
        composeConjunction
</jh>
The fourth congruence is <code>A x ≡ A y</code>.
<jh>
        Q A x B C y SegmentConstructionUniquenessAxAy
        composeConjunction
</jh>
We are ready to apply <code>OuterFiveSegment</code>.
<jh>
        Q A x Q A x x y OuterFiveSegment
        applySyllogism
))
</jh>

The final theorem is only a small step further.
<jh>
thm (SegmentConstructionUniqueness () () ((((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) ∧ (A y ≡ B C)) → (x = y)) (
        Q A x B C y SegmentConstructionUniquenessxxxy
        x x y CongruenceIdentityLeft
        applySyllogism
))
</jh>

== Betweenness ==
We start with a degenerate case of betweenness. It illustrates that we follow Tarski's definition of betweenness, in which the points need not be distinct, rather than Hilbert's, in which they do need to be.<ref>Discussion at Bet in Narboux</ref>

The proof extends the line segment <code>A B</code> beyond <code>B</code> to a point <code>a</code> such that <code>B a ≡ B B</code>. But <code>B a ≡ B B</code> implies <code>B = a</code>, so we have in fact shown <code>between A B B</code>.<ref>beetween_trivial in Narboux</ref>
<jh>
thm (BetweenABB ((a A) (a B)) () (between A B B) (
        a A B B B SegmentConstruction
</jh>
That gives us <code>∃ a (between A B a ∧ B a ≡ B B)</code>. We apply the theorem <code>B a ≡ B B → B = a</code> to get <code>∃ a (between A B a ∧ B = a)</code>.
<jh>
        B (value a) B CongruenceIdentity
        (between A B (value a)) conjoinLL
        a addThereExists

        applyModusPonens
</jh>
We now need to handle the substitution of <code>B</code> for <code>a</code>. We start with <code>B = a → (between A B B ↔ between A B a)</code>.
<jh>
        A EqualityReflexivity
        B EqualityReflexivity
        A A B B B (value a) BetweenBuilder
        detach2of3
        detach1of2
</jh>
Eliminating the forward direction of the biconditional and rearranging gets <code>between A B a ∧ B = a → between A B B</code>.
<jh>
        eliminateBiconditionalForwardInConsequent
        applyComm
        import
</jh>
Combining with our previous result we have <code>∃ a between A B B</code>.
<jh>
        a addThereExists
        applyModusPonens
</jh>
And now we just remove the quantifier, which is no longer needed.
<jh>
        removeThereExists
))
</jh>

=== Betweenness symmetry ===
Exchanging the endpoints of a betweenness formula has no effect. In other words, B is between A and C implies B is between C and A.<ref>between_symmetry in Narboux</ref><ref>Symmetry Axiom for Betweenness in Givant and Tarski (1999)</ref>

We move much of the proof into a lemma because it will be useful in other similar proofs.
<jh>
thm (BetweenSubstitution ((a A) (a B) (a C)) () ((∃ a ((between B (value a) B) ∧ (between C (value a) A))) → (between C B A)) (
</jh>
We start by noting that <code>between B a B</code> implies <code>B = a</code>, which lets us derive <code>∃ a (between B a B ∧ between C a A) → ∃ a (B = a ∧ between C a A)</code>.
<jh>
        B (value a) Indivisibility
        (between C (value a) A) conjoinRR
        a addThereExists
</jh>
Now we apply a substitution to reduce <code>B = a ∧ between C a A</code> to <code>between C B A</code>. We start with the substitution <code>B = a → (between C B A ↔ between C a A)</code>
<jh>
        C EqualityReflexivity
        A EqualityReflexivity
        C C B (value a) A A BetweenBuilder
        detach2of2
        detach1of2
</jh>
We eliminating the forward implication, import, and combine with the previous result to get <code>∃ a (between B a B ∧ between C a A) → ∃ a between C B A</code>
<jh>
        eliminateBiconditionalForwardInConsequent
        import
        a addThereExists
        applySyllogism
</jh>
Removing the unnecessary quantifier is all that remains.
<jh>
        removeThereExistsInConsequent
))

thm (BetweennessSymmetryImplication ((a A) (a B) (a C)) () ((between A B C) → (between C B A)) (
</jh>
We'll be applying the <code>Pasch</code> axiom with <code>between A B C</code> and <code>between B C C</code> as the antecedents. The second of those is a theorem.
<jh>
        B C BetweenABB
        A B C B C a Pasch
        detach2of2
</jh>
That gives us <code>between A B C → ∃ a (between B a B ∧ between C a A)</code>. Applying our lemma is all we need.
<jh>
        a B C A BetweenSubstitution
        applySyllogism
))

thm (BetweennessSymmetry () () ((between A B C) ↔ (between C B A)) (
        A B C BetweennessSymmetryImplication
        C B A BetweennessSymmetryImplication
        introduceBiconditionalFromImplications
))
</jh>

Symmetry lets us easily prove the other degenerate case.<ref>beetween_trivial2 in Narboux</ref>
<jh>
thm (BetweenAAB () () (between A A B) (
        B A BetweenABB
        B A A BetweennessSymmetry
        eliminateBiconditionalReverse
        applyModusPonens
))
</jh>

=== Equality ===
If <code>B</code> is between <code>A</code> and <code>C</code>, and <code>A</code> is between <code>B</code> and <code>C</code>, then <code>A</code> and <code>B</code> must be equal.<ref>between_egality in Narboux</ref>

This property is analogous to antisymmetry for an [[w:Partial_order|order relation]].
<jh>
thm (BetweennessEquality ( (a A) (a B) (a C)) () (((between A B C) ∧ (between B A C)) → (A = B)) (
        A B C B A a Pasch
</jh>
That gives us <code>∃ a (between B a B ∧ between A a A)</code>. We just need to apply the <code>BetweenSubstitution</code> lemma to get <code>between A B A</code>,
<jh>
        a B A A BetweenSubstitution
        applySyllogism
</jh>
which in turn implies <code>A = B</code>
<jh>
        A B Indivisibility
        applySyllogism
))
</jh>

=== Transitivity ===
In this section we prove six similar theorems which involve four points on a line. Given two betweenness relationships, we conclude a third. Three of the six are just versions of the other three which are flipped left-to-right.

==== Inner transitivity, regular and flipped ====
The first one is known as inner transitivity.<ref>Inner Transitivity Axiom for Betweenness in Givant and Tarski, 1999</ref><ref>between_inner_transitivity in Narboux</ref>
<jh>
thm (BetweennessInnerTransitivity ( (a A) (a B) (a C) (a D)) ()
  (((between A B D) ∧ (between B C D)) → (between A B C)) (
        A B D B C a Pasch
</jh>
That gives us <code>∃ a (between B a B ∧ between C a A)</code>. The <code>BetweenSubstitution</code> lemma turns this into <code>between C B A</code>, and we just need to switch the order of the endpoints to be done.
<jh>
        a B C A BetweenSubstitution
        applySyllogism

        C B A BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

Reflecting this left-to-right gives our next theorem.<ref>between_exchange3 in Narboux</ref>
<jh>
thm (BetweennessInnerTransitivityFlipped () () (((between A B C) ∧ (between A C D)) → (between B C D)) (
</jh>
We first rewrite <code>between A B C</code> into <code>between C B A</code> and <code>between A C D</code> into <code>between D C A</code>
<jh>
        A B C BetweennessSymmetry
        A C D BetweennessSymmetry
        buildConjunction
        eliminateBiconditionalReverse
</jh>
Now we switch the order of the conjuncts.
<jh>
        (between C B A) (between D C A) ConjunctionCommutativity
        eliminateBiconditionalReverse
        applySyllogism

</jh>
Now we are ready to apply inner transitivity (which, when expanded with these variables, works out to <code>between D C A ∧ between C B A → between D C B</code>)
<jh>
        D C A B BetweennessInnerTransitivity
        applySyllogism
</jh>
Turning <code>between D C B</code> into <code>between B C D</code> finishes the proof.
<jh>
        D C B BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

==== Outer transitivity, flipped ====
For outer transitivity, we prove the "flipped" version first (where we consider the "non-flipped" one to be the one in Givant and Tarski (1999)).

To be specific, the flipped outer transitivity is <code>between A B C ∧ between B C D ∧ B ≠ C → between A C D</code>. First we extend <code>A C</code> beyond <code>C</code> to a point <code>a</code> such that <code>C a ≡ C D</code>. Then <code>between A B C</code> and <code>between A C a</code> give us <code>between B C a</code> by <code>BetweennessInnerTransitivityFlipped</code>. That's part of what we need to apply uniqueness of segment construction, which gives us <code>a = D</code>. Then we can substitute <code>between A C a</code> to get <code>between A C D</code>, which is what we want.<ref>outer_transitivity_between2 in Narboux</ref>

The first two lemmas get as far as <code>between B C a</code> in the proof sketch above.
<jh>
thm (BetweennessOuterTransitivityFlipped-1 () () ((((between A C x) ∧ (C x ≡ C D)) ∧ (between A B C)) → (((between A C x) ∧ (C x ≡ C D)) ∧ (between B C x))) (
        ((between A C x) ∧ (C x ≡ C D)) (between A B C) ConjunctionRightElimination

        ((between A C x) ∧ (C x ≡ C D)) (between A B C) ConjunctionLeftElimination

        ((between A C x) ∧ (C x ≡ C D)) (between A B C) ConjunctionRightElimination
        (between A C x) (C x ≡ C D) ConjunctionRightElimination
        applySyllogism

        composeConjunction

        A B C x BetweennessInnerTransitivityFlipped
        applySyllogism

        composeConjunction
))

thm (BetweennessOuterTransitivityFlipped-bca ( (A a) (B a) (C a) (D a)) ()
  ((((between A B C) ∧ (between B C D)) ∧ (B ≠ C))
   → (∃ a (((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))))) (
        a A C C D SegmentConstruction
        (((between A B C) ∧ (between B C D)) ∧ (B ≠ C)) introduceAntecedent

        ((between A B C) ∧ (between B C D)) (B ≠ C) ConjunctionRightElimination
        (between A B C) (between B C D) ConjunctionRightElimination
        applySyllogism

        composeConjunction
</jh>
The consequent is now <code>∃ a (between A C a ∧ C a ≡ C D) ∧ between A B C</code>.  We move <code>between A B C</code> inside the quantifier.
<jh>
        a ((between A C (value a)) ∧ (C (value a) ≡ C D)) (between A B C) ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applySyllogism
</jh>
Now we just replace <code>between A B C</code> with <code>between B C a</code>.
<jh>
        A C (value a) D B BetweennessOuterTransitivityFlipped-1
        a addThereExists
        applySyllogism
))
</jh>
The next lemma is just a way of getting everything inside the quantifier.
<jh>
thm (BetweennessOuterTransitivityFlipped-2 ((A a) (B a) (C a) (D a)) ()
  ((((between A B C) ∧ (between B C D)) ∧ (B ≠ C))
   → (∃ a (((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) ∧ (B ≠ C)))) (
</jh>
First, <code>C a ≡ C D ∧ between B C a</code>.
<jh>
        A B C D a BetweennessOuterTransitivityFlipped-bca
</jh>
Next, <code>between B C D</code>
<jh>
        ((between A B C) ∧ (between B C D)) (B ≠ C) ConjunctionRightElimination
        eliminateLeftConjunctionInConsequent

        composeConjunction

        a (((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) (between B C D) ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applySyllogism
</jh>
Finally, <code>B ≠ C</code>
<jh>
        ((between A B C) ∧ (between B C D)) (B ≠ C) ConjunctionLeftElimination

        composeConjunction

        a ((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) (B ≠ C) ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applySyllogism
))
</jh>
The following lemma is where we show that <code>a = D</code>.
<jh>
thm (BetweennessOuterTransitivityFlipped-ad () () ((((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) ∧ (B ≠ C)) → ((value a) = D)) (
</jh>
We'll be applying <code>SegmentConstructionUniqueness</code>. It has five antecedents. The first is <code>B ≠ C</code>.
<jh>
        ((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) (B ≠ C) ConjunctionLeftElimination
</jh>
The second is <code>between B C a</code>
<jh>
        ((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) (B ≠ C) ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        composeConjunction
</jh>
The third is <code>C a ≡ C D</code>
<jh>
        ((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) (B ≠ C) ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        composeConjunction
</jh>
The fourth is <code>between B C D</code>
<jh>
        ((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) (B ≠ C) ConjunctionRightElimination
        eliminateLeftConjunctionInConsequent

        composeConjunction
</jh>
The fifth is <code>C D ≡ C D</code>
<jh>
        C D CongruenceReflexivity
        (((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) ∧ (B ≠ C)) introduceAntecedent

        composeConjunction
</jh>
Applying <code>SegmentConstructionUniqueness</code> we can conclude <code>a = D</code>.
<jh>
        B C (value a) C D D SegmentConstructionUniqueness
        applySyllogism
))
</jh>
Here we combine the <code>a = D</code> result with picking <code>between A C a</code> out of the antecedent.
<jh>
thm (BetweennessOuterTransitivityFlipped-aca-ad () () ((((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) ∧ (B ≠ C)) → (((value a) = D) ∧ (between A C (value a)))) (
        A C a D B BetweennessOuterTransitivityFlipped-ad

        ((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) (B ≠ C) ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        composeConjunction
))
</jh>
Now our substitution.
<jh>
thm (BetweennessOuterTransitivityFlipped-sub () () ((((value a) = D) ∧ (between A C (value a))) → (between A C D)) (
        A EqualityReflexivity
        C EqualityReflexivity
        A A C C (value a) D BetweenBuilder
        detach2of3
        detach1of2
</jh>
That gives us <code>a = D → (between A C a ↔ between A C D)</code>.
<jh>
        eliminateBiconditionalReverseInConsequent
        import
))
</jh>
We're ready to combine the various pieces.
<jh>
thm (BetweennessOuterTransitivityFlipped ((A a) (B a) (C a) (D a)) () ((((between A B C) ∧ (between B C D)) ∧ (B ≠ C)) → (between A C D)) (
        A B C D a BetweennessOuterTransitivityFlipped-2

        A C a D B BetweennessOuterTransitivityFlipped-aca-ad
        a D A C BetweennessOuterTransitivityFlipped-sub
        applySyllogism

        a addThereExists
        applySyllogism

        removeThereExistsInConsequent
))
</jh>

==== Middle transitivity ====
The next result is <code>between A B D ∧ between B C D → between A C D</code>. The proof has two cases. If <code>B = C</code>, then we can substitute <code>between A B D</code> into <code>between A C D</code> and we are done. If <code>B ≠ C</code>, then we first apply inner transitivity to get <code>between A B C</code>, and then apply outer transitivity (flipped) to get <code>between A C D</code>.<ref>between_exchange2 in Narboux</ref>
<jh>
thm (BetweennessMiddleTransitivityBEqualsC () () ((B = C) → (((between A B D) ∧ (between B C D)) → (between A C D))) (
        A EqualityReflexivity
        D EqualityReflexivity
        A A B C D D BetweenBuilder
        detach2of2
        detach1of2
        eliminateBiconditionalReverseInConsequent

        (between A B D) (between B C D) ConjunctionRightElimination
        (between A C D) addCommonConsequent
        applySyllogism
))

thm (BetweennessMiddleTransitivityBNotEqualC () () ((B ≠ C) → (((between A B D) ∧ (between B C D)) → (between A C D))) (
</jh>
We'll prove <code>B ≠ C ∧ (between A B D ∧ between B C D) → between A C D</code>, which is only an export away from our desired result.

To apply <code>BetweennessOuterTransitivityFlipped</code> we need three things.  The first is <code>between A B C</code>
<jh>
        (B ≠ C) ((between A B D) ∧ (between B C D)) ConjunctionLeftElimination
        A B D C BetweennessInnerTransitivity
        applySyllogism
</jh>
The second is <code>between B C D</code>
<jh>
        (B ≠ C) ((between A B D) ∧ (between B C D)) ConjunctionLeftElimination
        eliminateLeftConjunctionInConsequent

        composeConjunction
</jh>
The third is <code>B ≠ C</code>
<jh>
        (B ≠ C) ((between A B D) ∧ (between B C D)) ConjunctionRightElimination
        composeConjunction

        A B C D BetweennessOuterTransitivityFlipped
        applySyllogism
        export
))

thm (BetweennessMiddleTransitivity () () (((between A B D) ∧ (between B C D)) → (between A C D)) (
        B C A D BetweennessMiddleTransitivityBEqualsC
        B C A D BetweennessMiddleTransitivityBNotEqualC
        eliminateCases
))
</jh>

==== Outer transitivity, non-flipped ====
The non-flipped outer transitivity is <code>between A B C ∧ between B C D ∧ B ≠ C → between A B D</code>.<ref>outer_transitivity_between in Narboux</ref><ref>Axiom 16 in Givant and Tarski, 1999</ref> Our proof just takes <code>BetweennessOuterTransitivityFlipped</code> and flips it, whereas Narboux's proof also invokes <code>BetweennessMiddleTransitivity</code>.

<jh>
thm (BetweennessOuterTransitivity () () ((((between A B C) ∧ (between B C D)) ∧ (B ≠ C)) → (between A B D)) (
        A B C BetweennessSymmetry
        B C D BetweennessSymmetry
        buildConjunction

        (between C B A) (between D C B) ConjunctionCommutativity
        applyBiconditionalTransitivity

        B C EqualitySymmetry
        addNegation

        buildConjunction
        eliminateBiconditionalReverse

        D C B A BetweennessOuterTransitivityFlipped
        applySyllogism

        D B A BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

==== Middle transitivity, flipped ====
Here we prove <code>between A B C ∧ between A C D → between A B D</code>.<ref>between_exchange4 in Narboux</ref>
<jh>
thm (BetweennessMiddleTransitivityFlipped () () (((between A B C) ∧ (between A C D)) → (between A B D)) (
        A B C BetweennessSymmetry
        A C D BetweennessSymmetry
        buildConjunction

        (between C B A) (between D C A) ConjunctionCommutativity
        applyBiconditionalTransitivity

        eliminateBiconditionalReverse

        D C A B BetweennessMiddleTransitivity
        applySyllogism

        D B A BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

=== Betweenness of more than three points ===
Narboux defines the concept of a betweenness relationship between four points, but we omit it here as Narboux does not use it anywhere.<ref>Bet_4 and l_3_9_4 in Narboux</ref>

== Twoness ==
There exist two distinct points. In symbols, <code>∃ a ∃ b a ≠ b</code>.<ref>two_distinct_points in Narboux</ref> The proof is based on the <code>LowerDimension</code> axiom. There are two cases. If <code>a ≠ b</code>, we are done. If <code>a = b</code>, then we can take <code>¬ between b c a</code> from the axiom and turn it into <code>¬ between b c b</code> which in turn implies <code>b ≠ c</code>.

Formalizing this proof has two parts. The first one follows the informal proof above and gets us as far as showing <code>a ≠ b</code> or <code>b ≠ c</code>. The second part does the predicate logic needed to switch variables and combine the two inequalities.

The first thing is a lemma bidirectionalizing <code>Indivisibility</code>.
<jh>
thm (IndivisibilityBidirectional () () ((between x y x) ↔ (x = y)) (
        x y Indivisibility

        x x BetweenAAB

        x EqualityReflexivity
        x EqualityReflexivity
        x x x y x x BetweenBuilder
        detach2of2
        detach1of2

        detachImplicationBiconditional

        introduceBiconditionalFromImplications
))

thm (TwonessLemma ((a b c)) () (∃ a (∃ b (∃ c (((value a) ≠ (value b)) ∨ ((value b) ≠ (value c)))))) (
        a b c LowerDimension
</jh>
The <code>a = b</code> case involves first picking out <code>¬ between b c a</code>.
<jh>
        ((¬ (between (value a) (value b) (value c)))
          ∧ (¬ (between (value b) (value c) (value a))))
        (¬ (between (value c) (value a) (value b)))
        ConjunctionRightElimination

        (¬ (between (value a) (value b) (value c))) (¬ (between (value b) (value c) (value a))) ConjunctionLeftElimination
        applySyllogism

        ((value a) = (value b)) introduceAntecedent
</jh>
Now we prove a substitution, <code>a = b → (¬ between b c a ↔ ¬ between b c b)</code>
<jh>
        (value b) EqualityReflexivity
        (value c) EqualityReflexivity
        (value b) (value b) (value c) (value c) (value a) (value b) BetweenBuilder
        detach2of3
        detach1of2

        addNegationInConsequent
</jh>
We combine the substitution with our previous result to get <code>a = b → (¬ between a b c ∧ ¬ between b c a ∧ ¬ between c a b → ¬ between b c b)</code>.
<jh>
        eliminateBiconditionalReverseInConsequent
        applySyllogismInConsequent
</jh>
Now we turn the consequent into <code>b ≠ c</code>,
<jh>
        (value b) (value c) IndivisibilityBidirectional
        addNegation
        eliminateBiconditionalReverse
        ((value a) = (value b)) introduceAntecedent
        applySyllogismInConsequent
</jh>
and add the <code>a ≠ b</code> disjunct.
<jh>
        ((value b) ≠ (value c)) ((value a) ≠ (value b)) DisjunctionLeftIntroduction
        ((value a) = (value b)) introduceAntecedent
        applySyllogismInConsequent
</jh>
The <code>a ≠ b</code> case is just a matter of arranging formulas for the case elimination and hooking to <code>LowerDimension</code>.
<jh>
        ((value a) ≠ (value b)) ((value b) ≠ (value c)) DisjunctionRightIntroduction
        (((value a) ≠ (value b)) ∨ ((value b) ≠ (value c)))
        (((¬ (between (value a) (value b) (value c)))
          ∧ (¬ (between (value b) (value c) (value a))))
          ∧ (¬ (between (value c) (value a) (value b)))
        ) AntecedentIntroduction
        applySyllogism
</jh>
We combine the cases and finish the proof.
<jh>
        eliminateCases
        c addThereExists
        b addThereExists
        a addThereExists
        applyModusPonens
))
</jh>
That's the first part of the proof. Now for the predicate logic. First is a lemma which expresses the variable change which is at the heart of all this rearrangement.
<jh>
thm (TwonessLemma2 ((a b c)) () ((∃ a (∃ b ((value a) ≠ (value b)))) ↔ (∃ b (∃ c ((value b) ≠ (value c))))) (
</jh>
Starting from the inside, our first substitution is <code>b = c → (a ≠ b ↔ a ≠ c)</code>
<jh>
        (value b) (value c) (value a) EqualityBuilderLL
        addNegationInConsequent
</jh>
That leads to the variable change <code>∃ b a ≠ b ↔ ∃ c a ≠ c</code>.
<jh>
        ChangeVariableThereExists
        a buildThereExists
</jh>
We repeat the process with the outer quantifiers. The substitution is <code>a = b → (∃ c a ≠ c ↔ ∃ c b ≠ c)</code>.
<jh>
        (value a) (value b) (value c) EqualityBuilderRR
        addNegationInConsequent
        c buildThereExistsInConsequent
</jh>
The corresponding variable change is <code>∃ a ∃ c a ≠ c ↔ ∃ b ∃ c b ≠ c</code>. Combining this with the first variable change proves our lemma.
<jh>
        ChangeVariableThereExists
        applyBiconditionalTransitivity
))

thm (Twoness ((a b c)) () (∃ a (∃ b ((value a) ≠ (value b)))) (
        a b c TwonessLemma

        c ((value a) ≠ (value b)) ((value b) ≠ (value c)) ThereExistsDisjunctionMovement
        eliminateBiconditionalReverse
        b addThereExists
        a addThereExists
        applyModusPonens
</jh>
We now have <code>∃ a ∃ b (a ≠ b ∨ ∃ c b ≠ c)</code>. We distribute <code>∃ b</code> across the disjunction.
<jh>
        b ((value a) ≠ (value b)) (∃ c ((value b) ≠ (value c))) ThereExistsDisjunction
        eliminateBiconditionalReverse
        a addThereExists
        applyModusPonens
</jh>
We have <code>∃ a (∃ b a ≠ b ∨ ∃ b ∃ c b ≠ c)</code>. We move the second disjunct outside of the quantifier for <code>a</code> to get <code>∃ a ∃ b a ≠ b ∨ ∃ b ∃ c b ≠ c</code>
<jh>
        a (∃ b ((value a) ≠ (value b))) (∃ b (∃ c ((value b) ≠ (value c)))) ThereExistsDisjunctionRightMovement
        eliminateBiconditionalReverse
        applyModusPonens
</jh>
At this point, we can change the variables in the latter disjunct.
<jh>
        a b c TwonessLemma2
        eliminateBiconditionalForward
        (∃ a (∃ b ((value a) ≠ (value b)))) disjoinLL
        applyModusPonens
</jh>
Having gotten both disjuncts to use the same variables, we are done.
<jh>
        conflateDisjunction
))
</jh>

=== Extending a line segment to a distinct point ===
Any line segment <code>A B</code> can be extended beyond <code>B</code> to a point <code>c</code> which does not equal <code>B</code>.<ref>point_construction_different in Narboux</ref>

First we prove a lemma which just rearranges <code>CongruenceIdentityFromEquality</code>.
<jh>
thm (PointConstructionDifferentLemma () () (((A B ≡ C D) ∧ (C ≠ D)) → (A ≠ B)) (
        A B C D CongruenceIdentityFromEquality
        applyComm

        (A = B) (C = D) Transposition
        eliminateBiconditionalReverse
        applySyllogism

        import
))
</jh>
The next lemma is just rearranging conjuncts and applying the previous lemma.
<jh>
thm (PointConstructionDifferentLemma2 () () ((((between A B C) ∧ (B C ≡ x y)) ∧ (x ≠ y)) → ((between A B C) ∧ (B ≠ C))) (
</jh>
First we pick out <code>between A B C</code>.
<jh>
        ((between A B C) ∧ (B C ≡ x y)) (x ≠ y) ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
</jh>
Next we pick out <code>B C ≡ x y</code>.
<jh>
        ((between A B C) ∧ (B C ≡ x y)) (x ≠ y) ConjunctionRightElimination
        eliminateLeftConjunctionInConsequent
</jh>
Next we pick out <code>x ≠ y</code>.
<jh>
        ((between A B C) ∧ (B C ≡ x y)) (x ≠ y) ConjunctionLeftElimination
</jh>
Combining the second two results and applying the previous lemma gives us <code>B ≠ C</code>.
<jh>
        composeConjunction
        B C x y PointConstructionDifferentLemma
        applySyllogism
</jh>
Combining <code>between A B C</code> and <code>B ≠ C</code> finishes the proof.
<jh>
        composeConjunction
))

thm (PointConstructionDifferent ((c A) (c B)  (a b A) (a b B) (a b c)) () (∃ c ((between A B (value c)) ∧ (B ≠ (value c)))) (
</jh>
The proof of our main theorem will proceed by constructing two different points <code>a</code> and <code>b</code>, and using them to extend the segment <code>A B</code> to a distinct point.

We start with the extension of <code>A B</code> beyond <code>B</code> to a point <code>c</code>.
<jh>
        c A B (value a) (value b) SegmentConstruction
</jh>
That gives us <code>∃ c (between A B c ∧ B c ≡ a b)</code>. This a relationship which holds for any values of <code>a</code> and <code>b</code>
<jh>
        b generalize
        a generalize
</jh>
Now we put in the construction of the two distinct points,
<jh>
        a b Twoness
</jh>
and combine the two statements and gather the quantifiers at the beginning to get <code>∃ a ∃ b ∃ c ((between A B c ∧ B c ≡ a b) ∧ a ≠ b)</code>
<jh>
        introduceConjunction

        a (∀ b (∃ c ((between A B (value c)) ∧ (B (value c) ≡ (value a) (value b))))) (∃ b ((value a) ≠ (value b))) ThereExistsConjunctionCombining
        applyModusPonens

        b (∃ c ((between A B (value c)) ∧ (B (value c) ≡ (value a) (value b)))) ((value a) ≠ (value b)) ThereExistsConjunctionCombining
        a addThereExists
        applyModusPonens

        c ((between A B (value c)) ∧ (B (value c) ≡ (value a) (value b))) ((value a) ≠ (value b)) ThereExistsConjunctionRightMovement
        b buildThereExists
        a buildThereExists
        eliminateBiconditionalForward
        applyModusPonens
</jh>
Applying our lemma, we get <code>∃ a ∃ b ∃ c (between A B c ∧ B ≠ c)</code>
<jh>
        A B (value c) (value a) (value b) PointConstructionDifferentLemma2
        c addThereExists
        b addThereExists
        a addThereExists
        applyModusPonens
</jh>
The first two quantifiers are no longer needed, and that finishes the proof.
<jh>
        removeThereExists
        removeThereExists
))
</jh>

=== A point distinct from a given point exists ===
Given a point <code>A</code>, there exists a point <code>b</code> distinct from it.<ref>another_point in Narboux</ref> Here's the sketch of Narboux's proof: apply <code>Twoness</code> to get <code>x</code> and <code>y</code> such that <code>x ≠ y</code>. If <code>A ≠ x</code>, we are done (<code>x</code> is the desired point). If <code>A = x</code>, then subsituting into <code>x ≠ y</code> gives us <code>A ≠ y</code>, and <code>y</code> is the desired point. It would be possible (although somewhat cumbersome) to formalize this argument here, but it will be easier just to prove this theorem as a special case of <code>PointConstructionDifferent</code>.
<jh>
thm (AnotherPoint ((b A)) () (∃ b (A ≠ (value b))) (
        b A A PointConstructionDifferent

        (between A A (value b)) (A ≠ (value b)) ConjunctionLeftElimination
        b addThereExists

        applyModusPonens
))
</jh>

== Lemma l3_17 (Pasch variant) ==
[[File:Lemma l3_17 from Narboux.svg|thumb|right|Top: statement of the lemma; Middle: construction of <code>q′</code>; Bottom: construction of <code>q</code>]]
This lemma is a variant of Pasch's axiom.  The lemma is <code>between A B C ∧ between A′ B′ C ∧ between A P A′ → ∃ q (between P q C ∧ between B q B′)</code>. The proof consists of two applications of Pasch's axiom. The first one uses the triangle <code>A A′ C</code> (with points <code>P</code> and <code>B′</code>) to construct a point <code>q′</code>. The second uses the triangle <code>A C B′</code> (with points <code>B</code> and <code>q′</code>) to construct the point <code>q</code>.
<jh>
thm (PaschLine ((q P) (q C) (q A) (q B) (q B′)  (q′ q) (q′ P) (q′ C) (q′ B) (q′ A) (q′ B′) (q′ A′)) ()
  ((((between A B C) ∧ (between A′ B′ C)) ∧ (between A P A′)) → (∃ q ((between P (value q) C) ∧ (between B (value q) B′)))) (
</jh>
To construct <code>q′</code>, we need <code>between A P A′</code> and <code>between C B′ A′</code>, and Pasch's axiom will give us <code>between P q′ C</code> and <code>between B′ q′ A</code>.
<jh>
        ((between A B C) ∧ (between A′ B′ C)) (between A P A′) ConjunctionLeftElimination

        ((between A B C) ∧ (between A′ B′ C)) (between A P A′) ConjunctionRightElimination
        eliminateLeftConjunctionInConsequent
        A′ B′ C BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        A P A′ C B′ q′ Pasch
        applySyllogism
</jh>
That gives us <code>between A B C ∧ between A′ B′ C ∧ between A P A′ → ∃ q′ (between P q′ C ∧ between B′ q′ A)</code>. We'll need <code>between C B A</code> in the next step, so we put <code>between C B A</code> inside the quantifier to get <code>between A B C ∧ between A′ B′ C ∧ between A P A′ → ∃ q′ (between P q′ C ∧ between B′ q′ A ∧ between C B A)</code>.
<jh>
        ((between A B C) ∧ (between A′ B′ C)) (between A P A′) ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        A B C BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        q′ ((between P (value q′) C) ∧ (between B′ (value q′) A)) (between C B A) ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applySyllogism
</jh>
To construct <code>q</code>, we need <code>between C B A</code> and <code>between B′ q′ A</code>, and Pasch's axiom will give us <code>between B q B′</code> and <code>between q′ q C</code>.
<jh>
        ((between P (value q′) C) ∧ (between B′ (value q′) A)) (between C B A) ConjunctionLeftElimination

        ((between P (value q′) C) ∧ (between B′ (value q′) A)) (between C B A) ConjunctionRightElimination
        eliminateLeftConjunctionInConsequent

        composeConjunction

        C B A B′ (value q′) q Pasch
        applySyllogism
</jh>
We're getting close. Right now there are two things on the proof stack, <code><code>between A B C ∧ between A′ B′ C ∧ between A P A′ → ∃ q′ (between P q′ C ∧ between B′ q′ A ∧ between C B A)</code> and <code>between P q′ C ∧ between B′ q′ A ∧ between C B A → ∃ q between B q B′ ∧ between q′ q C</code>. Half of what we need is <code>between B q B′</code>. We'll need to fish out <code>between q′ q C</code> and <code>between P q′ C</code> to get <code>between P q C</code>, so start by putting <code>between P q′ C</code> inside the <code>∃ q</code>
<jh>
        ((between P (value q′) C) ∧ (between B′ (value q′) A)) (between C B A) ConjunctionRightElimination
        eliminateRightConjunctionInConsequent

        composeConjunction

        q ((between B (value q) B′) ∧ (between (value q′) (value q) C)) (between P (value q′) C) ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applySyllogism
</jh>
Combining with the previous results we get <code>between A B C ∧ between A′ B′ C ∧ between A P A′ → ∃ q′ ∃ q (between B q B′ ∧ between q′ q C ∧ P q′ C)</code>
<jh>
        q′ addThereExists
        applySyllogism
</jh>
Now we can extract <code>between P q′ C</code> and <code>between q′ q C</code>, and apply <code>BetweennessMiddleTransitivity</code>.
<jh>
        ((between B (value q) B′) ∧ (between (value q′) (value q) C)) (between P (value q′) C) ConjunctionLeftElimination

        ((between B (value q) B′) ∧ (between (value q′) (value q) C)) (between P (value q′) C) ConjunctionRightElimination
        eliminateLeftConjunctionInConsequent

        composeConjunction

        P (value q′) C (value q) BetweennessMiddleTransitivity
        applySyllogism
</jh>
The other half of what we need is <code>between B q B′</code>
<jh>
        ((between B (value q) B′) ∧ (between (value q′) (value q) C)) (between P (value q′) C) ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
</jh>
Combining we get <code>between A B C ∧ between A′ B′ C ∧ between A P A′ → ∃ q′ ∃ q (between P q C ∧ between B q B′)</code>.
<jh>
        composeConjunction

        q addThereExists
        q′ addThereExists
        applySyllogism
</jh>
The <code>∃ q′</code> quantifier is now unneeded, so remove it.
<jh>
        removeThereExistsInConsequent
))
</jh>

== Inner five segment ==
[[File:Inner five segment.svg|thumb|Inner five segment]]
The five segment axiom can be thought of as an "outer five segment" statement, as one is given a set of congruences and concludes a congruence for a segment outside the given ones. The inner five segment theorem is similar, but the given set of congruences are for the outer segments and the theorem supplies a congruence inside those. The key change, comparing the axiom/theorem and diagrams, is to move the congruence for <code>z u</code> from the consequent to the antecedent, and the congruence for <code>y u</code> from the antecedent to the consequent.<ref>Lemma l4_2 in Narboux</ref>

The proof has two cases.  The first case is <code>x = z</code>. From <code>between x y z</code> we get <code>x = y</code>. Likewise, <code>x z ≡ x′ z′</code> implies <code>x′ = z′</code>, which in turn implies <code>x′ = y′</code>. Thus, we can turn <code>x u ≡ x′ u′</code> into <code>y u ≡ y u′</code>.
<jh>
thm (IndivisibilityFromEquality () () (((x = z) ∧ (between x y z)) → (x = y)) (
        x EqualityReflexivity
        y EqualityReflexivity
        x x y y x z BetweenBuilder
        detach2of3
        detach1of2

        eliminateBiconditionalForwardInConsequent

        x y Indivisibility
        (x = z) introduceAntecedent

        applySyllogismInConsequent

        import
))

thm (InnerFiveSegmentXEqualsZ () () ((x = z) → (((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′)) → (y u ≡ y′ u′))) (
</jh>
First we pick out <code>between x y z</code>.
<jh>
        (((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) (z u ≡ z′ u′) ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
</jh>
Then we apply <code>IndivisibilityFromEquality</code> to get <code>x = z ∧ ''many conjuncts'' → x = y</code>.
<jh>
        (x = z) conjoinLL

        x z y IndivisibilityFromEquality
        applySyllogism
</jh>
Now we pick out <code>x z ≡ x′ z′</code> and apply <code>CongruenceIdentityFromEquality</code> to get <code>x = z ∧ ''many conjuncts'' → x′ = z′</code>.
<jh>
        (((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) (z u ≡ z′ u′) ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        (x = z) conjoinLL
        x z x′ z′ CongruenceIdentityFromEquality
        import
        applySyllogism
</jh>
Now we pick out <code>between x′ y′ z′</code> and apply <code>IndivisibilityFromEquality</code> to get <code>x = z ∧ ''many conjuncts'' → x′ = y′</code>.
<jh>
        (x = z) ((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′)) ConjunctionLeftElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        composeConjunction

        x′ z′ y′ IndivisibilityFromEquality
        applySyllogism

        composeConjunction
</jh>
Next we pick out <code>x u ≡ x′ u′</code> and combine with the previous results to get <code>x = z ∧ ''many conjuncts'' → x = y ∧ x′ = y′ ∧ x u ≡ x′ u′</code>
<jh>
        (x = z) ((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′)) ConjunctionLeftElimination
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        composeConjunction
</jh>
Now we transform <code>x = y ∧ x′ = y′ ∧ x u ≡ x′ u′</code> into <code>y u ≡ y′ u′</code>.
<jh>
        u EqualityReflexivity
        u′ EqualityReflexivity
        x y u u x′ y′ u′ u′ CongruenceBuilder
        detach2of2
        detach2of3

        eliminateBiconditionalReverseInConsequent
        import

        applySyllogism
        export
))
</jh>
[[File:Inner five segment proof.svg|thumb|right|The <code>x ≠ z</code> case. <code>w z ≡ w′ z′</code> by construction. <code>w u ≡ w′ u′</code> by applying outer five segment to <code>x z w u</code>. <code>y u ≡ y′ u′</code> by applying outer five segment to <code>w z y u</code>.]]
The <code>x ≠ z</code> case is proved by two applications of outer five segment. First extend the line segment <code>x z</code> beyond <code>z</code> to a distinct point <code>w</code>. Extend <code>x′ z′</code> beyond <code>z′</code> to a point <code>w′</code> such that <code>w z ≡ w′ z′</code>. We can now apply outer five segment to <code>x z w u</code> to get <code>w u ≡ w′ u′</code>. Then we apply outer five segment to <code>w z y u</code> to get <code>y u ≡ y′ u′</code>.

The bulk of the proof consists of picking out conjuncts to satisfy the antecedents of the outer five segment invocations. We break it out into two lemmas, which start after the construction of <code>w</code> and <code>w′</code> and go from there. The first lemma proves <code>w u ≡ w′ u′</code> and the second applies the first and proves <code>y u ≡ y′ u′</code>. The two lemmas have the same antecedent, which is parenthesized in the following way. It consists of four conjuncts, the first of which corresponds to the construction of <code>w</code>, the second of which corresponds to the construction of <code>w′</code>, the third of which is <code>w ≠ z</code>, and the fourth of which is the antecedent of the eventual <code>InnerFiveSegment</code> theorem we are working towards.
<jh>
thm (InnerFiveSegmentWU () () ((
    ((between x z w) ∧ (z ≠ w)) ∧ (
    ((between x′ z′ w′) ∧ (z′ w′ ≡ z w)) ∧ (
    (x ≠ z) ∧ (
    (((((between x y z) ∧
      (between x′ y′ z′)) ∧
      (x z ≡ x′ z′)) ∧
      (y z ≡ y′ z′)) ∧
      (x u ≡ x′ u′)) ∧
      (z u ≡ z′ u′)))))
  → (w u ≡ w′ u′)) (
</jh>
The first thing we need to apply outer five segment to <code>x z w u</code> is <code>x ≠ z</code>
<jh>
        ((between x z w) ∧ (z ≠ w)) (((between x′ z′ w′) ∧ (z′ w′ ≡ z w)) ∧ ((x ≠ z) ∧ ((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′)))) ConjunctionLeftElimination
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent
</jh>
The second thing we need is <code>between x z w</code>.
<jh>
        ((between x z w) ∧ (z ≠ w)) (((between x′ z′ w′) ∧ (z′ w′ ≡ z w)) ∧ ((x ≠ z) ∧ ((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′)))) ConjunctionRightElimination
        eliminateRightConjunctionInConsequent

        composeConjunction
</jh>
The third thing we need is <code>between x′ z′ w′</code>.
<jh>
        ((between x z w) ∧ (z ≠ w)) (((between x′ z′ w′) ∧ (z′ w′ ≡ z w)) ∧ ((x ≠ z) ∧ ((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′)))) ConjunctionLeftElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        composeConjunction
</jh>
The fourth thing we need is <code>x z ≡ x′ z′</code>.
<jh>
        ((between x z w) ∧ (z ≠ w)) (((between x′ z′ w′) ∧ (z′ w′ ≡ z w)) ∧ ((x ≠ z) ∧ ((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′)))) ConjunctionLeftElimination
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        composeConjunction
</jh>
The fifth thing we need is <code>z w ≡ z′ w′</code>.
<jh>
        ((between x z w) ∧ (z ≠ w)) (((between x′ z′ w′) ∧ (z′ w′ ≡ z w)) ∧ ((x ≠ z) ∧ ((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′)))) ConjunctionLeftElimination
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        z′ w′ z w CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
The sixth thing we need is <code>x u ≡ x′ u′</code>.
<jh>
        ((between x z w) ∧ (z ≠ w)) (((between x′ z′ w′) ∧ (z′ w′ ≡ z w)) ∧ ((x ≠ z) ∧ ((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′)))) ConjunctionLeftElimination
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        composeConjunction
</jh>
The last thing we need is <code>z u ≡ z′ u′</code>.
<jh>
        ((between x z w) ∧ (z ≠ w)) (((between x′ z′ w′) ∧ (z′ w′ ≡ z w)) ∧ ((x ≠ z) ∧ ((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′)))) ConjunctionLeftElimination
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        composeConjunction
</jh>
Applying outer five segment, we conclude <code>w u ≡ w′ u′</code>.
<jh>
        x z w x′ z′ w′ u u′ OuterFiveSegment
        applySyllogism
))

thm (InnerFiveSegmentYU () () ((
    ((between x z w) ∧ (z ≠ w)) ∧ (
    ((between x′ z′ w′) ∧ (z′ w′ ≡ z w)) ∧ (
    (x ≠ z) ∧ (
    (((((between x y z) ∧
      (between x′ y′ z′)) ∧
      (x z ≡ x′ z′)) ∧
      (y z ≡ y′ z′)) ∧
      (x u ≡ x′ u′)) ∧
      (z u ≡ z′ u′)))))
  → (y u ≡ y′ u′)) (
</jh>
The first thing we need to apply outer five segment to <code>w z y u</code> is <code>w ≠ z</code>.
<jh>
        (((between x z w) ∧ (z ≠ w)) ∧ (((between x′ z′ w′) ∧ (z′ w′ ≡ z w)) ∧ ((x ≠ z) ∧ ((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′))))) ImplicationReflexivity
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        z w EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
The second thing we need is <code>between w z y</code>. This follows from <code>between w z x</code> and <code>between z y x</code>.
<jh>
        (((between x z w) ∧ (z ≠ w)) ∧ (((between x′ z′ w′) ∧ (z′ w′ ≡ z w)) ∧ ((x ≠ z) ∧ ((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′))))) ImplicationReflexivity
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        x z w BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        (((between x z w) ∧ (z ≠ w)) ∧ (((between x′ z′ w′) ∧ (z′ w′ ≡ z w)) ∧ ((x ≠ z) ∧ ((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′))))) ImplicationReflexivity
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        x y z BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        w z x y BetweennessInnerTransitivity
        applySyllogism

        composeConjunction
</jh>
The third thing we need is <code>between w′ z′ y′</code>. This follows from <code>between w′ z′ x′</code> and <code>between z′ y′ x′</code>.
<jh>
        (((between x z w) ∧ (z ≠ w)) ∧ (((between x′ z′ w′) ∧ (z′ w′ ≡ z w)) ∧ ((x ≠ z) ∧ ((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′))))) ImplicationReflexivity
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        x′ z′ w′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        (((between x z w) ∧ (z ≠ w)) ∧ (((between x′ z′ w′) ∧ (z′ w′ ≡ z w)) ∧ ((x ≠ z) ∧ ((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′))))) ImplicationReflexivity
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        x′ y′ z′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        w′ z′ x′ y′ BetweennessInnerTransitivity
        applySyllogism

        composeConjunction
</jh>
The fourth thing we need is <code>w z ≡ w′ z′</code>.
<jh>
        (((between x z w) ∧ (z ≠ w)) ∧ (((between x′ z′ w′) ∧ (z′ w′ ≡ z w)) ∧ ((x ≠ z) ∧ ((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′))))) ImplicationReflexivity
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        z′ w′ z w CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        z w z′ w′ CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
The fifth thing we need is <code>z y ≡ z′ y′</code>.
<jh>
        (((between x z w) ∧ (z ≠ w)) ∧ (((between x′ z′ w′) ∧ (z′ w′ ≡ z w)) ∧ ((x ≠ z) ∧ ((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′))))) ImplicationReflexivity
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        y z y′ z′ CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
The sixth thing we need is <code>w u ≡ w′ u′</code>.
<jh>
        x z w x′ z′ w′ y y′ u u′ InnerFiveSegmentWU
        composeConjunction
</jh>
The last thing we need is <code>z u ≡ z′ u′</code>.
<jh>
        (((between x z w) ∧ (z ≠ w)) ∧ (((between x′ z′ w′) ∧ (z′ w′ ≡ z w)) ∧ ((x ≠ z) ∧ ((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′))))) ImplicationReflexivity
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        composeConjunction
</jh>
Applying outer five segment, we conclude <code>y u ≡ y′ u′</code>.
<jh>
        w z y w′ z′ y′ u u′ OuterFiveSegment
        applySyllogism
))
</jh>
Now it is time to assemble the <code>x ≠ z</code> case. It basically consists of predicate logic. There might be an clearer way to arrange this proof, but the basic idea is to construct <code>w′</code> (which we call <code>ww′</code> when we need a variable) with <code>SegmentConstruction</code>, to construct <code>w</code> (which we call <code>ww</code> when we need a variable) using <code>PointConstructionDifferent</code>, and to use those constructions to remove antecedents from the formula we get from <code>InnerFiveSegmentYU</code>.
<jh>
thm (InnerFiveSegmentXNotEqualZ
  ((ww′ x) (ww′ y) (ww′ z) (ww′ x′) (ww′ y′) (ww′ z′) (ww′ u) (ww′ u′) (ww′ ww) (ww x) (ww y) (ww z) (ww x′) (ww y′) (ww z′) (ww u) (ww u′))
  ()
  ((x ≠ z) → (((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′)) → (y u ≡ y′ u′))) (
        ww x z PointConstructionDifferent

        ww′ x′ z′ z (value ww) SegmentConstruction

        x z (value ww) x′ z′ (value ww′) y y′ u u′ InnerFiveSegmentYU
        export
        exportInConsequent
        applyComm
        ww′ addThereExistsToAntecedent

        applyModusPonens

        ww addThereExistsToAntecedent

        applyModusPonens

        export
))

thm (InnerFiveSegment () ()
  (((((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ∧ (x u ≡ x′ u′)) ∧ (z u ≡ z′ u′)) → (y u ≡ y′ u′)) (
        x z y x′ y′ z′ u u′ InnerFiveSegmentXEqualsZ
        x z y x′ y′ z′ u u′ InnerFiveSegmentXNotEqualZ
        eliminateCases
))
</jh>

== Inner three segment ==
The next theorem, <code>between x y z ∧ between x′ y′ z′ ∧ x z ≡ x′ z′ ∧ y z ≡ y′ z′ → x y ≡ x′ y′</code>, is analogous to the three segment theorem we proved earlier, except that we are given the outer congruence and conclude an inner one.<ref>Lemma l4_3 in Narboux</ref><ref>Axiom 24 in Givant and Tarski, 1999</ref> The proof is a straightforward application of inner five segments; there is no need to treat any degenerate cases separately (as we did with outer three segment).

<jh>
thm (InnerThreeSegment () ()
  (((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) → (x y ≡ x′ y′)) (
</jh>
To apply inner five segment we will need <code>between x y z ∧ between x′ y′ z′ ∧ x z ≡ x′ z′ ∧ y z ≡ y′ z′ ∧ x x ≡ x′ x′ ∧ z x ≡ z′ x′</code>. The first four conjuncts are identical.
<jh>
        ((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ImplicationReflexivity
</jh>
The next is <code>x x ≡ x′ x′</code>.
<jh>
        x x′ CongruenceTrivialIdentity
        ((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) introduceAntecedent
        composeConjunction
</jh>
The last conjunct is <code>z x ≡ z′ x′</code>
<jh>
        ((((between x y z) ∧ (between x′ y′ z′)) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)) ImplicationReflexivity
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        x z x′ z′ CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Applying inner five segment gives us <code>y x ≡ y′ x′</code>, and we just need to flip it to <code>x y ≡ x′ y′</code>.
<jh>
        x y z x′ y′ z′ x x′ InnerFiveSegment
        applySyllogism

        y x y′ x′ CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

== Congruence of three points ==
We call one set of three points congruent to a second set if each of the three corresponding congruences hold. In other words, two triangles are congruent if their corresponding sides are congruent (side-side-side) (except that our definition also holds for degenerate cases, where not all three points are distinct). The conventional notation is <code>△ABC ≅ △DEF</code> but because of the degenerate cases and JHilbert limitations, we just call it <code>A B C ≅ D E F</code>.
<jh>
def ((≅ x y z x′ y′ z′) (((x y ≡ x′ y′) ∧ (x z ≡ x′ z′)) ∧ (y z ≡ y′ z′)))
</jh>

The corresponding sides of congruent (possibly degenerate) triangles are congruent.
<jh>
thm (Congruence12 () () ((A B C ≅ A′ B′ C′) → (A B ≡ A′ B′)) (
        ((A B ≡ A′ B′) ∧ (A C ≡ A′ C′)) (B C ≡ B′ C′) ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
))

thm (Congruence23 () () ((A B C ≅ A′ B′ C′) → (B C ≡ B′ C′)) (
        ((A B ≡ A′ B′) ∧ (A C ≡ A′ C′)) (B C ≡ B′ C′) ConjunctionLeftElimination
))

thm (Congruence13 () () ((A B C ≅ A′ B′ C′) → (A C ≡ A′ C′)) (
        ((A B ≡ A′ B′) ∧ (A C ≡ A′ C′)) (B C ≡ B′ C′) ConjunctionRightElimination
        eliminateLeftConjunctionInConsequent
))
</jh>

=== Constructing a degenerate congruent triangle ===
Given two congruent line segments <code>A C</code> and <code>A′ C′</code>, where <code>B</code> is on the former, we construct a point <code>b′</code> on the latter line segment such that the degenerate triangles <code>A B C</code> and <code>A′ b′ C′</code/'> are congruent.<ref>Lemma l4_5 in Narboux</ref> In symbols this is <code>between A B C ∧ A C ≡ A′ C′ → ∃ b′ (between A′ b′ C′ ∧ A B C ≅ A′ b′ C′)</code>

Here is a sketch of the proof: Extend <code>C′ A′</code> to a distinct point <code>d′</code>. Extend <code>d′ A′</code> to a point <code>b′</code> such that <code>A B ≡ A′ b′</code>. Extend <code>d′ b′</code> to a point <code>c″</code> such that <code>b′ c″ ≡ B C</code>. From <code>between d′ A′ b′</code> and <code>between d′ b′ c″</code> we can conclude <code>between A′ b′ c″</code> (by <code>BetweennessInnerTransitivityFlipped</code>). Applying outer three segment to <code>A B C</code> and <code>A′ b′ c″</code> gives us <code>A C ≡ A′ c″</code>. By the uniqueness of segment construction, applied to <code>d′ A′ C′</code> and <code>d′ A′ c″</code>, we conclude that <code>C′ = c″</code>. Given this equality, we merely need to do some substitution to prove each of the three congruences which make up <code>A B C ≅ A′ b′ C′</code>.

Our first lemma constructs the points and moves the quantifiers a bit.
<jh>
thm (InnerDegenerateTriangle-1 ((b′ A) (b′ B) (b′ C) (b′ A′) (b′ C′)
    (d′ c″ b′ A) (d′ c″ B) (d′ c″ C) (d′ c″ A′) (d′ c″ C′)) ()
  (((between A B C) ∧ (A C ≡ A′ C′)) → 
    (∃ d′ (∃ b′ (∃ c″
      (((((between C′ A′ (value d′)) ∧ (A′ ≠ (value d′))) ∧
      ((between (value d′) A′ (value b′)) ∧ (A′ (value b′) ≡ A B))) ∧
      ((between (value d′) (value b′) (value c″)) ∧
        ((value b′) (value c″) ≡ B C))) ∧
      ((between A B C) ∧ (A C ≡ A′ C′))))))) (
</jh>
We start with the theorems <code>∃ d′ between C′ A′ d′ ∧ A′ ≠ d′</code> and <code>∀ d′ ∃ b′ between d′ A′ b′ ∧ A′ b′ ≡ A B</code>.
<jh>
        d′ C′ A′ PointConstructionDifferent

        b′ (value d′) A′ A B SegmentConstruction
        d′ generalize

        introduceConjunction
</jh>
We gather the quantifiers,
<jh>
        d′ ((between C′ A′ (value d′)) ∧ (A′ ≠ (value d′))) (∃ b′ ((between (value d′) A′ (value b′)) ∧ (A′ (value b′) ≡ A B))) ThereExistsConjunctionRightCombining
        applyModusPonens

        b′ ((between C′ A′ (value d′)) ∧ (A′ ≠ (value d′))) ((between (value d′) A′ (value b′)) ∧ (A′ (value b′) ≡ A B)) ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        d′ addThereExists
        applyModusPonens
</jh>
That gives us <code>∃ d′ ∃ b′ ((between C′ A′ d′ ∧ A′ ≠ d′) ∧ (between d′ A′ b′ ∧ A′ b′ ≡ A B))</code>. We now perform similar steps with our third construction theorem <code>∃ c″ between d′ b′ c″ ∧ b′ c″ ≡ B C</code>.
<jh>
        c″ (value d′) (value b′) B C SegmentConstruction
        b′ generalize
        d′ generalize
        introduceConjunction

        d′
          (∃ b′ (((between C′ A′ (value d′)) ∧ (A′ ≠ (value d′))) ∧
            ((between (value d′) A′ (value b′)) ∧ (A′ (value b′) ≡ A B))))
          (∀ b′ (∃ c″ ((between (value d′) (value b′) (value c″)) ∧ ((value b′) (value c″) ≡ B C))))
          ThereExistsConjunctionRightCombining
        applyModusPonens

        b′
          (((between C′ A′ (value d′)) ∧ (A′ ≠ (value d′))) ∧
            ((between (value d′) A′ (value b′)) ∧ (A′ (value b′) ≡ A B)))
          (∃ c″ ((between (value d′) (value b′) (value c″)) ∧ ((value b′) (value c″) ≡ B C)))
          ThereExistsConjunctionRightCombining
        d′ addThereExists
        applyModusPonens

        c″
          (((between C′ A′ (value d′)) ∧ (A′ ≠ (value d′))) ∧
            ((between (value d′) A′ (value b′)) ∧ (A′ (value b′) ≡ A B)))
          ((between (value d′) (value b′) (value c″)) ∧ ((value b′) (value c″) ≡ B C))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        b′ addThereExists
        d′ addThereExists
        applyModusPonens
</jh>
Now we have the construction of the three points, with all three quantifiers gathered to the beginning. The only thing left is to add in <code>between A B C ∧ A C ≡ A′ C′</code>,
<jh>
        ((between A B C) ∧ (A C ≡ A′ C′)) introduceAntecedent

        ((between A B C) ∧ (A C ≡ A′ C′)) ImplicationReflexivity

        composeConjunction
</jh>
and move the quantifiers to the start of the consequent.
<jh>
        d′
          (∃ b′ (∃ c″
            ((((between C′ A′ (value d′)) ∧ (A′ ≠ (value d′))) ∧
            ((between (value d′) A′ (value b′)) ∧ (A′ (value b′) ≡ A B))) ∧
            ((between (value d′) (value b′) (value c″)) ∧ ((value b′) (value c″) ≡ B C)))))
          ((between A B C) ∧ (A C ≡ A′ C′))
          ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applySyllogism

        b′
          (∃ c″
            ((((between C′ A′ (value d′)) ∧ (A′ ≠ (value d′))) ∧
            ((between (value d′) A′ (value b′)) ∧ (A′ (value b′) ≡ A B))) ∧
            ((between (value d′) (value b′) (value c″)) ∧ ((value b′) (value c″) ≡ B C))))
          ((between A B C) ∧ (A C ≡ A′ C′))
          ThereExistsConjunctionRightMovement
        d′ buildThereExists
        eliminateBiconditionalForward
        applySyllogism

        c″
          ((((between C′ A′ (value d′)) ∧ (A′ ≠ (value d′))) ∧
            ((between (value d′) A′ (value b′)) ∧ (A′ (value b′) ≡ A B))) ∧
            ((between (value d′) (value b′) (value c″)) ∧ ((value b′) (value c″) ≡ B C)))
          ((between A B C) ∧ (A C ≡ A′ C′))
          ThereExistsConjunctionRightMovement
        b′ buildThereExists
        d′ buildThereExists
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

The next few lemmas start after the construction of the points (that is, their antecedent is the consequent of the previous lemma, minus the quantifiers). We use <code>D′</code> as an <code>object</code> which corresponds to the <code>variable</code> <code>d′</code> (and likewise for the other quantified variables). The next lemma proves <code>between A′ B′ C″</code>.
<jh>
thm (InnerDegenerateTriangle-abc () () (
  (((((between C′ A′ D′) ∧ (A′ ≠ D′)) ∧
   ((between D′ A′ B′) ∧ (A′ B′ ≡ A B))) ∧
   ((between D′ B′ C″) ∧ (B′ C″ ≡ B C))) ∧
   ((between A B C) ∧ (A C ≡ A′ C′))) →
  (between A′ B′ C″)) (
</jh>
First we pick out <code>between D′ A′ B′</code>.
<jh>
        (((((between C′ A′ D′) ∧ (A′ ≠ D′)) ∧
          ((between D′ A′ B′) ∧ (A′ B′ ≡ A B))) ∧
          ((between D′ B′ C″) ∧ (B′ C″ ≡ B C))) ∧
          ((between A B C) ∧ (A C ≡ A′ C′)))
          ImplicationReflexivity
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent
</jh>
Second we pick out <code>between D′ B′ C″</code>.
<jh>
        (((((between C′ A′ D′) ∧ (A′ ≠ D′)) ∧
          ((between D′ A′ B′) ∧ (A′ B′ ≡ A B))) ∧
          ((between D′ B′ C″) ∧ (B′ C″ ≡ B C))) ∧
          ((between A B C) ∧ (A C ≡ A′ C′)))
          ImplicationReflexivity
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        composeConjunction
</jh>
By transitivity, those two imply <code>between A′ B′ C″</code>.
<jh>
        D′ A′ B′ C″ BetweennessInnerTransitivityFlipped
        applySyllogism
))
</jh>

The next lemma applies outer three segment to <code>A B C</code> and <code>A′ B′ C″</code> to yield <code>A C ≡ A′ C″</code>.
<jh>
thm (InnerDegenerateTriangle-acac () () (
  (((((between C′ A′ D′) ∧ (A′ ≠ D′)) ∧
   ((between D′ A′ B′) ∧ (A′ B′ ≡ A B))) ∧
   ((between D′ B′ C″) ∧ (B′ C″ ≡ B C))) ∧
   ((between A B C) ∧ (A C ≡ A′ C′))) →
  (A C ≡ A′ C″)) (
</jh>
First we pick out <code>between A B C</code>.
<jh>
        (((((between C′ A′ D′) ∧ (A′ ≠ D′)) ∧
          ((between D′ A′ B′) ∧ (A′ B′ ≡ A B))) ∧
          ((between D′ B′ C″) ∧ (B′ C″ ≡ B C))) ∧
          ((between A B C) ∧ (A C ≡ A′ C′)))
          ImplicationReflexivity
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent
</jh>
Second is <code>between A′ B′ C″</code>.
<jh>
        C′ A′ D′ B′ A B C″ C InnerDegenerateTriangle-abc
        composeConjunction
</jh>
Third is <code>A B ≡ A′ B′</code>.
<jh>
        (((((between C′ A′ D′) ∧ (A′ ≠ D′)) ∧
          ((between D′ A′ B′) ∧ (A′ B′ ≡ A B))) ∧
          ((between D′ B′ C″) ∧ (B′ C″ ≡ B C))) ∧
          ((between A B C) ∧ (A C ≡ A′ C′)))
          ImplicationReflexivity
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        A′ B′ A B CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Fourth is <code>B C ≡ B′ C″</code>.
<jh>
        (((((between C′ A′ D′) ∧ (A′ ≠ D′)) ∧
          ((between D′ A′ B′) ∧ (A′ B′ ≡ A B))) ∧
          ((between D′ B′ C″) ∧ (B′ C″ ≡ B C))) ∧
          ((between A B C) ∧ (A C ≡ A′ C′)))
          ImplicationReflexivity
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        B′ C″ B C CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
We apply outer three segment and are done.
<jh>
        A B C A′ B′ C″ OuterThreeSegment
        applySyllogism
))
</jh>

The next lemma, <code>between D′ A′ C″</code>, is an obvious consequence of betweenness transitivity.
<jh>
thm (InnerDegenerateTriangle-dac () () (
  (((((between C′ A′ D′) ∧ (A′ ≠ D′)) ∧
   ((between D′ A′ B′) ∧ (A′ B′ ≡ A B))) ∧
   ((between D′ B′ C″) ∧ (B′ C″ ≡ B C))) ∧
   ((between A B C) ∧ (A C ≡ A′ C′))) →
  (between D′ A′ C″)) (
</jh>
First we need <code>between D′ A′ B′</code>.
<jh>
        (((((between C′ A′ D′) ∧ (A′ ≠ D′)) ∧
          ((between D′ A′ B′) ∧ (A′ B′ ≡ A B))) ∧
          ((between D′ B′ C″) ∧ (B′ C″ ≡ B C))) ∧
          ((between A B C) ∧ (A C ≡ A′ C′)))
          ImplicationReflexivity
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent
</jh>
Secondly we need <code>between D′ B′ C″</code>.
<jh>
        (((((between C′ A′ D′) ∧ (A′ ≠ D′)) ∧
          ((between D′ A′ B′) ∧ (A′ B′ ≡ A B))) ∧
          ((between D′ B′ C″) ∧ (B′ C″ ≡ B C))) ∧
          ((between A B C) ∧ (A C ≡ A′ C′)))
          ImplicationReflexivity
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        composeConjunction
</jh>
Those imply our result.
<jh>
        D′ A′ B′ C″ BetweennessMiddleTransitivityFlipped
        applySyllogism
))
</jh>

The next lemma applies uniqueness of segment construction to <code>D′ A′ C′</code> and <code>D′ A′ C″</code> and concludes <code>C′ = C″</code>.

<jh>
thm (InnerDegenerateTriangle-cc () () (
  (((((between C′ A′ D′) ∧ (A′ ≠ D′)) ∧
   ((between D′ A′ B′) ∧ (A′ B′ ≡ A B))) ∧
   ((between D′ B′ C″) ∧ (B′ C″ ≡ B C))) ∧
   ((between A B C) ∧ (A C ≡ A′ C′))) →
  (C′ = C″)) (
</jh>
The first antecedent for segment construction uniqueness is <code>D′ ≠ A′</code>.
<jh>
        (((((between C′ A′ D′) ∧ (A′ ≠ D′)) ∧
          ((between D′ A′ B′) ∧ (A′ B′ ≡ A B))) ∧
          ((between D′ B′ C″) ∧ (B′ C″ ≡ B C))) ∧
          ((between A B C) ∧ (A C ≡ A′ C′)))
          ImplicationReflexivity
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        A′ D′ EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
The second is <code>between D′ A′ C′</code>.
<jh>
        (((((between C′ A′ D′) ∧ (A′ ≠ D′)) ∧
          ((between D′ A′ B′) ∧ (A′ B′ ≡ A B))) ∧
          ((between D′ B′ C″) ∧ (B′ C″ ≡ B C))) ∧
          ((between A B C) ∧ (A C ≡ A′ C′)))
          ImplicationReflexivity
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        C′ A′ D′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
The third is <code>A′ C′ ≡ A C</code>.
<jh>
        (((((between C′ A′ D′) ∧ (A′ ≠ D′)) ∧
          ((between D′ A′ B′) ∧ (A′ B′ ≡ A B))) ∧
          ((between D′ B′ C″) ∧ (B′ C″ ≡ B C))) ∧
          ((between A B C) ∧ (A C ≡ A′ C′)))
          ImplicationReflexivity
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        A C A′ C′ CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
The fourth is <code>between D′ A′ C″</code>.
<jh>
        C′ A′ D′ B′ A B C″ C InnerDegenerateTriangle-dac
        composeConjunction
</jh>
And the last is <code>A′ C″ ≡ A C</code>.
<jh>
        C′ A′ D′ B′ A B C″ C InnerDegenerateTriangle-acac

        A C A′ C″ CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
That's all we need.
<jh>
        D′ A′ C′ A C C″ SegmentConstructionUniqueness
        applySyllogism
))
</jh>

Given this equality, we merely need to do some substitution to prove each of the three congruences which make up <code>A B C ≅ A′ B′ C′</code>.

We start with a lemma which performs the substitution.
<jh>
thm (InnerDegenerateTriangle-bcbc () () (((C′ = C″) ∧ (B′ C″ ≡ B C)) → (B′ C′ ≡ B C)) (
</jh>
We first apply a builder to get <code>C′ = C″ → (B′ C′ ≡ B C ↔ B′ C″ ≡ B C</code>.
<jh>
        B EqualityReflexivity
        C EqualityReflexivity
        B′ EqualityReflexivity
        B′ B′ C′ C″ B B C C CongruenceBuilder
        detach1of4
        detach2of2
        detach2of2
</jh>
A bit of rearrangement and we are done.
<jh>
        eliminateBiconditionalForwardInConsequent
        import
))
</jh>

Now we can proceed to <code>A B C ≅ A′ B′ C′</code>.
<jh>
thm (InnerDegenerateTriangle-abcabc () () (
  (((((between C′ A′ D′) ∧ (A′ ≠ D′)) ∧
   ((between D′ A′ B′) ∧ (A′ B′ ≡ A B))) ∧
   ((between D′ B′ C″) ∧ (B′ C″ ≡ B C))) ∧
   ((between A B C) ∧ (A C ≡ A′ C′))) →
  (A B C ≅ A′ B′ C′)) (
</jh>
<code>A B ≡ A′ B′</code>:
<jh>
        (((((between C′ A′ D′) ∧ (A′ ≠ D′)) ∧
          ((between D′ A′ B′) ∧ (A′ B′ ≡ A B))) ∧
          ((between D′ B′ C″) ∧ (B′ C″ ≡ B C))) ∧
          ((between A B C) ∧ (A C ≡ A′ C′)))
          ImplicationReflexivity
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        A′ B′ A B CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
<code>A C ≡ A′ C′</code>:
<jh>
        (((((between C′ A′ D′) ∧ (A′ ≠ D′)) ∧
          ((between D′ A′ B′) ∧ (A′ B′ ≡ A B))) ∧
          ((between D′ B′ C″) ∧ (B′ C″ ≡ B C))) ∧
          ((between A B C) ∧ (A C ≡ A′ C′)))
          ImplicationReflexivity
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        composeConjunction
</jh>
<code>B C ≡ B′ C′</code>:
<jh>
        C′ A′ D′ B′ A B C″ C InnerDegenerateTriangle-cc

        (((((between C′ A′ D′) ∧ (A′ ≠ D′)) ∧
          ((between D′ A′ B′) ∧ (A′ B′ ≡ A B))) ∧
          ((between D′ B′ C″) ∧ (B′ C″ ≡ B C))) ∧
          ((between A B C) ∧ (A C ≡ A′ C′)))
          ImplicationReflexivity
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        composeConjunction

        C′ C″ B′ B C InnerDegenerateTriangle-bcbc
        applySyllogism

        B′ C′ B C CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
))
</jh>

A similar substitution turns <code>between A′ B′ C″</code> into <code>between A′ B′ C′</code>
<jh>
thm (InnerDegenerateTriangle-abc1-sub () ()
  (((C′ = C″) ∧ (between A′ B′ C″)) → (between A′ B′ C′)) (
</jh>
We first apply a builder to get <code>C′ = C″ → (between A′ B′ C′ ↔ between A′ B′ C″</code>.
<jh>
        A′ EqualityReflexivity
        B′ EqualityReflexivity
        A′ A′ B′ B′ C′ C″ BetweenBuilder
        detach2of3
        detach1of2
</jh>
A bit of rearrangement and we are done.
<jh>
        eliminateBiconditionalForwardInConsequent
        import
))

thm (InnerDegenerateTriangle-abc1 () () (
  (((((between C′ A′ D′) ∧ (A′ ≠ D′)) ∧
   ((between D′ A′ B′) ∧ (A′ B′ ≡ A B))) ∧
   ((between D′ B′ C″) ∧ (B′ C″ ≡ B C))) ∧
   ((between A B C) ∧ (A C ≡ A′ C′))) →
  (between A′ B′ C′)) (
        C′ A′ D′ B′ A B C″ C InnerDegenerateTriangle-cc
        C′ A′ D′ B′ A B C″ C InnerDegenerateTriangle-abc
        composeConjunction

        C′ C″ A′ B′ InnerDegenerateTriangle-abc1-sub
        applySyllogism
))
</jh>

We're ready to assemble the result and remove the quantifiers which don't apply once the conclusion is reached.
<jh>
thm (InnerDegenerateTriangle ((b′ A) (b′ B) (b′ C) (b′ A′) (b′ C′)
    (d′ c″ b′ A) (d′ c″ B) (d′ c″ C) (d′ c″ A′) (d′ c″ C′)) ()
  (((between A B C) ∧ (A C ≡ A′ C′)) → (∃ b′ ((between A′ (value b′) C′) ∧ (A B C ≅ A′ (value b′) C′)))) (
        A B C A′ C′ d′ b′ c″ InnerDegenerateTriangle-1

        C′ A′ (value d′) (value b′) A B (value c″) C InnerDegenerateTriangle-abc1
        C′ A′ (value d′) (value b′) A B (value c″) C InnerDegenerateTriangle-abcabc
        composeConjunction

        c″ addThereExists
        b′ addThereExists
        d′ addThereExists

        applySyllogism

        removeThereExistsInConsequent

        c″ ((between A′ (value b′) C′) ∧ (A B C ≅ A′ (value b′) C′)) NullThereExists
        eliminateBiconditionalReverse
        b′ addThereExists
        applySyllogism
))
</jh>

=== Betweenness of congruent degenerate triangles ===
Given two (degenerate) congruent triangles, if the points of the first one are in a betweenness relationship, the corresponding points of the second are in a respective betweenness relationship. That is, <code>between A B C ∧ A B C ≅ A′ B′ C′ → between A′ B′ C′</code>.<ref>l4_6 in Narboux</ref> Here's the proof: apply <code>InnerDegenerateTriangle</code> to construct <code>B″</code> such that <code>between A′ B″ C′</code> and <code>A B C ≅ A′ B″ C′</code>. The congruences give us <code>A′ B″ ≡ A′ B′</code> and <code>C′ B″ ≡ C′ B′</code>. Given those two, and a few trivial congruences, we can apply inner five segment to the line segments <code>A′ B″ C′</code> and <code>A′ B″ C′</code> and points <code>B″</code> and <code>B′</code>, which gives us <code>B″ B″ ≡ B″ B′</code>. This of course implies <code>B″ = B′</code>, and substitution produces <code>between A′ B′ C′</code>.

Our first lemma constructs <code>B″</code> and rearranges the quantifiers somewhat.
<jh>
thm (BetweennessDegenerateTriangle-1
  ((b″ A) (b″ B) (b″ C) (b″ A′) (b″ B′) (b″ C′)) ()
  (((between A B C) ∧ (A B C ≅ A′ B′ C′)) →
    (∃ b″ (((between A′ (value b″) C′) ∧ (A B C ≅ A′ (value b″) C′)) ∧
      ((between A B C) ∧ (A B C ≅ A′ B′ C′))))) (
</jh>
To apply <code>InnerDegenerateTriangle</code> we need <code>between A B C</code>,
<jh>
        (between A B C) (A B C ≅ A′ B′ C′) ConjunctionRightElimination
</jh>
and <code>A C ≡ A′ C′</code>.
<jh>
        (between A B C) (A B C ≅ A′ B′ C′) ConjunctionLeftElimination

        A B C A′ B′ C′ Congruence13
        applySyllogism

        composeConjunction
</jh>
Applying <code>InnerDegenerateTriangle</code> gives us <code>∃ b″ (between A′ b″ C′ ∧ A B C ≅ A′ b″ C′)</code>.
<jh>
        A B C A′ C′ b″ InnerDegenerateTriangle
        applySyllogism
</jh>
Now we just add <code>between A B C ∧ A B C ≅ A′ B′ C′</code> to the consequent and move it inside the quantifier.
<jh>
        ((between A B C) ∧ (A B C ≅ A′ B′ C′)) ImplicationReflexivity
        composeConjunction

        b″
          ((between A′ (value b″) C′) ∧ (A B C ≅ A′ (value b″) C′))
          ((between A B C) ∧ (A B C ≅ A′ B′ C′))
          ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

The next lemma proves <code>A′ B″ ≡ A′ B′</code>.

<jh>
thm (BetweennessDegenerateTriangle-abab () () (
  (((between A′ B″ C′) ∧ (A B C ≅ A′ B″ C′)) ∧
    ((between A B C) ∧ (A B C ≅ A′ B′ C′))) → 
  (A′ B″ ≡ A′ B′)) (
</jh>
We start with <code>A′ B″ ≡ A B</code>.
<jh>
        (((between A′ B″ C′) ∧ (A B C ≅ A′ B″ C′)) ∧
          ((between A B C) ∧ (A B C ≅ A′ B′ C′)))
          ImplicationReflexivity
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        A B C A′ B″ C′ Congruence12
        applySyllogism

        A B A′ B″ CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
In a similar way we get <code>A B ≡ A′ B′</code>.
<jh>
        (((between A′ B″ C′) ∧ (A B C ≅ A′ B″ C′)) ∧
          ((between A B C) ∧ (A B C ≅ A′ B′ C′)))
          ImplicationReflexivity
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        A B C A′ B′ C′ Congruence12
        applySyllogism

        composeConjunction
</jh>
We now just need congruence transitivity.
<jh>
        A′ B″ A B A′ B′ CongruenceTransitivity
        applySyllogism
))

</jh>
The proof of the <code>C′ B″ ≡ C′ B′</code> lemma is very similar.
<jh>
thm (BetweennessDegenerateTriangle-cbcb () () (
  (((between A′ B″ C′) ∧ (A B C ≅ A′ B″ C′)) ∧
    ((between A B C) ∧ (A B C ≅ A′ B′ C′))) → 
  (C′ B″ ≡ C′ B′)) (
</jh>
We start with <code>B″ C′ ≡ B C</code>.
<jh>
        (((between A′ B″ C′) ∧ (A B C ≅ A′ B″ C′)) ∧
          ((between A B C) ∧ (A B C ≅ A′ B′ C′)))
          ImplicationReflexivity
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        A B C A′ B″ C′ Congruence23
        applySyllogism

        B C B″ C′ CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
In a similar way we get <code>B C ≡ B′ C′</code>.
<jh>
        (((between A′ B″ C′) ∧ (A B C ≅ A′ B″ C′)) ∧
          ((between A B C) ∧ (A B C ≅ A′ B′ C′)))
          ImplicationReflexivity
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        A B C A′ B′ C′ Congruence23
        applySyllogism

        composeConjunction
</jh>
We now combine and rearrange a bit.
<jh>
        B″ C′ B C B′ C′ CongruenceTransitivity
        applySyllogism

        B″ C′ B′ C′ CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

We're now ready to prove <code>B″ = B′</code>.

<jh>
thm (BetweennessDegenerateTriangle-bb () () (
  (((between A′ B″ C′) ∧ (A B C ≅ A′ B″ C′)) ∧
    ((between A B C) ∧ (A B C ≅ A′ B′ C′))) → 
  (B″ = B′)) (
</jh>
The proof is by inner five segment on the line segments <code>A′ B″ C′</code> and <code>A′ B″ C′</code> and points <code>B″</code> and <code>B′</code>. To apply inner five segment, we need two betweenness relationships and four congruences. The betweenness relationships are both the same: <code>between A′ B″ C′</code>.
<jh>
        ((between A′ B″ C′) ∧ (A B C ≅ A′ B″ C′))
          ((between A B C) ∧ (A B C ≅ A′ B′ C′))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent

        (between A′ B″ C′) ConjunctionIdempotence
        eliminateBiconditionalReverse
        applySyllogism
</jh>
The first congruence is <code>A′ C′ ≡ A′ C′</code>.
<jh>
        A′ C′ CongruenceReflexivity
        (((between A′ B″ C′) ∧ (A B C ≅ A′ B″ C′)) ∧
          ((between A B C) ∧ (A B C ≅ A′ B′ C′)))
          introduceAntecedent
        composeConjunction
</jh>
The second congruence is <code>B″ C′ ≡ B″ C′</code>.
<jh>
        B″ C′ CongruenceReflexivity
        (((between A′ B″ C′) ∧ (A B C ≅ A′ B″ C′)) ∧
          ((between A B C) ∧ (A B C ≅ A′ B′ C′)))
          introduceAntecedent
        composeConjunction
</jh>
The third congruence is <code>A′ B″ ≡ A′ B′</code>.
<jh>
        A′ B″ C′ A B C B′ BetweennessDegenerateTriangle-abab
        composeConjunction
</jh>
The fourth congruence is <code>C′ B″ ≡ C′ B′</code>.
<jh>
        A′ B″ C′ A B C B′ BetweennessDegenerateTriangle-cbcb
        composeConjunction
</jh>
Applying inner five segment gives us <code>B″ B″ ≡ B″ B′</code>.
<jh>
        A′ B″ C′ A′ B″ C′ B″ B′ InnerFiveSegment
        applySyllogism
</jh>
That in turn implies <code>B″ = B′</code>.
<jh>
        B″ B″ B′ CongruenceIdentityLeft
        applySyllogism
))
</jh>
We're just a substitution away from <code>between A′ B′ C′</code>.
<jh>
thm (BetweennessDegenerateTriangle-abc () () (
  (((between A′ B″ C′) ∧ (A B C ≅ A′ B″ C′)) ∧
    ((between A B C) ∧ (A B C ≅ A′ B′ C′))) → 
  (between A′ B′ C′)) (
</jh>
Here's <code>B″ = B′</code>:
<jh>
        A′ B″ C′ A B C B′ BetweennessDegenerateTriangle-bb
</jh>
Here's <code>between A′ B″ C′</code>:
<jh>
        ((between A′ B″ C′) ∧ (A B C ≅ A′ B″ C′))
          ((between A B C) ∧ (A B C ≅ A′ B′ C′))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent

        composeConjunction
</jh>
The substitution is <code>B″ = B′ ∧ between A′ B″ C′ → between A′ B′ C′</code>, and that suffices.
<jh>
        A′ EqualityReflexivity
        C′ EqualityReflexivity
        A′ A′ B″ B′ C′ C′ BetweenBuilder
        detach2of2
        detach1of2

        eliminateBiconditionalReverseInConsequent
        import

        applySyllogism
))
</jh>
The final theorem is just a matter of assembling and removing the quantifier.
<jh>
thm (BetweennessDegenerateTriangle
  ((b″ A) (b″ B) (b″ C) (b″ A′) (b″ B′) (b″ C′)) ()
  (((between A B C) ∧ (A B C ≅ A′ B′ C′)) → (between A′ B′ C′)) (
        A B C A′ B′ C′ b″ BetweennessDegenerateTriangle-1

        A′ (value b″) C′ A B C B′ BetweennessDegenerateTriangle-abc
        b″ addThereExists

        applySyllogism

        removeThereExistsInConsequent
))
</jh>

== Collinearity ==
To say that three points are collinear is just to say that one of them is between the other two (in any order).<ref>Definition Col in Narboux</ref>
<jh>
def ((collinear x y z) (((between x y z) ∨ (between y z x)) ∨ (between z x y)))
</jh>

=== Permutations ===
One way to express the "in any order" concept is to provide permutation theorems. The first is rotation: <code>collinear x y z ↔ collinear y z x</code>.<ref>col_permutation_1 and col_permutation_2 in Narboux</ref>
<jh>
thm (CollinearityRotation () () ((collinear x y z) ↔ (collinear y z x)) (
        (between x y z) (between y z x) (between z x y) DisjunctionAssociativity

        (between x y z) ((between y z x) ∨ (between z x y)) DisjunctionCommutativity

        applyBiconditionalTransitivity
))
</jh>

The next permutation swaps the second and third points.<ref>col_permutation_5 in Narboux, biconditionalized</ref>
<jh>
thm (Collinearity23 () () ((collinear x y z) ↔ (collinear x z y)) (
</jh>
The proof starts with <code>between x y z ↔ between z y x</code> and <code>between y z x ↔ between x z y</code>.
<jh>
        x y z BetweennessSymmetry
        y z x BetweennessSymmetry
</jh>
We combine those and switch the order to get <code>between x y z ∨ between y z x ↔ between x z y ∨ between z y x</code>.
<jh>
        buildDisjunction

        (between z y x) (between x z y) DisjunctionCommutativity
        applyBiconditionalTransitivity
</jh>
Combining that with <code>between z x y ↔ between y x z</code> finishes the task.
<jh>
        z x y BetweennessSymmetry
        buildDisjunction
))
</jh>

To swap the first and second points, we rotate and then swap the second and third points.<ref>col_permutation_4 in Narboux, biconditionalized</ref>
<jh>
thm (Collinearity12 () () ((collinear x y z) ↔ (collinear y x z)) (
        x y z CollinearityRotation
        y z x Collinearity23
        applyBiconditionalTransitivity
))
</jh>

To swap the first and third points, we rotate and then swap the first and second points.<ref>col_permutation_3 in Narboux, biconditionalized</ref>
<jh>
thm (Collinearity13 () () ((collinear x y z) ↔ (collinear z y x)) (
        x y z CollinearityRotation
        y z x Collinearity12
        applyBiconditionalTransitivity
))
</jh>

=== Collinearity of a point, itself, and another point ===
A point is collinear with itself and any second point. That is, <code>collinear A A B</code>, and likewise for any other order of the three points.<ref>col_trivial_1, col_trivial_2, and col_trivial_3 in Narboux</ref>
<jh>
thm (CollinearityAAB () () (collinear A A B) (
        B A BetweenABB
        ((between A A B) ∨ (between A B A)) introduceLeftDisjunction
))

thm (CollinearityABB () () (collinear A B B) (
        B A CollinearityAAB

        B B A Collinearity13
        eliminateBiconditionalReverse
        applyModusPonens
))

thm (CollinearityABA () () (collinear A B A) (
        A B CollinearityAAB

        A A B Collinearity23
        eliminateBiconditionalReverse
        applyModusPonens
))
</jh>

== Export ==
We now export to [[Interface:Basic geometry]].
<jh>
export (GEOMETRY Interface:Basic_geometry (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]