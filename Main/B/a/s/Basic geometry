{{interfaces
| imports = [[Interface:Tarski's geometry axioms]]
| exports = [[Interface:Basic geometry]]
}}

Here we prove a variety of basic geometrical theorems involving collinearity, midpoints, perpendiculars, and the like, starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Tarski's geometry axioms|geometry axioms]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (AXIOMS Interface:Tarski's_geometry_axioms (CLASSICAL FIRSTORDER) ())

var (point x y z w u v A B C D E Q)
var (variable a b c)
</jh>

== Collinearity ==
To say that three points are collinear is just to say that one of them is between the other two (in any order).<ref>Definition Col in Narboux</ref>
<jh>
def ((collinear x y z) (((between x y z) ∨ (between y z x)) ∨ (between z x y)))
</jh>

== Congruence ==
A line segment is congruent to itself.<ref>Lemma cong_reflexivity in Narboux</ref>
<jh>
thm (CongruenceReflexivity () () (x y ≡ x y) (
        y x CongruenceReflexivityAxiom
        y x CongruenceReflexivityAxiom
        introduceConjunction

        y x x y x y CongruenceTransitivityAxiom

        applyModusPonens
))
</jh>

Congruence is symmetrical.<ref>Lemma cong_symmetry in Narboux</ref> The biconditionalized version is not in Narboux, but fits our usual conventions and the nature of JHilbert.
<jh>
thm (CongruenceSymmetryImplication () () ((x y ≡ z w) → (z w ≡ x y)) (
        x y CongruenceReflexivity
        x y z w x y CongruenceTransitivityAxiom
        detach2of2
))

thm (CongruenceSymmetry () () ((x y ≡ z w) ↔ (z w ≡ x y)) (
        x y z w CongruenceSymmetryImplication
        z w x y CongruenceSymmetryImplication
        introduceBiconditionalFromImplications
))
</jh>

Congruence is transitive.<ref>Lemma cong_transitivity in Narboux</ref>
<jh>
thm (CongruenceTransitivity () () (((x y ≡ z w) ∧ (z w ≡ u v)) → (x y ≡ u v)) (
        x y z w CongruenceSymmetry
        eliminateBiconditionalReverse
        (z w ≡ u v) conjoinRR

        z w x y u v CongruenceTransitivityAxiom

        applySyllogism
))
</jh>

We can commute the endpoints of the first line segment.<ref>Lemma cong_left_commutativity in Narboux</ref>
<jh>
thm (CongruenceLeftCommutativityImplication () () ((x y ≡ z w) → (y x ≡ z w)) (
        x y CongruenceReflexivityAxiom
        x y y x z w CongruenceTransitivityAxiom
        detach1of2
))

thm (CongruenceLeftCommutativity () () ((x y ≡ z w) ↔ (y x ≡ z w)) (
        x y z w CongruenceLeftCommutativityImplication
        y x z w CongruenceLeftCommutativityImplication
        introduceBiconditionalFromImplications
))
</jh>

Likewise for the second line segment.<ref>Lemma cong_right_commutativity in Narboux, biconditionalized</ref>
<jh>
thm (CongruenceRightCommutativity () () ((x y ≡ z w) ↔ (x y ≡ w z)) (
        x y z w CongruenceSymmetry

        z w x y CongruenceLeftCommutativity
        applyBiconditionalTransitivity

        w z x y CongruenceSymmetry
        applyBiconditionalTransitivity
))
</jh>

A line segment with the same point as both of its endpoints is congruent to another such segment. To prove this, start with the line segment x x. Extend x y beyond y to another point a such that y a ≡ x x. Then we show that a must equal y.<ref>Lemma cong_trivial_identity in Narboux</ref>
<jh>
thm (CongruenceTrivialIdentity ((a x) (a y)) () (y y ≡ x x) (
        a x y x x SegmentConstruction
</jh>
Now we have <code>∃ a (between x y a ∧ y a ≡ x x)</code>. We drop the between part.
<jh>
        (between x y (value a)) (y (value a) ≡ x x) ConjunctionLeftElimination
        a addThereExists
        applyModusPonens
</jh>
Here we combine <code>y a ≡ x x → y = a</code> with our previous result and rearrange a bit to get <code>∃ a (y = a ∧ y a ≡ x x)</code>.
<jh>
        y (value a) x CongruenceIdentity
        (y (value a) ≡ x x) ImplicationReflexivity
        composeConjunction
        a addThereExists
        applyModusPonens
</jh>
Now we just need a substitution.  The substitution is <code>y = a → (y y ≡ x x ↔ y a ≡ x x)</code>.
<jh>
        x EqualityReflexivity
        x EqualityReflexivity
        y EqualityReflexivity
        y y y (value a) x x x x CongruenceBuilder
        detach1of4
        detach2of2
        detach2of2
</jh>
Taking the reverse implication and combining with the previous result gives us <code>∃ a y y ≡ x x</code>.
<jh>
        eliminateBiconditionalForwardInConsequent
        import
        a addThereExists
        applyModusPonens
</jh>
The quantifier is no longer needed, and removing it finishes the proof.
<jh>
        removeThereExists
))
</jh>

Here is a version of <code>CongruenceIdentity</code> with left and right sides swapped.<ref>Lemma cong_reverse_identity in Narboux</ref>
<jh>
thm (CongruenceIdentityLeft () () ((x x ≡ y z) → (y = z)) (
        x x y z CongruenceSymmetry
        eliminateBiconditionalReverse

        y z x CongruenceIdentity
        applySyllogism
))
</jh>

Congruence is unaffected by exchanging the endpoints of both line segments.<ref>Lemma cong_commutativity in Narboux</ref>
<jh>
thm (CongruenceCommutativity () () ((x y ≡ z w) ↔ (y x ≡ w z)) (
        x y z w CongruenceLeftCommutativity
        y x z w CongruenceRightCommutativity
        applyBiconditionalTransitivity
))
</jh>

The next lemma is a convenience form of <code>CongruenceIdentity</code>.<ref>not in Narboux</ref>
<jh>
thm (CongruenceIdentityFromEquality () () ((x = y) → ((x y ≡ z w) → (z = w))) (
</jh>
This is just a substitution away from <code>CongruenceIdentityLeft</code>.  The substitution is <code>x = y → (x x ≡ z w ↔ x y ≡ z w)</code>.
<jh>
        z EqualityReflexivity
        w EqualityReflexivity
        x EqualityReflexivity
        x x x y z z w w CongruenceBuilder
        detach1of4
        detach2of2
        detach2of2

        eliminateBiconditionalForwardInConsequent

        x z w CongruenceIdentityLeft
        (x = y) introduceAntecedent
        applySyllogismInConsequent
))
</jh>

== Five segment ==
The next theorem, <code>between x y z ∧ between x′ y′ z′ ∧ x y ≡ x′ y′ ∧ y z ≡ y′ z′ → x z ≡ x′ z′</code>, is basically a degenerate case of the five segment axiom.<ref>Lemma l2_11 in Narboux</ref><ref>Axiom 23 in Givant and Tarski, 1999</ref> There are two cases. If <code>x ≠ y</code>, then applying five segments to x y z and x yields the desired result (the additional two antecedents are fulfilled because one becomes <code>x x ≡ x′ x′</code> and the other <code>y x ≡ y′ x′</code>). If <code>x = y</code>, then <code>x z ≡ x′ z′</code> follows from <code>y z ≡ y′ z′</code> (and <code>x′ = y′</code>, which follows from <code>x y ≡ x′ y′</code>).

We first prove the <code>x = y</code> case as a lemma.
<jh>
var (point x′ y′ z′ u′)
thm (ThreeSegmentXEqualsY () () ((x = y) → (((((between x y z) ∧ (between x′ y′ z′)) ∧ (x y ≡ x′ y′)) ∧ (y z ≡ y′ z′)) → (x z ≡ x′ z′))) (
</jh>
We start with <code>x = y → (x y ≡ x′ y′ → x′ = y′)</code>
<jh>
        x y x′ y′ CongruenceIdentityFromEquality
</jh>
Using <code>x′ = y′</code> for something takes this form: <code>x = y → (x′ = y′ → (y z ≡ y′ z′ → x z ≡ x′ z′))</code>.
<jh>
        z EqualityReflexivity
        z′ EqualityReflexivity
        x y z z x′ y′ z′ z′ CongruenceBuilder
        detach2of2
        detach2of3
        eliminateBiconditionalForwardInConsequent
        export
</jh>
We combine those to get <code>x = y → (x y ≡ x′ y′ → (y z ≡ y′ z′ → x z ≡ x′ z′))</code>.
<jh>
        applySyllogismInConsequent
</jh>
Adding two more antecedents and importing several times gives us the complete <code>x = y</code> case.
<jh>
        (between x′ y′ z′) introduceAntecedentInConsequent
        (between x y z) introduceAntecedentInConsequent
        importInConsequent
        importInConsequent
        importInConsequent
))
</jh>
Now, the <code>x ≠ y</code> case.
<jh>
thm (ThreeSegmentXNotEqualY () () ((x ≠ y) → (((((between x y z) ∧ (between x′ y′ z′)) ∧ (x y ≡ x′ y′)) ∧ (y z ≡ y′ z′)) → (x z ≡ x′ z′))) (
</jh>
Applying the five segment axiom gives us <code>x ≠ y ∧ between x y z ∧ between x′ y′ z′ ∧ x y ≡ x′ y′ ∧ y z ≡ y′ z′ ∧ x x ≡ x′ x′ ∧ y x ≡ y′ x′ → z x ≡ z′ x′</code>. First we detach <code>x x ≡ x′ x′</code>
<jh>
        x x′ CongruenceTrivialIdentity
        x y z x′ y′ z′ x x′ FiveSegment
        detach2of3
</jh>
Next we commute <code>z x ≡ z′ x′</code> to <code>x z ≡ x′ z′</code>.
<jh>
        z x z′ x′ CongruenceCommutativity eliminateBiconditionalReverse
        applySyllogism
</jh>
We are still facing <code>x ≠ y ∧ between x y z ∧ between x′ y′ z′ ∧ x y ≡ x′ y′ ∧ y z ≡ y′ z′ ∧ y x ≡ y′ x′ → x z ≡ x′ z′</code>. We need to remove the <code>y x ≡ y′ x′</code> (because it is redundant with <code>x y ≡ x′ y′</code>).

We get most of the way with <code>x y ≡ x′ y′ ∧ y z ≡ y′ z′ → (x y ≡ x′ y′ ∧ y z ≡ y′ z′) ∧ y x ≡ y′ x′</code>:
<jh>
        ((x y ≡ x′ y′) ∧ (y z ≡ y′ z′)) ImplicationReflexivity

        (x y ≡ x′ y′) (y z ≡ y′ z′) ConjunctionRightElimination
        x y x′ y′ CongruenceCommutativity eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Now we just add the rest of the antecedents and combine to finish the <code>x ≠ y</code> case.
<jh>
        (x z ≡ x′ z′) addCommonConsequent
        exportInAntecedent
        exportInAntecedent
        exportInConsequent
        (between x′ y′ z′) addCommonAntecedent
        (between x y z) addCommonAntecedent
        (x ≠ y) addCommonAntecedent

        importInAntecedent
        importInAntecedent
        importInAntecedent
        importInAntecedent
        importInAntecedent

        applyModusPonens

        importInConsequent
        importInConsequent
        importInConsequent
))

thm (ThreeSegment () ()
  (((((between x y z) ∧ (between x′ y′ z′)) ∧ (x y ≡ x′ y′)) ∧ (y z ≡ y′ z′)) → (x z ≡ x′ z′)) (
        x y z x′ y′ z′ ThreeSegmentXEqualsY
        x y z x′ y′ z′ ThreeSegmentXNotEqualY
        eliminateCases
))
</jh>

== Uniqueness of segment construction ==
Here we prove that the segment constructed by the segment construction axiom is unique. We state this as <code>Q ≠ A ∧ between Q A x ∧ A x ≡ B C ∧ between Q A y ∧ A y ≡ B C → x = y</code>. The proof is first that <code>A x ≡ A y</code> (because both are congruent to <code>B C</code>), and between that and <code>Q A ≡ Q A</code> we can apply <code>ThreeSegment</code> to <code>Q A x</code> and <code>Q A y</code> to get <code>Q x ≡ Q y</code>. Then we will apply <code>FiveSegment</code> with the lines <code>Q A x</code> and <code>Q A x</code> and the points <code>x</code> and <code>y</code>. The four congruences we need are <code>Q A ≡ Q A</code>, <code>A x ≡ A x</code>, <code>Q x ≡ Q y</code>, and <code>A x ≡ A y</code>, and then <code>FiveSegment</code> gives us <code>x x ≡ x y</code>. This congruence yields <code>x = y</code> by <code>CongruenceIdentityLeft</code>.<ref>construction_unicity in Narboux</ref>

The only real difficulty in formalizing this is juggling all those conjunctions and multiple antecedents. The first lemma shows <code>A x ≡ A y</code>.
<jh>
thm (SegmentConstructionUniquenessAxAy () () ((((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) ∧ (A y ≡ B C)) → (A x ≡ A y)) (
</jh>
First we extract the two pieces we care about, first showing that big long antecedent implies <code>A x ≡ B C</code>,
<jh>
        ((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) (A y ≡ B C) ConjunctionRightElimination
        (((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) (between Q A y) ConjunctionRightElimination
        applySyllogism
        ((Q ≠ A) ∧ (between Q A x)) (A x ≡ B C) ConjunctionLeftElimination
        applySyllogism

</jh>
And then that it implies <code>A y ≡ B C</code>.
<jh>
        ((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) (A y ≡ B C) ConjunctionLeftElimination
</jh>
We apply symmetry to turn that into <code>B C ≡ A y</code>.
<jh>
        A y B C CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
We combine the two to get <code>A x ≡ B C ∧ B C ≡ A y</code>, and apply transitivity to finish.
<jh>
        composeConjunction

        A x B C A y CongruenceTransitivity
        applySyllogism
))
</jh>
The next lemma shows <code>Q x ≡ Q y</code>.
<jh>
thm (SegmentConstructionUniquenessQxQy () () ((((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) ∧ (A y ≡ B C)) → (Q x ≡ Q y)) (
</jh>
To apply <code>ThreeSegment</code> we need four things. The first is <code>between Q A x</code>.
<jh>
        ((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) (A y ≡ B C) ConjunctionRightElimination
        (((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) (between Q A y) ConjunctionRightElimination
        applySyllogism
        ((Q ≠ A) ∧ (between Q A x)) (A x ≡ B C) ConjunctionRightElimination
        applySyllogism
        (Q ≠ A) (between Q A x) ConjunctionLeftElimination
        applySyllogism
</jh>
The second is <code>between Q A y</code>.
<jh>
        ((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) (A y ≡ B C) ConjunctionRightElimination
        (((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) (between Q A y) ConjunctionLeftElimination
        applySyllogism

        composeConjunction
</jh>
The third is <code>Q A ≡ Q A</code>.
<jh>
        Q A CongruenceReflexivity
        (((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) ∧ (A y ≡ B C)) introduceAntecedent

        composeConjunction
</jh>
The fourth is <code>A x ≡ A y</code>.
<jh>
        Q A x B C y SegmentConstructionUniquenessAxAy

        composeConjunction
</jh>
Applying <code>ThreeSegment</code> we are done.
<jh>
        Q A x Q A y ThreeSegment
        applySyllogism
))
</jh>

The next lemma gets us most of the way. It shows <code>x x ≡ x y</code>.
<jh>
thm (SegmentConstructionUniquenessxxxy () () ((((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) ∧ (A y ≡ B C)) → (x x ≡ x y)) (
</jh>
We'll be applying <code>FiveSegment</code> which has seven antecedents. The first two we can do together, <code>Q ≠ A ∧ between Q A x</code>.
<jh>
        ((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) (A y ≡ B C) ConjunctionRightElimination
        (((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) (between Q A y) ConjunctionRightElimination
        applySyllogism
        ((Q ≠ A) ∧ (between Q A x)) (A x ≡ B C) ConjunctionRightElimination
        applySyllogism
</jh>
The next is <code>between Q A x</code>.
<jh>
        ((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) (A y ≡ B C) ConjunctionRightElimination
        (((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) (between Q A y) ConjunctionRightElimination
        applySyllogism
        ((Q ≠ A) ∧ (between Q A x)) (A x ≡ B C) ConjunctionRightElimination
        applySyllogism
        (Q ≠ A) (between Q A x) ConjunctionLeftElimination
        applySyllogism

        composeConjunction
</jh>
We now need four congruences. The first is <code>Q A ≡ Q A</code>.
<jh>
        Q A CongruenceReflexivity
        (((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) ∧ (A y ≡ B C)) introduceAntecedent

        composeConjunction
</jh>
The second congruence is <code>A x ≡ A x</code>.
<jh>
        A x CongruenceReflexivity
        (((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) ∧ (A y ≡ B C)) introduceAntecedent

        composeConjunction
</jh>
The third congruence is <code>Q x ≡ Q y</code>.
<jh>
        Q A x B C y SegmentConstructionUniquenessQxQy
        composeConjunction
</jh>
The fourth congruence is <code>A x ≡ A y</code>.
<jh>
        Q A x B C y SegmentConstructionUniquenessAxAy
        composeConjunction
</jh>
We are ready to apply <code>FiveSegment</code>.
<jh>
        Q A x Q A x x y FiveSegment
        applySyllogism
))
</jh>

The final theorem is only a small step further.
<jh>
thm (SegmentConstructionUniqueness () () ((((((Q ≠ A) ∧ (between Q A x)) ∧ (A x ≡ B C)) ∧ (between Q A y)) ∧ (A y ≡ B C)) → (x = y)) (
        Q A x B C y SegmentConstructionUniquenessxxxy
        x x y CongruenceIdentityLeft
        applySyllogism
))
</jh>

== Betweenness ==
We start with a degenerate case of betweenness. It illustrates that we follow Tarski's definition of betweenness, in which the points need not be distinct, rather than Hilbert's, in which they do need to be.<ref>Discussion at Bet in Narboux</ref>

The proof extends the line segment <code>A B</code> beyond <code>B</code> to a point <code>a</code> such that <code>B a ≡ B B</code>. But <code>B a ≡ B B</code> implies <code>B = a</code>, so we have in fact shown <code>between A B B</code>.<ref>beetween_trivial in Narboux</ref>
<jh>
thm (BetweenABB ((a A) (a B)) () (between A B B) (
        a A B B B SegmentConstruction
</jh>
That gives us <code>∃ a (between A B a ∧ B a ≡ B B)</code>. We apply the theorem <code>B a ≡ B B → B = a</code> to get <code>∃ a (between A B a ∧ B = a)</code>.
<jh>
        B (value a) B CongruenceIdentity
        (between A B (value a)) conjoinLL
        a addThereExists

        applyModusPonens
</jh>
We now need to handle the substitution of <code>B</code> for <code>a</code>. We start with <code>B = a → (between A B B ↔ between A B a)</code>.
<jh>
        A EqualityReflexivity
        B EqualityReflexivity
        A A B B B (value a) BetweenBuilder
        detach2of3
        detach1of2
</jh>
Eliminating the forward direction of the biconditional and rearranging gets <code>between A B a ∧ B = a → between A B B</code>.
<jh>
        eliminateBiconditionalForwardInConsequent
        applyComm
        import
</jh>
Combining with our previous result we have <code>∃ a between A B B</code>.
<jh>
        a addThereExists
        applyModusPonens
</jh>
And now we just remove the quantifier, which is no longer needed.
<jh>
        removeThereExists
))
</jh>

=== Betweenness symmetry ===
Exchanging the endpoints of a betweenness formula has no effect. In other words, B is between A and C implies B is between C and A.<ref>between_symmetry in Narboux</ref><ref>Symmetry Axiom for Betweenness in Givant and Tarski (1999)</ref>

We move much of the proof into a lemma because it will be useful in other similar proofs.
<jh>
thm (BetweenSubstitution ((a A) (a B) (a C)) () ((∃ a ((between B (value a) B) ∧ (between C (value a) A))) → (between C B A)) (
</jh>
We start by noting that <code>between B a B</code> implies <code>B = a</code>, which lets us derive <code>∃ a (between B a B ∧ between C a A) → ∃ a (B = a ∧ between C a A)</code>.
<jh>
        B (value a) Indivisibility
        (between C (value a) A) conjoinRR
        a addThereExists
</jh>
Now we apply a substitution to reduce <code>B = a ∧ between C a A</code> to <code>between C B A</code>. We start with the substitution <code>B = a → (between C B A ↔ between C a A)</code>
<jh>
        C EqualityReflexivity
        A EqualityReflexivity
        C C B (value a) A A BetweenBuilder
        detach2of2
        detach1of2
</jh>
We eliminating the forward implication, import, and combine with the previous result to get <code>∃ a (between B a B ∧ between C a A) → ∃ a between C B A</code>
<jh>
        eliminateBiconditionalForwardInConsequent
        import
        a addThereExists
        applySyllogism
</jh>
Removing the unnecessary quantifier is all that remains.
<jh>
        removeThereExistsInConsequent
))

thm (BetweennessSymmetryImplication ((a A) (a B) (a C)) () ((between A B C) → (between C B A)) (
</jh>
We'll be applying the <code>Pasch</code> axiom with <code>between A B C</code> and <code>between B C C</code> as the antecedents. The second of those is a theorem.
<jh>
        B C BetweenABB
        A B C B C a Pasch
        detach2of2
</jh>
That gives us <code>between A B C → ∃ a (between B a B ∧ between C a A)</code>. Applying our lemma is all we need.
<jh>
        a B C A BetweenSubstitution
        applySyllogism
))

thm (BetweennessSymmetry () () ((between A B C) ↔ (between C B A)) (
        A B C BetweennessSymmetryImplication
        C B A BetweennessSymmetryImplication
        introduceBiconditionalFromImplications
))
</jh>

Symmetry lets us easily prove the other degenerate case.<ref>beetween_trivial2 in Narboux</ref>
<jh>
thm (BetweenAAB () () (between A A B) (
        B A BetweenABB
        B A A BetweennessSymmetry
        eliminateBiconditionalReverse
        applyModusPonens
))
</jh>

=== Equality ===
If <code>B</code> is between <code>A</code> and <code>C</code>, and <code>A</code> is between <code>B</code> and <code>C</code>, then <code>A</code> and <code>B</code> must be equal.<ref>between_egality in Narboux</ref>

This property is analogous to antisymmetry for an [[w:Partial_order|order relation]].
<jh>
thm (BetweennessEquality ((a A) (a B)) () (((between A B C) ∧ (between B A C)) → (A = B)) (
        A B C B A a Pasch
</jh>
That gives us <code>∃ a (between B a B ∧ between A a A)</code>. We just need to apply the <code>BetweenSubstitution</code> lemma to get <code>between A B A</code>,
<jh>
        a B A A BetweenSubstitution
        applySyllogism
</jh>
which in turn implies <code>A = B</code>
<jh>
        A B Indivisibility
        applySyllogism
))
</jh>

=== Transitivity ===
In this section we prove six similar theorems which involve four points on a line. Given two betweenness relationships, we conclude a third. Three of the six are just versions of the other three which are flipped left-to-right.

==== Inner transitivity, regular and flipped ====
The first one is known as inner transitivity.<ref>Inner Transitivity Axiom for Betweenness in Givant and Tarski, 1999</ref><ref>between_inner_transitivity in Narboux</ref>
<jh>
thm (BetweennessInnerTransitivity ((a A) (a B) (a C)) ()
  (((between A B D) ∧ (between B C D)) → (between A B C)) (
        A B D B C a Pasch
</jh>
That gives us <code>∃ a (between B a B ∧ between C a A)</code>. The <code>BetweenSubstitution</code> lemma turns this into <code>between C B A</code>, and we just need to switch the order of the endpoints to be done.
<jh>
        a B C A BetweenSubstitution
        applySyllogism

        C B A BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

Reflecting this left-to-right gives our next theorem.<ref>between_exchange3 in Narboux</ref>
<jh>
thm (BetweennessInnerTransitivityFlipped () () (((between A B C) ∧ (between A C D)) → (between B C D)) (
</jh>
We first rewrite <code>between A B C</code> into <code>between C B A</code> and <code>between A C D</code> into <code>between D C A</code>
<jh>
        A B C BetweennessSymmetry
        A C D BetweennessSymmetry
        buildConjunction
        eliminateBiconditionalReverse
</jh>
Now we switch the order of the conjuncts.
<jh>
        (between C B A) (between D C A) ConjunctionCommutativity
        eliminateBiconditionalReverse
        applySyllogism

</jh>
Now we are ready to apply inner transitivity (which, when expanded with these variables, works out to <code>between D C A ∧ between C B A → between D C B</code>)
<jh>
        D C A B BetweennessInnerTransitivity
        applySyllogism
</jh>
Turning <code>between D C B</code> into <code>between B C D</code> finishes the proof.
<jh>
        D C B BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

==== Outer transitivity, flipped ====
For outer transitivity, we prove the "flipped" version first (where we consider the "non-flipped" one to be the one in Givant and Tarski (1999)).

To be specific, the flipped outer transitivity is <code>between A B C ∧ between B C D ∧ B ≠ C → between A C D</code>. First we extend <code>A C</code> beyond <code>C</code> to a point <code>a</code> such that <code>C a ≡ C D</code>. Then <code>between A B C</code> and <code>between A C a</code> give us <code>between B C a</code> by <code>BetweennessInnerTransitivityFlipped</code>. That's part of what we need to apply uniqueness of segment construction, which gives us <code>a = D</code>. Then we can substitute <code>between A C a</code> to get <code>between A C D</code>, which is what we want.<ref>outer_transitivity_between2 in Narboux</ref>

The first two lemmas get as far as <code>between B C a</code> in the proof sketch above.
<jh>
thm (BetweennessOuterTransitivityFlipped-1 () () ((((between A C x) ∧ (C x ≡ C D)) ∧ (between A B C)) → (((between A C x) ∧ (C x ≡ C D)) ∧ (between B C x))) (
        ((between A C x) ∧ (C x ≡ C D)) (between A B C) ConjunctionRightElimination

        ((between A C x) ∧ (C x ≡ C D)) (between A B C) ConjunctionLeftElimination

        ((between A C x) ∧ (C x ≡ C D)) (between A B C) ConjunctionRightElimination
        (between A C x) (C x ≡ C D) ConjunctionRightElimination
        applySyllogism

        composeConjunction

        A B C x BetweennessInnerTransitivityFlipped
        applySyllogism

        composeConjunction
))

thm (BetweennessOuterTransitivityFlipped-bca ((A a) (B a) (C a)) ()
  ((((between A B C) ∧ (between B C D)) ∧ (B ≠ C))
   → (∃ a (((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))))) (
        a A C C D SegmentConstruction
        (((between A B C) ∧ (between B C D)) ∧ (B ≠ C)) introduceAntecedent

        ((between A B C) ∧ (between B C D)) (B ≠ C) ConjunctionRightElimination
        (between A B C) (between B C D) ConjunctionRightElimination
        applySyllogism

        composeConjunction
</jh>
The consequent is now <code>∃ a (between A C a ∧ C a ≡ C D) ∧ between A B C</code>.  We move <code>between A B C</code> inside the quantifier.
<jh>
        a ((between A C (value a)) ∧ (C (value a) ≡ C D)) (between A B C) ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applySyllogism
</jh>
Now we just replace <code>between A B C</code> with <code>between B C a</code>.
<jh>
        A C (value a) D B BetweennessOuterTransitivityFlipped-1
        a addThereExists
        applySyllogism
))
</jh>
The next lemma is just a way of getting everything inside the quantifier.
<jh>
thm (BetweennessOuterTransitivityFlipped-2 ((A a) (B a) (C a) (D a)) ()
  ((((between A B C) ∧ (between B C D)) ∧ (B ≠ C))
   → (∃ a (((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) ∧ (B ≠ C)))) (
</jh>
First, <code>C a ≡ C D ∧ between B C a</code>.
<jh>
        A B C D a BetweennessOuterTransitivityFlipped-bca
</jh>
Next, <code>between B C D</code>
<jh>
        ((between A B C) ∧ (between B C D)) (B ≠ C) ConjunctionRightElimination
        (between A B C) (between B C D) ConjunctionLeftElimination
        applySyllogism

        composeConjunction

        a (((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) (between B C D) ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applySyllogism
</jh>
Finally, <code>B ≠ C</code>
<jh>
        ((between A B C) ∧ (between B C D)) (B ≠ C) ConjunctionLeftElimination

        composeConjunction

        a ((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) (B ≠ C) ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applySyllogism
))
</jh>
The following lemma is where we show that <code>a = D</code>.
<jh>
thm (BetweennessOuterTransitivityFlipped-ad () () ((((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) ∧ (B ≠ C)) → ((value a) = D)) (
</jh>
We'll be applying <code>SegmentConstructionUniqueness</code>. It has five antecedents. The first is <code>B ≠ C</code>.
<jh>
        ((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) (B ≠ C) ConjunctionLeftElimination
</jh>
The second is <code>between B C a</code>
<jh>
        ((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) (B ≠ C) ConjunctionRightElimination
        (((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) (between B C D) ConjunctionRightElimination
        applySyllogism
        ((between A C (value a)) ∧ (C (value a) ≡ C D)) (between B C (value a)) ConjunctionLeftElimination
        applySyllogism

        composeConjunction
</jh>
The third is <code>C a ≡ C D</code>
<jh>
        ((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) (B ≠ C) ConjunctionRightElimination
        (((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) (between B C D) ConjunctionRightElimination
        applySyllogism
        ((between A C (value a)) ∧ (C (value a) ≡ C D)) (between B C (value a)) ConjunctionRightElimination
        applySyllogism
        (between A C (value a)) (C (value a) ≡ C D) ConjunctionLeftElimination
        applySyllogism

        composeConjunction
</jh>
The fourth is <code>between B C D</code>
<jh>
        ((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) (B ≠ C) ConjunctionRightElimination
        (((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) (between B C D) ConjunctionLeftElimination
        applySyllogism

        composeConjunction
</jh>
The fifth is <code>C D ≡ C D</code>
<jh>
        C D CongruenceReflexivity
        (((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) ∧ (B ≠ C)) introduceAntecedent

        composeConjunction
</jh>
Applying <code>SegmentConstructionUniqueness</code> we can conclude <code>a = D</code>.
<jh>
        B C (value a) C D D SegmentConstructionUniqueness
        applySyllogism
))
</jh>
Here we combine the <code>a = D</code> result with picking <code>between A C a</code> out of the antecedent.
<jh>
thm (BetweennessOuterTransitivityFlipped-aca-ad () () ((((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) ∧ (B ≠ C)) → (((value a) = D) ∧ (between A C (value a)))) (
        A C a D B BetweennessOuterTransitivityFlipped-ad

        ((((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) ∧ (between B C D)) (B ≠ C) ConjunctionRightElimination
        (((between A C (value a)) ∧ (C (value a) ≡ C D)) ∧ (between B C (value a))) (between B C D) ConjunctionRightElimination
        applySyllogism
        ((between A C (value a)) ∧ (C (value a) ≡ C D)) (between B C (value a)) ConjunctionRightElimination
        applySyllogism
        (between A C (value a)) (C (value a) ≡ C D) ConjunctionRightElimination
        applySyllogism

        composeConjunction
))
</jh>
Now our substitution.
<jh>
thm (BetweennessOuterTransitivityFlipped-sub () () ((((value a) = D) ∧ (between A C (value a))) → (between A C D)) (
        A EqualityReflexivity
        C EqualityReflexivity
        A A C C (value a) D BetweenBuilder
        detach2of3
        detach1of2
</jh>
That gives us <code>a = D → (between A C a ↔ between A C D)</code>.
<jh>
        eliminateBiconditionalReverseInConsequent
        import
))
</jh>
We're ready to combine the various pieces.
<jh>
thm (BetweennessOuterTransitivityFlipped ((A a) (B a) (C a) (D a)) () ((((between A B C) ∧ (between B C D)) ∧ (B ≠ C)) → (between A C D)) (
        A B C D a BetweennessOuterTransitivityFlipped-2

        A C a D B BetweennessOuterTransitivityFlipped-aca-ad
        a D A C BetweennessOuterTransitivityFlipped-sub
        applySyllogism

        a addThereExists
        applySyllogism

        removeThereExistsInConsequent
))
</jh>

==== Middle transitivity ====
The next result is <code>between A B D ∧ between B C D → between A C D</code>. The proof has two cases. If <code>B = C</code>, then we can substitute <code>between A B D</code> into <code>between A C D</code> and we are done. If <code>B ≠ C</code>, then we first apply inner transitivity to get <code>between A B C</code>, and then apply outer transitivity (flipped) to get <code>between A C D</code>.<ref>between_exchange2 in Narboux</ref>
<jh>
thm (BetweennessMiddleTransitivityBEqualsC () () ((B = C) → (((between A B D) ∧ (between B C D)) → (between A C D))) (
        A EqualityReflexivity
        D EqualityReflexivity
        A A B C D D BetweenBuilder
        detach2of2
        detach1of2
        eliminateBiconditionalReverseInConsequent

        (between A B D) (between B C D) ConjunctionRightElimination
        (between A C D) addCommonConsequent
        applySyllogism
))

thm (BetweennessMiddleTransitivityBNotEqualC () () ((B ≠ C) → (((between A B D) ∧ (between B C D)) → (between A C D))) (
</jh>
We'll prove <code>B ≠ C ∧ (between A B D ∧ between B C D) → between A C D</code>, which is only an export away from our desired result.

To apply <code>BetweennessOuterTransitivityFlipped</code> we need three things.  The first is <code>between A B C</code>
<jh>
        (B ≠ C) ((between A B D) ∧ (between B C D)) ConjunctionLeftElimination
        A B D C BetweennessInnerTransitivity
        applySyllogism
</jh>
The second is <code>between B C D</code>
<jh>
        (B ≠ C) ((between A B D) ∧ (between B C D)) ConjunctionLeftElimination
        (between A B D) (between B C D) ConjunctionLeftElimination
        applySyllogism

        composeConjunction
</jh>
The third is <code>B ≠ C</code>
<jh>
        (B ≠ C) ((between A B D) ∧ (between B C D)) ConjunctionRightElimination
        composeConjunction

        A B C D BetweennessOuterTransitivityFlipped
        applySyllogism
        export
))

thm (BetweennessMiddleTransitivity () () (((between A B D) ∧ (between B C D)) → (between A C D)) (
        B C A D BetweennessMiddleTransitivityBEqualsC
        B C A D BetweennessMiddleTransitivityBNotEqualC
        eliminateCases
))
</jh>

==== Outer transitivity, non-flipped ====
The non-flipped outer transitivity is <code>between A B C ∧ between B C D ∧ B ≠ C → between A B D</code>.<ref>outer_transitivity_between in Narboux</ref><ref>Axiom 16 in Givant and Tarski, 1999</ref> Our proof just takes <code>BetweennessOuterTransitivityFlipped</code> and flips it, whereas Narboux's proof also invokes <code>BetweennessMiddleTransitivity</code>.

<jh>
thm (BetweennessOuterTransitivity () () ((((between A B C) ∧ (between B C D)) ∧ (B ≠ C)) → (between A B D)) (
        A B C BetweennessSymmetry
        B C D BetweennessSymmetry
        buildConjunction

        (between C B A) (between D C B) ConjunctionCommutativity
        applyBiconditionalTransitivity

        B C EqualitySymmetry
        addNegation

        buildConjunction
        eliminateBiconditionalReverse

        D C B A BetweennessOuterTransitivityFlipped
        applySyllogism

        D B A BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

==== Middle transitivity, flipped ====
Here we prove <code>between A B C ∧ between A C D → between A B D</code>.<ref>between_exchange4 in Narboux</ref>
<jh>
thm (BetweennessMiddleTransitivityFlipped () () (((between A B C) ∧ (between A C D)) → (between A B D)) (
        A B C BetweennessSymmetry
        A C D BetweennessSymmetry
        buildConjunction

        (between C B A) (between D C A) ConjunctionCommutativity
        applyBiconditionalTransitivity

        eliminateBiconditionalReverse

        D C A B BetweennessMiddleTransitivity
        applySyllogism

        D B A BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

=== Betweenness of more than three points ===
Narboux defines the concept of a betweenness relationship between four points, but we omit it here as Narboux does not use it anywhere.<ref>Bet_4 and l_3_9_4 in Narboux</ref>

== Twoness ==
There exist two distinct points. In symbols, <code>∃ a ∃ b a ≠ b</code>.<ref>two_distinct_points in Narboux</ref> The proof is based on the <code>LowerDimension</code> axiom. There are two cases. If <code>a ≠ b</code>, we are done. If <code>a = b</code>, then we can take <code>¬ between b c a</code> from the axiom and turn it into <code>¬ between b c b</code> which in turn implies <code>b ≠ c</code>.

Formalizing this proof has two parts. The first one follows the informal proof above and gets us as far as showing <code>a ≠ b</code> or <code>b ≠ c</code>. The second part does the predicate logic needed to switch variables and combine the two inequalities.

The first thing is a lemma bidirectionalizing <code>Indivisibility</code>.
<jh>
thm (IndivisibilityBidirectional () () ((between x y x) ↔ (x = y)) (
        x y Indivisibility

        x x BetweenAAB

        x EqualityReflexivity
        x EqualityReflexivity
        x x x y x x BetweenBuilder
        detach2of2
        detach1of2

        detachImplicationBiconditional

        introduceBiconditionalFromImplications
))

thm (TwonessLemma () () (∃ a (∃ b (∃ c (((value a) ≠ (value b)) ∨ ((value b) ≠ (value c)))))) (
        a b c LowerDimension
</jh>
The <code>a = b</code> case involves first picking out <code>¬ between b c a</code>.
<jh>
        ((¬ (between (value a) (value b) (value c)))
          ∧ (¬ (between (value b) (value c) (value a))))
        (¬ (between (value c) (value a) (value b)))
        ConjunctionRightElimination

        (¬ (between (value a) (value b) (value c))) (¬ (between (value b) (value c) (value a))) ConjunctionLeftElimination
        applySyllogism

        ((value a) = (value b)) introduceAntecedent
</jh>
Now we prove a substitution, <code>a = b → (¬ between b c a ↔ ¬ between b c b)</code>
<jh>
        (value b) EqualityReflexivity
        (value c) EqualityReflexivity
        (value b) (value b) (value c) (value c) (value a) (value b) BetweenBuilder
        detach2of3
        detach1of2

        addNegationInConsequent
</jh>
We combine the substitution with our previous result to get <code>a = b → (¬ between a b c ∧ ¬ between b c a ∧ ¬ between c a b → ¬ between b c b)</code>.
<jh>
        eliminateBiconditionalReverseInConsequent
        applySyllogismInConsequent
</jh>
Now we turn the consequent into <code>b ≠ c</code>,
<jh>
        (value b) (value c) IndivisibilityBidirectional
        addNegation
        eliminateBiconditionalReverse
        ((value a) = (value b)) introduceAntecedent
        applySyllogismInConsequent
</jh>
and add the <code>a ≠ b</code> disjunct.
<jh>
        ((value b) ≠ (value c)) ((value a) ≠ (value b)) DisjunctionLeftIntroduction
        ((value a) = (value b)) introduceAntecedent
        applySyllogismInConsequent
</jh>
The <code>a ≠ b</code> case is just a matter of arranging formulas for the case elimination and hooking to <code>LowerDimension</code>.
<jh>
        ((value a) ≠ (value b)) ((value b) ≠ (value c)) DisjunctionRightIntroduction
        (((value a) ≠ (value b)) ∨ ((value b) ≠ (value c)))
        (((¬ (between (value a) (value b) (value c)))
          ∧ (¬ (between (value b) (value c) (value a))))
          ∧ (¬ (between (value c) (value a) (value b)))
        ) AntecedentIntroduction
        applySyllogism
</jh>
We combine the cases and finish the proof.
<jh>
        eliminateCases
        c addThereExists
        b addThereExists
        a addThereExists
        applyModusPonens
))
</jh>
That's the first part of the proof. Now for the predicate logic. First is a lemma which expresses the variable change which is at the heart of all this rearrangement.
<jh>
thm (TwonessLemma2 ((a b c)) () ((∃ a (∃ b ((value a) ≠ (value b)))) ↔ (∃ b (∃ c ((value b) ≠ (value c))))) (
</jh>
Starting from the inside, our first substitution is <code>b = c → (a ≠ b ↔ a ≠ c)</code>
<jh>
        (value b) (value c) (value a) EqualityBuilderLL
        addNegationInConsequent
</jh>
That leads to the variable change <code>∃ b a ≠ b ↔ ∃ c a ≠ c</code>.
<jh>
        ChangeVariableThereExists
        a buildThereExists
</jh>
We repeat the process with the outer quantifiers. The substitution is <code>a = b → (∃ c a ≠ c ↔ ∃ c b ≠ c)</code>.
<jh>
        (value a) (value b) (value c) EqualityBuilderRR
        addNegationInConsequent
        c buildThereExistsInConsequent
</jh>
The corresponding variable change is <code>∃ a ∃ c a ≠ c ↔ ∃ b ∃ c b ≠ c</code>. Combining this with the first variable change proves our lemma.
<jh>
        ChangeVariableThereExists
        applyBiconditionalTransitivity
))

thm (Twoness ((a b c)) () (∃ a (∃ b ((value a) ≠ (value b)))) (
        a b c TwonessLemma

        c ((value a) ≠ (value b)) ((value b) ≠ (value c)) ThereExistsDisjunctionMovement
        eliminateBiconditionalReverse
        b addThereExists
        a addThereExists
        applyModusPonens
</jh>
We now have <code>∃ a ∃ b (a ≠ b ∨ ∃ c b ≠ c)</code>. We distribute <code>∃ b</code> across the disjunction.
<jh>
        b ((value a) ≠ (value b)) (∃ c ((value b) ≠ (value c))) ThereExistsDisjunction
        eliminateBiconditionalReverse
        a addThereExists
        applyModusPonens
</jh>
We have <code>∃ a (∃ b a ≠ b ∨ ∃ b ∃ c b ≠ c)</code>. We move the second disjunct outside of the quantifier for <code>a</code> to get <code>∃ a ∃ b a ≠ b ∨ ∃ b ∃ c b ≠ c</code>
<jh>
        a (∃ b ((value a) ≠ (value b))) (∃ b (∃ c ((value b) ≠ (value c)))) ThereExistsDisjunctionRightMovement
        eliminateBiconditionalReverse
        applyModusPonens
</jh>
At this point, we can change the variables in the latter disjunct.
<jh>
        a b c TwonessLemma2
        eliminateBiconditionalForward
        (∃ a (∃ b ((value a) ≠ (value b)))) disjoinLL
        applyModusPonens
</jh>
Having gotten both disjuncts to use the same variables, we are done.
<jh>
        conflateDisjunction
))
</jh>

=== Extending a line segment to a distinct point ===
Any line segment <code>A B</code> can be extended beyond <code>B</code> to a point <code>c</code> which does not equal <code>B</code>.<ref>point_construction_different in Narboux</ref>

First we prove a lemma which just rearranges <code>CongruenceIdentityFromEquality</code>.
<jh>
thm (PointConstructionDifferentLemma () () (((A B ≡ C D) ∧ (C ≠ D)) → (A ≠ B)) (
        A B C D CongruenceIdentityFromEquality
        applyComm

        (A = B) (C = D) Transposition
        eliminateBiconditionalReverse
        applySyllogism

        import
))
</jh>
The next lemma is just rearranging conjuncts and applying the previous lemma.
<jh>
thm (PointConstructionDifferentLemma2 () () ((((between A B C) ∧ (B C ≡ x y)) ∧ (x ≠ y)) → ((between A B C) ∧ (B ≠ C))) (
</jh>
First we pick out <code>between A B C</code>.
<jh>
        ((between A B C) ∧ (B C ≡ x y)) (x ≠ y) ConjunctionRightElimination
        (between A B C) (B C ≡ x y) ConjunctionRightElimination
        applySyllogism
</jh>
Next we pick out <code>B C ≡ x y</code>.
<jh>
        ((between A B C) ∧ (B C ≡ x y)) (x ≠ y) ConjunctionRightElimination
        (between A B C) (B C ≡ x y) ConjunctionLeftElimination
        applySyllogism
</jh>
Next we pick out <code>x ≠ y</code>.
<jh>
        ((between A B C) ∧ (B C ≡ x y)) (x ≠ y) ConjunctionLeftElimination
</jh>
Combining the second two results and applying the previous lemma gives us <code>B ≠ C</code>.
<jh>
        composeConjunction
        B C x y PointConstructionDifferentLemma
        applySyllogism
</jh>
Combining <code>between A B C</code> and <code>B ≠ C</code> finishes the proof.
<jh>
        composeConjunction
))

thm (PointConstructionDifferent ((a b A) (a b B) (a b c)) () (∃ c ((between A B (value c)) ∧ (B ≠ (value c)))) (
</jh>
The proof of our main theorem will proceed by constructing two different points <code>a</code> and <code>b</code>, and using them to extend the segment <code>A B</code> to a distinct point.

We start with the extension of <code>A B</code> beyond <code>B</code> to a point <code>c</code>.
<jh>
        c A B (value a) (value b) SegmentConstruction
</jh>
That gives us <code>∃ c (between A B c ∧ B c ≡ a b)</code>. This a relationship which holds for any values of <code>a</code> and <code>b</code>
<jh>
        b generalize
        a generalize
</jh>
Now we put in the construction of the two distinct points,
<jh>
        a b Twoness
</jh>
and combine the two statements and gather the quantifiers at the beginning to get <code>∃ a ∃ b ∃ c ((between A B c ∧ B c ≡ a b) ∧ a ≠ b)</code>
<jh>
        introduceConjunction

        a (∀ b (∃ c ((between A B (value c)) ∧ (B (value c) ≡ (value a) (value b))))) (∃ b ((value a) ≠ (value b))) ThereExistsConjunctionCombining
        applyModusPonens

        b (∃ c ((between A B (value c)) ∧ (B (value c) ≡ (value a) (value b)))) ((value a) ≠ (value b)) ThereExistsConjunctionCombining
        a addThereExists
        applyModusPonens

        c ((between A B (value c)) ∧ (B (value c) ≡ (value a) (value b))) ((value a) ≠ (value b)) ThereExistsConjunctionRightMovement
        b buildThereExists
        a buildThereExists
        eliminateBiconditionalForward
        applyModusPonens
</jh>
Applying our lemma, we get <code>∃ a ∃ b ∃ c (between A B c ∧ B ≠ c)</code>
<jh>
        A B (value c) (value a) (value b) PointConstructionDifferentLemma2
        c addThereExists
        b addThereExists
        a addThereExists
        applyModusPonens
</jh>
The first two quantifiers are no longer needed, and that finishes the proof.
<jh>
        removeThereExists
        removeThereExists
))
</jh>

== Export ==
<jh>
export (GEOMETRY Interface:Basic_geometry (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]