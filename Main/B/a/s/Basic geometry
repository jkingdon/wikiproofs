{{interfaces
| imports = [[Interface:Tarski's geometry axioms]]
| exports = None yet
}}

Here we prove a variety of basic geometrical theorems involving collinearity, midpoints, perpendiculars, and the like, starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Tarski's geometry axioms|geometry axioms]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (AXIOMS Interface:Tarski's_geometry_axioms (CLASSICAL FIRSTORDER) ())

var (point x y z w u v)
var (variable a b c)
</jh>

== Collinearity ==
To say that three points are collinear is just to say that one of them is between the other two (in any order).<ref>Definition Col in Narboux</ref>
<jh>
def ((collinear x y z) (((between x y z) ∨ (between y z x)) ∨ (between z x y)))
</jh>

== Congruence ==
A line segment is congruent to itself.<ref>Lemma cong_reflexivity in Narboux</ref>
<jh>
thm (CongruenceReflexivity () () (x y ≡ x y) (
        y x CongruenceReflexivityAxiom
        y x CongruenceReflexivityAxiom
        introduceConjunction

        y x x y x y CongruenceTransitivityAxiom

        applyModusPonens
))
</jh>

Congruence is symmetrical.<ref>Lemma cong_symmetry in Narboux</ref> The biconditionalized version is not in Narboux, but fits our usual conventions and the nature of JHilbert.
<jh>
thm (CongruenceSymmetryImplication () () ((x y ≡ z w) → (z w ≡ x y)) (
        x y CongruenceReflexivity
        x y z w x y CongruenceTransitivityAxiom
        detach2of2
))

thm (CongruenceSymmetry () () ((x y ≡ z w) ↔ (z w ≡ x y)) (
        x y z w CongruenceSymmetryImplication
        z w x y CongruenceSymmetryImplication
        introduceBiconditionalFromImplications
))
</jh>

Congruence is transitive.<ref>Lemma cong_transitivity in Narboux</ref>
<jh>
thm (CongruenceTransitivity () () (((x y ≡ z w) ∧ (z w ≡ u v)) → (x y ≡ u v)) (
        x y z w CongruenceSymmetry
        eliminateBiconditionalReverse
        (z w ≡ u v) conjoinRR

        z w x y u v CongruenceTransitivityAxiom

        applySyllogism
))
</jh>

We can commute the endpoints of the first line segment.<ref>Lemma cong_left_commutativity in Narboux</ref>
<jh>
thm (CongruenceLeftCommutativityImplication () () ((x y ≡ z w) → (y x ≡ z w)) (
        x y CongruenceReflexivityAxiom
        x y y x z w CongruenceTransitivityAxiom
        detach1of2
))

thm (CongruenceLeftCommutativity () () ((x y ≡ z w) ↔ (y x ≡ z w)) (
        x y z w CongruenceLeftCommutativityImplication
        y x z w CongruenceLeftCommutativityImplication
        introduceBiconditionalFromImplications
))
</jh>

Likewise for the second line segment.<ref>Lemma cong_right_commutativity in Narboux, biconditionalized</ref>
<jh>
thm (CongruenceRightCommutativity () () ((x y ≡ z w) ↔ (x y ≡ w z)) (
        x y z w CongruenceSymmetry

        z w x y CongruenceLeftCommutativity
        applyBiconditionalTransitivity

        w z x y CongruenceSymmetry
        applyBiconditionalTransitivity
))
</jh>

A line segment with the same point as start and end is congruent to another such segment. To prove this, start with the line segment x x. Extend x y beyond y to another point a such that y a ≡ x x. Then we show that a must equal y.<ref>Lemma cong_trivial_identity in Narboux</ref>
<jh>
thm (CongruenceTrivialIdentity ((a x) (a y)) () (y y ≡ x x) (
        a x y x x SegmentConstruction
</jh>
Now we have <code>∃ a (between x y a ∧ y a ≡ x x)</code>. We drop the between part.
<jh>
        (between x y (value a)) (y (value a) ≡ x x) ConjunctionLeftElimination
        a addThereExists
        applyModusPonens
</jh>
Here we combine <code>y a ≡ x x → y = a</code> with our previous result and rearrange a bit to get <code>∃ a (y = a ∧ y a ≡ x x)</code>.
<jh>
        y (value a) x CongruenceIdentity
        (y (value a) ≡ x x) ImplicationReflexivity
        composeConjunction
        a addThereExists
        applyModusPonens
</jh>
Now we just need a substitution.  The substitution is <code>y = a → (y y ≡ x x ↔ y a ≡ x x)</code>.
<jh>
        x EqualityReflexivity
        x EqualityReflexivity
        y EqualityReflexivity
        y y y (value a) x x x x CongruenceBuilder
        detach1of4
        detach2of2
        detach2of2
</jh>
Taking the reverse implication and combining with the previous result gives us <code>∃ a y y ≡ x x</code>.
<jh>
        eliminateBiconditionalForwardInConsequent
        import
        a addThereExists
        applyModusPonens
</jh>
The quantifier is no longer needed, and removing it finishes the proof.
<jh>
        removeThereExists
))
</jh>

== References ==
<references/>

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]