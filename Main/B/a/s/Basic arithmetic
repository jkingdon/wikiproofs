{{header
 | notes = This page covers basic arithmetic, starting from [[Interface:Peano axioms]] and proceeding as far as all the familiar laws of arithmetic: commutative, associative, distributive, etc.  At least for now, it stops before continuing into number theory (divisibility, primes, etc).
}}

We import [[Interface:Classical propositional calculus]], [[Interface:First-order logic]], and [[Interface:Peano axioms]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic (CLASSICAL) ())
import (PEANO Interface:Peano_axioms (CLASSICAL FIRSTORDER) ())

var (formula φ)
var (nat k n m n0 n1 m0 m1 a b c)
</jh>

Many of the proofs in this file are based on versions from Raph Levien.<ref>[http://levien.com/garden/ghnew/peano/ Peano], accessed March 2, 2010</ref>

== Builders ==
We provide rules and variants for the builder axioms.
<jh>
thm (AdditionBuilderLL () () ((m0 = m1) → ((n + m0) = (n + m1))) (
        n EqualityReflexivity
        (n = n) (m0 = m1) ConjunctionRightIntroduction
        applyModusPonens

        n n m0 m1 AdditionBuilder
        applySyllogism
))

thm (AdditionBuilderRR () () ((n0 = n1) → ((n0 + m) = (n1 + m))) (
        m EqualityReflexivity
        (m = m) (n0 = n1) ConjunctionLeftIntroduction
        applyModusPonens

        n0 n1 m m AdditionBuilder
        applySyllogism
))

thm (buildAddition () ((HN (n0 = n1)) (HM (m0 = m1))) ((n0 + m0) = (n1 + m1)) (
        HN
        HM
        introduceConjunction
        n0 n1 m0 m1 AdditionBuilder
        applyModusPonens
))

thm (buildAdditionLL () ((HM (m0 = m1))) ((n + m0) = (n + m1)) (
        HM
        m0 m1 n AdditionBuilderLL
        applyModusPonens
))

thm (buildAdditionRR () ((HN (n0 = n1))) ((n0 + m) = (n1 + m)) (
        HN
        n0 n1 m AdditionBuilderRR
        applyModusPonens
))

thm (addSuccessor () ((H (n = m))) ((succ n) = (succ m)) (
        H
        n m Successor eliminateBiconditionalForward
        applyModusPonens
))

thm (removeSuccessor () ((H ((succ n) = (succ m)))) (n = m) (
        H
        n m Successor eliminateBiconditionalReverse
        applyModusPonens
))

thm (MultiplicationBuilderLL () () ((m0 = m1) → ((n · m0) = (n · m1))) (
        n EqualityReflexivity
        (n = n) (m0 = m1) ConjunctionRightIntroduction
        applyModusPonens

        n n m0 m1 MultiplicationBuilder
        applySyllogism
))

thm (MultiplicationBuilderRR () () ((n0 = n1) → ((n0 · m) = (n1 · m))) (
        m EqualityReflexivity
        (m = m) (n0 = n1) ConjunctionLeftIntroduction
        applyModusPonens

        n0 n1 m m MultiplicationBuilder
        applySyllogism
))

thm (buildMultiplication () ((HN (n0 = n1)) (HM (m0 = m1))) ((n0 · m0) = (n1 · m1)) (
        HN
        HM
        introduceConjunction
        n0 n1 m0 m1 MultiplicationBuilder
        applyModusPonens
))

thm (buildMultiplicationLL () ((HM (m0 = m1))) ((n · m0) = (n · m1)) (
        HM
        m0 m1 n MultiplicationBuilderLL
        applyModusPonens
))

thm (buildMultiplicationRR () ((HN (n0 = n1))) ((n0 · m) = (n1 · m)) (
        HN
        n0 n1 m MultiplicationBuilderRR
        applyModusPonens
))
</jh>

Proofs using induction tend to make particularly heavy use of this one:
<jh>
thm (buildEqualityInConsequent ()
  ((HN (φ → (n0 = n1)))
   (HM (φ → (m0 = m1))))
  (φ → ((n0 = m0) ↔ (n1 = m1))) (
        HN HM composeConjunction
        n0 n1 m0 m1 EqualityBuilder
        applySyllogism
))
</jh>

== Induction ==
Here we present some induction theorems.

=== Induction5 ===
This version has five hypotheses, which despite the large number turns out to be easier to handle than expressing base cases and induction steps via <code>subst</code>. The first three hypotheses handle the substitution machinery.  The last two express the base case and induction step, and because the substitution has already been taken care of, tend to contain more mathematically interesting content and less substitution machinery.

<jh>
var (formula φ0 φk φSk)

thm (Induction5 ((φ0 n) (φk n) (φSk n) (φ k))
  ((HSUB0 ((n = (0)) → (φ ↔ φ0)))
   (HSUBK ((n = k) → (φ ↔ φk)))
   (HSUBSK ((n = (succ k)) → (φ ↔ φSk)))
   (HBASE φ0)
   (HIND (φk → φSk))
  )
  φ (
</jh>
The main difference between this and <code>Induction</code> is that the latter uses <code>subst</code> and we use implicit substitutions. The theorem linking the two is <code>makeSubstExplicit</code>. We first show the base case, <code>(subst (0) n φ)</code>.
<jh>
        HBASE
        HSUB0 makeSubstExplicit eliminateBiconditionalForward
        applyModusPonens
</jh>
The induction step is similar.
<jh>
        HSUBK makeSubstExplicit eliminateBiconditionalReverse
        HIND
        applySyllogism
        HSUBSK makeSubstExplicit eliminateBiconditionalForward
        applySyllogism
        k generalize
</jh>
Now we combine the two and apply <code>Induction</code>.
<jh>
        introduceConjunction
        n φ k Induction
        applyModusPonens

        specialize
))
</jh>

=== Induction6 ===
Having presented <code>Induction5</code>, there's an admission to make: it isn't quite enough for most situations.  The reason is that the discrete variable constraints on n (for example, <code>(φ0 n)</code>) are a bit too onerous. For example, suppose we are trying to prove <code>Sm + n = S(m + n)</code> by induction on <code>n</code>. Then <code>φ0</code> would be <code>Sm + 0 = S(m + 0)</code>.  This only passes the constraint <code>(φ0 n)</code> if <code>m</code> is distinct from <code>n</code>, which is not a condition we want to impose.

The solution is <code>Induction6</code>, which adds one more substitution, to separate the result from the variables used in the proof.  The naming conventions in the following are: <code>n</code> still is the variable which will appear in the final result, <code>k</code> is the variable which appears in the induction step, and <code>subk</code> is a variable which is used only in substitutions (the limitation of <code>Induction5</code> happens because it combines this one with <code>n</code>).

<jh>
var (formula φn)
var (nat subk)

thm (Induction6 ((subk n) (φ0 subk) (φk subk) (φSk subk) (φn subk) (φ k))
  ((HSUB0 ((subk = (0)) → (φ ↔ φ0)))
   (HSUBK ((subk = k) → (φ ↔ φk)))
   (HSUBSK ((subk = (succ k)) → (φ ↔ φSk)))
   (HSUBA ((subk = n) → (φ ↔ φn)))
   (HBASE φ0)
   (HIND (φk → φSk))
  )
  φn (
        HSUB0 HSUBK HSUBSK HBASE HIND Induction5
        n subk introduceSubst

        HSUBA makeSubstExplicit eliminateBiconditionalReverse

        applyModusPonens
))
</jh>

== Addition is commutative ==
The proof that <code>n + m = m + n</code> will be by induction, but we first prove two results which will underpin the base case and induction step.

=== Commuted version of the AdditiveIdentity axiom ===
The first step towards proving that addition is commutative will be a commuted version of the AdditiveIdentity axiom. We proceed by induction.

<jh>
thm (AdditiveIdentityLeft ((n k)) () (((0) + n) = n) (
</jh>
The substitution for the base case is <code>n = 0 → (0 + n = n ↔ 0 + 0 = 0)</code>.
<jh>
        n (0) (0) AdditionBuilderLL
        (n = (0)) ImplicationReflexivity
        buildEqualityInConsequent
</jh>
The substitution for the induction step antecedent is <code>n = k → (0 + n = n ↔ 0 + k = k)</code>.
<jh>
        n k (0) AdditionBuilderLL
        (n = k) ImplicationReflexivity
        buildEqualityInConsequent
</jh>
The substitution for the induction step consequent is similar.
<jh>
        n (succ k) (0) AdditionBuilderLL
        (n = (succ k)) ImplicationReflexivity
        buildEqualityInConsequent
</jh>
The base case, <code>0 + 0 = 0</code>, follows from the AdditiveIdentity axiom.
<jh>
        (0) AdditiveIdentity
</jh>
The induction step, <code>0 + k = k → 0 + Sk = Sk</code>, follows from the Addition axiom.
<jh>
        ((0) + k) k Successor eliminateBiconditionalForward

        (0) k Addition swapEquality
        (succ k) buildEqualityRR eliminateBiconditionalReverse

        applySyllogism

        Induction5
))
</jh>

Now that we have a <code>AdditiveIdentityLeft</code>, we'll also add <code>AdditiveIdentityRight</code> as a new name for the <code>AdditiveIdentity</code> axiom:
<jh>
thm (AdditiveIdentityRight () () ((n + (0)) = n) (
        n AdditiveIdentity
))
</jh>

=== Commuted version of the Addition axiom ===
The proof is by induction on <code>m</code>.

<jh>
thm (AdditionCommuted ((subk n) (subk m) (subk k) (k n)) () 
  (((succ n) + m) = (succ (n + m))) (
</jh>
The substitution for the base case is <code>subk = 0 → (Sn + subk = S(n + subk) ↔ Sn + 0 = S(n + 0))</code>.
<jh>
        subk (0) (succ n) AdditionBuilderLL

        subk (0) n AdditionBuilderLL
        (n + subk) (n + (0)) Successor eliminateBiconditionalForward
        applySyllogism

        buildEqualityInConsequent
</jh>
Substitution for the induction step antecedent:
<jh>
        subk k (succ n) AdditionBuilderLL

        subk k n AdditionBuilderLL
        (n + subk) (n + k) Successor eliminateBiconditionalForward
        applySyllogism

        buildEqualityInConsequent
</jh>
Substitution for the induction step consequent:
<jh>
        subk (succ k) (succ n) AdditionBuilderLL

        subk (succ k) n AdditionBuilderLL
        (n + subk) (n + (succ k)) Successor eliminateBiconditionalForward
        applySyllogism

        buildEqualityInConsequent
</jh>
Substitution for the result:
<jh>
        subk m (succ n) AdditionBuilderLL

        subk m n AdditionBuilderLL
        (n + subk) (n + m) Successor eliminateBiconditionalForward
        applySyllogism

        buildEqualityInConsequent
</jh>
The base case is <code>Sn + 0 = S(n + 0)</code>. The <code>AdditiveIdentity</code> axiom implies that each side is equal to <code>Sn</code>.
<jh>
        (succ n) AdditiveIdentity

        n AdditiveIdentity
        addSuccessor
        swapEquality

        applyEqualityTransitivity
</jh>
The induction step is <code>Sn + k = S(n + k) → Sn + Sk = S(n + Sk)</code>. We prove this by starting with the antecedent and taking the successor of both sides, to get <code>S(Sn + k) = S(S(n + k))</code>.  Applying the <code>Addition</code> axiom to each of the two additions gets us <code>Sn + Sk = S(n + Sk)</code>, which is what we need.
<jh>
        ((succ n) + k) (succ (n + k)) Successor eliminateBiconditionalForward

        (succ n) k Addition swapEquality
        n k Addition addSuccessor swapEquality
        buildEquality eliminateBiconditionalReverse

        applySyllogism

        Induction6
))
</jh>

=== Proof that addition is commutative ===
We prove <code>n + m = m + n</code> by induction on <code>n</code>.
<jh>
thm (AdditionCommutativity ((subk n) (subk m) (subk k) (k m)) () ((n + m) = (m + n)) (
</jh>
The substitution for the base case is <code>subk = 0 → subk + m = m + subk ↔ 0 + m = m + 0</code>.
<jh>
        subk (0) m AdditionBuilderRR
        subk (0) m AdditionBuilderLL
        buildEqualityInConsequent
</jh>
Substitution for the induction step antecedent:
<jh>
        subk k m AdditionBuilderRR
        subk k m AdditionBuilderLL
        buildEqualityInConsequent
</jh>
Substitution for the induction step consequent:
<jh>
        subk (succ k) m AdditionBuilderRR
        subk (succ k) m AdditionBuilderLL
        buildEqualityInConsequent
</jh>
Substitution for the result:
<jh>
        subk n m AdditionBuilderRR
        subk n m AdditionBuilderLL
        buildEqualityInConsequent
</jh>
The base case, <code>0 + m = m + 0</code> follows from right and left identity.
<jh>
        m AdditiveIdentityLeft
        m AdditiveIdentityRight swapEquality
        applyEqualityTransitivity
</jh>
The induction step, <code>k + m = m + k → Sk + m = m + Sk</code> follows from the regular and commuted versions of the <code>Addition</code> axiom.
<jh>
        (k + m) (m + k) Successor eliminateBiconditionalForward

        k m AdditionCommuted swapEquality
        m k Addition swapEquality
        buildEquality eliminateBiconditionalReverse

        applySyllogism

        Induction6
))
</jh>

== Addition is associative ==
<jh>
thm (AdditionAssociativity ((subk a) (subk b) (subk c) (subk k) (k b) (k c)) ()
  (((a + b) + c) = (a + (b + c))) (
</jh>
The proof proceeds by induction on <code>a</code>. The substitution for the base case is <code>subk = 0 → (subk + b) + c = subk + (b + c) ↔ (0 + b) + c = 0 + (b + c)</code>:
<jh>
        subk (0) b AdditionBuilderRR
        (subk + b) ((0) + b) c AdditionBuilderRR
        applySyllogism

        subk (0) (b + c) AdditionBuilderRR

        buildEqualityInConsequent
</jh>
Substitution for the induction step antecedent:
<jh>
        subk k b AdditionBuilderRR
        (subk + b) (k + b) c AdditionBuilderRR
        applySyllogism

        subk k (b + c) AdditionBuilderRR

        buildEqualityInConsequent
</jh>
Substitution for the induction step consequent:
<jh>
        subk (succ k) b AdditionBuilderRR
        (subk + b) ((succ k) + b) c AdditionBuilderRR
        applySyllogism

        subk (succ k) (b + c) AdditionBuilderRR

        buildEqualityInConsequent
</jh>
Substitution for the result:
<jh>
        subk a b AdditionBuilderRR
        (subk + b) (a + b) c AdditionBuilderRR
        applySyllogism

        subk a (b + c) AdditionBuilderRR

        buildEqualityInConsequent
</jh>
Each side of the base case, <code>(0 + b) + c = 0 + (b + c)</code>, is equal to <code>b + c</code> by <code>AdditiveIdentityLeft</code>.
<jh>
        b AdditiveIdentityLeft
        c buildAdditionRR

        (b + c) AdditiveIdentityLeft
        swapEquality

        applyEqualityTransitivity
</jh>
To prove <code>(Sk + b) + c = Sk + (b + c)</code> from <code>(k + b) + c = k + (b + c)</code>, take the successor of both sides and apply <code>AdditionCommuted</code>, twice to the left side and once to the right side.
<jh>
        ((k + b) + c) (k + (b + c)) Successor eliminateBiconditionalForward

        k b AdditionCommuted
        c buildAdditionRR
        (k + b) c AdditionCommuted
        applyEqualityTransitivity

        k (b + c) AdditionCommuted

        buildEquality eliminateBiconditionalForward

        applySyllogism

        Induction6
))
</jh>

== Multiplication is commutative ==
The proof that multiplication is commutative is analogous to the proof that addition is commutative. It starts with proving commuted versions of the two multiplication axioms by induction, and then using those results to prove <code>n · m = m · n</code> by induction.

=== Commuted version of the MultiplicativeZero axiom ===

<jh>
thm (MultiplicativeZeroLeft ((n k)) () (((0) · n) = (0)) (
</jh>
The proof proceeds by induction on <code>n</code>. The substitution for the base case is <code>n = 0 → (0 · n = 0 ↔ 0 · 0 = 0)</code>:
<jh>
        n (0) (0) MultiplicationBuilderLL
        (0) EqualityReflexivity
        (n = (0)) introduceAntecedent
        buildEqualityInConsequent
</jh>
Substitution for the induction step antecedent:
<jh>
        n k (0) MultiplicationBuilderLL
        (0) EqualityReflexivity
        (n = k) introduceAntecedent
        buildEqualityInConsequent
</jh>
Substitution for the induction step consequent:
<jh>
        n (succ k) (0) MultiplicationBuilderLL
        (0) EqualityReflexivity
        (n = (succ k)) introduceAntecedent
        buildEqualityInConsequent
</jh>
The base case is <code>0 · 0 = 0</code>, which follows from the <code>MultiplicativeZero</code> axiom.
<jh>
        (0) MultiplicativeZero
</jh>
The induction step is proved as follows:
 0 · k = 0 → 0 + 0 · k = 0 + 0 (adding 0 to both sides)
 0 + 0 · k = 0 · Sk (by Multiplication axiom)
 0 + 0 = 0 (by AdditiveIdentity axiom)
 0 · k = 0 → 0 · Sk = 0 (combining the above steps)
<jh>
        ((0) · k) (0) (0) AdditionBuilderLL

        (0) k Multiplication swapEquality
        (0) AdditiveIdentity
        buildEquality eliminateBiconditionalReverse

        applySyllogism

        Induction5
))
</jh>

== References ==
<references/>

[[Category:Elementary number theory|{{PAGENAME}}]]