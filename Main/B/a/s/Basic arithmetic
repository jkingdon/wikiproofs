{{header
 | notes = This page covers basic arithmetic, starting from [[Interface:Peano axioms]] and proceeding as far as all the familiar laws of arithmetic: commutative, associative, distributive, etc.  At least for now, it stops before continuing into number theory (divisibility, primes, etc).
}}
{{interfaces
| imports = [[Interface:Peano axioms]]
| exports = [[Interface:Basic arithmetic]]
}}

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Peano axioms|Peano axioms]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (PEANO Interface:Peano_axioms (CLASSICAL FIRSTORDER) ())

var (formula φ)
var (variable k n)
var (nat a b c d a0 a1 b0 b1)
</jh>

Many of the proofs in this file are based on versions from Raph Levien.<ref>[http://levien.com/garden/ghnew/peano/ Peano], accessed March 2, 2010</ref>

== Builders ==
We provide rules and variants for the builder axioms.
<jh>
thm (AdditionBuilderLL () () ((b0 = b1) → ((a + b0) = (a + b1))) (
        a EqualityReflexivity
        (a = a) (b0 = b1) ConjunctionRightIntroduction
        applyModusPonens

        a a b0 b1 AdditionBuilder
        applySyllogism
))

thm (AdditionBuilderRR () () ((a0 = a1) → ((a0 + b) = (a1 + b))) (
        b EqualityReflexivity
        (b = b) (a0 = a1) ConjunctionLeftIntroduction
        applyModusPonens

        a0 a1 b b AdditionBuilder
        applySyllogism
))

thm (buildAddition () ((HN (a0 = a1)) (HM (b0 = b1))) ((a0 + b0) = (a1 + b1)) (
        HN
        HM
        introduceConjunction
        a0 a1 b0 b1 AdditionBuilder
        applyModusPonens
))

thm (buildAdditionLL () ((HM (b0 = b1))) ((a + b0) = (a + b1)) (
        HM
        b0 b1 a AdditionBuilderLL
        applyModusPonens
))

thm (buildAdditionRR () ((HN (a0 = a1))) ((a0 + b) = (a1 + b)) (
        HN
        a0 a1 b AdditionBuilderRR
        applyModusPonens
))

thm (addSuccessor () ((H (a = b))) ((succ a) = (succ b)) (
        H
        a b Successor eliminateBiconditionalForward
        applyModusPonens
))

thm (removeSuccessor () ((H ((succ a) = (succ b)))) (a = b) (
        H
        a b Successor eliminateBiconditionalReverse
        applyModusPonens
))

thm (MultiplicationBuilderLL () () ((b0 = b1) → ((a · b0) = (a · b1))) (
        a EqualityReflexivity
        (a = a) (b0 = b1) ConjunctionRightIntroduction
        applyModusPonens

        a a b0 b1 MultiplicationBuilder
        applySyllogism
))

thm (MultiplicationBuilderRR () () ((a0 = a1) → ((a0 · b) = (a1 · b))) (
        b EqualityReflexivity
        (b = b) (a0 = a1) ConjunctionLeftIntroduction
        applyModusPonens

        a0 a1 b b MultiplicationBuilder
        applySyllogism
))

thm (buildMultiplication () ((HN (a0 = a1)) (HM (b0 = b1))) ((a0 · b0) = (a1 · b1)) (
        HN
        HM
        introduceConjunction
        a0 a1 b0 b1 MultiplicationBuilder
        applyModusPonens
))

thm (buildMultiplicationLL () ((HM (b0 = b1))) ((a · b0) = (a · b1)) (
        HM
        b0 b1 a MultiplicationBuilderLL
        applyModusPonens
))

thm (buildMultiplicationRR () ((HN (a0 = a1))) ((a0 · b) = (a1 · b)) (
        HN
        a0 a1 b MultiplicationBuilderRR
        applyModusPonens
))
</jh>

Proofs using induction, when they build up their substitutions, make heavy use of builders in consequents:
<jh>
thm (buildAdditionInConsequent ()
  ((HN (φ → (a0 = a1)))
   (HM (φ → (b0 = b1))))
  (φ → ((a0 + b0) = (a1 + b1))) (
        HN HM composeConjunction
        a0 a1 b0 b1 AdditionBuilder
        applySyllogism
))
</jh>

== Induction ==
Here we present some induction theorems.

=== Induction5 ===
This version has five hypotheses, which despite the large number turns out to be easier to handle than expressing base cases and induction steps via <code>subst</code>. The first three hypotheses handle the substitution machinery.  The last two express the base case and induction step, and because the substitution has already been taken care of, tend to contain more mathematically interesting content and less substitution machinery.

<jh>
var (formula φ0 φk φSk)

thm (Induction5 ((φ0 n) (φk n) (φSk n) (φ k) (n k))
  ((HSUB0 (((value n) = (0)) → (φ ↔ φ0)))
   (HSUBK (((value n) = (value k)) → (φ ↔ φk)))
   (HSUBSK (((value n) = (succ (value k))) → (φ ↔ φSk)))
   (HBASE φ0)
   (HIND (φk → φSk))
  )
  φ (
</jh>
The main difference between this and <code>Induction</code> is that the latter uses <code>subst</code> and we use implicit substitutions. The theorem linking the two is <code>makeSubstExplicit</code>. We first show the base case, <code>(subst (0) n φ)</code>.
<jh>
        HBASE
        HSUB0 makeSubstExplicit eliminateBiconditionalForward
        applyModusPonens
</jh>
The induction step is similar.
<jh>
        HSUBK makeSubstExplicit eliminateBiconditionalReverse
        HIND
        applySyllogism
        HSUBSK makeSubstExplicit eliminateBiconditionalForward
        applySyllogism
        k generalize
</jh>
Now we combine the two and apply <code>Induction</code>.
<jh>
        introduceConjunction
        n φ k Induction
        applyModusPonens

        specialize
))
</jh>

=== Induction6S ===
Having presented <code>Induction5</code>, there's an admission to make: it isn't quite enough.  There are two reasons.  The first is that the discrete variable constraints on n (for example, <code>(φ0 n)</code>) are a bit too onerous. For example, suppose we are trying to prove <code>Sm + n = S(m + n)</code> by induction on <code>n</code>. Then <code>φ0</code> would be <code>Sm + 0 = S(m + 0)</code>.  This only passes the constraint <code>(φ0 n)</code> if <code>m</code> is distinct from <code>n</code>, which is not a condition we want to impose.

The second reason is that <code>n</code> in <code>Induction5</code> is a <code>variable</code>, rather than an <code>object</code>. Because the quantifiers and substitution are only needed during the proof, not at the end, this is an unnecessary restriction.

The solution is <code>Induction6S</code>, which adds one more substitution, to separate the result from the variables used in the proof.  The naming conventions in the following are: <code>a</code> is the variable which will appear in the final result, <code>k</code> is the variable which appears in the induction step, and <code>n</code> is a variable which is used only in substitutions (the limitation of <code>Induction5</code> happens because it combines this one with what corresponds to <code>a</code> here).

<jh>
var (formula φa)

thm (Induction6S ((n a) (φ0 n) (φk n) (φSk n) (φa n) (φ k) (n k))
  ((HSUB0 (((value n) = (0)) → (φ ↔ φ0)))
   (HSUBK (((value n) = (value k)) → (φ ↔ φk)))
   (HSUBSK (((value n) = (succ (value k))) → (φ ↔ φSk)))
   (HSUBA (((value n) = a) → (φ ↔ φa)))
   (HBASE φ0)
   (HIND (φk → φSk))
  )
  φa (
        HSUB0 HSUBK HSUBSK HBASE HIND Induction5
        a n introduceSubst

        HSUBA makeSubstExplicit eliminateBiconditionalReverse

        applyModusPonens
))
</jh>

== Addition is commutative ==
The proof that <code>a + b = b + a</code> will be by induction, but we first prove two results which will underpin the base case and induction step.

=== Commuted version of the AdditiveIdentity axiom ===
The first step towards proving that addition is commutative will be a commuted version of the AdditiveIdentity axiom. We proceed by induction.

<jh>
thm (AdditiveIdentityLeft ((a k) (n k) (n a)) () (((0) + a) = a) (
</jh>
The substitution for the base case is <code>n = 0 → (0 + n = n ↔ 0 + 0 = 0)</code>.
<jh>
        (value n) (0) (0) AdditionBuilderLL
        ((value n) = (0)) ImplicationReflexivity
        buildEqualityInConsequent
</jh>
The substitution for the induction step antecedent is <code>n = k → (0 + n = n ↔ 0 + k = k)</code>.
<jh>
        (value n) (value k) (0) AdditionBuilderLL
        ((value n) = (value k)) ImplicationReflexivity
        buildEqualityInConsequent
</jh>
The substitution for the induction step consequent is similar.
<jh>
        (value n) (succ (value k)) (0) AdditionBuilderLL
        ((value n) = (succ (value k))) ImplicationReflexivity
        buildEqualityInConsequent
</jh>
The substitution for the result is similar.
<jh>
        (value n) a (0) AdditionBuilderLL
        ((value n) = a) ImplicationReflexivity
        buildEqualityInConsequent
</jh>
The base case, <code>0 + 0 = 0</code>, follows from the AdditiveIdentity axiom.
<jh>
        (0) AdditiveIdentity
</jh>
The induction step, <code>0 + k = k → 0 + Sk = Sk</code>, follows from the Addition axiom.
<jh>
        ((0) + (value k)) (value k) Successor eliminateBiconditionalForward

        (0) (value k) Addition swapEquality
        (succ (value k)) buildEqualityRR eliminateBiconditionalReverse

        applySyllogism

        Induction6S
))
</jh>

Now that we have a <code>AdditiveIdentityLeft</code>, we'll also add <code>AdditiveIdentityRight</code> as a new name for the <code>AdditiveIdentity</code> axiom:
<jh>
thm (AdditiveIdentityRight () () ((a + (0)) = a) (
        a AdditiveIdentity
))
</jh>

=== Commuted version of the Addition axiom ===
The proof is by induction on <code>b</code>.

<jh>
thm (AdditionCommuted ((n a) (n b) (n k) (k a)) () 
  (((succ a) + b) = (succ (a + b))) (
</jh>
The substitution for the base case is <code>n = 0 → (Sa + n = S(a + n) ↔ Sa + 0 = S(a + 0))</code>.
<jh>
        (value n) (0) (succ a) AdditionBuilderLL

        (value n) (0) a AdditionBuilderLL
        (a + (value n)) (a + (0)) Successor eliminateBiconditionalForward
        applySyllogism

        buildEqualityInConsequent
</jh>
Substitution for the induction step antecedent:
<jh>
        (value n) (value k) (succ a) AdditionBuilderLL

        (value n) (value k) a AdditionBuilderLL
        (a + (value n)) (a + (value k)) Successor eliminateBiconditionalForward
        applySyllogism

        buildEqualityInConsequent
</jh>
Substitution for the induction step consequent:
<jh>
        (value n) (succ (value k)) (succ a) AdditionBuilderLL

        (value n) (succ (value k)) a AdditionBuilderLL
        (a + (value n)) (a + (succ (value k))) Successor eliminateBiconditionalForward
        applySyllogism

        buildEqualityInConsequent
</jh>
Substitution for the result:
<jh>
        (value n) b (succ a) AdditionBuilderLL

        (value n) b a AdditionBuilderLL
        (a + (value n)) (a + b) Successor eliminateBiconditionalForward
        applySyllogism

        buildEqualityInConsequent
</jh>
The base case is <code>Sa + 0 = S(a + 0)</code>. The <code>AdditiveIdentity</code> axiom implies that each side is equal to <code>Sn</code>.
<jh>
        (succ a) AdditiveIdentity

        a AdditiveIdentity
        addSuccessor
        swapEquality

        applyEqualityTransitivity
</jh>
The induction step is <code>Sa + k = S(a + k) → Sa + Sk = S(a + Sk)</code>. We prove this by starting with the antecedent and taking the successor of both sides, to get <code>S(Sa + k) = S(S(a + k))</code>.  Applying the <code>Addition</code> axiom to each of the two additions gets us <code>Sa + Sk = S(a + Sk)</code>, which is what we need.
<jh>
        ((succ a) + (value k)) (succ (a + (value k))) Successor eliminateBiconditionalForward

        (succ a) (value k) Addition swapEquality
        a (value k) Addition addSuccessor swapEquality
        buildEquality eliminateBiconditionalReverse

        applySyllogism

        Induction6S
))
</jh>

=== Proof that addition is commutative ===
We prove <code>a + b = b + a</code> by induction on <code>a</code>.
<jh>
thm (AdditionCommutativity ((n a) (n b) (n k) (k b)) () ((a + b) = (b + a)) (
</jh>
The substitution for the base case is <code>n = 0 → n + b = b + n ↔ 0 + b = b + 0</code>.
<jh>
        (value n) (0) b AdditionBuilderRR
        (value n) (0) b AdditionBuilderLL
        buildEqualityInConsequent
</jh>
Substitution for the induction step antecedent:
<jh>
        (value n) (value k) b AdditionBuilderRR
        (value n) (value k) b AdditionBuilderLL
        buildEqualityInConsequent
</jh>
Substitution for the induction step consequent:
<jh>
        (value n) (succ (value k)) b AdditionBuilderRR
        (value n) (succ (value k)) b AdditionBuilderLL
        buildEqualityInConsequent
</jh>
Substitution for the result:
<jh>
        (value n) a b AdditionBuilderRR
        (value n) a b AdditionBuilderLL
        buildEqualityInConsequent
</jh>
The base case, <code>0 + b = b + 0</code>, follows from right and left identity.
<jh>
        b AdditiveIdentityLeft
        b AdditiveIdentityRight swapEquality
        applyEqualityTransitivity
</jh>
The induction step, <code>k + b = b + k → Sk + b = b + Sk</code> follows from the regular and commuted versions of the <code>Addition</code> axiom.
<jh>
        ((value k) + b) (b + (value k)) Successor eliminateBiconditionalForward

        (value k) b AdditionCommuted swapEquality
        b (value k) Addition swapEquality
        buildEquality eliminateBiconditionalReverse

        applySyllogism

        Induction6S
))
</jh>

== Addition is associative ==
<jh>
thm (AdditionAssociativity ((n a) (n b) (n c) (n k) (k b) (k c)) ()
  (((a + b) + c) = (a + (b + c))) (
</jh>
The proof proceeds by induction on <code>a</code>. The substitution for the base case is <code>n = 0 → (n + b) + c = n + (b + c) ↔ (0 + b) + c = 0 + (b + c)</code>:
<jh>
        (value n) (0) b AdditionBuilderRR
        ((value n) + b) ((0) + b) c AdditionBuilderRR
        applySyllogism

        (value n) (0) (b + c) AdditionBuilderRR

        buildEqualityInConsequent
</jh>
Substitution for the induction step antecedent:
<jh>
        (value n) (value k) b AdditionBuilderRR
        ((value n) + b) ((value k) + b) c AdditionBuilderRR
        applySyllogism

        (value n) (value k) (b + c) AdditionBuilderRR

        buildEqualityInConsequent
</jh>
Substitution for the induction step consequent:
<jh>
        (value n) (succ (value k)) b AdditionBuilderRR
        ((value n) + b) ((succ (value k)) + b) c AdditionBuilderRR
        applySyllogism

        (value n) (succ (value k)) (b + c) AdditionBuilderRR

        buildEqualityInConsequent
</jh>
Substitution for the result:
<jh>
        (value n) a b AdditionBuilderRR
        ((value n) + b) (a + b) c AdditionBuilderRR
        applySyllogism

        (value n) a (b + c) AdditionBuilderRR

        buildEqualityInConsequent
</jh>
Each side of the base case, <code>(0 + b) + c = 0 + (b + c)</code>, is equal to <code>b + c</code> by <code>AdditiveIdentityLeft</code>.
<jh>
        b AdditiveIdentityLeft
        c buildAdditionRR

        (b + c) AdditiveIdentityLeft
        swapEquality

        applyEqualityTransitivity
</jh>
To prove <code>(Sk + b) + c = Sk + (b + c)</code> from <code>(k + b) + c = k + (b + c)</code>, take the successor of both sides and apply <code>AdditionCommuted</code>, twice to the left side and once to the right side.
<jh>
        (((value k) + b) + c) ((value k) + (b + c)) Successor eliminateBiconditionalForward

        (value k) b AdditionCommuted
        c buildAdditionRR
        ((value k) + b) c AdditionCommuted
        applyEqualityTransitivity

        (value k) (b + c) AdditionCommuted

        buildEquality eliminateBiconditionalForward

        applySyllogism

        Induction6S
))
</jh>

== Addition cancellation ==
The converse of <code>AdditionBuilderRR</code>, <code>a + c = b + c → a = b</code>, also holds.

The substitution for our addition cancellation induction is worth breaking out into a lemma:
<jh>
var (object sub)
thm (AdditionCancellationRight-substitution () () (
  ((value n) = sub) → (
    (((a + (value n)) = (b + (value n))) → (a = b)) ↔ 
    (((a + sub) = (b + sub)) → (a = b))
  )) (
        (value n) sub a AdditionBuilderLL
        (value n) sub b AdditionBuilderLL
        buildEqualityInConsequent

        ((a + (value n)) = (b + (value n)))
          ((a + sub) = (b + sub))
          (a = b) ImplicationBuilderRR

        applySyllogism
))
</jh>

Now we can prove our addition cancellation theorem:
<jh>
thm (AdditionCancellationRightForward ((n a) (n b) (n c) (n k) (k a) (k b)) () (((a + c) = (b + c)) → (a = b)) (
</jh>
We proceed by induction on <code>c</code>.

Here are the substitutions:
<jh>
        n (0) a b AdditionCancellationRight-substitution
        n (value k) a b AdditionCancellationRight-substitution
        n (succ (value k)) a b AdditionCancellationRight-substitution
        n c a b AdditionCancellationRight-substitution
</jh>
The base case is <code>a + 0 = b + 0 → a = b</code>.
<jh>
        a AdditiveIdentityRight
        b AdditiveIdentityRight
        buildEquality
        eliminateBiconditionalReverse
</jh>
The induction step is that <code>a + k = b + k → a = b</code> implies <code>a + Sk = b + Sk → a = b</code>. Starting with <code>a + Sk = b + Sk</code> we first move the successor operation to the start of each side: <code>S(a + k) = S(b + k)</code>.
<jh>
        a (value k) Addition
        b (value k) Addition
        buildEquality eliminateBiconditionalReverse
</jh>
Next we drop the successor operation from both sides:
<jh>
        (a + (value k)) (b + (value k)) Successor eliminateBiconditionalReverse
        applySyllogism
</jh>
So far we have <code>a + Sk = b + Sk → a + k = b + k</code>.  We just need to add <code>a = b</code> as a common consequent, and we have our induction step.
<jh>
        (a = b) addCommonConsequent

        Induction6S
))
</jh>

As we tend to do with theorems which hold in both directions, we provide the biconditionalized version.
<jh>
thm (AdditionCancellationRight () () (((a + c) = (b + c)) ↔ (a = b)) (
        a c b AdditionCancellationRightForward
        a b c AdditionBuilderRR
        introduceBiconditionalFromImplications
))

thm (cancelAdditionRight () ((H ((a + c) = (b + c)))) (a = b) (
        H
        a c b AdditionCancellationRight
        eliminateBiconditionalReverse
        applyModusPonens
))
</jh>

A commuted version is an easy consequence, but will be convenient to have:

<jh>
thm (AdditionCancellationLeft () () 
  (((c + a) = (c + b)) ↔ (a = b)) (
        c a AdditionCommutativity
        c b AdditionCommutativity
        buildEquality

        a c b AdditionCancellationRight
        applyBiconditionalTransitivity
))

thm (cancelAdditionLeft () 
  ((H ((c + a) = (c + b))))
  (a = b) (
        H
        c a b AdditionCancellationLeft
        eliminateBiconditionalReverse
        applyModusPonens
))
</jh>

== Multiplication is commutative ==
The proof that multiplication is commutative is analogous to the proof that addition is commutative. It starts with proving commuted versions of the two multiplication axioms by induction, and then using those results to prove <code>n · m = m · n</code> by induction.

=== Commuted version of the MultiplicativeZero axiom ===

<jh>
thm (MultiplicativeZeroLeft ((n a) (n k) (k a)) () (((0) · a) = (0)) (
</jh>
The proof proceeds by induction on <code>a</code>. The substitution for the base case is <code>n = 0 → (0 · n = 0 ↔ 0 · 0 = 0)</code>:
<jh>
        (value n) (0) (0) MultiplicationBuilderLL
        (0) EqualityReflexivity
        ((value n) = (0)) introduceAntecedent
        buildEqualityInConsequent
</jh>
Substitution for the induction step antecedent:
<jh>
        (value n) (value k) (0) MultiplicationBuilderLL
        (0) EqualityReflexivity
        ((value n) = (value k)) introduceAntecedent
        buildEqualityInConsequent
</jh>
Substitution for the induction step consequent:
<jh>
        (value n) (succ (value k)) (0) MultiplicationBuilderLL
        (0) EqualityReflexivity
        ((value n) = (succ (value k))) introduceAntecedent
        buildEqualityInConsequent
</jh>
Substitution for the result:
<jh>
        (value n) a (0) MultiplicationBuilderLL
        (0) EqualityReflexivity
        ((value n) = a) introduceAntecedent
        buildEqualityInConsequent
</jh>
The base case is <code>0 · 0 = 0</code>, which follows from the <code>MultiplicativeZero</code> axiom.
<jh>
        (0) MultiplicativeZero
</jh>
The induction step is proved as follows:
 0 · k = 0 → 0 + 0 · k = 0 + 0 (adding 0 to both sides)
 0 + 0 · k = 0 · Sk (by Multiplication axiom)
 0 + 0 = 0 (by AdditiveIdentity axiom)
 0 · k = 0 → 0 · Sk = 0 (combining the above steps)
<jh>
        ((0) · (value k)) (0) (0) AdditionBuilderLL

        (0) (value k) Multiplication swapEquality
        (0) AdditiveIdentity
        buildEquality eliminateBiconditionalReverse

        applySyllogism

        Induction6S
))
</jh>

For parallelism, we also give an additional name to the <code>MultiplicativeZero</code> axiom:

<jh>
thm (MultiplicativeZeroRight () () ((a · (0)) = (0)) (
        a MultiplicativeZero
))
</jh>

=== Commuted version of the Multiplication axiom ===
Here we prove <code>Sa · b = a · b + b</code>. We break apart some parts of the proof into separate lemmas.

<jh>
# kk corresponds to (value k)
var (object kk)
thm (MultiplicationCommuted-left () () ((((succ a) · kk) + (succ a)) = ((succ a) · (succ kk))) (
        ((succ a) · kk) (succ a) AdditionCommutativity
        (succ a) kk Multiplication swapEquality
        applyEqualityTransitivity
))

thm (MultiplicationCommuted-right () () 
  ((((a · kk) + kk) + (succ a)) = ((a · (succ kk)) + (succ kk))) (
</jh>
First we transform <code>n · k + k + Sn</code> to S(n · k + k + n):
<jh>
        ((a · kk) + kk) a Addition
</jh>
Now we swap the last <code>k</code> and <code>n</code> to get <code>S(n · k + n + k)</code>.  This is basically just <code>AdditionCommutativity</code>, but there's quite a bit of rearranging and building:
<jh>
        (a · kk) kk a AdditionAssociativity
        kk a AdditionCommutativity (a · kk) buildAdditionLL
        applyEqualityTransitivity

        (a · kk) a kk AdditionAssociativity swapEquality
        applyEqualityTransitivity
        addSuccessor

        applyEqualityTransitivity
</jh>
We now apply <code>Addition</code> to turn that into <code>n · k + n + Sk</code>
<jh>
        ((a · kk) + a) kk Addition swapEquality
        applyEqualityTransitivity
</jh>
And <code>Multiplication</code> to get <code>n · Sk + Sk</code>
<jh>
        (a · kk) a AdditionCommutativity
        a kk Multiplication swapEquality
        applyEqualityTransitivity

        (succ kk) buildAdditionRR

        applyEqualityTransitivity
))

thm (MultiplicationCommuted-step () () 
  ((((succ a) · kk) = ((a · kk) + kk)) →
    (((succ a) · (succ kk)) = ((a · (succ kk)) + (succ kk)))) (
</jh>
Induction step: We get started by adding <code>Sn</code> to the right side of our induction step antecedant: <code>Sn · k = n · k + k → Sn · k + Sn = n · k + k + Sn</code>.
<jh>
        ((succ a) · kk) ((a · kk) + kk) (succ a) AdditionBuilderRR
</jh>
We transform <code>Sn · k + Sn</code> into <code>Sn · Sk</code>:
<jh>
        a kk MultiplicationCommuted-left
</jh>
Now we turn <code>n · k + k + Sn</code> into <code>n · Sk + Sk</code>:
<jh>
        a kk MultiplicationCommuted-right
</jh>
Now we just need to reassemble the entire induction step implication:
<jh>
        buildEquality eliminateBiconditionalReverse
        applySyllogism
))

thm (MultiplicationCommuted ((n a) (n b) (n k) (k a)) () 
  (((succ a) · b) = ((a · b) + b)) (
</jh>
The proof is by induction on <code>b</code>. The substitution for the base case is <code>n = 0 → (Sa · n = a · n + n ↔ Sa · 0 = a · 0 + 0)</code>.
<jh>
        (value n) (0) (succ a) MultiplicationBuilderLL

        (value n) (0) a MultiplicationBuilderLL
        ((value n) = (0)) ImplicationReflexivity
        buildAdditionInConsequent

        buildEqualityInConsequent
</jh>
Substitution for the induction step antecedent:
<jh>
        (value n) (value k) (succ a) MultiplicationBuilderLL

        (value n) (value k) a MultiplicationBuilderLL
        ((value n) = (value k)) ImplicationReflexivity
        buildAdditionInConsequent

        buildEqualityInConsequent
</jh>
Substitution for the induction step consequent:
<jh>
        (value n) (succ (value k)) (succ a) MultiplicationBuilderLL

        (value n) (succ (value k)) a MultiplicationBuilderLL
        ((value n) = (succ (value k))) ImplicationReflexivity
        buildAdditionInConsequent

        buildEqualityInConsequent
</jh>
Substitution for the result:
<jh>
        (value n) b (succ a) MultiplicationBuilderLL

        (value n) b a MultiplicationBuilderLL
        ((value n) = b) ImplicationReflexivity
        buildAdditionInConsequent

        buildEqualityInConsequent
</jh>
The base case is <code>Sa · 0 = a · 0 + 0</code>.
<jh>
        (succ a) MultiplicativeZero
        a MultiplicativeZero swapEquality
        applyEqualityTransitivity

        (a · (0)) AdditiveIdentityRight swapEquality
        applyEqualityTransitivity
</jh>
Induction step:
<jh>
        a (value k) MultiplicationCommuted-step

        Induction6S
))
</jh>

=== Proof that multiplication is commutative ===

The proof is by induction on <code>a</code>.
<jh>
thm (MultiplicationCommutativity ((n a) (n b) (n k) (k b)) () 
  ((a · b) = (b · a)) (
</jh>
The substitution for the base case is <code>n = 0 → (n · b = b · n ↔ 0 · b = b · 0)</code>:
<jh>
        (value n) (0) b MultiplicationBuilderRR
        (value n) (0) b MultiplicationBuilderLL
        buildEqualityInConsequent
</jh>
Substitution for the induction step antecedent:
<jh>
        (value n) (value k) b MultiplicationBuilderRR
        (value n) (value k) b MultiplicationBuilderLL
        buildEqualityInConsequent
</jh>
Substitution for the induction step consequent:
<jh>
        (value n) (succ (value k)) b MultiplicationBuilderRR
        (value n) (succ (value k)) b MultiplicationBuilderLL
        buildEqualityInConsequent
</jh>
Substitution for the result:
<jh>
        (value n) a b MultiplicationBuilderRR
        (value n) a b MultiplicationBuilderLL
        buildEqualityInConsequent
</jh>
The base case is <code>0 · b = b · 0</code>, and follows from left and right zeros, which we have already proved:
<jh>
        b MultiplicativeZeroLeft
        b MultiplicativeZeroRight swapEquality
        applyEqualityTransitivity
</jh>
Induction step.  Starting with <code>k · b = b · k</code> we add b to both sides:
<jh>
        ((value k) · b) (b · (value k)) b AdditionBuilderLL

</jh>
Then we note that <code>b + k · b = Sk · b</code>:
<jh>
        b ((value k) · b) AdditionCommutativity
        (value k) b MultiplicationCommuted swapEquality
        applyEqualityTransitivity
</jh>
And <code>b + b · k = b · Sk</code>:
<jh>
        b (value k) Multiplication swapEquality
</jh>
Now we combine these, to get <code>k · b = b · k → Sk · b = b · Sk</code>.
<jh>
        buildEquality
        eliminateBiconditionalReverse
        applySyllogism

        Induction6S
))
</jh>

== Rearrangement ==
Although there are a wide varieties of ways that a term could be rearranged by commutativity and associativity, the following rearrangements turn out to be common:
<jh>
thm (Addition4 () () (((a + b) + (c + d)) = ((a + c) + (b + d))) (
        a b (c + d) AdditionAssociativity

        b c d AdditionAssociativity swapEquality
        a buildAdditionLL
        applyEqualityTransitivity

        b c AdditionCommutativity
        d buildAdditionRR
        a buildAdditionLL
        applyEqualityTransitivity

        c b d AdditionAssociativity
        a buildAdditionLL
        applyEqualityTransitivity

        a c (b + d) AdditionAssociativity swapEquality
        applyEqualityTransitivity
))

thm (Addition3 () () (((a + b) + c) = ((a + c) + b)) (
        a b c AdditionAssociativity

        b c AdditionCommutativity
        a buildAdditionLL
        applyEqualityTransitivity

        a c b AdditionAssociativity
        swapEquality
        applyEqualityTransitivity
))
</jh>

== Multiplication distributes over addition ==
<jh>
thm (LeftDistribution ((n a) (n b) (n c) (n k) (k b) (k c)) ()
  ((a · (b + c)) = ((a · b) + (a · c))) (
</jh>
The proof is by induction on <code>a</code>. The substitution for the base case is <code>n = 0 → (n · (b + c) = n · b + n · c ↔ 0 · (b + c) = 0 · b + 0 · c)</code>.
<jh>
        (value n) (0) (b + c) MultiplicationBuilderRR

        (value n) (0) b MultiplicationBuilderRR
        (value n) (0) c MultiplicationBuilderRR
        composeConjunction
        ((value n) · b) ((0) · b) ((value n) · c) ((0) · c) AdditionBuilder
        applySyllogism

        buildEqualityInConsequent
</jh>
Substitution for the induction case antecedent:
<jh>
        (value n) (value k) (b + c) MultiplicationBuilderRR

        (value n) (value k) b MultiplicationBuilderRR
        (value n) (value k) c MultiplicationBuilderRR
        composeConjunction
        ((value n) · b) ((value k) · b) ((value n) · c) ((value k) · c) AdditionBuilder
        applySyllogism

        buildEqualityInConsequent
</jh>
Substitution for the induction case consequent:
<jh>
        (value n) (succ (value k)) (b + c) MultiplicationBuilderRR

        (value n) (succ (value k)) b MultiplicationBuilderRR
        (value n) (succ (value k)) c MultiplicationBuilderRR
        composeConjunction
        ((value n) · b) ((succ (value k)) · b) 
          ((value n) · c) ((succ (value k)) · c) AdditionBuilder
        applySyllogism

        buildEqualityInConsequent
</jh>
Substitution for the result:
<jh>
        (value n) a (b + c) MultiplicationBuilderRR

        (value n) a b MultiplicationBuilderRR
        (value n) a c MultiplicationBuilderRR
        composeConjunction
        ((value n) · b) (a · b) ((value n) · c) (a · c) AdditionBuilder
        applySyllogism

        buildEqualityInConsequent
</jh>
The base case is <code>0 · (b + c) = 0 · b + 0 · c</code>.
<jh>
        (b + c) MultiplicativeZeroLeft

        b MultiplicativeZeroLeft
        c MultiplicativeZeroLeft
        buildAddition
        (0) AdditiveIdentity
        applyEqualityTransitivity
        swapEquality

        applyEqualityTransitivity
</jh>
Now the induction step. We start with <code>k · (b + c) = k · b + k · c</code> and add (b + c) to the right of both sides:
<jh>
        ((value k) · (b + c)) (((value k) · b) + ((value k) · c)) (b + c) AdditionBuilderRR
</jh>
The left side is handled by observing that <code>k · (b + c) + (b + c) = Sk · (b + c)</code>:
<jh>
        (value k) (b + c) MultiplicationCommuted swapEquality
</jh>
For the right side, <code>k · b + k · c + (b + c)</code>, we rearrange the terms and apply MultiplicationCommuted twice, to get <code>Sk · b + Sk · c</code>.
<jh>
        ((value k) · b) ((value k) · c) b c Addition4

        (value k) b MultiplicationCommuted swapEquality
        (value k) c MultiplicationCommuted swapEquality
        buildAddition

        applyEqualityTransitivity
</jh>
Now we combine these, to get the induction step.
<jh>
        buildEquality
        eliminateBiconditionalReverse
        applySyllogism

        Induction6S
))
</jh>

It will be convenient to also have a commuted version of this:

<jh>
thm (RightDistribution () ()
  (((a + b) · c) = ((a · c) + (b · c))) (
        (a + b) c MultiplicationCommutativity

        c a b LeftDistribution
        applyEqualityTransitivity

        c a MultiplicationCommutativity
        c b MultiplicationCommutativity
        buildAddition
        applyEqualityTransitivity
))
</jh>

== Multiplication is associative ==

<jh>
thm (MultiplicationAssociativity ((n a) (n b) (n c) (n k) (k b) (k c)) ()
  (((a · b) · c) = (a · (b · c))) (
</jh>
The proof is by induction on <code>a</code>. The substitution for the base case is <code>n = 0 → ((n · b) · c = n · (b · c) ↔ (0 · b) · c = 0 · (b · c))</code>.
<jh>
        (value n) (0) b MultiplicationBuilderRR
        ((value n) · b) ((0) · b) c MultiplicationBuilderRR
        applySyllogism

        (value n) (0) (b · c) MultiplicationBuilderRR

        buildEqualityInConsequent
</jh>
Substitution for the induction step antecedent:
<jh>
        (value n) (value k) b MultiplicationBuilderRR
        ((value n) · b) ((value k) · b) c MultiplicationBuilderRR
        applySyllogism

        (value n) (value k) (b · c) MultiplicationBuilderRR

        buildEqualityInConsequent
</jh>
Substitution for the induction step consequent:
<jh>
        (value n) (succ (value k)) b MultiplicationBuilderRR
        ((value n) · b) ((succ (value k)) · b) c MultiplicationBuilderRR
        applySyllogism

        (value n) (succ (value k)) (b · c) MultiplicationBuilderRR

        buildEqualityInConsequent
</jh>
Substitution for the result:
<jh>
        (value n) a b MultiplicationBuilderRR
        ((value n) · b) (a · b) c MultiplicationBuilderRR
        applySyllogism

        (value n) a (b · c) MultiplicationBuilderRR

        buildEqualityInConsequent
</jh>
The base case is <code>(0 · b) · c = 0 · (b · c))</code>
<jh>
        b MultiplicativeZeroLeft
        c buildMultiplicationRR
        c MultiplicativeZeroLeft
        applyEqualityTransitivity

        (b · c) MultiplicativeZeroLeft

        swapEquality
        applyEqualityTransitivity
</jh>
For the induction step, we take <code>(k · b) · c = k · (b · c))</code> and add <code>b · c</code> to both sides:
<jh>
        (((value k) · b) · c) ((value k) · (b · c)) (b · c) AdditionBuilderRR
</jh>
To the left side, <code>(k · b) · c + (b · c)</code>, we first collect the <code>c</code> using distributivity:
<jh>
        ((value k) · b) b c RightDistribution swapEquality
</jh>
That gives us <code>(k · b + b) · c</code> so we just need to turn it into <code>(Sk · b) · c</code>:
<jh>
        (value k) b MultiplicationCommuted swapEquality
        c buildMultiplicationRR
        applyEqualityTransitivity
</jh>
The right side, <code>k · (b · c) + b · c</code>, is even easier:
<jh>
        (value k) (b · c) MultiplicationCommuted swapEquality
</jh>
Now we combine these, to get the induction step.
<jh>
        buildEquality
        eliminateBiconditionalReverse
        applySyllogism

        Induction6S
))
</jh>

== One ==
One is the successor of zero:

<jh>
def ((1) (succ (0)))
</jh>

It serves as a multiplicative identity:
<jh>
thm (MultiplicativeIdentityRight () ()
  ((a · (1)) = a) (
        a (0) Multiplication
</jh>
That gives us <code>a · 1 = a + a · 0</code>, so we first simplify <code>a · 0</code> to <code>0</code>.
<jh>
        a MultiplicativeZeroRight
        a buildAdditionLL
        applyEqualityTransitivity
</jh>
Now we turn <code>a + 0</code> to <code>a</code>.
<jh>
        a AdditiveIdentityRight
        applyEqualityTransitivity
))

thm (MultiplicativeIdentityLeft () ()
  (((1) · a) = a) (
        (1) a MultiplicationCommutativity
        a MultiplicativeIdentityRight
        applyEqualityTransitivity
))
</jh>

One does not equal zero.
<jh>
thm (ZeroOne () () ((0) ≠ (1)) (
        (0) ZeroNotSuccessor
))
</jh>

== Inequality ==
We define an order on natural numbers:

<jh>
def ((≤ a b) (∃ n ((a + (value n)) = b)))
</jh>

===Definition as an equivalence===

The following theorem looks just like the definition for <code>≤</code>.  However, at least as JHilbert is right now, it is subtly different, as it enables one to specify the bound variable on the right hand side.

<jh>
var (variable m)
thm (LessEqual ((m n) (a m) (a n) (b m) (b n)) () ((a ≤ b) ↔ (∃ n ((a + (value n)) = b))) (
</jh>
To restate our "subtle difference" in terms of explaining what we need for our proof, the quantified variable on the left side of the biconditional (which results from the expansion of <code>≤</code>) is different from the quantified variable on the right hand side (<code>n</code>). So we need to switch variables.

We start with <code>m = n → (a + m = b ↔ a + n = b)</code>,
<jh>
        (value m) (value n) a AdditionBuilderLL
        b buildEqualityRRInConsequent
</jh>
and apply <code>ChangeVariableThereExists</code>.
<jh>
        ChangeVariableThereExists
</jh>
We have proved <code>∃ m a + m = b ↔ ∃ n a + n = b</code>, and that is enough since JHilbert is able to recognize that the left side is the definition of <code>a ≤ b</code>.
<jh>
))
</jh>

=== Builders ===
The builders for <code>≤</code> follow readily from the builders for addition, equality, and so on.
<jh>
thm (LessEqualBuilderRR ((a0 n) (a1 n) (b n)) () ((a0 = a1) → ((a0 ≤ b) ↔ (a1 ≤ b))) (
</jh>
What we do here is prove <code>a0 = a1 → (∃ n a0 + n = b ↔ ∃ n a1 + n = b)</code>.  The right hand side basically consists of the desired theorem with ≤ expanded, but with a twist: here it holds with the same variable for both quantifiers.
<jh>
        a0 a1 (value n) AdditionBuilderRR
        b buildEqualityRRInConsequent

        n addForAllToConsequent
        n ((a0 + (value n)) = b) ((a1 + (value n)) = b) ForAllBiconditionalThereExists
        applySyllogism

        a0 b n LessEqual
        a1 b n LessEqual
        buildBiconditional
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

The builder for adding a common number to the left is similar, and is proved in the same way.
<jh>
thm (LessEqualBuilderLL ((a n) (b0 n) (b1 n)) () ((b0 = b1) → ((a ≤ b0) ↔ (a ≤ b1))) (
        b0 b1 (a + (value n)) EqualityBuilderLL

        n addForAllToConsequent
        n ((a + (value n)) = b0) ((a + (value n)) = b1) ForAllBiconditionalThereExists
        applySyllogism

        a b0 n LessEqual
        a b1 n LessEqual
        buildBiconditional
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

Combining <code>LessEqualBuilderLL</code> and <code>LessEqualBuilderRR</code> gives us the full builder.

<jh>
thm (LessEqualBuilder () () (((a0 = a1) ∧ (b0 = b1)) → ((a0 ≤ b0) ↔ (a1 ≤ b1))) (
        (a0 = a1) (b0 = b1) ConjunctionRightElimination
        a0 a1 b0 LessEqualBuilderRR
        applySyllogism

        (a0 = a1) (b0 = b1) ConjunctionLeftElimination
        b0 b1 a1 LessEqualBuilderLL
        applySyllogism

        composeConjunction

        (a0 ≤ b0) (a1 ≤ b0) (a1 ≤ b1) BiconditionalTransitivity
        applySyllogism
))

thm (buildLessEqual () ((HA (a0 = a1)) (HB (b0 = b1))) ((a0 ≤ b0) ↔ (a1 ≤ b1)) (
        HA
        HB
        introduceConjunction
        a0 a1 b0 b1 LessEqualBuilder
        applyModusPonens
))

thm (buildLessEqualRR () ((H (a0 = a1))) ((a0 ≤ b) ↔ (a1 ≤ b)) (
        H
        a0 a1 b LessEqualBuilderRR
        applyModusPonens
))

thm (buildLessEqualLL () ((H (b0 = b1))) ((a ≤ b0) ↔ (a ≤ b1)) (
        H
        b0 b1 a LessEqualBuilderLL
        applyModusPonens
))
</jh>

=== Proving inequality with an object ===
We can prove <code>a ≤ b</code> by proving <code>∃ n a + n = b</code>. Well, the usual way to do this is to provide a value for <code>n</code>.
<jh>
thm (LessEqualObject ((c n) (a n) (b n)) () (((a + c) = b) → (a ≤ b)) (
</jh>
The proof is basically substitution machinery. We start with <code>n = c → (a + n = b ↔ a + c = b)</code>:
<jh>
        (value n) c a AdditionBuilderLL

        b EqualityReflexivity
        ((value n) = c) introduceAntecedent

        composeConjunction

        (a + (value n)) (a + c) b b EqualityBuilder
        applySyllogism
</jh>
We turn that into <code>(subst c n (a + n = b)) ↔ a + c = b</code>,
<jh>
        makeSubstExplicit
</jh>
and take the reverse implication.
<jh>
        eliminateBiconditionalForward
</jh>
That in turn implies <code>∃ n a + n = b</code>, which is <code>a ≤ b</code> by the definition of <code>≤</code>.
<jh>
        c n ((a + (value n)) = b) ThereExistsIntroductionFromObject
        applySyllogism

        a b n LessEqual
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

===Zero is the smallest natural number===

Every number is greater than or equal to zero:
<jh>
thm (ZeroSmallest () () ((0) ≤ a) (
</jh>
To prove this inequality, we need to find a number ''n'' such that <code>0 + ''n'' = a</code>. The number <code>a</code> does this.
<jh>
        a AdditiveIdentityLeft

        (0) a a LessEqualObject
        applyModusPonens
))
</jh>

=== Predecessor ===
Any nonzero natural number has a predecessor. We express this as <code>a ≠ 0 → ∃ m Sm = a</code>. The proof will be by induction on <code>a</code>, and we start with the substitution.
<jh>
thm (Predecessor-sub ((m n) (m sub)) () (
  ((value n) = sub) → (
    (((value n) ≠ (0)) → (∃ m ((succ (value m)) = (value n)))) ↔ 
    ((sub ≠ (0)) → (∃ m ((succ (value m)) = sub)))
  )) (
        (value n) sub (0) EqualityBuilderRR
        addNegationInConsequent
        (value n) sub (succ (value m)) EqualityBuilderLL
        m buildThereExistsInConsequent
        buildImplicationInConsequent
))

thm (Predecessor ((n m) (m k) (m a) (n k) (n a)) () ((a ≠ (0)) → (∃ m ((succ (value m)) = a))) (
        n (0) m Predecessor-sub
        n (value k) m Predecessor-sub
        n (succ (value k)) m Predecessor-sub
        n a m Predecessor-sub
</jh>
The base case is <code>0 ≠ 0 → ∃ m Sm = 0</code>, which follows from <code>0 = 0</code>.
<jh>
        (0) EqualityReflexivity
        (¬ (∃ m ((succ (value m)) = (0)))) introduceAntecedent
        transposeWithNegatedAntecedent
</jh>
The induction step is <code>(k ≠ 0 → ∃ m Sm = k) → (Sk ≠ 0 → ∃ m Sm = Sk)</code>.  We first show <code>∃ m Sm = Sk</code> (one way of thinking of this is that we could choose <code>k</code> as the value for <code>m</code>, but our proof short-cuts that a bit by resorting to the <code>Quantifiability</code> axiom).
<jh>
        m (value k) Quantifiability

        (value m) (value k) Successor
        eliminateBiconditionalForward
        m addThereExists

        applyModusPonens
</jh>
To get the induction step, we just need to introduce some antecedents.
<jh>
        ((succ (value k)) ≠ (0)) introduceAntecedent
        (((value k) ≠ (0)) → (∃ m ((succ (value m)) = (value k)))) introduceAntecedent

        Induction6S
))
</jh>

=== Total order ===
We'll show that ≤ has the [[w:Total order|expected properties of a total order]].
* If a ≤ b and b ≤ c then a ≤ c (transitivity)
* If a ≤ b and b ≤ a then a = b (antisymmetry)
* a ≤ b or b ≤ a (totality). 

==== Transitivity ====

Here we prove that <code>a ≤ b ∧ b ≤ c → a ≤ c</code>.  The proof is simple to sketch out: by the definition of <code>≤</code>, we have <code>∃ ab a + ab = b</code> and <code>∃ bc b + bc = c</code>. Applying the addition builder, we get <code>a + ab + b + bc = b + c</code>.  Rearranging the terms and cancelling the <code>b</code>, we get <code>a + (ab + bc) = c</code>.  That implies <code>a ≤ c</code>, by <code>LessEqualObject</code>.

Formalizing the proof is somewhat tedious, because "rearranging the terms and cancelling" expands to many steps, but the idea is unchanged (and <code>LessEqualObject</code> takes care of much of the predicate logic which might otherwise clutter this sort of proof).

<jh>
var (object ab bc)
var (variable vab vbc vac)

</jh>
The following lemma includes the rearrangements we will need. It is a straightforward application of commutativity, associativity, and cancellation.
<jh>
thm (LessEqualTransitivity-1 () ()
  ((((a + ab) = b) ∧ ((b + bc) = c)) → ((a + (ab + bc)) = c)) (
</jh>
We start with <code>a + ab = b ∧ b + bc = c → (a + ab) + (b + bc) = b + c</code>
<jh>
        (a + ab) b (b + bc) c AdditionBuilder
</jh>
On the left hand side of the consequent's equality, we commute <code>b</code> and <code>bc</code> and associate:
<jh>
        b bc AdditionCommutativity
        (a + ab) buildAdditionLL

        (a + ab) bc b AdditionAssociativity
        swapEquality
        applyEqualityTransitivity
</jh>
On the right hand side, we just commute <code>b</code> and <code>c</code>:
<jh>
        b c AdditionCommutativity
</jh>
Combining the two sides and cancelling the <code>b</code> gives <code>(a + ab) + bc = c</code>
<jh>
        buildEquality
        eliminateBiconditionalReverse
        applySyllogism

        ((a + ab) + bc) b c AdditionCancellationRight
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Now we just apply associativity to the left hand side of that equality:
<jh>
        a ab bc AdditionAssociativity
        c buildEqualityRR
        eliminateBiconditionalReverse
        applySyllogism
))

</jh>

We are now ready to prove <code>a ≤ b ∧ b ≤ c → a ≤ c</code>.
<jh>
thm (LessEqualTransitivity (
  (vab vbc) (vab a) (vab b) (vab c)
  (vbc a) (vbc b) (vbc c)
  (vab vac) (vbc vac) (vac a) (vac c)
  ) () 
  (((a ≤ b) ∧ (b ≤ c)) → (a ≤ c)) (
</jh>
We start by expanding <code>a ≤ b</code> and <code>b ≤ c</code> according to the definition and gathering the quantifiers at the start of the formula.
<jh>
        a b vab LessEqual
        b c vbc LessEqual
        buildConjunction
        eliminateBiconditionalReverse

        vab vbc ((a + (value vab)) = b) ((b + (value vbc)) = c) ThereExistsScattering
        eliminateBiconditionalForward
        applySyllogism
</jh>
That gives us <code>∃ ab ∃ bc a + ab = b ∧ b + bc = c</code>.

The <code>a + ab = b ∧ b + bc = c</code> part of this implies first <code>a + (ab + bc) = c</code>,
<jh>
        a (value vab) b (value vbc) c LessEqualTransitivity-1
</jh>
and then <code>a ≤ c</code>.
<jh>
        a ((value vab) + (value vbc)) c LessEqualObject
        applySyllogism
</jh>
Adding back the quantifiers gives us <code>a ≤ b ∧ b ≤ c → ∃ ab ∃ bc a ≤ c</code>.
<jh>
        vbc addThereExists
        vab addThereExists
        applySyllogism
</jh>
and then we can remove the quantifiers because the variables they quantify over are gone. One detail (at least as long as JHilbert continues to automatically apply definitions): we need to rewrite <code>a ≤ c</code> as <code>∃ ac a + ac = c</code> so that we can express the distinct variable constraint between <code>ab</code> and <code>ac</code>.
<jh>
        a c vac LessEqual
        vbc buildThereExists
        vab buildThereExists
        eliminateBiconditionalReverse
        applySyllogism

        vab (∃ vbc (∃ vac ((a + (value vac)) = c))) NullThereExists eliminateBiconditionalReverse
        applySyllogism

        vbc (∃ vac ((a + (value vac)) = c)) NullThereExists eliminateBiconditionalReverse
        applySyllogism
))
</jh>

==== Antisymmetry ====
Before we prove antisymmetry, we prove several lemmas. The first is a substitution (think of it as substituting zero for <code>b</code> in the left hand conjunct).
<jh>
thm (LessEqualAntisymmetry-1 () () ((((a + b) = c) ∧ (b = (0))) → (a = c)) (
</jh>
We start with <code>b = 0 → a + b = a + 0</code>.
<jh>
        b (0) a AdditionBuilderLL
</jh>
Next is <code>b = 0 → (a + b = c → a + 0 = c)</code>.
<jh>
        c buildEqualityRRInConsequent
        ((a + b) = c) ((a + (0)) = c) BiconditionalReverseElimination
        applySyllogism
</jh>
We turn that into <code>a + b = c ∧ b = 0 → a + 0 = c</code>,
<jh>
        applyComm
        import
</jh>
and all that remains is removing the extra addition of zero.
<jh>
        a AdditiveIdentity
        c buildEqualityRR
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

Our second lemma is <code>a + b = 0 → a = 0</code>.
<jh>
thm (LessEqualAntisymmetry-2 ((a n) (b n)) () (((a + b) = (0)) → (a = (0))) (
</jh>
The idea of the proof is not too complicated: if <code>a</code> is not zero, <code>a + b</code> can be written as the successor of something (namely the predecessor of <code>a</code> added to <code>b</code>).  But this is not possible if <code>a + b</code> is zero.

Near the end of the proof we'll need <code>¬ ∃ n 0 = S(n + b)</code>, so we stick it on the proof stack. It is a consequence of the axiom that zero is not the successor of anything.
<jh>
        ((value n) + b) ZeroNotSuccessor
        n generalize
        n ((0) = (succ ((value n) + b))) NotThereExists
        eliminateBiconditionalForward
        applyModusPonens
</jh>
Setting that aside, we start with <code>a ≠ 0 → ∃ n Sn = a</code>.
<jh>
        a n Predecessor
</jh>
Working with the <code>Sn = a</code> part of that, we show it implies <code>Sn + b = a + b</code>, then <code>S(n + b) = a + b</code>, then <code>0 = S(n + b) ↔ 0 = a + b</code>, then <code>0 = a + b → 0 = S(n + b)</code>.
<jh>
        (succ (value n)) a b AdditionBuilderRR

        (value n) b AdditionCommuted
        (a + b) buildEqualityRR
        eliminateBiconditionalReverse
        applySyllogism

        (succ ((value n) + b)) (a + b) (0) EqualityBuilderLL
        applySyllogism

        ((0) = (succ ((value n) + b))) ((0) = (a + b)) BiconditionalForwardElimination
        applySyllogism
</jh>
It is now time to add the quantifier and combine with the previous result to get <code>a ≠ 0 → ∃ n (0 = a + b → 0 = S(n + b))</code>
<jh>
        n addThereExists
        applySyllogism
</jh>
Since <code>0 = a + b</code> does not contain <code>n</code>, we can move it out of the quantifier, which gets us <code>a ≠ 0 → (0 = a + b → ∃ n 0 = S(n + b))</code>.
<jh>
        n ((0) = (a + b)) ((0) = (succ ((value n) + b))) ThereExistsAntecedentMovement
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Pulling <code>¬ ∃ n 0 = S(n + b)</code> off the proof stack, we turn this into <code>a ≠ 0 → 0 ≠ a + b</code>
<jh>
        negatedDetachImplicationImplication
</jh>
Now we just switch the order of one the equalities and transpose.
<jh>
        (0) (a + b) EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism

        eliminateTransposition
))
</jh>

The next lemma is <code>a + n = b ∧ b + m = a → a = b</code>. The proof proceeds by rearranging the terms to get <code>n + m = 0</code>, and using that to get <code>n = 0</code>.
<jh>
thm (LessEqualAntisymmetry-3 () () ((((a + (value n)) = b) ∧ ((b + (value m)) = a)) → (a = b)) (
</jh>
Although we won't need it for a while, we put <code>a + n = b ∧ b + m = a → a + n = b</code> on the proof stack.
<jh>
        ((a + (value n)) = b) ((b + (value m)) = a) ConjunctionRightElimination
</jh>
Now we start again with <code>a + n = b ∧ b + m = a</code>.
<jh>
        (a + (value n)) b (value m) AdditionBuilderRR
        ((b + (value m)) = a) conjoinRR
</jh>
So far we have <code>a + n + m = b + m ∧ b + m = a</code>. Applying transitivity gives us <code>a + n + m = a</code>.
<jh>
        ((a + (value n)) + (value m)) (b + (value m)) a EqualityTransitivity
        applySyllogism
</jh>
We now turn the right-hand <code>a</code> into <code>a + 0</code>, and reassociate the left-hand side from <code>(a + n) + m</code> to <code>a + (n + m)</code>.
<jh>
        a (value n) (value m) AdditionAssociativity
        a AdditiveIdentity swapEquality
        buildEquality
        eliminateBiconditionalReverse
        applySyllogism
</jh>
We have <code>a + (n + m) = a + 0</code> and cancelling the <code>a</code> gives us <code>n + m = 0</code>.
<jh>
        a ((value n) + (value m)) (0) AdditionCancellationLeft
        eliminateBiconditionalReverse
        applySyllogism
</jh>
That in turn implies <code>n = 0</code>
<jh>
        (value n) (value m) LessEqualAntisymmetry-2
        applySyllogism
</jh>
The entire statement on the proof stack is <code>a + n = b ∧ b + m = a → n = 0</code>.  Combining that with our statement from the start of the proof, we get <code>a + n = b ∧ b + m = a → a + n = b ∧ n = 0</code>.  But the right hand side is, of course, just <code>LessEqualAntisymmetry-1</code> away from our desired <code>a = b</code>.
<jh>
        composeConjunction

        a (value n) b LessEqualAntisymmetry-1
        applySyllogism
))
</jh>

That lemma gets us most of the way. We just need to deal with a bit of predicate logic to finish our proof of antisymmetry, <code>a ≤ b ∧ b ≤ a → a = b</code>
<jh>
thm (LessEqualAntisymmetry ((n a) (n b) (n m) (m a) (m b)) () (((a ≤ b) ∧ (b ≤ a)) → (a = b)) (
        a b n LessEqual
        b a m LessEqual
        buildConjunction
        eliminateBiconditionalReverse

        n m ((a + (value n)) = b) ((b + (value m)) = a) ThereExistsScattering
        eliminateBiconditionalForward
        applySyllogism

        a n b m LessEqualAntisymmetry-3
        m addThereExists
        n addThereExists
        applySyllogism

        n (∃ m (a = b)) NullThereExists eliminateBiconditionalReverse
        applySyllogism

        m (a = b) NullThereExists eliminateBiconditionalReverse
        applySyllogism
))
</jh>

==== Totality ====
This section proves <code>a ≤ b ∨ b ≤ a</code>. The outline of the proof is as follows.  Proceed by induction on <code>b</code>. The base case follows from <code>0 ≤ a</code>. The induction step, <code>a ≤ k ∨ k ≤ a → a ≤ Sk ∨ Sk ≤ a</code>, has two cases. The <code>a ≤ k</code> case is easy: if <code>a</code> is less than <code>k</code>, it is also less than <code>Sk</code>. The <code>k ≤ a</code> case in turn has two cases, which amount to <code>k = a</code> and <code>k < a</code> (although our formal machinery isn't advanced enough to refer to them exactly that way in the proof).  In the first case, <code>k = a</code> easily implies <code>a ≤ Sk</code>. In the <code>k < a</code> case, we will show <code>Sk ≤ a</code> (via several steps, of which applying <code>Predecessor</code> is a key one).

Our first lemma is just working around a problem with JHilbert, as it exists now, and distinct variables. In a just world, it would just be an instance of <code>NullThereExists</code>, but JHilbert expands the definition of <code>a ≤ b</code>, thus introducing a variable which we need a distinct variable constraint for. The proof is just a matter of applying <code>LessEqual</code> so we can name the variable and the constraint.
<jh>
thm (NullThereExistsLessEqual ((n a) (n b) (n m) (a m) (b m)) () ((∃ n (a ≤ b)) ↔ (a ≤ b)) (
        a b m LessEqual
        n buildThereExists

        n (∃ m ((a + (value m)) = b)) NullThereExists
        applyBiconditionalTransitivity

        a b m LessEqual
        swapBiconditional
        applyBiconditionalTransitivity
))
</jh>

While we're at it, we prove another similar lemma we'll need later in the proof of totality.
<jh>
thm (NullThereExistsDisjunctionLessEqual ((n a) (n b) (n c) (n d)) () ((∃ n ((a ≤ b) ∨ (c ≤ d))) ↔ ((a ≤ b) ∨ (c ≤ d))) (
        n (a ≤ b) (c ≤ d) ThereExistsDisjunction

        n a b NullThereExistsLessEqual
        n c d NullThereExistsLessEqual
        buildDisjunction
        applyBiconditionalTransitivity
))
</jh>

The key result for the <code>a ≤ k</code> case is <code>a ≤ k → a ≤ Sk</code>.
<jh>
thm (LessEqualSuccessor ((k a) (k n) (n a)) () ((a ≤ (value k)) → (a ≤ (succ (value k)))) (
        a (value k) n LessEqual
        eliminateBiconditionalReverse
</jh>
So far we have <code>a ≤ k → ∃ n a + n = k</code>. We take the successor of both sides of the equality and rearrange to get <code>a + Sn = Sk</code>
<jh>
        (a + (value n)) (value k) Successor
        eliminateBiconditionalForward

        a (value n) Addition
        (succ (value k)) buildEqualityRR
        eliminateBiconditionalForward
        applySyllogism
</jh>
But <code>a + Sn = Sk</code> implies <code>a ≤ Sk</code> and a bit of work with the quantifier gives us <code>a ≤ k → a ≤ Sk</code>.
<jh>
        a (succ (value n)) (succ (value k)) LessEqualObject
        applySyllogism

        n addThereExists
        applySyllogism

        n a (succ (value k)) NullThereExistsLessEqual
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

What we actually need for the <code>a ≤ k</code> case is a slight variation of that, <code>a ≤ k → a ≤ Sk ∨ Sk ≤ a</code>.
<jh>
thm (TotalityLemmaALessEqualK ((a k)) () ((a ≤ (value k)) → ((a ≤ (succ (value k))) ∨ ((succ (value k)) ≤ a))) (
        a k LessEqualSuccessor

        (a ≤ (succ (value k))) ((succ (value k)) ≤ a) DisjunctionRightIntroduction
        applySyllogism
))
</jh>

The <code>a = k</code> case we express as <code>m = 0 → (k + m = a → a ≤ Sk ∨ Sk ≤ a)</code>. We prove it via several lemmas.
<jh>
thm (TotalityLemmaAEqualK-1 () () (((value m) = (0)) → ((((value k) + (value m)) = a) → ((value k) = a))) (
        (value m) (0) (value k) AdditionBuilderLL

        (value k) AdditiveIdentity
        ((value m) = (0)) introduceAntecedent

        applyEqualityTransitivityInConsequent

        a buildEqualityRRInConsequent
        eliminateBiconditionalReverseInConsequent
))

thm (TotalityLemmaAEqualK-2a () () ((a = (value k)) → (a ≤ (value k))) (
        a (value k) (0) AdditionBuilderRR
        (value k) AdditiveIdentity
        (a + (0)) buildEqualityLL
        eliminateBiconditionalReverse
        applySyllogism
</jh>
That gives us <code>a = k → a + 0 = k</code>.
<jh>
        a (0) (value k) LessEqualObject
        applySyllogism
))

thm (TotalityLemmaAEqualK-2 ((a k)) () ((a = (value k)) → (a ≤ (succ (value k)))) (
        a k TotalityLemmaAEqualK-2a
        a k LessEqualSuccessor
        applySyllogism
))

thm (TotalityLemmaAEqualK ((a k)) () (((value m) = (0)) → ((((value k) + (value m)) = a) → ((a ≤ (succ (value k))) ∨ ((succ (value k)) ≤ a)))) (
        m k a TotalityLemmaAEqualK-1

        (value k) a EqualitySymmetry eliminateBiconditionalReverse
        a k TotalityLemmaAEqualK-2
        applySyllogism

        (a ≤ (succ (value k))) ((succ (value k)) ≤ a) DisjunctionRightIntroduction
        applySyllogism

        (((value k) + (value m)) = a) addCommonAntecedent
        applySyllogism
))
</jh>

The <code>k < a</code> case we express as <code>m ≠ 0 → (k + m = a → a ≤ Sk ∨ Sk ≤ a)</code>. Here is an outline of the proof of this case. We will be proving that <code>m ≠ 0</code> and <code>k + m = a</code> imply <code>Sk ≤ a</code>. To do this we need a number <code>n</code> for which <code>Sk + n = a</code>. The predecessor of <code>m</code> is the value we choose.
<jh>
thm (TotalityLemmaKLessThanA ((n m) (n k) (n a)) () (((value m) ≠ (0)) → ((((value k) + (value m)) = a) → ((a ≤ (succ (value k))) ∨ ((succ (value k)) ≤ a)))) (
        (value m) n Predecessor
</jh>
Next we show <code>Sn = m → (k + m = a → k + Sn = a)</code>
<jh>
        (succ (value n)) (value m) (value k) AdditionBuilderLL
        a buildEqualityRRInConsequent
        eliminateBiconditionalForwardInConsequent
</jh>
Adding ∃ and combining with the previous step gives <code>m ≠ 0 → ∃ n (k + m = a → k + Sn = a)</code>
<jh>
        n addThereExists
        applySyllogism
</jh>
We move <code>k + m = a</code> out of the quantifier.
<jh>
        n (((value k) + (value m)) = a) (((value k) + (succ (value n))) = a) ThereExistsAntecedentMovement
        eliminateBiconditionalReverse
        applySyllogism
</jh>
We have <code>m ≠ 0 → (k + m = a → ∃ n k + Sn = a)</code>. We transform <code>k + Sn = a</code> into <code>Sk + n = a</code>.
<jh>
        (value k) (value n) Addition

        (value k) (value n) AdditionCommutativity
        addSuccessor
        applyEqualityTransitivity

        (value n) (value k) Addition
        swapEquality
        applyEqualityTransitivity

        (value n) (succ (value k)) AdditionCommutativity
        applyEqualityTransitivity

        a buildEqualityRR

        n buildThereExists
        transformImplicationImplicationConsequent
</jh>
Now we show that <code>∃ n Sk + n = a</code> implies <code>a ≤ Sk ∨ Sk ≤ a</code>,
<jh>
        (succ (value k)) a n LessEqual eliminateBiconditionalForward
        ((succ (value k)) ≤ a) (a ≤ (succ (value k))) DisjunctionLeftIntroduction
        applySyllogism
</jh>
and assemble the result.
<jh>
        (((value k) + (value m)) = a) addCommonAntecedent
        ((value m) ≠ (0)) addCommonAntecedent
        applyModusPonens
))
</jh>

Taking one step back, the combination of the <code>a = k</code> and <code>k < a</code> cases is the <code>k ≤ a</code> case, <code>k ≤ a → a ≤ Sk ∨ Sk ≤ a</code>.
<jh>
thm (TotalityLemmaKLessEqualA ((a k) (m a) (m k)) () (((value k) ≤ a) → ((a ≤ (succ (value k))) ∨ ((succ (value k)) ≤ a))) (
</jh>
We start with <code>k ≤ a → ∃ m k + m = a</code>.
<jh>
        (value k) a m LessEqual
        eliminateBiconditionalReverse
</jh>
That <code>k + m = a → a ≤ Sk ∨ Sk ≤ a</code> is just the combination of the <code>a = k</code> and <code>k < a</code> cases.
<jh>
        m k a TotalityLemmaAEqualK
        m k a TotalityLemmaKLessThanA
        eliminateCases
</jh>
Now we just add ∃ and combine with the previous result to get <code>k ≤ a → ∃ m a ≤ Sk ∨ Sk ≤ a</code>.
<jh>
        m addThereExists
        applySyllogism
</jh>
Since m does not occur in <code>a ≤ Sk ∨ Sk ≤ a</code>, the quantifier is unnecessary, and we are done.
<jh>
        m a (succ (value k)) (succ (value k)) a NullThereExistsDisjunctionLessEqual
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

We are ready to return to the proof of <code>a ≤ b ∨ b ≤ a</code> by induction. We first prove the substitution. Conceptually, it is <code>n = sub → (a ≤ n ∨ n ≤ a ↔ a ≤ sub ∨ sub ≤ a</code>.  However, as long as JHilbert automatically expands definitions, we need to expand each definition of <code>≤</code> so that we can express the distinct variable constraints with the dummy variables.
<jh>
var (variable an na)
thm (Totality-sub ((an n) (an sub) (na n) (na sub)) () (
  ((value n) = sub) → (
    ((∃ an ((a + (value an)) = (value n))) ∨ (∃ na (((value n) + (value na)) = a))) ↔ 
    ((∃ an ((a + (value an)) = sub)) ∨ (∃ na ((sub + (value na)) = a)))
  )) (
 # Without the need to expand ≤, this would be:
 #        (value n) sub a LessEqualBuilderLL
 #        (value n) sub a LessEqualBuilderRR
 #        buildDisjunctionInConsequent
        (value n) sub (a + (value an)) EqualityBuilderLL
        an addForAllToConsequent
        an ((a + (value an)) = (value n)) ((a + (value an)) = sub) ForAllBiconditionalThereExists
        applySyllogism

        (value n) sub (value na) AdditionBuilderRR
        a buildEqualityRRInConsequent
        na addForAllToConsequent
        na (((value n) + (value na)) = a) ((sub + (value na)) = a) ForAllBiconditionalThereExists
        applySyllogism

        buildDisjunctionInConsequent
))
</jh>
And here is the proof, by induction on <code>b</code>.
<jh>
thm (LessEqualTotality ((n k an na) (n a an na) (n b an na) (k a)) () ((a ≤ b) ∨ (b ≤ a)) (
        n (0) an a na Totality-sub
        n (value k) an a na Totality-sub
        n (succ (value k)) an a na Totality-sub
        n b an a na Totality-sub
</jh>
The base case is <code>a ≤ 0 ∨ 0 ≤ a</code>.
<jh>
        a ZeroSmallest
        (a ≤ (0)) introduceLeftDisjunction
</jh>
Due to the issue with distinct variables discussed at <code>Totality-sub</code>, we need to expand the inequalities.
<jh>
        a (0) an LessEqual
        (0) a na LessEqual
        buildDisjunction
        eliminateBiconditionalReverse
        applyModusPonens
</jh>
The induction step is <code>a ≤ k ∨ k ≤ a → a ≤ Sk ∨ Sk ≤ a</code>.
<jh>
        a k TotalityLemmaALessEqualK
        k a TotalityLemmaKLessEqualA
        composeDisjunction
</jh>
Due to the issue with distinct variables discussed at <code>Totality-sub</code>, we need to expand the inequalities.
<jh>
        a (value k) an LessEqual
        (value k) a na LessEqual
        buildDisjunction

        a (succ (value k)) an LessEqual
        (succ (value k)) a na LessEqual
        buildDisjunction

        buildImplication
        eliminateBiconditionalReverse
        applyModusPonens

        Induction6S
</jh>
Due to the issue with distinct variables discussed at <code>Totality-sub</code>, we unexpand the inequalities.
<jh>
        a b an LessEqual
        b a na LessEqual
        buildDisjunction
        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

=== Consequences of total order properties ===
Reflexivity follows from totality:
<jh>
thm (LessEqualReflexivity () () (a ≤ a) (
        a a LessEqualTotality
        conflateDisjunction
))
</jh>

Equality implies <code>≤</code>.
<jh>
thm (EqualityLessEqual () () ((a = b) → (a ≤ b)) (
        a LessEqualReflexivity

        a b a LessEqualBuilderLL
</jh>
The builder gives us <code>a = b → (a ≤ a ↔ a ≤ b)</code>.  But <code>a ≤ a</code> is a theorem, so we are done.
<jh>
        detachImplicationBiconditional
))
</jh>

==== Strict order ====
Here we define <code><</code>, as well as <code>></code> and <code>≥</code>.
<jh>
def ((< a b) ((a ≤ b) ∧ (a ≠ b)))
def ((> b a) (a < b))
def ((≥ b a) (a ≤ b))
</jh>

We next prove <code>a ≤ b ↔ a < b ∨ a = b</code> (finally justifying the informal name "less than or equal to" for <code>≤</code>). The proof is fairly straightforward expansion of the definition and rearrangement, but it will be easier to break out part of the proof into a lemma.
<jh>
thm (LessEqualLessThanLemma () () ((a ≤ b) ↔ (((a ≤ b) ∨ (a = b)) ∧ ((a ≠ b) ∨ (a = b)))) (
</jh>
We start with the forward implication. The first half is <code>a ≤ b → a ≤ b ∨ a = b</code>
<jh>
        (a ≤ b) (a = b) DisjunctionRightIntroduction
</jh>
The second half is <code>a ≤ b → a ≠ b ∨ a = b</code>
<jh>
        (a = b) TertiumNonDatur swapDisjunction
        (a ≤ b) introduceAntecedent
</jh>
Combining these gives us the forward implication.
<jh>
        composeConjunction
</jh>
Moving on to the reverse implication, we start with <code>(a ≤ b ∨ a = b) ∧ (a ≠ b ∨ a = b) → a ≤ b ∨ a = b</code>
<jh>
        ((a ≤ b) ∨ (a = b)) ((a ≠ b) ∨ (a = b)) ConjunctionRightElimination
</jh>
Then we show <code>a ≤ b ∨ a = b → a ≤ b</code>.
<jh>
        (a ≤ b) ImplicationReflexivity
        a b EqualityLessEqual
        composeDisjunction
</jh>
Combining these gives the reverse implication,
<jh>
        applySyllogism
</jh>
and combining forward and reverse implications completes the proof.
<jh>
        introduceBiconditionalFromImplications
))

thm (LessEqualLessThan () () ((a ≤ b) ↔ ((a < b) ∨ (a = b))) (
        a b LessEqualLessThanLemma

        (a ≤ b) (a ≠ b) (a = b) DisjunctionRightDistribution
        swapBiconditional
        applyBiconditionalTransitivity
</jh>
That gives us <code>a ≤ b ↔ (a ≤ b ∧ a ≠ b) ∨ a = b</code>.  But <code>a ≤ b ∧ a ≠ b</code> is just the definition of <code><</code>, so this is enough.
<jh>
))
</jh>

For parallelism, we also provide the definition of <code><</code> as a theorem.
<jh>
thm (LessThanLessEqual () () ((a < b) ↔ ((a ≤ b) ∧ (a ≠ b))) (
        (a < b) BiconditionalReflexivity
))
</jh>

The builder for <code><</code> is a consequence of the one for <code>≤</code>.

<jh>
thm (LessThanBuilder () () (((a0 = a1) ∧ (b0 = b1)) → ((a0 < b0) ↔ (a1 < b1))) (
        a0 a1 b0 b1 LessEqualBuilder

        a0 a1 b0 b1 EqualityBuilder
        addNegationInConsequent

        buildConjunctionInConsequent
))

thm (LessThanBuilderLL () () ((b0 = b1) → ((a < b0) ↔ (a < b1))) (
        a EqualityReflexivity
        a a b0 b1 LessThanBuilder
        detach1of2
))

thm (LessThanBuilderRR () () ((a0 = a1) → ((a0 < b) ↔ (a1 < b))) (
        b EqualityReflexivity
        a0 a1 b b LessThanBuilder
        detach2of2
))

thm (buildLessThan () ((HA (a0 = a1)) (HB (b0 = b1))) ((a0 < b0) ↔ (a1 < b1)) (
        HA
        HB
        introduceConjunction
        a0 a1 b0 b1 LessThanBuilder
        applyModusPonens
))

thm (buildLessThanLL () ((HB (b0 = b1))) ((a < b0) ↔ (a < b1)) (
        HB
        b0 b1 a LessThanBuilderLL
        applyModusPonens
))

thm (buildLessThanRR () ((HA (a0 = a1))) ((a0 < b) ↔ (a1 < b)) (
        HA
        a0 a1 b LessThanBuilderRR
        applyModusPonens
))
</jh>

==== Transitivity ====
We start by proving that <code>a ≤ b ∧ b < c → a < c</code>. This has transitivity for <code><</code> as an immediate consequence, but will occasionally be useful in its own right.

The first lemma constitutes the easy part of the proof.
<jh>
thm (LessEqualLessThanTransitivity-1 () () (((a ≤ b) ∧ (b < c)) → (a ≤ c)) (
        (b ≤ c) (b ≠ c) ConjunctionRightElimination
        (a ≤ b) conjoinLL

        a b c LessEqualTransitivity
        applySyllogism
))
</jh>

The harder part of the proof is that <code>a ≤ b ∧ b < c → a ≠ c</code>.  This is fairly easy to sketch out: suppose that <code>a ≤ b ∧ b < c</code> and that <code>a = c</code>. Applying <code>a = c</code> to the first formula gives <code>a ≤ b ∧ b ≤ a</code>, and thus <code>a = b</code> by antisymmetry. But <code>a = b</code> and <code>a = c</code> imply <code>b = c</code>, and this contradicts <code>b < c</code>.  Here is one way to formalize that argument.
<jh>
thm (LessEqualLessThanTransitivity-2 () () (((a ≤ b) ∧ (b < c)) → (a ≠ c)) (
</jh>
We start with a substitution, <code>a = c → (a ≤ b ∧ b < a ↔ a ≤ b ∧ b < c)</code>
<jh>
        a c b LessThanBuilderLL
        (a ≤ b) buildConjunctionLLInConsequent
</jh>
Taking the reverse direction of the biconditional, expanding the definition of <code>b < a</code> and assocating the conjunctions gives <code>a = c → (a ≤ b ∧ b < c → (a ≤ b ∧ b ≤ a) ∧ b ≠ a)</code>
<jh>
        eliminateBiconditionalForwardInConsequent

        (a ≤ b) (b ≤ a) (b ≠ a) ConjunctionAssociativity
        swapBiconditional
        transformImplicationImplicationConsequent
</jh>
But <code>a ≤ b ∧ b ≤ a</code> implies <code>b = a</code>,
<jh>
        a b LessEqualAntisymmetry

        a b EqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
so <code>(a ≤ b ∧ b ≤ a) ∧ b ≠ a</code> implies <code>⊥</code> (false).
<jh>
        (b ≠ a) conjoinRR

        (b = a) Contradiction
        eliminateBiconditionalReverse
        applySyllogism
</jh>
The next step is <code>(a ≤ b ∧ b < c → (a ≤ b ∧ b ≤ a) ∧ b ≠ a) → ¬ (a ≤ b ∧ b < c)</code>.
<jh>
        ((a ≤ b) ∧ (b < c)) addCommonAntecedent

        ((a ≤ b) ∧ (b < c)) NegationImplication
        eliminateBiconditionalForward
        applySyllogism
</jh>
Combining that with the previous result gives <code>a = c → ¬ (a ≤ b ∧ b < c)</code>.
<jh>
        applySyllogism
</jh>
And a transposition finishes the job.
<jh>
        transposeWithNegatedConsequent
))
</jh>

Combining the two lemmas gives us transitivity for <code>a ≤ b ∧ b < c</code>.
<jh>
thm (LessEqualLessThanTransitivity () () (((a ≤ b) ∧ (b < c)) → (a < c)) (
        a b c  LessEqualLessThanTransitivity-1
        a b c  LessEqualLessThanTransitivity-2
        composeConjunction
))
</jh>

Transitivity for <code><</code> is an immediate consequence.
<jh>
thm (LessThanLessEqualImplication () () ((a < b) → (a ≤ b)) (
        (a ≤ b) (a ≠ b) ConjunctionRightElimination
))

thm (LessThanTransitivity () () (((a < b) ∧ (b < c)) → (a < c)) (
        a b LessThanLessEqualImplication

        (b < c) conjoinRR

        a b c LessEqualLessThanTransitivity
        applySyllogism
))
</jh>

==== Strict order totality ====
Exactly one of <code>a < b</code>, <code>a = b</code>, or <code>a > b</code> holds. We start with the proposition that at least one of the three holds.
<jh>
thm (LessThanTotality () () (((a < b) ∨ (a = b)) ∨ (a > b)) (
</jh>
The meat of the proof is <code>(a < b ∨ a = b) ∨ (b < a ∨ b = a)</code>.
<jh>
        a b LessEqualTotality

        a b LessEqualLessThan
        b a LessEqualLessThan
        buildDisjunction

        eliminateBiconditionalReverse
        applyModusPonens
</jh>
We just need to do some rearranging to finish.
<jh>
        swap23ofDisjunction4

        b a EqualitySymmetry
        (a = b) buildDisjunctionLL

        (a = b) DisjunctionIdempotence
        swapBiconditional
        applyBiconditionalTransitivity

        transformDisjunctionRight

        swap23ofDisjunction3
))
</jh>

The following theorems imply that no more than one of <code>a < b</code>, <code>a = b</code>, or <code>a > b</code> holds.
<jh>
thm (LessThanEquality () () ((a < b) → (a ≠ b)) (
        a b LessThanLessEqual
        eliminateBiconditionalReverse

        (a ≤ b) (a ≠ b) ConjunctionLeftElimination

        applySyllogism
))

thm (LessThanGreaterThan () () ((a < b) → (¬ (a > b))) (
        a EqualityReflexivity

</jh>
We start with <code>a < b ∧ b < a → a < a</code>.
<jh>
        a b a LessThanTransitivity
</jh>
Using the previous theorem we turn this into <code>a < b ∧ b < a → a ≠ a</code>.
<jh>
        a a LessThanEquality
        applySyllogism

</jh>
Since <code>a = a</code> is a theorem, this gives us <code>¬ (a < b ∧ b < a)</code>
<jh>
        transposeWithNegatedConsequent
        applyModusPonens
</jh>
A bit of propositional logic turns this into what we need.
<jh>
        distributeNegationPCP
        convertToImplicationFromDisjunction
))

thm (EqualityLessThan () () ((a = b) → (¬ (a < b))) (
        a b LessThanEquality
        transposeWithNegatedConsequent
))
</jh>

=== This order is consistent with addition ===
<jh>
thm (LessEqualAdditionRR ((a n) (b n) (c n)) () ((a ≤ b) ↔ ((a + c) ≤ (b + c))) (
        a b n LessEqual
</jh>
The right hand side is now <code>∃ n a + n = b</code>. We add <code>c</code> to both sides of the equality,
<jh>
        (a + (value n)) c b AdditionCancellationRight
        swapBiconditional
</jh>
rewrite it as <code>(a + c) + n = b + c</code>,
<jh>
        a (value n) c Addition3
        (b + c) buildEqualityRR
        applyBiconditionalTransitivity
</jh>
and reinstate the quantifier to get <code>a ≤ b ↔ ∃ n (a + c) + n = b + c</code>.
<jh>
        n buildThereExists
        applyBiconditionalTransitivity
</jh>
Applying <code>LessEqual</code> we are done.
<jh>
        (a + c) (b + c) n LessEqual
        swapBiconditional
        applyBiconditionalTransitivity
))
</jh>

Here is the same theorem with the additions commuted.
<jh>
thm (LessEqualAdditionLL () () ((b0 ≤ b1) ↔ ((a + b0) ≤ (a + b1))) (
        b0 b1 a LessEqualAdditionRR

        b0 a AdditionCommutativity
        b1 a AdditionCommutativity
        buildLessEqual

        applyBiconditionalTransitivity
))
</jh>

Combining the two gives the full theorem.
<jh>
thm (LessEqualAddition () () (((a0 ≤ a1) ∧ (b0 ≤ b1)) → ((a0 + b0) ≤ (a1 + b1))) (
        (a0 ≤ a1) (b0 ≤ b1) ConjunctionRightElimination
        a0 a1 b0 LessEqualAdditionRR
        eliminateBiconditionalReverse
        applySyllogism
</jh>
That gives us <code>a0 ≤ a1 ∧ b0 ≤ b1 → a0 + b0 ≤ a1 + b0</code>. Now we apply a similar technique to also get <code>a0 ≤ a1 ∧ b0 ≤ b1 → a1 + b0 ≤ a1 + b1</code>.
<jh>
        (a0 ≤ a1) (b0 ≤ b1) ConjunctionLeftElimination
        b0 b1 a1 LessEqualAdditionLL
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Combining these two finishes the proof.
<jh>
        composeConjunction
        (a0 + b0) (a1 + b0) (a1 + b1) LessEqualTransitivity
        applySyllogism
))
</jh>

Here we prove the analogous theorems for the strict order.
<jh>
thm (LessThanAdditionRR () () ((a0 < a1) ↔ ((a0 + b) < (a1 + b))) (
        a0 a1 b LessEqualAdditionRR

        a0 b a1 AdditionCancellationRight
        swapBiconditional
        addNegation

        buildConjunction
))

thm (LessThanAdditionLL () () ((b0 < b1) ↔ ((a + b0) < (a + b1))) (
        b0 b1 a LessEqualAdditionLL

        a b0 b1 AdditionCancellationLeft
        swapBiconditional
        addNegation

        buildConjunction
))

thm (LessEqualLessThanAddition () () (((a0 ≤ a1) ∧ (b0 < b1)) → ((a0 + b0) < (a1 + b1))) (
</jh>
First we show <code>a0 ≤ a1 ∧ b0 < b1 → a0 + b0 ≤ a1 + b0</code>.
<jh>
        (a0 ≤ a1) (b0 < b1) ConjunctionRightElimination
        a0 a1 b0 LessEqualAdditionRR
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next is <code>a0 ≤ a1 ∧ b0 < b1 → a1 + b0 < a1 + b1</code>.
<jh>
        (a0 ≤ a1) (b0 < b1) ConjunctionLeftElimination
        b0 b1 a1 LessThanAdditionLL
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Combining the two finishes the proof.
<jh>
        composeConjunction
        (a0 + b0) (a1 + b0) (a1 + b1) LessEqualLessThanTransitivity
        applySyllogism
))

thm (LessThanAddition () () (((a0 < a1) ∧ (b0 < b1)) → ((a0 + b0) < (a1 + b1))) (
        a0 a1 LessThanLessEqualImplication
        (b0 < b1) conjoinRR

        a0 a1 b0 b1 LessEqualLessThanAddition

        applySyllogism
))
</jh>

=== This order is consistent with multiplication ===
In systems admitting negative numbers, such as the integers or reals, the term "multiplication is consistent with ≤" will generally refer to a weaker result, such as <code>0 ≤ b ∧ 0 ≤ c → 0 ≤ b · c</code>. But we prove a more powerful theorem, <code>a ≤ b → a · c ≤ b · c</code>
<jh>
thm (LessEqualAdditionRRForward ((a n) (b n) (c n)) () ((a ≤ b) → ((a · c) ≤ (b · c))) (
        a b n LessEqual
        eliminateBiconditionalReverse

        (a + (value n)) b c MultiplicationBuilderRR
</jh>
That gives <code>a + n = b → (a + n) · c = b · c</code>. Distributivity turns <code>(a + n) · c</code> into <code>a · c + n · c</code>.
<jh>
        a (value n) c RightDistribution
        (b · c) buildEqualityRR
        eliminateBiconditionalReverse
        applySyllogism
</jh>
But <code>a · c + n · c = b · c</code> implies <code>a · c ≤ b · c</code>.
<jh>
        (a · c) ((value n) · c) (b · c) LessEqualObject
        applySyllogism
</jh>
Adding back the quantifier and reassembling, we get <code><code>a ≤ b → ∃ n a · c ≤ b · c</code>.
<jh>
        n addThereExists
        applySyllogism
</jh>
Removing the quantifier we are done.
<jh>
        n (a · c) (b · c) NullThereExistsLessEqual
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

== Adding one and successor ==

Before we export to [[Interface:Basic arithmetic]], we have one style point to clear up.  The induction theorems there are stated in terms of <code>k + 1</code> (as that file does not have the successor operation).

<jh>
thm (SuccessorAddsOne () () ((a + (1)) = (succ a)) (
        a (0) Addition

        a AdditiveIdentityRight
        addSuccessor

        applyEqualityTransitivity
))

thm (Induction6 ((n a) (φ0 n) (φk n) (φSk n) (φa n) (φ k) (n k))
  ((HSUB0 (((value n) = (0)) → (φ ↔ φ0)))
   (HSUBK (((value n) = (value k)) → (φ ↔ φk)))
   (HSUBSK (((value n) = ((value k) + (1))) → (φ ↔ φSk)))
   (HSUBA (((value n) = a) → (φ ↔ φa)))
   (HBASE φ0)
   (HIND (φk → φSk))
  )
  φa (
        HSUB0 HSUBK

        (value k) SuccessorAddsOne
        (value n) buildEqualityLL
        eliminateBiconditionalForward
        HSUBSK
        applySyllogism

        HSUBA HBASE HIND
        Induction6S
))
</jh>

Changing <code>succ k</code> to <code>k + 1</code> in the <code>subst</code>-based form of induction is a simple application of builders. We apply the builders via several lemmas:

<jh>
thm (InductionSubst-1 () ()
  ((subst ((value k) + (1)) n φ) ↔ (subst (succ (value k)) n φ)) (
        (value k) SuccessorAddsOne
        n φ buildSubstReplacement
))

thm (InductionSubst-2 () ()
  ((∀ k ((subst (value k) n φ) → (subst ((value k) + (1)) n φ))) ↔
   (∀ k ((subst (value k) n φ) → (subst (succ (value k)) n φ)))) (
        (subst (value k) n φ) BiconditionalReflexivity
        k n φ InductionSubst-1
        buildImplication
        k buildForAll
))

thm (InductionSubst-3 () ()
  ((((subst (0) n φ) ∧ 
     (∀ k ((subst (value k) n φ) → (subst ((value k) + (1)) n φ)))) 
    → (∀ n φ)) ↔
  (((subst (0) n φ) ∧ 
     (∀ k ((subst (value k) n φ) → (subst (succ (value k)) n φ)))) 
    → (∀ n φ))) (
        (subst (0) n φ) BiconditionalReflexivity
        k n φ InductionSubst-2
        buildConjunction

        (∀ n φ) BiconditionalReflexivity
        buildImplication
))

thm (InductionSubst () () 
  (((subst (0) n φ) ∧ 
    (∀ k ((subst (value k) n φ) → (subst ((value k) + (1)) n φ)))) 
   → (∀ n φ)) (
        n φ k Induction

        n φ k InductionSubst-3
        eliminateBiconditionalForward

        applyModusPonens
))
</jh>

== Export ==

<jh>
export (ARITHMETIC Interface:Basic_arithmetic (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>

[[Category:Elementary number theory|{{PAGENAME}}]]