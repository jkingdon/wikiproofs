{{interfaces
| imports = [[Interface:Out lines]]
| exports = [[Interface:Midpoint]]
}}

This is part of a series of modules which prove a variety of geometrical theorems starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

This page proves various results involving the midpoint of a line segment. We don't yet prove the existence of a midpoint (that's in the next chapter).

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Line segment inequality|geometry results so far]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (START Interface:Line_segment_inequality (CLASSICAL FIRSTORDER) ())

var (point A B C D E F M P Q R S X Y Z A′ B′ C′ D′ E′ B″ C″ P′ Q′ X′ Y′)
var (point P1 P2)
var (variable a b c c′ d d′ e e′ f p p′ x x′ y y′ z)
</jh>

== Midpoint defined ==
A point is the midpoint of a line segment if it is between the endpoints and is equidistant from each one.
<jh>
def ((is-midpoint-of M A B) ((between A M B) ∧ (A M ≡ M B)))
</jh>

Whether a point is the midpoint does not depend on the order in which we list the endpoints.<ref>Lemma l7_2 in Narboux</ref> This is easily proved from the corresponding theorems for betweenness and congruence.
<jh>
thm (MidpointSymmetry () ()
  ((M is-midpoint-of A B) ↔ (M is-midpoint-of B A)) (
        A M B BetweennessSymmetry

        A M M B CongruenceSymmetry
        M B A M CongruenceCommutativity
        applyBiconditionalTransitivity

        buildConjunction
))
</jh>

The only midpoint of an empty line segment is the endpoint of the line segment.<ref>l7_3 in Narboux</ref>
<jh>
thm (IndivisibilityBiconditional () () ((between A B A) ↔ (A = B)) (
        A B IndivisibilityBidirectional
))

thm (MidpointIndivisibility () ()
  ((M is-midpoint-of A A) → (M = A)) (
        (between A M A) (A M ≡ M A) ConjunctionRightElimination

        A M IndivisibilityBiconditional
        eliminateBiconditionalReverse
        applySyllogism

        A M EqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

The endpoint of an empty line segment is a midpoint of that segment.<ref>Lemma l7_3_2 in Narboux</ref>
<jh>
thm (MidpointReflexivity () () (A is-midpoint-of A A) (
        A A BetweenAAB
        A A CongruenceReflexivity
        introduceConjunction
))
</jh>

== Reflection through a point ==
[[w:Point reflection|Point symmetry]], or reflection through a point, refers to the process of starting with a single point (which in special cases might be called the origin or the center) and mapping every point to a point directly opposite the given point (at the same distance).

=== Existence of the symmetric point ===
Given a point <code>A</code>, the symmetric point of <code>P</code> through <code>A</code> is a point <code>P′</code> such that <code>A is-midpoint-of P P′</code>. This point always exists and is unique. We first prove existence.<ref>symmetric_point_construction in Narboux, with the cosmetic change that Narboux interchanges A and P</ref> The proof just applies line segment construction to extend the line segment <code>P A</code> to a point <code>p′</code> by a distance of <code>P A</code>, or in other words, <code>∃ p′ (between P A p′ ∧ A p′ ≡ P A)</code>.
<jh>
thm (SymmetricPoint ((p′ A) (p′ P)) ()
  (∃ p′ (A is-midpoint-of P (value p′))) (
        p′ P A P A SegmentConstruction

        A (value p′) P A CongruenceSymmetry
        eliminateBiconditionalReverse
        (between P A (value p′)) conjoinLL
        p′ addThereExists
        applyModusPonens
))
</jh>

=== Symmetric point uniqueness ===
Uniqueness is <code>A is-midpoint-of P P1 ∧ A is-midpoint-of P P2 → P1 = P2</code>.<ref>symmetric_point_unicity in Narboux, again exchanging A and P</ref> We first consider the <code>P = A</code> case, which is just a matter of applying <code>CongruenceIdentityFromEquality</code>
<jh>
thm (SymmetricPointUniqueness-pa () ()
  (((P = A) ∧ ((A is-midpoint-of P P1) ∧ (A is-midpoint-of P P2))) →
    (P1 = P2)) (
</jh>
Our first application of <code>CongruenceIdentityFromEquality</code> will be <code>P = A ∧ P A ≡ A P1 → A = P1</code>. After that, we flip <code>A = P1</code> to <code>P1 = A</code>.
<jh>
        (P = A)
          ((A is-midpoint-of P P1) ∧ (A is-midpoint-of P P2))
          ConjunctionRightElimination

        (P = A)
          ((A is-midpoint-of P P1) ∧ (A is-midpoint-of P P2))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction

        P A A P1 CongruenceIdentityFromEquality
        applySyllogism

        A P1 EqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
The other application of <code>CongruenceIdentityFromEquality</code> is the same thing but with <code>P2</code>.
<jh>
        (P = A)
          ((A is-midpoint-of P P1) ∧ (A is-midpoint-of P P2))
          ConjunctionRightElimination

        (P = A)
          ((A is-midpoint-of P P1) ∧ (A is-midpoint-of P P2))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction

        P A A P2 CongruenceIdentityFromEquality
        applySyllogism
</jh>
Combining the two gives <code>P1 = P2</code>.
<jh>
        composeConjunction
        P1 A P2 EqualityTransitivity
        applySyllogism
))
</jh>

The <code>P ≠ A</code> case is a straightforward application of <code>SegmentConstructionUniqueness</code>.
<jh>
thm (SymmetricPointUniqueness-pnota () ()
  (((P ≠ A) ∧ ((A is-midpoint-of P P1) ∧ (A is-midpoint-of P P2))) →
    (P1 = P2)) (
</jh>
First, <code>P ≠ A</code>.
<jh>
        (P ≠ A)
          ((A is-midpoint-of P P1) ∧ (A is-midpoint-of P P2))
          ConjunctionRightElimination
</jh>
Next, <code>between P A P1</code>.
<jh>
        (P ≠ A)
          ((A is-midpoint-of P P1) ∧ (A is-midpoint-of P P2))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
Next, <code>A P1 ≡ P A</code>.
<jh>
        (P ≠ A)
          ((A is-midpoint-of P P1) ∧ (A is-midpoint-of P P2))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        P A A P1 CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
The corresponding statements for <code>P2</code> are similar, which are <code>between P A P2</code>,
<jh>
        (P ≠ A)
          ((A is-midpoint-of P P1) ∧ (A is-midpoint-of P P2))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
and <code>A P2 ≡ P A</code>
<jh>
        (P ≠ A)
          ((A is-midpoint-of P P1) ∧ (A is-midpoint-of P P2))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        P A A P2 CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        P A P1 P A P2 SegmentConstructionUniqueness
        applySyllogism
))
</jh>

Combining the two cases completes the proof of uniqueness.
<jh>
thm (SymmetricPointUniqueness () ()
  (((A is-midpoint-of P P1) ∧ (A is-midpoint-of P P2)) →
    (P1 = P2)) (
        P A P1 P2 SymmetricPointUniqueness-pa
        export

        P A P1 P2 SymmetricPointUniqueness-pnota
        export

        eliminateCases
))
</jh>

=== One to one ===
Reflecting through a point is one to one.<ref>Lemma l7_9 in Narboux</ref>
<jh>
thm (SymmetricPointOneToOne () ()
  (((A is-midpoint-of P1 P) ∧ (A is-midpoint-of P2 P)) →
    (P1 = P2)) (
        A P1 P MidpointSymmetry
        A P2 P MidpointSymmetry
        buildConjunction
        eliminateBiconditionalReverse

        A P P1 P2 SymmetricPointUniqueness
        applySyllogism
))
</jh>

=== Distance-preserving ===
Reflecting through a point preserves distances. That is, <code>A is-midpoint-of P′ P ∧ A is-midpoint-of Q′ Q → P Q ≡ P′ Q′</code>.<ref>Lemma l7_13 in Narboux</ref>

[[File:Proof of lemma l7_13 in Narboux.svg|thumb|right|Proof that reflecting through a point preserves distance]]
The proof is a bit involved, so we'll start with a brief outline. The <code>P = A</code> case is trivial, so henceforth we assume <code>P ≠ A</code>. Starting with the line segment <code>P P′</code>, we extend the two endpoints to points <code>X</code> and <code>X′</code> (by a distance of <code>Q A</code> in both cases). Then we do something similar: extend both ends of <code>Q Q′</code> to <code>Y</code> and <code>Y′</code> by a distance of <code>P A</code>.

The next step is <code>X′ Y′ ≡ Y X</code>, which we get by applying five segment to baselines <code>X A X′</code> and <code>Y′ A Y</code> and points <code>Y′</code> and <code>X</code>.

Then we apply inner five segment to baselines <code>Y Q A</code> and <code>Y′ Q′ A</code> and points <code>X</code> and <code>X′</code>, which gives <code>Q X ≡ Q′ X′</code>.

Finally, applying inner five segment to baselines <code>X P A</code> and <code>X′ P′ A</code> and points Q and <code>Q′</code> yields <code>P Q ≡ P′ Q′</code>, as desired.

==== P = A case ====
We start formalizing this proof with the <code>P = A</code> case. Because <code>A</code> is the midpoint of <code>Q′ Q</code>, we know that <code>Q′ A ≡ Q A</code>, and we can substitute <code>P</code> for <code>A</code>. We can also substitute <code>P′</code> for <code>A</code>, as <code>A = P′</code> follows from <code>P = A</code> and <code>P′ A ≡ A P</code>.

To understand the organization of the proof, it is based on the substitution <code>A = P′ ∧ A = P → (Q′ A ≡ Q A ↔ Q′ P′ ≡ Q P)</code>.
<jh>
thm (SymmetricPointDistance-pa () ()
  (((P = A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) →
  (P Q ≡ P′ Q′)) (
</jh>
First we need <code>A = P′</code>, which follows from <code>P = A</code> and <code>P A ≡ A P′</code>.
<jh>
        (P = A)
          ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))
          ConjunctionRightElimination

        (P = A)
          ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        A P′ P MidpointSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        eliminateLeftConjunctInConsequent

        composeConjunction

        P A A P′ CongruenceIdentityFromEquality
        applySyllogism
</jh>
Second is <code>A = P</code>.
<jh>
        (P = A)
          ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))
          ConjunctionRightElimination

        P A EqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction 
</jh>
Last is <code>Q′ A ≡ Q A</code>
<jh>
        (P = A)
          ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        Q′ A A Q CongruenceRightCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
We're ready to prove and apply <code>A = P′ ∧ A = P → (Q′ A ≡ Q A ↔ Q′ P′ ≡ Q P)</code>.
<jh>
        Q EqualityReflexivity
        Q′ EqualityReflexivity
        Q′ Q′ A P′ Q Q A P CongruenceBuilder
        detach1of4
        detach2of3

        eliminateBiconditionalReverseInConsequent
        import

        applySyllogism
</jh>
Now we just need to rearrange <code>Q′ P′ ≡ Q P</code> into <code>P Q ≡ P′ Q′</code>.
<jh>
        Q′ P′ Q P CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        Q P Q′ P′ CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

==== Constructing X, X′, Y, and Y′ ====
The first step for the <code>P ≠ A</code> case is to construct the points we will need. The first lemma constructs two points (and we'll be able to use it twice, once for <code>x</code> and <code>x′</code> and once for <code>y</code> and <code>y′</code>).

<jh>
thm (SymmetricPointDistance-xx (
    (P x x′) (P′ x x′) (Q x x′) (A x x′)
  ) () (∃ x (∃ x′ (
    ((between P′ P (value x)) ∧ (P (value x) ≡ Q A)) ∧
      ((between (value x) P′ (value x′)) ∧ (P′ (value x′) ≡ Q A))
    ))) (
        x P′ P Q A SegmentConstruction

        x′ (value x) P′ Q A SegmentConstruction
        x generalize

        introduceConjunction

        x
          ((between P′ P (value x)) ∧ (P (value x) ≡ Q A))
          (∃ x′ ((between (value x) P′ (value x′)) ∧ (P′ (value x′) ≡ Q A)))
          ThereExistsConjunctionRightCombining
        applyModusPonens

        x′
          ((between P′ P (value x)) ∧ (P (value x) ≡ Q A))
          ((between (value x) P′ (value x′)) ∧ (P′ (value x′) ≡ Q A))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        x addThereExists
        applyModusPonens
))

thm (SymmetricPointDistance-xxyy (
    (P x x′ y y′) (P′ x x′ y y′) (Q x x′ y y′) (Q′ x x′ y y′) (A x x′ y y′)
  ) ()
  (((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) →
  (∃ x (∃ x′ (∃ y (∃ y′ (
    ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) ∧
    ((((between P′ P (value x)) ∧ (P (value x) ≡ Q A)) ∧
    ((between (value x) P′ (value x′)) ∧ (P′ (value x′) ≡ Q A))) ∧
    (((between Q′ Q (value y)) ∧ (Q (value y) ≡ P A)) ∧
    ((between (value y) Q′ (value y′)) ∧
      (Q′ (value y′) ≡ P A)))))))))) (
</jh>
First we stick something on the proof stack for later use.
<jh>
        ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) ImplicationReflexivity
</jh>
Leaving that aside, the next step is to construct our four points.
<jh>
        x x′ P′ P Q A SymmetricPointDistance-xx
        y y′ Q′ Q P A SymmetricPointDistance-xx
        introduceConjunction
</jh>
Now we move the quantifiers to the front.
<jh>
        x
          (∃ x′ (((between P′ P (value x)) ∧ (P (value x) ≡ Q A)) ∧
            ((between (value x) P′ (value x′)) ∧ (P′ (value x′) ≡ Q A))))
          (∃ y (∃ y′ (((between Q′ Q (value y)) ∧
              (Q (value y) ≡ P A)) ∧
            ((between (value y) Q′ (value y′)) ∧
              (Q′ (value y′) ≡ P A)))))
          ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applyModusPonens

        x′
          (((between P′ P (value x)) ∧ (P (value x) ≡ Q A)) ∧
            ((between (value x) P′ (value x′)) ∧ (P′ (value x′) ≡ Q A)))
          (∃ y (∃ y′ (((between Q′ Q (value y)) ∧
              (Q (value y) ≡ P A)) ∧
            ((between (value y) Q′ (value y′)) ∧
              (Q′ (value y′) ≡ P A)))))
          ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        x addThereExists
        applyModusPonens

        y
          (((between P′ P (value x)) ∧ (P (value x) ≡ Q A)) ∧
            ((between (value x) P′ (value x′)) ∧ (P′ (value x′) ≡ Q A)))
          (∃ y′ (((between Q′ Q (value y)) ∧
              (Q (value y) ≡ P A)) ∧
            ((between (value y) Q′ (value y′)) ∧
              (Q′ (value y′) ≡ P A))))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        x′ addThereExists
        x addThereExists
        applyModusPonens

        y′
          (((between P′ P (value x)) ∧ (P (value x) ≡ Q A)) ∧
            ((between (value x) P′ (value x′)) ∧ (P′ (value x′) ≡ Q A)))
          (((between Q′ Q (value y)) ∧
              (Q (value y) ≡ P A)) ∧
            ((between (value y) Q′ (value y′)) ∧
              (Q′ (value y′) ≡ P A)))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        y addThereExists
        x′ addThereExists
        x addThereExists
        applyModusPonens
</jh>
Now we just need to pick <code>P ≠ A ∧ (A is-midpoint-of P′ P ∧ A is-midpoint-of Q′ Q)</code> up off the proof stack and move it inside the quantifiers.
<jh>
        introduceRightConjunctToConsequent
        x
          ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          (∃ x′ (∃ y (∃ y′ (
            (((between P′ P (value x)) ∧ (P (value x) ≡ Q A)) ∧
            ((between (value x) P′ (value x′)) ∧ (P′ (value x′) ≡ Q A))) ∧
            (((between Q′ Q (value y)) ∧ (Q (value y) ≡ P A)) ∧
            ((between (value y) Q′ (value y′)) ∧
              (Q′ (value y′) ≡ P A)))))))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        applySyllogism

        x′
          ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          (∃ y (∃ y′ (
            (((between P′ P (value x)) ∧ (P (value x) ≡ Q A)) ∧
            ((between (value x) P′ (value x′)) ∧ (P′ (value x′) ≡ Q A))) ∧
            (((between Q′ Q (value y)) ∧ (Q (value y) ≡ P A)) ∧
            ((between (value y) Q′ (value y′)) ∧
              (Q′ (value y′) ≡ P A))))))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        x addThereExists
        applySyllogism

        y
          ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          (∃ y′ (
            (((between P′ P (value x)) ∧ (P (value x) ≡ Q A)) ∧
            ((between (value x) P′ (value x′)) ∧ (P′ (value x′) ≡ Q A))) ∧
            (((between Q′ Q (value y)) ∧ (Q (value y) ≡ P A)) ∧
            ((between (value y) Q′ (value y′)) ∧
              (Q′ (value y′) ≡ P A)))))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        x′ addThereExists
        x addThereExists
        applySyllogism

        y′
          ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          (
            (((between P′ P (value x)) ∧ (P (value x) ≡ Q A)) ∧
            ((between (value x) P′ (value x′)) ∧ (P′ (value x′) ≡ Q A))) ∧
            (((between Q′ Q (value y)) ∧ (Q (value y) ≡ P A)) ∧
            ((between (value y) Q′ (value y′)) ∧
              (Q′ (value y′) ≡ P A))))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        y addThereExists
        x′ addThereExists
        x addThereExists
        applySyllogism
))
</jh>

==== Applying betweenness transitivity ====
[[File:Proof of lemma l7_13 in Narboux.svg|thumb|right|X′, P′, A, P, and X are in that order and so are Y′, Q′, A, Q, and Y]]
Visually the diagram makes it clear that the points of each of the two lines are in a certain order: in the one case X′, P′, A, P, and X and in the other case Y′, Q′, A, Q, and Y. To express this formally involves a large number of betweenness formulas, and we now prove a number of them. The first is <code>between A P X</code>, which follows from <code>between P′ A P</code> and <code>between P′ P X</code>.
<jh>
thm (SymmetricPointDistance-apx () ()
  ((
    ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) ∧
    ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
    ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
    (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
    ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))) →
  (between A P X)) (
        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction

        P′ A P X BetweennessInnerTransitivityFlipped
        applySyllogism
))
</jh>

A similar result is <code>between A Q Y</code>, which follows from <code>between Q′ A Q</code> and <code>between Q′ Q Y</code>.
<jh>
thm (SymmetricPointDistance-aqy () ()
  ((
    ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) ∧
    ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
    ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
    (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
    ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))) →
  (between A Q Y)) (
        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction

        Q′ A Q Y BetweennessInnerTransitivityFlipped
        applySyllogism
))
</jh>

The next betweenness result is <code>between A Q′ Y′</code>. Unlike the previous two, we need to apply transitivity twice (because of the way we constructed <code>Y′</code>). The first application applies transitivity to <code>between Q′ A Q</code> and <code>between Q′ Q Y</code> to give <code>between Q′ A Y</code>.
<jh>
thm (SymmetricPointDistance-qprime-a-y () ()
  ((
    ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) ∧
    ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
    ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
    (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
    ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))) →
  (between Q′ A Y)) (
        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction

        Q′ A Q Y BetweennessMiddleTransitivityFlipped
        applySyllogism
))
</jh>
The second application applies transitivity to <code>between Y′ Q′ Y</code> and <code>between Q′ A Y</code> to give <code>between Y′ Q′ A</code>.
<jh>
thm (SymmetricPointDistance-a-qprime-yprime () ()
  ((
    ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) ∧
    ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
    ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
    (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
    ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))) →
  (between A Q′ Y′)) (
        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        Y Q′ Y′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-qprime-a-y

        composeConjunction

        Y′ Q′ Y A BetweennessInnerTransitivity
        applySyllogism

        Y′ Q′ A BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

The same reasoning applied to the other line gives <code>between A P′ X′</code>. The first application of transitivity is to <code>between P′ A P</code> and <code>between P′ P X</code> and gives <code>between P′ A X</code>.
<jh>
thm (SymmetricPointDistance-pprime-a-x () ()
  ((
    ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) ∧
    ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
    ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
    (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
    ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))) →
  (between P′ A X)) (
        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction

        P′ A P X BetweennessMiddleTransitivityFlipped
        applySyllogism
))
</jh>
The second application applies transitivity to <code>between X′ P′ X</code> and <code>between P′ A X</code> to give <code>between X′ P′ A</code>.
<jh>
thm (SymmetricPointDistance-a-pprime-xprime () ()
  ((
    ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) ∧
    ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
    ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
    (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
    ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))) →
  (between A P′ X′)) (
        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        X P′ X′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-pprime-a-x

        composeConjunction

        X′ P′ X A BetweennessInnerTransitivity
        applySyllogism

        X′ P′ A BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

==== Congruences ====
[[File:Proof of lemma l7_13 in Narboux.svg|thumb|right|A X, A Y, A X′, and A Y′ are all congruent]]
From the diagram it should be clear that the line segments <code>A X</code>, <code>A Y</code>, <code>A X′</code>, and <code>A Y′</code> are all congruent, as they each consist of one line segment congruent to <code>P A</code> plus one congruent to <code>Q A</code>. We formalize this through a series of lemmas which apply the three segment theorem.
<jh>
thm (SymmetricPointDistance-axya () ()
  ((
    ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) ∧
    ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
    ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
    (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
    ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))) →
  (A X ≡ Y A)) (
</jh>
First is <code>between A P X</code>.
<jh>
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-apx
</jh>
Then <code>between Y Q A</code>.
<jh>
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-aqy

        A Q Y BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
The first congruence we'll need is <code>A P ≡ Y Q</code>.
<jh>
        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        Q Y P A CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        P A Q Y CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
The other is <code>P X ≡ Q A</code>.
<jh>
        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction

        A P X Y Q A OuterThreeSegment
        applySyllogism
))

</jh>
The next congruence is <code>A Y′ ≡ X′ A</code>, by three segment from <code>A Q′ Y′</code> and <code>X′ P′ A</code>.
<jh>
thm (SymmetricPointDistance-ayxa () ()
  ((
    ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) ∧
    ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
    ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
    (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
    ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))) →
  (A Y′ ≡ X′ A)) (
</jh>
First is <code>between A Q′ Y′</code>.
<jh>
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-a-qprime-yprime
</jh>
Next is <code>between X′ P′ A</code>.
<jh>
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-a-pprime-xprime

        A P′ X′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Next is <code>A Q′ ≡ X′ P′</code>, which holds because those two line segments are each congruent to <code>A Q</code>.
<jh>
        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        Q′ A A Q CongruenceLeftCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        P′ X′ Q A CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        X′ P′ A Q CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
        A Q′ A Q X′ P′ CongruenceTransitivity
        applySyllogism

        composeConjunction
</jh>
Last is <code>Q′ Y′ ≡ P′ A</code>, which holds because those two line segments are each congruent to <code>P A</code>.
<jh>
        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        P′ A A P CongruenceRightCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        P′ A P A CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
        Q′ Y′ P A P′ A CongruenceTransitivity
        applySyllogism

        composeConjunction
</jh>
This lets us conclude <code>A Y′ ≡ X′ A</code>.
<jh>
        A Q′ Y′ X′ P′ A OuterThreeSegment
        applySyllogism
))
</jh>

We have one more similar congruence, <code>A Y ≡ A Y′</code>, which follows from outer three segment on lines <code>A Q Y</code> and <code>A Q′ Y′</code>.
<jh>
thm (SymmetricPointDistance-a-y-a-yprime () ()
  ((
    ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) ∧
    ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
    ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
    (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
    ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))) →
  (A Y ≡ A Y′)) (
</jh>
First is <code>between A Q Y</code>.
<jh>
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-aqy
</jh>
Next is <code>between A Q′ Y′</code>.
<jh>
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-a-qprime-yprime

        composeConjunction
</jh>
The first congruence is <code>A Q ≡ A Q′</code>.
<jh>
        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        commuteCongruenceLeftInConsequent
        swapCongruenceInConsequent

        composeConjunction
</jh>
The other congruence is <code>Q Y ≡ Q′ Y′</code>, which holds because each of those line segments is congruent to <code>P A</code>.
<jh>
        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        swapCongruenceInConsequent

        composeConjunction

        Q Y P A Q′ Y′ CongruenceTransitivity
        applySyllogism

        composeConjunction
</jh>
We can now conclude <code>A Y ≡ A Y′</code>.
<jh>
        A Q Y A Q′ Y′ OuterThreeSegment
        applySyllogism
))
</jh>

Other similar congruences can be derived from those by transitivity. Here is <code>A X ≡ A X′</code>
<jh>
thm (SymmetricPointDistance-axax () ()
  ((
    ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) ∧
    ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
    ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
    (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
    ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))) →
  (A X ≡ A X′)) (
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-axya
        commuteCongruenceRightInConsequent

        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-a-y-a-yprime

        composeConjunction
        A X A Y A Y′ CongruenceTransitivity
        applySyllogism

        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-ayxa

        composeConjunction
        A X A Y′ X′ A CongruenceTransitivity
        applySyllogism

        commuteCongruenceRightInConsequent
))
</jh>

==== X′ Y′ ≡ Y X ====

All that seems fairly preparatory, and visually obvious. Now for a more substantial result: <code>X′ Y′ ≡ Y X</code>, which we get by applying outer five segment to baselines <code>X A X′</code> and <code>Y′ A Y</code> and points <code>Y′</code> and <code>X</code>. We break some of the antecedents of outer five segment into their own lemmas, and then proceed with outer five segment.
<jh>
thm (SymmetricPointDistance-xa () ()
  ((
    ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) ∧
    ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
    ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
    (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
    ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))) →
  (X ≠ A)) (
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-apx
</jh>
We'll also need <code>A ≠ P</code>.
<jh>
        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        P A EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
So far we have <code>between A P X ∧ A ≠ P</code>, and we want to show that it implies <code>A ≠ X</code>. This is just <code>IndivisibilityFromEquality</code> and some rearrangement. In this case, indivisibility is <code>A = X ∧ between A P X → A = P</code>.
<jh>
        A X P IndivisibilityFromEquality
        export
        applyComm

        (A = X) (A = P) Transposition
        eliminateBiconditionalReverse
        applySyllogism

        import
        applySyllogism
</jh>
Now we just flip <code>A ≠ X</code> to get <code>X ≠ A</code>.
<jh>
        A X EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
))

thm (SymmetricPointDistance-x-a-xprime () ()
  ((
    ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) ∧
    ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
    ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
    (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
    ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))) →
  (between X A X′)) (
</jh>
Here we apply transitivity twice. The first application is <code>between P′ A P ∧ between P′ P X → between P′ A X</code>,
<jh>
        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction

        P′ A P X BetweennessMiddleTransitivityFlipped
        applySyllogism
</jh>
and the second is <code>between X A P′ ∧ between X P′ X′ → between X A X′</code>.
<jh>
        P′ A X BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction

        X A P′ X′ BetweennessMiddleTransitivityFlipped
        applySyllogism
))

thm (SymmetricPointDistance-y-a-yprime () ()
  ((
    ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) ∧
    ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
    ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
    (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
    ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))) →
  (between Y A Y′)) (
</jh>The proof is extremely similar to that for <code>between X A X′</code> (in fact, it is a close call whether to break out a lemma to express the commonality, but here we just repeat the similar proof). The first application of transitivity is <code>between Q′ A Q ∧ between Q′ Q Y → between Q′ A Y</code>,
<jh>
        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction

        Q′ A Q Y BetweennessMiddleTransitivityFlipped
        applySyllogism
</jh>
and the second is <code>between Y A Q′ ∧ between Y Q′ Y′ → between Y A Y′</code>.
<jh>
        Q′ A Y BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction

        Y A Q′ Y′ BetweennessMiddleTransitivityFlipped
        applySyllogism
))

</jh>
Next is <code>X A ≡ Y′ A</code>, which follows from <code>A X ≡ Y A</code> and <code>A Y ≡ A Y′</code>.
<jh>
thm (SymmetricPointDistance-x-a-yprime-a () ()
  ((
    ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) ∧
    ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
    ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
    (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
    ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))) →
  (X A ≡ Y′ A)) (
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-axya

        A X Y A CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-a-y-a-yprime

        composeConjunction

        X A A Y A Y′ CongruenceTransitivity
        applySyllogism

        X A A Y′ CongruenceRightCommutativity
        eliminateBiconditionalReverse
        applySyllogism
))

</jh>
Next is <code>A X′ ≡ A Y</code>, which follows from <code>A Y′ ≡ X′ A</code> and <code>A Y ≡ A Y′</code>.
<jh>
thm (SymmetricPointDistance-a-xprime-a-y () ()
  ((
    ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) ∧
    ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
    ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
    (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
    ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))) →
  (A X′ ≡ A Y)) (
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-ayxa

        A Y′ X′ A CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        X′ A A Y′ CongruenceLeftCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-a-y-a-yprime
        swapCongruenceInConsequent

        composeConjunction

        A X′ A Y′ A Y CongruenceTransitivity
        applySyllogism
))

thm (SymmetricPointDistance-xyyx () ()
  ((
    ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) ∧
    ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
    ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
    (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
    ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))) →
  (X′ Y′ ≡ Y X)) (
</jh>
First we need <code>X ≠ A</code>.
<jh>
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-xa
</jh>
Next is <code>between X A X′</code>.
<jh>
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-x-a-xprime
        composeConjunction
</jh>
Next is <code>between Y′ A Y</code>.
<jh>
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-y-a-yprime
        swapBetweennessInConsequent
        composeConjunction
</jh>
Next is <code>X A ≡ Y′ A</code>.
<jh>
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-x-a-yprime-a
        composeConjunction
</jh>
Next is <code>A X′ ≡ A Y</code>.
<jh>
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-a-xprime-a-y
        composeConjunction
</jh>
Next is <code>X Y′ ≡ Y′ X</code>.
<jh>
        X Y′ CongruenceABBA
        introduceRightConjunctToConsequent
</jh>
Next is <code>A Y′ ≡ A X</code>. It is essentially the same as <code>X A ≡ Y′ A</code> which we did a few steps back.
<jh>
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-x-a-yprime-a
        swapCongruenceInConsequent
        commuteCongruenceInConsequent
        composeConjunction
</jh>
That gives us <code>X′ Y′ ≡ Y X</code>.
<jh>
        X A X′ Y′ A Y Y′ X OuterFiveSegment
        applySyllogism
))
</jh>

==== Q X ≡ Q′ X′ ====
Now it is time to apply inner five segment to baselines <code>Y Q A</code> and <code>Y′ Q′ A</code> and points <code>X</code> and <code>X′</code>, which gives <code>Q X ≡ Q′ X′</code>.
<jh>
thm (SymmetricPointDistance-qxqx () ()
  ((
    ((P ≠ A) ∧ ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q))) ∧
    ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
    ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
    (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
    ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))) →
  (Q X ≡ Q′ X′)) (
</jh>
First we need betweenness for the two baselines, starting with <code>between Y Q A</code>.
<jh>
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-aqy

        A Q Y BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Betweenness for the other baseline is <code>between Y′ Q′ A</code>.
<jh>
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-a-qprime-yprime

        A Q′ Y′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
We need two congruences for the baselines. The first is <code>Y A ≡ Y′ A</code>,
<jh>
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-a-y-a-yprime
        commuteCongruenceInConsequent

        composeConjunction
</jh>
and the other is <code>Q A ≡ Q′ A</code>.
<jh>
        ((P ≠ A) ∧ 
            ((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)))
          ((((between P′ P X) ∧ (P X ≡ Q A)) ∧
            ((between X P′ X′) ∧ (P′ X′ ≡ Q A))) ∧
            (((between Q′ Q Y) ∧ (Q Y ≡ P A)) ∧
            ((between Y Q′ Y′) ∧ (Q′ Y′ ≡ P A))))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        commuteCongruenceRightInConsequent
        swapCongruenceInConsequent

        composeConjunction
</jh>
The congruences for the points are <code>Y X ≡ Y′ X′</code>,
<jh>
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-xyyx
        swapCongruenceInConsequent
        commuteCongruenceRightInConsequent
        composeConjunction
</jh>
and <code>A X ≡ A X′</code>.
<jh>
        P A P′ Q′ Q X X′ Y Y′ SymmetricPointDistance-axax
        composeConjunction
</jh>
This lets us conclude <code>Q X ≡ Q′ X′</code>.
<jh>
        Y Q A Y′ Q′ A X X′ InnerFiveSegment
        applySyllogism
))
</jh>

==== Finishing the proof ====
{{under construction}}

<jh>
#thm (SymmetricPointDistance () ()
#  (((A is-midpoint-of P′ P) ∧ (A is-midpoint-of Q′ Q)) →
#  (P Q ≡ P′ Q′)) (
#))
</jh>

== Export ==
We now export to [[Interface:Midpoint]].
<jh>
#export (RESULTS Interface:Midpoint (CLASSICAL FIRSTORDER) ())
</jh>

Also, since this is currently the last proof module for geometry, we export to [[Interface:Basic geometry]].
<jh>
export (GEOMETRY Interface:Basic_geometry (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>
* Tarski, Alfred; Givant, Steven (1999), "Tarski's system of geometry", The Bulletin of Symbolic Logic 5 (2): 175–214, doi:10.2307/421089, MR1791303, ISSN 1079-8986

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]