{{header
 | title    = First-order logic
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = The purpose of this page is to prove the statements of [[Interface:First-order logic with quantifiability]] from [[Interface:First-order logic]] and the [[Interface:Axiom of quantifiability]]. In particular, it adds substitution of an object (term) for a variable.

{{under construction}}
}}
{{interfaces
| imports = [[Interface:First-order logic]] [[Interface:Axiom of quantifiability]]
| exports = [[Interface:First-order logic with quantifiability]]
}}

We start with [[Interface:Classical propositional calculus]] and [[Interface:First-order logic]]. We don't import the [[Interface:Axiom of quantifiability]] yet.

<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (WITHOUT_QUANTIFIABILITY Interface:First-order_logic (CLASSICAL) ())
</jh>

As usual, φ, ψ, χ, and θ are formulas, x, y, and z are variables, and s, t, and u are objects:

<jh>
var (formula φ ψ χ θ)
var (object s t u s0 s1 t0 t1)
var (variable x y z x0 x1 y0 y1)
</jh>

== Substitution of objects ==
We now turn to substitution of an object for a variable.

In some formulations of predicate logic, this kind of substitution (known as ''proper substitution'' as there are some rules about what kinds of substitution are valid) is performed syntactically and the rules governing it are expressed in English or a meta-theory.  JHilbert does not have a feature to do syntactic proper substitution, but we are able to build up equivalent mechanisms from equality. The theorems in [[Interface:First-order logic]] could be proven from either the syntactic definition or ours.

We define a formula <code>(subst s x φ)</code> which means, roughly, that <code>φ</code> is true if ocurrences of <code>x</code> are replaced by <code>s</code> ("roughly" because we have not tried to define proper substitution precisely). The definition contains a dummy variable <code>y</code> to give the expected results if <code>x</code> and <code>s</code> are not distinct.<ref>It resembles [http://us.metamath.org/mpeuni/dfsb7.html dfsb7] in metamath's set.mm, accessed March 8, 2010, except that <code>s</code> (the replacement) is an <code>object</code> rather than a <code>variable</code>.</ref>
<jh>
def ((subst s x φ) (∃ y (((value y) = s) ∧ (∃ x (((value x) = (value y)) ∧ φ)))))
</jh>

This section contains a few of the preliminary results, which we can prove without the axiom of quantifiability.

=== Builders ===
We can build up formulas based on equivalences or equalities of the the substituted proposition or the replacement (that is, <code>φ</code> or <code>s</code> in <code>(subst s x φ)</code>, respectively).

==== Based on replacement ====
In this section we will prove <code>s = t → ((subst s x φ) ↔ (subst t x φ))</code>. This is like dfsbcq in set.mm.<ref>[http://us.metamath.org/mpeuni/dfsbcq.html dfsbcq] in metamath's set.mm, accessed March 7, 2010</ref>

<jh>
thm (19.18 () ()
  ((∀ x (φ ↔ ψ)) → ((∃ x φ) ↔ (∃ x ψ))) (
        φ ψ BiconditionalReverseElimination x addForAll
        x φ ψ ForAllImplicationThereExists applySyllogism

        φ ψ BiconditionalForwardElimination x addForAll
        x ψ φ ForAllImplicationThereExists applySyllogism

        composeConjunction
        (∃ x φ) (∃ x ψ) BiconditionalImplication
        eliminateBiconditionalForward applySyllogism
))

thm (19.21aiv ((φ x))
  ((H (φ → ψ)))
  (φ → (∀ x ψ)) (
        x φ DistinctNotFree ForAllAddRemove eliminateBiconditionalForward
        H x addForAll applySyllogism
))

thm (exbidv ((φ x))
  ((H (φ → (ψ ↔ χ))))
  (φ → ((∃ x ψ) ↔ (∃ x χ))) (
        H x 19.21aiv x ψ χ 19.18 applySyllogism
))

thm (mpan2 ()
  ((H1 ψ) (H2 ((φ ∧ ψ) → χ)))
  (φ → χ) (
        H1 ψ φ ConjunctionCommutativity eliminateBiconditionalReverse
        H2 applySyllogism export applyModusPonens
))

thm (anbi1d ()
  ((H (φ → (ψ ↔ χ))))
  (φ → ((ψ ∧ θ) ↔ (χ ∧ θ))) (
        H
        θ BiconditionalReflexivity
        ψ χ θ θ ConjunctionFunction mpan2
        applySyllogism
))

thm (SubstBuilderReplacement ((s y) (t y)) ()
  ((s = t) → ((subst s x φ) ↔ (subst t x φ))) (
        s t (value y) EqualityBuilderLL
        (∃ x (((value x) = (value y)) ∧ φ)) anbi1d
        y exbidv
))

thm (buildSubstReplacement () ((H (s = t))) 
  ((subst s x φ) ↔ (subst t x φ)) (
        H
        s t x φ SubstBuilderReplacement
        applyModusPonens
))
</jh>

==== Implication builder ====
Analogous to our other implication builders, this theorem takes an implication and lets us add <code>subst</code> to both sides. The proof is just a straightforward application of the existing builders for conjunction and ∃.
<jh>
thm (addSubst () ((H (φ → ψ))) ((subst s x φ) → (subst s x ψ)) (
        H
        ((value x) = (value y)) conjoinLL
        x addThereExists
        ((value y) = s) conjoinLL
        y addThereExists
))
</jh>

==== Biconditional builder ====
The builder for the biconditional is very similar to the implication builder.  It could be proved much the way we proved the implication builder, but we derive it from the implication builder.<ref>Similar to [http://us.metamath.org/mpeuni/sbbii.html sbbii] in metamath's set.mm, accessed February 24, 2010, except that <code>s</code> is an <code>object</code> not a <code>variable</code></ref>

<jh>
thm (buildSubst () ((H (φ ↔ ψ))) ((subst s x φ) ↔ (subst s x ψ)) (
        H eliminateBiconditionalReverse
        s x addSubst
        H eliminateBiconditionalForward
        s x addSubst
        introduceBiconditionalFromImplications
))
</jh>

=== Proving there-exists ===
One way to prove a formula of the form <code>∃xφ</code> is to demonstrate a particular <code>x</code> for which <code>φ</code> holds.  In [[w:Intuitionistic logic|constructive logic]] any theorem <code>∃xφ</code> can be proved this way (because of the [[w:Existence property|existence property]]), but even in classical (non-constructive) logic this is one of the most common ways of proving <code>∃xφ</code>.

In our notation, this idea is expressed via <code>subst</code>:
<jh>
thm (ThereExistsIntroduction ((y φ) (y x)) () ((subst s x φ) → (∃ x φ)) (
</jh>
The proof takes the definition of <code>subst</code>, <code>(∃ y (y = s ∧ (∃ x (x = y ∧ φ))))</code> and pares it down by eliminating the parts we don't need.

We start with <code>(y = s ∧ ∃ x (x = y ∧ φ)) → ∃ x (x = y ∧ φ)</code>
<jh>
        ((value y) = s) (∃ x (((value x) = (value y)) ∧ φ)) ConjunctionLeftElimination

</jh>
and <code>∃ x (x = y ∧ φ) → ∃ x φ</code>:
<jh>
        ((value x) = (value y)) φ ConjunctionLeftElimination
        x addThereExists
</jh>
which by syllogism gives us <code>(y = s ∧ ∃ x (x = y ∧ φ)) → ∃ x φ</code>
<jh>
        applySyllogism
</jh>
We add <code>∃ y</code> to both sides and simplify <code>∃ y ∃ x φ</code> to <code>∃ x φ</code>:
<jh>
        y addThereExists

        y (∃ x φ) DistinctNotFree
        ThereExistsAddRemove eliminateBiconditionalReverse
        applySyllogism
))

thm (introduceThereExists () ((H (subst s x φ))) (∃ x φ) (
        H
        s x φ ThereExistsIntroduction
        applyModusPonens
))
</jh>

== Axiom of quantifiability ==
Having gotten about as far as we're going to get without the [[Interface:Axiom of quantifiability]], we now import it and start proving some consequences of it.
<jh>
import (QUANTIFIABILITY_AXIOM Interface:Axiom_of_quantifiability (CLASSICAL WITHOUT_QUANTIFIABILITY) ())
</jh>

== Quantifiers and equality ==

Here we prove a number of results involving equality and quantifiers. Many of them will pave the way for results involving explicit (subst) substitution.

=== ax9oc ===
First is a consequence of the <code>Quantifiability</code> axiom:<ref>like [http://us.metamath.org/mpeuni/ax9o.html ax9o] in metamath's set.mm, accessed February 22, 2010, but for an object not a variable</ref>

<jh>
thm (ax9oc () () ((∀ x (((value x) = s) → (∀ x φ))) → φ) (
        x ((value x) = s) (∀ x φ) ForAllImplicationThereExists
</jh>
This gives us <code>∀x(x = s → ∀xφ) → (∃x x = s → ∃x∀xφ)</code>, which can be simplified to our desired result.  The first step is to note that <code>∃x x = s</code> is just the <code>Quantifiability</code> axiom, and can therefore be removed:
<jh>
        x s Quantifiability
        applyNestedModusPonens
</jh>
Now we need to reduce <code>∃x∀xφ</code> to <code>φ</code>:
<jh>
        x φ ax6o
        applySyllogism
))
</jh>

=== Implicit substitution and ∀ ===
A statement of the form <code>x = s → (φ ↔ ψ)</code>, where <code>x</code> is not free in <code>ψ</code>, can be thought of as an ''implicit substitution'', as it can be used to relate a formula about <code>x</code> to a formula about <code>s</code>. Here we relate such a statement to <code>∀x(x = s → φ)</code> (which is one of the formulas we'll be using in manipulating substitutions).<ref>[http://us.metamath.org/mpeuni/equsal.html equsal] in metamath's set.mm, accessed May 11, 2010, but for an object not a variable</ref>

First, a propositional logic theorem:<ref>*5.74 from A. Whitehead, B. Russell, Principia Mathematica, Cambridge University Press, 1910.</ref>
<jh>
thm (ImplicationDistributionOverBiconditional () () ((φ → (ψ ↔ χ)) ↔ ((φ → ψ) ↔ (φ → χ))) (
</jh>
We split <code>(φ → ψ) ↔ (φ → χ)</code> into two implications:
<jh>
        (φ → ψ) (φ → χ) BiconditionalImplication
</jh>
Then we apply <code>AntecedentDistribution</code> to each one,
<jh>
        φ ψ χ AntecedentDistribution swapBiconditional
        φ χ ψ AntecedentDistribution swapBiconditional
</jh>
and combine them.
<jh>
        buildConjunction
</jh>
The left hand side from buildConjunction was <code>((φ → ψ) → (φ → χ)) ∧ ((φ → χ) → (φ → ψ))</code>, so we are ready to apply transitivity there.
<jh>
        applyBiconditionalTransitivity
</jh>
The right hand side from buildConjunction was <code>(φ → (ψ → χ)) ∧ (φ → (χ → ψ))</code>, which we first transform to <code>φ → ((ψ → χ) ∧ (χ → ψ))</code>,
<jh>
        φ (ψ → χ) (χ → ψ) ConjunctionComposition
        applyBiconditionalTransitivity
</jh>
and then to <code>φ → (ψ ↔ χ)</code>.
<jh>
        φ BiconditionalReflexivity
        ψ χ BiconditionalImplication swapBiconditional
        buildImplication
        applyBiconditionalTransitivity

</jh>
We now have our desired result except the two sides are interchanged.
<jh>
        swapBiconditional
))

thm (distributeImplicationOverBiconditional () ((H (φ → (ψ ↔ χ)))) ((φ → ψ) ↔ (φ → χ)) (
        H
        φ ψ χ ImplicationDistributionOverBiconditional eliminateBiconditionalReverse
        applyModusPonens
))
</jh>

And our implicit substitution theorem:
<jh>
thm (ImplicitSubstitutionForAll () ((HFREE (x is-not-free-in ψ))) 
  ((∀ x (((value x) = s) → (φ ↔ ψ))) → ((∀ x (((value x) = s) → φ)) ↔ ψ)) (
</jh>
Starting with <code>x = s → (φ ↔ ψ)</code>, we first add <code>∀x</code> in front of the <code>ψ</code>:
<jh>
        HFREE
        ForAllAddRemove swapBiconditional

        φ ψ (∀ x ψ) BiconditionalTransitivity export applyComm

        applyModusPonens

        ((value x) = s) addCommonAntecedent
</jh>
We now distribute the implication over the biconditional to get <code>(x = s → φ) ↔ (x = s → ∀xψ)</code>.
<jh>
        ((value x) = s) φ (∀ x ψ) ImplicationDistributionOverBiconditional eliminateBiconditionalReverse
        applySyllogism
</jh>
The entire formula we have at this point is <code>(x = s → (φ ↔ ψ)) → ((x = s → φ) ↔ (x = s → ∀xψ))</code>.  We will add <code>∀x</code> to the start of each of the three parts.
<jh>
        x addForAll
        x (((value x) = s) → φ) (((value x) = s) → (∀ x ψ)) ForAllBiconditional
        applySyllogism
</jh>
The left side of that consequent, <code>∀x(x = s → φ)</code>, is the left side of our desired consequent.

We will show that the right side, <code>∀x(x = s → ∀xψ)</code>, is equivalent to <code>ψ</code>. The forward direction is just <code>ax9oc</code>:
<jh>
        x s ψ ax9oc
</jh>
The reverse direction is introducing an antecedent and messing around with quantifiers:
<jh>
        HFREE ForAllAddRemove eliminateBiconditionalForward

        (∀ x ψ) ((value x) = s) AntecedentIntroduction
        a5i
        applySyllogism
</jh>
Now we just need to combine the forward and reverse directions,
<jh>
        introduceBiconditionalFromImplications
</jh>
and reassemble our result.
<jh>
        (∀ x (((value x) = s) → φ)) (∀ x (((value x) = s) → (∀ x ψ))) ψ BiconditionalTransitivity
        export
        applyComm
        applyModusPonens

        applySyllogism
))
</jh>

Here's a rule form of basically the same theorem:

<jh>
thm (SubstImplicitForAll () ((HFREE (x is-not-free-in ψ)) (HEQ (((value x) = s) → (φ ↔ ψ))))
  ((∀ x (((value x) = s) → φ)) ↔ ψ) (
        HEQ
        x generalize

        HFREE
        s φ ImplicitSubstitutionForAll

        applyModusPonens
))
</jh>

=== Implicit substitution and ∃ ===
There is a similar result with ∃.<ref>[http://us.metamath.org/mpeuni/equsex.html equsex] in metamath's set.mm, accessed March 9, 2010, with <code>s</code> (the replacement) changed from a <code>variable</code> to an <code>object</code></ref>

We first provide a bit more propositional logic:
<jh>
thm (ConjunctionImplication () () ((φ ∧ ψ) ↔ (¬ (φ → (¬ ψ)))) (
        φ ψ DeMorganNDN swapBiconditional

        φ (¬ ψ) ImplicationDisjunction swapBiconditional
        addNegation

        applyBiconditionalTransitivity
))

thm (ImplicationConjunction () () ((φ → ψ) ↔ (¬ (φ ∧ (¬ ψ)))) (
        φ ψ ImplicationDisjunction

        φ ψ DeMorganPCN swapBiconditional

        applyBiconditionalTransitivity
))
</jh>

Our implicit substitution theorem is:
<jh>
thm (ImplicitSubstitutionThereExists () ((HFREE (x is-not-free-in ψ))) 
  ((∀ x (((value x) = s) → (φ ↔ ψ))) → ((∃ x (((value x) = s) ∧ φ)) ↔ ψ)) (
</jh>
The proof basically consists of massaging negations to derive this result from the corresponding one for ∀. We start by showing that <code>∀x (x = s → (φ ↔ ψ))</code> implies that <code>∀x(x = s → ¬ φ)</code> is equivalent to <code>¬ ψ</code>.
<jh>
        φ ψ NegationFunction eliminateBiconditionalReverse
        ((value x) = s) addCommonAntecedent
        x addForAll

        HFREE
        negateNotFree
        s (¬ φ) ImplicitSubstitutionForAll

        applySyllogism
</jh>
Now we need to show that <code>∀x(x = s → ¬ φ) ↔ (¬ ψ)</code> implies <code>∃x(x = s ∧ φ) ↔ ψ</code>. We first turn the former into <code>ψ ↔ (¬ ∀x(x = s → ¬ φ))</code>:
<jh>
        (∀ x (((value x) = s) → (¬ φ))) ψ BiconditionalTranspositionWithNegatedRight
</jh>
We stick <code>ψ ↔ ψ</code> on the proof stack for later use,
<jh>
        ψ BiconditionalReflexivity
</jh>
and work just with <code>¬ ∀x(x = s → ¬ φ)</code> for now. We move the negation past the quantifier to get <code>∃x ¬ (x = s → ¬ φ)</code>:
<jh>
        x (((value x) = s) → (¬ φ)) NotForAll
</jh>
Now we turn the negations and implication into a conjunction:
<jh>
        ((value x) = s) φ ConjunctionImplication swapBiconditional
        x buildThereExists
        applyBiconditionalTransitivity
</jh>
Bringing back two statements we left on the proof stack, we assemble the formula that <code>∀x(x = s → ¬ φ) ↔ (¬ ψ)</code> is equivalent to <code>ψ ↔ ∃x(x = s ∧ φ)</code>,
<jh>
        buildBiconditional
        applyBiconditionalTransitivity
</jh>
flip the order to get <code>∃x(x = s ∧ φ) ↔ ψ</code>,
<jh>
        eliminateBiconditionalReverse
        ψ (∃ x (((value x) = s) ∧ φ)) BiconditionalSymmetry eliminateBiconditionalReverse
        applySyllogism
</jh>
and combine this with the first part of the proof.
<jh>
        applySyllogism
))
</jh>

The rule form is:
<jh>
thm (SubstImplicitThereExists () ((HFREE (x is-not-free-in ψ)) (HEQ (((value x) = s) → (φ ↔ ψ))))
  ((∃ x (((value x) = s) ∧ φ)) ↔ ψ) (
        HEQ
        x generalize

        HFREE
        s φ ImplicitSubstitutionThereExists

        applyModusPonens
))
</jh>

== equs4c ==
This is an analogue to equs4 from [[First-order logic]] but for objects not variables:

<jh>
thm (equs4c () () ((∀ x (((value x) = s) → φ)) → (∃ x (((value x) = s) ∧ φ))) (
        (∀ x (((value x) = s) → φ)) ((value x) = s) ConjunctionLeftElimination

        x (((value x) = s) → φ) Specialization
        import

        joinConsequents
</jh>
That gives us <code>((∀ x ((x = y) → φ)) ∧ x = y) → (¬ ((x = y) → (¬ φ)))</code>. We transform the consequent to <code>(¬ (∀ x ((x = y) → (¬ φ))))</code>:
<jh>
        x (((value x) = s) → (¬ φ)) Specialization
        introduceTransposition
        applySyllogism
</jh>
And then we add <code>∀x</code> to the front of that consequent:
<jh>
        x (((value x) = s) → (¬ φ)) BoundForAllNotFree
        negateNotFree
        ForAllAddRemove eliminateBiconditionalForward

        applySyllogism
</jh>
We export and add one more ∀x:
<jh>
        export
        a5i
</jh>
which gives us <code>(∀x(x = s → φ) → ∀x(x = s → ∀x ¬ ∀x(x = s → ¬ φ)))</code>.  The consequent of that is just what we need to apply <code>ax9oc</code>:
<jh>
        x s (¬ (∀ x (((value x) = s) → (¬ φ)))) ax9oc
        applySyllogism
</jh>
so we have simplified the consequent to <code>¬ ∀x(x = y → ¬ φ))</code>. We merely apply <code>equs3</code> to that and we're done.
<jh>
        x s φ equs3 eliminateBiconditionalForward
        applySyllogism
))
</jh>

== Substitution of objects, with axiom of quantifiability ==
The axiom of quantifiability allows us to prove more substitution results because we can assume that a variable can take on a value corresponding to any object.

=== Substitution of a theorem remains a theorem ===
If we have a theorem, we can add a variable substitution onto it.

<jh>
thm (introduceSubst () ((H φ)) (subst s x φ) (
        H
        ((value x) = (value y)) introduceAntecedent
        x generalize

        x (value y) φ equs4c
        applyModusPonens

        ((value y) = s) introduceAntecedent
        y generalize

        y s (∃ x (((value x) = (value y)) ∧ φ)) equs4c
        applyModusPonens
))
</jh>

=== Convert from implicit substitution ===
A statement of the form <code>x = s → (φ ↔ ψ)</code>, where <code>x</code> is not free in <code>ψ</code>, can be thought of as an ''implicit substitution'', as it can be used to relate a formula about <code>x</code> to a formula about <code>s</code>.

Although the distinct variable constraint between <code>x</code> and <code>s</code> should not be necessary (if we wanted to require that <code>x</code> and <code>s</code> are distinct we could have a simpler definition of <code>subst</code>), even the version with the constraint can be useful.

<jh>
thm (convertImplicitToSubst ((x s) (y ψ) (x y)) 
  ((HFREE (x is-not-free-in ψ))
   (HEQ (((value x) = s) → (φ ↔ ψ)))
  )
  ((subst s x φ) ↔ ψ) (
</jh>
The proof will basically consist of two applications of <code>ImplicitSubstitutionThereExists</code>.

First we rewrite <code>x = s → (φ ↔ ψ)</code> as <code>y = s → (x = y → (φ ↔ ψ))</code>
<jh>
        ((value y) = s) ((value x) = (value y)) ConjunctionCommutativity eliminateBiconditionalReverse
        (value x) (value y) s EqualityTransitivity
        applySyllogism

        HEQ
        applySyllogism

        export
</jh>
Now we add ∀x to the consequent:
<jh>
        x generalize
        x ((value y) = s) DistinctNotFree
        moveAntecedentOutOfForAll
</jh>
The first application of <code>ImplicitSubstitutionThereExists</code> turns <code>∀x(x = y → (φ ↔ ψ))</code> into <code>(∃x x = y ∧ φ) ↔ ψ</code>:
<jh>
        HFREE
        (value y) φ ImplicitSubstitutionThereExists
</jh>
Combining these results gets <code>y = s → ((∃x x = y ∧ φ) ↔ ψ)</code>:
<jh>
        applySyllogism
</jh>
We then apply <code>ImplicitSubstitutionThereExists</code> again to get <code>∃ y (y = s ∧ (∃x x = y ∧ φ)) ↔ ψ)</code>, which is our desired result.
<jh>
        y generalize
        y ψ DistinctNotFree
        s (∃ x (((value x) = (value y)) ∧ φ)) ImplicitSubstitutionThereExists
        applyModusPonens
))

thm (makeSubstExplicit ((x s) (x ψ))
  ((H (((value x) = s) → (φ ↔ ψ))))
  ((subst s x φ) ↔ ψ) (
        x ψ DistinctNotFree
        H
        convertImplicitToSubst
))
</jh>

== Export ==
That gives us [[Interface:First-order logic with quantifiability]], which we now export.
<jh>
export (WITH_QUANTIFIABILITY Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
</jh>

== References ==
<references/>

[[Category:Classical first-order logic]]