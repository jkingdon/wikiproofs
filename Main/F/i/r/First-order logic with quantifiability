{{header
 | title    = First-order logic
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = The purpose of this page is to prove the statements of [[Interface:First-order logic]] from [[Interface:Axioms of first-order logic]].

{{under construction}}
}}
{{interfaces
| imports = [[Interface:First-order logic]]
| exports = [[Interface:First-order logic with quantifiability]]
}}

We start with [[Interface:Classical propositional calculus]], [[Interface:First-order logic]], and [[Interface:Axiom of quantifiability]]:

<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (WITHOUT_QUANTIFIABILITY Interface:First-order_logic (CLASSICAL) ())
import (QUANTIFIABILITY_AXIOM Interface:Axiom_of_quantifiability (CLASSICAL WITHOUT_QUANTIFIABILITY) ())
</jh>

As usual, φ, ψ, χ, and θ are formulas, x, y, and z are variables, and s, t, and u are objects:

<jh>
var (formula φ ψ χ θ)
var (object s t u s0 s1 t0 t1)
var (variable x y z x0 x1 y0 y1)
</jh>

== Quantifiers and equality ==

Here we prove a number of results involving equality and quantifiers. Many of them will pave the way for results involving explicit (subst) substitution.

=== ax9oc ===
First is a consequence of the <code>Quantifiability</code> axiom:<ref>like [http://us.metamath.org/mpeuni/ax9o.html ax9o] in metamath's set.mm, accessed February 22, 2010, but for an object not a variable</ref>

<jh>
thm (ax9oc () () ((∀ x (((value x) = s) → (∀ x φ))) → φ) (
        x ((value x) = s) (∀ x φ) ForAllImplicationThereExists
</jh>
This gives us <code>∀x(x = s → ∀xφ) → (∃x x = s → ∃x∀xφ)</code>, which can be simplified to our desired result.  The first step is to note that <code>∃x x = s</code> is just the <code>Quantifiability</code> axiom, and can therefore be removed:
<jh>
        x s Quantifiability
        applyNestedModusPonens
</jh>
Now we need to reduce <code>∃x∀xφ</code> to <code>φ</code>:
<jh>
        x φ ax6o
        applySyllogism
))
</jh>

=== Implicit substitution and ∀ ===
A statement of the form <code>x = s → (φ ↔ ψ)</code>, where <code>x</code> is not free in <code>ψ</code>, can be thought of as an ''implicit substitution'', as it can be used to relate a formula about <code>x</code> to a formula about <code>s</code>. Here we relate such a statement to <code>∀x(x = s → φ)</code> (which is one of the formulas we'll be using in manipulating substitutions).<ref>[http://us.metamath.org/mpeuni/equsal.html equsal] in metamath's set.mm, accessed March 9, 2010</ref>

First, a propositional logic theorem:<ref>*5.74 from A. Whitehead, B. Russell, Principia Mathematica, Cambridge University Press, 1910.</ref>
<jh>
thm (ImplicationDistributionOverBiconditional () () ((φ → (ψ ↔ χ)) ↔ ((φ → ψ) ↔ (φ → χ))) (
</jh>
We split <code>(φ → ψ) ↔ (φ → χ)</code> into two implications:
<jh>
        (φ → ψ) (φ → χ) BiconditionalImplication
</jh>
Then we apply <code>AntecedentDistribution</code> to each one,
<jh>
        φ ψ χ AntecedentDistribution swapBiconditional
        φ χ ψ AntecedentDistribution swapBiconditional
</jh>
and combine them.
<jh>
        buildConjunction
</jh>
The left hand side from buildConjunction was <code>((φ → ψ) → (φ → χ)) ∧ ((φ → χ) → (φ → ψ))</code>, so we are ready to apply transitivity there.
<jh>
        applyBiconditionalTransitivity
</jh>
The right hand side from buildConjunction was <code>(φ → (ψ → χ)) ∧ (φ → (χ → ψ))</code>, which we first transform to <code>φ → ((ψ → χ) ∧ (χ → ψ))</code>,
<jh>
        φ (ψ → χ) (χ → ψ) ConjunctionComposition
        applyBiconditionalTransitivity
</jh>
and then to <code>φ → (ψ ↔ χ)</code>.
<jh>
        φ BiconditionalReflexivity
        ψ χ BiconditionalImplication swapBiconditional
        buildImplication
        applyBiconditionalTransitivity

</jh>
We now have our desired result except the two sides are interchanged.
<jh>
        swapBiconditional
))

thm (distributeImplicationOverBiconditional () ((H (φ → (ψ ↔ χ)))) ((φ → ψ) ↔ (φ → χ)) (
        H
        φ ψ χ ImplicationDistributionOverBiconditional eliminateBiconditionalReverse
        applyModusPonens
))
</jh>

And our implicit substitution theorem:
<jh>
thm (ImplicitSubstitutionForAll () ((HFREE (x is-not-free-in ψ))) 
  ((∀ x (((value x) = s) → (φ ↔ ψ))) → ((∀ x (((value x) = s) → φ)) ↔ ψ)) (
</jh>
Starting with <code>x = s → (φ ↔ ψ)</code>, we first add <code>∀x</code> in front of the <code>ψ</code>:
<jh>
        HFREE
        ForAllAddRemove swapBiconditional

        φ ψ (∀ x ψ) BiconditionalTransitivity export applyComm

        applyModusPonens

        ((value x) = s) addCommonAntecedent
</jh>
We now distribute the implication over the biconditional to get <code>(x = s → φ) ↔ (x = s → ∀xψ)</code>.
<jh>
        ((value x) = s) φ (∀ x ψ) ImplicationDistributionOverBiconditional eliminateBiconditionalReverse
        applySyllogism
</jh>
The entire formula we have at this point is <code>(x = s → (φ ↔ ψ)) → ((x = s → φ) ↔ (x = s → ∀xψ))</code>.  We will add <code>∀x</code> to the start of each of the three parts.
<jh>
        x addForAll
        x (((value x) = s) → φ) (((value x) = s) → (∀ x ψ)) ForAllBiconditional
        applySyllogism
</jh>
The left side of that consequent, <code>∀x(x = s → φ)</code>, is the left side of our desired consequent.

We will show that the right side, <code>∀x(x = s → ∀xψ)</code>, is equivalent to <code>ψ</code>. The forward direction is just <code>ax9oc</code>:
<jh>
        x s ψ ax9oc
</jh>
The reverse direction is introducing an antecedent and messing around with quantifiers:
<jh>
        HFREE ForAllAddRemove eliminateBiconditionalForward

        (∀ x ψ) ((value x) = s) AntecedentIntroduction
        a5i
        applySyllogism
</jh>
Now we just need to combine the forward and reverse directions,
<jh>
        introduceBiconditionalFromImplications
</jh>
and reassemble our result.
<jh>
        (∀ x (((value x) = s) → φ)) (∀ x (((value x) = s) → (∀ x ψ))) ψ BiconditionalTransitivity
        export
        applyComm
        applyModusPonens

        applySyllogism
))
</jh>

Here's a rule form of basically the same theorem:

<jh>
thm (SubstImplicitForAll () ((HFREE (x is-not-free-in ψ)) (HEQ (((value x) = s) → (φ ↔ ψ))))
  ((∀ x (((value x) = s) → φ)) ↔ ψ) (
        HEQ
        x generalize

        HFREE
        s φ ImplicitSubstitutionForAll

        applyModusPonens
))
</jh>

=== Implicit substitution and ∃ ===
There is a similar result with ∃.<ref>[http://us.metamath.org/mpeuni/equsex.html equsex] in metamath's set.mm, accessed March 9, 2010, with <code>s</code> (the replacement) changed from a <code>variable</code> to an <code>object</code></ref>

We first provide a bit more propositional logic:
<jh>
thm (ConjunctionImplication () () ((φ ∧ ψ) ↔ (¬ (φ → (¬ ψ)))) (
        φ ψ DeMorganNDN swapBiconditional

        φ (¬ ψ) ImplicationDisjunction swapBiconditional
        addNegation

        applyBiconditionalTransitivity
))

thm (ImplicationConjunction () () ((φ → ψ) ↔ (¬ (φ ∧ (¬ ψ)))) (
        φ ψ ImplicationDisjunction

        φ ψ DeMorganPCN swapBiconditional

        applyBiconditionalTransitivity
))
</jh>

Our implicit substitution theorem is:
<jh>
thm (ImplicitSubstitutionThereExists () ((HFREE (x is-not-free-in ψ))) 
  ((∀ x (((value x) = s) → (φ ↔ ψ))) → ((∃ x (((value x) = s) ∧ φ)) ↔ ψ)) (
</jh>
The proof basically consists of massaging negations to derive this result from the corresponding one for ∀. We start by showing that <code>∀x (x = s → (φ ↔ ψ))</code> implies that <code>∀x(x = s → ¬ φ)</code> is equivalent to <code>¬ ψ</code>.
<jh>
        φ ψ NegationFunction eliminateBiconditionalReverse
        ((value x) = s) addCommonAntecedent
        x addForAll

        HFREE
        negateNotFree
        s (¬ φ) ImplicitSubstitutionForAll

        applySyllogism
</jh>
Now we need to show that <code>∀x(x = s → ¬ φ) ↔ (¬ ψ)</code> implies <code>∃x(x = s ∧ φ) ↔ ψ</code>. We first turn the former into <code>ψ ↔ (¬ ∀x(x = s → ¬ φ))</code>:
<jh>
        (∀ x (((value x) = s) → (¬ φ))) ψ BiconditionalTranspositionWithNegatedRight
</jh>
We stick <code>ψ ↔ ψ</code> on the proof stack for later use,
<jh>
        ψ BiconditionalReflexivity
</jh>
and work just with <code>¬ ∀x(x = s → ¬ φ)</code> for now. We move the negation past the quantifier to get <code>∃x ¬ (x = s → ¬ φ)</code>:
<jh>
        x (((value x) = s) → (¬ φ)) NotForAll
</jh>
Now we turn the negations and implication into a conjunction:
<jh>
        ((value x) = s) φ ConjunctionImplication swapBiconditional
        x buildThereExists
        applyBiconditionalTransitivity
</jh>
Bringing back two statements we left on the proof stack, we assemble the formula that <code>∀x(x = s → ¬ φ) ↔ (¬ ψ)</code> is equivalent to <code>ψ ↔ ∃x(x = s ∧ φ)</code>,
<jh>
        buildBiconditional
        applyBiconditionalTransitivity
</jh>
flip the order to get <code>∃x(x = s ∧ φ) ↔ ψ</code>,
<jh>
        eliminateBiconditionalReverse
        ψ (∃ x (((value x) = s) ∧ φ)) BiconditionalSymmetry
        applySyllogism
</jh>
and combine this with the first part of the proof.
<jh>
        applySyllogism
))
</jh>

The rule form is:
<jh>
thm (SubstImplicitThereExists () ((HFREE (x is-not-free-in ψ)) (HEQ (((value x) = s) → (φ ↔ ψ))))
  ((∃ x (((value x) = s) ∧ φ)) ↔ ψ) (
        HEQ
        x generalize

        HFREE
        s φ ImplicitSubstitutionThereExists

        applyModusPonens
))
</jh>

== equs4c ==
This is an analogue to equs4 from [[First-order logic]] but for objects not variables:

<jh>
thm (equs4c () () ((∀ x (((value x) = s) → φ)) → (∃ x (((value x) = s) ∧ φ))) (
        (∀ x (((value x) = s) → φ)) ((value x) = s) ConjunctionLeftElimination

        x (((value x) = s) → φ) Specialization
        import

        joinConsequents
</jh>
That gives us <code>((∀ x ((x = y) → φ)) ∧ x = y) → (¬ ((x = y) → (¬ φ)))</code>. We transform the consequent to <code>(¬ (∀ x ((x = y) → (¬ φ))))</code>:
<jh>
        x (((value x) = s) → (¬ φ)) Specialization
        introduceTransposition
        applySyllogism
</jh>
And then we add <code>∀x</code> to the front of that consequent:
<jh>
        x (((value x) = s) → (¬ φ)) BoundForAllNotFree
        negateNotFree
        ForAllAddRemove eliminateBiconditionalForward

        applySyllogism
</jh>
We export and add one more ∀x:
<jh>
        export
        a5i
</jh>
which gives us <code>(∀x(x = s → φ) → ∀x(x = s → ∀x ¬ ∀x(x = s → ¬ φ)))</code>.  The consequent of that is just what we need to apply ax9o:
<jh>
        x s (¬ (∀ x (((value x) = s) → (¬ φ)))) ax9oc
        applySyllogism
</jh>
so we have simplified the consequent to <code>¬ ∀x(x = y → ¬ φ))</code>. We merely apply <code>equs3</code> to that and we're done.
<jh>
        x s φ equs3 eliminateBiconditionalForward
        applySyllogism
))
</jh>

== Export ==
When this page is done, we'd have proved all the theorems in [[Interface:First-order logic]], and would be able to export them.
<jh>
#export (WITH_QUANTIFIABILITY Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
</jh>

== References ==
<references/>

[[Category:Classical first-order logic]]