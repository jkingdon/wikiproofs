{{header
 | title    = First-order logic
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = The purpose of this page is to prove the statements of [[Interface:First-order logic with quantifiability]] from [[Interface:First-order logic]] and the [[Interface:Axiom of quantifiability]]. In particular, it adds substitution of an object (term) for a variable.
}}
{{interfaces
| imports = [[Interface:First-order logic]] [[Interface:Axiom of quantifiability]]
| exports = [[Interface:First-order logic with quantifiability]]
}}

We start with [[Interface:Classical propositional calculus]] and [[Interface:First-order logic]]. We don't import the [[Interface:Axiom of quantifiability]] yet.

<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (WITHOUT_QUANTIFIABILITY Interface:First-order_logic (CLASSICAL) ())
</jh>

As usual, φ and ψ are formulas, x, y, and z are variables, and s, t, and u are objects:

<jh>
var (formula φ ψ φx φy φs)
var (object s t u s0 s1 t0 t1)
var (variable x y z x0 x1 y0 y1)
</jh>

== Substitution of objects ==
We now turn to substitution of an object for a variable.

In some formulations of predicate logic, this kind of substitution (known as ''proper substitution'' as there are some rules about what kinds of substitution are valid) is performed syntactically and the rules governing it are expressed in English or a meta-theory.  JHilbert does not have a feature to do syntactic proper substitution, but we are able to build up equivalent mechanisms from equality. The theorems in [[Interface:First-order logic with quantifiability]] could be proven from either the syntactic definition or ours.

We define a formula <code>(subst s x φ)</code> which means, roughly, that <code>φ</code> is true if ocurrences of <code>x</code> are replaced by <code>s</code> ("roughly" because we have not tried to define proper substitution precisely). In dicussion, we also use the notation <code>[ s / x ] φ</code> (which is not legal JHilbert syntax) for the same thing. The definition is <code>[ s / x ] φ ≝ ∃ y (y = s ∧ ∃ x (x = y ∧ φ))</code>. The definition contains a dummy variable <code>y</code> to give the expected results if <code>x</code> and <code>s</code> are not distinct.<ref>It resembles [http://us.metamath.org/mpeuni/dfsb7.html dfsb7] in metamath's set.mm, accessed March 8, 2010, except that <code>s</code> (the replacement) is an <code>object</code> rather than a <code>variable</code>.</ref>
<jh>
def ((subst s x φ) (∃ y (((value y) = s) ∧ (∃ x (((value x) = (value y)) ∧ φ)))))
</jh>

This section contains a few of the preliminary results, which we can prove without the axiom of quantifiability.

=== Definition as theorem ===
We first prove a theorem form of the definition.
<jh>
thm (Subst ((x y) (y s) (y φ)  (z x) (y z) (z s) (z φ)) () (
  (subst s x φ) ↔ 
    (∃ y (((value y) = s) ∧ 
      (∃ x (((value x) = (value y)) ∧ φ))
    ))
) (
</jh>
What we need to prove is <code>∃ z (z = s ∧ ∃ x (x = z ∧ φ)) ↔ ∃ y (y = s ∧ ∃ x (x = y ∧ φ))</code>.  The first step is <code>z = y → (z = s ∧ ∃ x (x = z ∧ φ) ↔ y = s ∧ ∃ x (x = y ∧ φ))</code>
<jh>
        (value z) (value y) s EqualityBuilderRR

        (value z) (value y) (value x) EqualityBuilderLL
        φ buildConjunctionRRInConsequent
        x buildThereExistsInConsequent

        buildConjunctionInConsequent
</jh>
Then we just apply our change-variable theorem and we are done.
<jh>
        ChangeVariableThereExists
))
</jh>

=== Builders ===
We can build up formulas based on equivalences or equalities of the the substituted proposition or the replacement (that is, <code>φ</code> or <code>s</code> in <code>(subst s x φ)</code>, respectively).

==== Based on replacement ====
In this section we will prove <code>s = t → ((subst s x φ) ↔ (subst t x φ))</code>. This is like dfsbcq in set.mm.<ref>[http://us.metamath.org/mpeuni/dfsbcq.html dfsbcq] in metamath's set.mm, accessed March 7, 2010</ref> The set.mm analogue for substituting a <code>variable</code> (rather than an <code>object</code>) is sbequ.<ref>[http://us.metamath.org/mpeuni/sbequ.html sbequ] in metamath's set.mm, accessed June 20, 2010</ref>

<jh>
thm (SubstBuilderReplacement ((s y) (t y) (φ y) (x y)) ()
  ((s = t) → ((subst s x φ) ↔ (subst t x φ))) (
        s t (value y) EqualityBuilderLL
        (∃ x (((value x) = (value y)) ∧ φ)) buildConjunctionRRInConsequent
        y buildThereExistsInConsequent

</jh>
Now we just need to apply the definition of <code>subst</code> and we are done:
<jh>
        s x φ y Subst
        t x φ y Subst
        buildBiconditional

        eliminateBiconditionalForward
        applySyllogism
))

thm (buildSubstReplacement () ((H (s = t))) 
  ((subst s x φ) ↔ (subst t x φ)) (
        H
        s t x φ SubstBuilderReplacement
        applyModusPonens
))
</jh>

==== Implication builder ====
Analogous to our other implication builders, this theorem takes an implication and lets us add <code>subst</code> to both sides. The proof is just a straightforward application of the existing builders for conjunction and ∃.
<jh>
thm (SubstAddition ((y s) (y x) (y ψ) (y φ)) () ((∀ x (φ → ψ)) → ((subst s x φ) → (subst s x ψ))) (
        φ ψ ((value x) = (value y)) ConjunctionMultiplicationLL
        x addForAll

        x (((value x) = (value y)) ∧ φ) (((value x) = (value y)) ∧ ψ) ForAllImplicationThereExists
        applySyllogism

        (∃ x (((value x) = (value y)) ∧ φ))
          (∃ x (((value x) = (value y)) ∧ ψ))
          ((value y) = s) ConjunctionMultiplicationLL
        applySyllogism

        y addForAllToConsequent
        y
          (((value y) = s) ∧ (∃ x (((value x) = (value y)) ∧ φ)))
          (((value y) = s) ∧ (∃ x (((value x) = (value y)) ∧ ψ)))
          ForAllImplicationThereExists
        applySyllogism
</jh>
Now we just need to apply the definition of <code>subst</code> and we are done:
<jh>
        s x φ y Subst
        swapBiconditional

        s x ψ y Subst
        swapBiconditional

        buildImplication
        eliminateBiconditionalReverse
        applySyllogism
))

thm (addSubst () ((H (φ → ψ))) ((subst s x φ) → (subst s x ψ)) (
        H
        x generalize
        x φ ψ s SubstAddition
        applyModusPonens
))
</jh>

==== Biconditional builder ====
The builder for the biconditional is very similar to the implication builder.  It could be proved much the way we proved the implication builder, but we derive it from the implication builder.

<jh>
thm (SubstBuilder () () ((∀ x (φ ↔ ψ)) → ((subst s x φ) ↔ (subst s x ψ))) (
        φ ψ BiconditionalReverseElimination
        x addForAll
        x φ ψ s SubstAddition
        applySyllogism

        φ ψ BiconditionalForwardElimination
        x addForAll
        x ψ φ s SubstAddition
        applySyllogism

        introduceBiconditionalFromImplicationsInConsequent
))
</jh>

Here is a rule form.<ref>Similar to [http://us.metamath.org/mpeuni/sbbii.html sbbii] in metamath's set.mm, accessed February 24, 2010, except that <code>s</code> is an <code>object</code> not a <code>variable</code></ref>
<jh>
thm (buildSubst () ((H (φ ↔ ψ))) ((subst s x φ) ↔ (subst s x ψ)) (
        H eliminateBiconditionalReverse
        s x addSubst
        H eliminateBiconditionalForward
        s x addSubst
        introduceBiconditionalFromImplications
))
</jh>

=== Proving there-exists ===
One way to prove a formula of the form <code>∃ x φ</code> is to demonstrate a particular <code>x</code> for which <code>φ</code> holds.  In [[w:Intuitionistic logic|constructive logic]] any theorem <code>∃ x φ</code> can be proved this way (because of the [[w:Existence property|existence property]]), but even in classical (non-constructive) logic this is one of the most common ways of proving <code>∃ x φ</code>.

In our notation, this idea is expressed via <code>subst</code>:
<jh>
thm (ThereExistsIntroductionFromObject ( (y φ) (y x) (y s)) ()
  ((subst s x φ) → (∃ x φ)) (
</jh>
The proof takes the definition of <code>subst</code>, <code>∃ y (y = s ∧ ∃ x (x = y ∧ φ))</code> and pares it down by eliminating the parts we don't need. We start by expanding the definition.
<jh>
        s x φ y Subst
        eliminateBiconditionalReverse
</jh>
Then we trim out <code>y = s</code>,
<jh>
        ((value y) = s) (∃ x (((value x) = (value y)) ∧ φ)) ConjunctionLeftElimination
        y addThereExists
        applySyllogism
</jh>
and <code>x = y</code>.
<jh>
        ((value x) = (value y)) φ ConjunctionLeftElimination
        x addThereExists
        y addThereExists
        applySyllogism
</jh>
The only thing remaining is to simplify <code>∃ y ∃ x φ</code> to <code>∃ x φ</code>.
<jh>
        removeThereExistsInConsequent
))

thm (introduceThereExistsFromObject () ((H (subst s x φ))) (∃ x φ) (
        H
        s x φ ThereExistsIntroductionFromObject
        applyModusPonens
))
</jh>

== Free variables and substitution ==
A substitution acts like a quantifier in the sense that it binds the variable being substituted. So this variable is not free in the substituted formula (provided it is not free in the object being substituted for the variable).
<jh>
thm (SubstNotFree ((x s)  (y x) (y s) (y φ)) () (x is-not-free-in (subst s x φ)) (
</jh>
The proof consists of just applying our not-free theorems to each piece of the definition of <code>subst</code>
<jh>
        x ((value y) = s) DistinctNotFree
        x (((value x) = (value y)) ∧ φ) BoundThereExistsNotFree
        conjunctionNotFree
        y addThereExistsNotFree

        s x φ y Subst
        x buildNotFree
        eliminateBiconditionalForward

        applyModusPonens
))
</jh>

== Axiom of quantifiability ==
Having gotten about as far as we're going to get without the [[Interface:Axiom of quantifiability]], we now start proving some consequences of it.

<jh>
import (QUANTIFIABILITY_AXIOM Interface:Axiom_of_quantifiability (CLASSICAL WITHOUT_QUANTIFIABILITY) ())
</jh>

== Specialization with substitution ==
The version of <code>Specialization</code> from [[Interface:First-order logic]] is not the one most often presented as a theorem (or axiom) of predicate logic.  The standard version also contains a substitution, and is often worded something like "if a formula holds for all values of a variable, it also holds when a particular term is properly substituted for that variable" or in symbols <code>∀ x φ → [ s / x ] φ</code>.<ref>[http://us.metamath.org/mpeuni/stdpc4.html stdpc4] in metamath's set.mm, accessed June 9, 2010</ref><ref>a5sbc in Raph Levien's [http://levien.com/garden/ghnew/peano/ Peano], accessed June 9, 2010</ref><ref>Hirst and Hirst, axiom 4 on page 51</ref>
<jh>
thm (SpecializationToObject ((y s) (y x) (y φ)) () ((∀ x φ) → (subst s x φ)) (
</jh>
We start with <code>∀ x φ ∧ ∃ x x = y → ∃ x (φ ∧ x = y)</code> and eliminate the second antecedent (because it is an instance of <code>Quantifiability</code>).
<jh>
        x (value y) Quantifiability
        x φ ((value x) = (value y)) ThereExistsConjunctionCombining
        detach2of2
</jh>
Commuting the conjunction in the consequent gives <code>∀ x φ → ∃ x (x = y ∧ φ)</code>
<jh>
        φ ((value x) = (value y)) ConjunctionCommutativity
        x buildThereExists
        eliminateBiconditionalReverse
        applySyllogism
</jh>
We are heading towards the definition of <code>[ s / x ] φ</code>, which has two quantifiers: an outer one on <code>y</code> and an inner one on <code>x</code>.  So far we have the quantifier for <code>x</code> and a similar set of steps to the ones we just took will give us a similar expression with a quantifier for <code>y</code>.
<jh>
        y addForAllToConsequent
</jh>
We add <code>∃ y y = s</code> (a theorem) to the consequent:
<jh>
        y s Quantifiability
        (∀ x φ) introduceAntecedent
        composeConjunction
</jh>
The consequent is <code>∀ y ∃ x (x = y ∧ φ) ∧ ∃ y y = s)</code>, which we first turn into <code>∃ y (∃ x (x = y ∧ φ) ∧ y = s)</code>,
<jh>
        y (∃ x (((value x) = (value y)) ∧ φ)) ((value y) = s) ThereExistsConjunctionCombining
        applySyllogism
</jh>
And then into <code>∃ y (y = s ∧ ∃ x (x = y ∧ φ))</code>.
<jh>
        (∃ x (((value x) = (value y)) ∧ φ)) ((value y) = s) ConjunctionCommutativity
        y buildThereExists
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Now we just need to apply the definition of <code>subst</code> and we are done:
<jh>
        s x φ y Subst
        eliminateBiconditionalForward
        applySyllogism))
</jh>

== Quantifiers and equality ==

Here we prove a number of results involving equality and quantifiers. Many of them will pave the way for results involving explicit (subst) substitution.

=== ax9oc ===
First is a consequence of the <code>Quantifiability</code> axiom:<ref>like [http://us.metamath.org/mpeuni/ax9o.html ax9o] in metamath's set.mm, accessed February 22, 2010, but for an object not a variable</ref>

<jh>
thm (ax9oc () () ((∀ x (((value x) = s) → (∀ x φ))) → φ) (
        x s Quantifiability
        x ((value x) = s) (∀ x φ) ForAllImplicationThereExists
</jh>
This gives us <code>∀ x (x = s → ∀ x φ) → (∃ x x = s → ∃ x ∀ x φ)</code>, which can be simplified to our desired result.  The first step is to note that <code>∃x x = s</code> is just the <code>Quantifiability</code> axiom, and can therefore be removed:
<jh>
        detachImplicationImplication
</jh>
Now we need to reduce <code>∃ x ∀ x φ</code> to <code>φ</code>:
<jh>
        x φ ax6o
        applySyllogism
))
</jh>

=== Implicit substitution and ∀ ===
A statement of the form <code>x = s → (φ ↔ ψ)</code>, where <code>x</code> is not free in <code>ψ</code>, can be thought of as an ''implicit substitution'', as it can be used to relate a formula about <code>x</code> to a formula about <code>s</code>. Here we relate such a statement to <code>∀x(x = s → φ)</code> (which is one of the formulas we'll be using in manipulating substitutions).<ref>[http://us.metamath.org/mpeuni/equsal.html equsal] in metamath's set.mm, accessed May 11, 2010, but for an object not a variable</ref>
<jh>
thm (ImplicitSubstitutionForAll () ((HFREE (x is-not-free-in ψ))) 
  ((∀ x (((value x) = s) → (φ ↔ ψ))) → ((∀ x (((value x) = s) → φ)) ↔ ψ)) (
</jh>
Starting with <code>x = s → (φ ↔ ψ)</code>, we first add <code>∀x</code> in front of the <code>ψ</code>:
<jh>
        HFREE
        ForAllAddRemoveNotFree swapBiconditional

        φ ψ (∀ x ψ) BiconditionalTransitivity export

        detachImplicationImplication

        ((value x) = s) addCommonAntecedent
</jh>
We now distribute the implication over the biconditional to get <code>(x = s → φ) ↔ (x = s → ∀ x ψ)</code>.
<jh>
        ((value x) = s) φ (∀ x ψ) ImplicationDistributionOverBiconditional eliminateBiconditionalReverse
        applySyllogism
</jh>
The entire formula we have at this point is <code>(x = s → (φ ↔ ψ)) → ((x = s → φ) ↔ (x = s → ∀ x ψ))</code>.  We will add <code>∀ x</code> to the start of each of the three parts.
<jh>
        x addForAll
        x (((value x) = s) → φ) (((value x) = s) → (∀ x ψ)) ForAllBiconditional
        applySyllogism
</jh>
The left side of that consequent, <code>∀ x (x = s → φ)</code>, is the left side of our desired consequent.

We will show that the right side, <code>∀ x (x = s → ∀ x ψ)</code>, is equivalent to <code>ψ</code>. The forward direction is just <code>ax9oc</code>:
<jh>
        x s ψ ax9oc
</jh>
The reverse direction is introducing an antecedent and messing around with quantifiers:
<jh>
        HFREE ForAllAddRemoveNotFree eliminateBiconditionalForward

        (∀ x ψ) ((value x) = s) AntecedentIntroduction
        a5i
        applySyllogism
</jh>
Now we just need to combine the forward and reverse directions,
<jh>
        introduceBiconditionalFromImplications
</jh>
and reassemble our result.
<jh>
        (∀ x (((value x) = s) → φ)) (∀ x (((value x) = s) → (∀ x ψ))) ψ BiconditionalTransitivity
        export
        detachImplicationImplication

        applySyllogism
))
</jh>

A rule form with a distinct variable constraint instead of a freeness hypothesis is:
<jh>
thm (ImplicitForAll ((x ψ)) ((HEQ (((value x) = s) → (φ ↔ ψ))))
  ((∀ x (((value x) = s) → φ)) ↔ ψ) (
        HEQ
        x generalize

        x ψ DistinctNotFree
        s φ ImplicitSubstitutionForAll

        applyModusPonens
))
</jh>

=== Implicit substitution and ∃ ===
There is a similar result with ∃.<ref>[http://us.metamath.org/mpeuni/equsex.html equsex] in metamath's set.mm, accessed March 9, 2010, with <code>s</code> (the replacement) changed from a <code>variable</code> to an <code>object</code></ref>

Our implicit substitution theorem is:
<jh>
thm (ImplicitSubstitutionThereExists () ((HFREE (x is-not-free-in ψ))) 
  ((∀ x (((value x) = s) → (φ ↔ ψ))) → ((∃ x (((value x) = s) ∧ φ)) ↔ ψ)) (
</jh>
The proof basically consists of massaging negations to derive this result from the corresponding one for ∀. We start by showing that <code>∀x (x = s → (φ ↔ ψ))</code> implies that <code>∀x(x = s → ¬ φ)</code> is equivalent to <code>¬ ψ</code>.
<jh>
        φ ψ NegationFunction eliminateBiconditionalReverse
        ((value x) = s) addCommonAntecedent
        x addForAll

        HFREE
        negateNotFree
        s (¬ φ) ImplicitSubstitutionForAll

        applySyllogism
</jh>
Now we need to show that <code>∀ x (x = s → ¬ φ) ↔ (¬ ψ)</code> implies <code>∃ x (x = s ∧ φ) ↔ ψ</code>. We first turn the former into <code>ψ ↔ (¬ ∀ x (x = s → ¬ φ))</code>:
<jh>
        (∀ x (((value x) = s) → (¬ φ))) ψ BiconditionalTranspositionWithNegatedRight
</jh>
We stick <code>ψ ↔ ψ</code> on the proof stack for later use,
<jh>
        ψ BiconditionalReflexivity
</jh>
and work just with <code>¬ ∀ x (x = s → ¬ φ)</code> for now. We move the negation past the quantifier to get <code>∃ x ¬ (x = s → ¬ φ)</code>:
<jh>
        x (((value x) = s) → (¬ φ)) NotForAll
</jh>
Now we turn the negations and implication into a conjunction:
<jh>
        ((value x) = s) φ ConjunctionImplication swapBiconditional
        x buildThereExists
        applyBiconditionalTransitivity
</jh>
Bringing back two statements we left on the proof stack, we assemble the formula that <code>∀ x (x = s → ¬ φ) ↔ (¬ ψ)</code> is equivalent to <code>ψ ↔ ∃ x (x = s ∧ φ)</code>,
<jh>
        buildBiconditional
        applyBiconditionalTransitivity
</jh>
flip the order to get <code>∃ x (x = s ∧ φ) ↔ ψ</code>,
<jh>
        eliminateBiconditionalReverse
        ψ (∃ x (((value x) = s) ∧ φ)) BiconditionalSymmetry eliminateBiconditionalReverse
        applySyllogism
</jh>
and combine this with the first part of the proof.
<jh>
        applySyllogism
))
</jh>

The rule form is:
<jh>
thm (ImplicitThereExistsNotFree () ((HFREE (x is-not-free-in ψ)) (HEQ (((value x) = s) → (φ ↔ ψ))))
  ((∃ x (((value x) = s) ∧ φ)) ↔ ψ) (
        HEQ
        x generalize

        HFREE
        s φ ImplicitSubstitutionThereExists

        applyModusPonens
))
</jh>

and a version with distinct variable constraint instead of a freeness hypothesis is:
<jh>
thm (ImplicitThereExists ((x ψ)) ((HEQ (((value x) = s) → (φ ↔ ψ))))
  ((∃ x (((value x) = s) ∧ φ)) ↔ ψ) (
        x ψ DistinctNotFree
        HEQ
        ImplicitThereExistsNotFree
))
</jh>

As a parenthetical note, we have proved <code>ImplicitThereExists</code> (and related results) in a fairly roundabout way, via strange-looking theorems which we don't use elsewhere, like <code>ax6o</code>, <code>ax9oc</code>, and <code>a5i</code>. A more direct proof from <code>Quantifiability</code> is possible.<ref>ceqsex in Raph Levien's [http://levien.com/garden/ghnew/peano/ Peano], accessed 2010</ref> We might be better served by using that proof, although it does add a distinct variable constraint between <code>x</code> and <code>s</code> (our current treatment does not impose that constraint at this stage, although many of the later substitution theorems do have such a constraint anyway).

=== Implicit substitution of an object for a variable ===
Suppose that we have a formula <code>φx</code> and a formula <code>φs</code> which is much the same, but with <code>s</code> in place of <code>x</code>.  Then if <code>φx</code> is a theorem, we can conclude <code>φs</code>.

Before we state this more formally, we prove a lemma.

<jh>
thm (VariableToObjectLemma ((x s) (x φ))
  ((H (((value x) = s) → φ)))
  φ (
        x s Quantifiability
        H
        x addThereExistsToAntecedent
        applyModusPonens
))
</jh>

Our main result can be restated as that <code>φx</code> and <code>x = s → (φx ↔ φs)</code> enable us to conclude <code>φs</code>.

<jh>
thm (VariableToObject ((x s) (x φs))
  ((HSUB (((value x) = s) → (φx ↔ φs)))
   (Hφx φx)
  )
  φs (
        Hφx HSUB detachImplicationBiconditional
        VariableToObjectLemma
))
</jh>

=== Object version of VariableSubstitution axiom ===
The <code>VariableSubstitution</code> axiom is stated in terms of substitution of one variable for another. The analogue in which an object is substituted for a variable also holds.
<jh>
thm (ObjectSubstitution ((x s) (x y) (φ y) (s y)) () 
  (((value x) = s) → (φ → (∀ x (((value x) = s) → φ)))) (
</jh>
The general idea of the proof is to "substitute" <code>s</code> for <code>y</code> using a formula of the form <code>y = s → (''a formula with y in it'' ↔ ''much the same formula, but with s'')</code>.

We start with our substitution, <code>y = s → ((x = y → (φ → ∀ x (x = y → φ))) ↔ (x = s → (φ → ∀ x (x = s → φ))))</code>
<jh>
        (value y) s (value x) EqualityBuilderLL

        (value y) s (value x) EqualityBuilderLL
        φ buildCommonConsequentInConsequent
        x buildForAllInConsequent
        φ buildCommonAntecedentInConsequent

        buildImplicationInConsequent
</jh>
Now we apply <code>VariableToObject</code> to convert the axiom to our desired result.
<jh>
        x y φ VariableSubstitution
        VariableToObject
))
</jh>

=== Two ways to express substitution when variables are distinct ===
In previous sections, we have seen that <code>∃ x (x = s ∧ φ)</code> and <code>∀ x (x = s → φ)</code> behave similarly.  In fact, as long as <code>x</code> and <code>s</code> are distinct, they are completely equivalent.<ref>[http://us.metamath.org/mpeuni/sb56.html sb56] in metamath's set.mm, accessed June 17, 2010, except that <code>s</code> is an <code>object</code> rather than a <code>variable</code></ref>
<jh>
thm (ThereExistsForAll ((x s)) () ((∃ x (((value x) = s) ∧ φ)) ↔ (∀ x (((value x) = s) → φ))) (
</jh>
First we stick something on the proof stack for later use:
<jh>
        x (((value x) = s) → φ) BoundForAllNotFree
</jh>
The proof consists of first proving <code>x = s → (φ ↔ ∀ x (x = s → φ))</code>,
<jh>
        x s φ ObjectSubstitution

        x (((value x) = s) → φ) Specialization
        applyComm

        introduceBiconditionalFromImplicationsInConsequent
</jh>
and then turning this implicit substitution into its ∃ form.
<jh>
        ImplicitThereExistsNotFree
))
</jh>

== Substitution and ∃ ==
We've already seen that <code>∃ x (x = s ∧ φ)</code> is closely related to substitution.  Here we show that it is equivalent to <code>[ s / x ] φ</code>, as long as <code>x</code> does not appear in <code>s</code>.
<jh>
thm (SubstitutionThereExists ((x s) (s y) (x y) (φ y)) () ( (subst s x φ) ↔ (∃ x (((value x) = s) ∧ φ))) (
</jh>
We start with applying some builders to get <code>y = s → (∃ x (x = y ∧ φ) ↔ ∃ x (x = s ∧ φ))</code>.
<jh>
        (value y) s (value x) EqualityBuilderLL
        φ buildConjunctionRRInConsequent
        x buildThereExistsInConsequent
</jh>
<code>ImplicitThereExists</code> then gives us <code>∃ y (y = s ∧ ∃ x (x = y ∧ φ)) ↔ ∃ x (x = s ∧ φ)</code>, which is our desired result by the definition of <code>subst</code>.
<jh>
        ImplicitThereExists
</jh>
Now we just need to apply the definition of <code>subst</code> and we are done:
<jh>
        swapBiconditional
        s x φ y Subst
        swapBiconditional
        applyBiconditionalTransitivity
        swapBiconditional
))
</jh>

== Substitution of a variable which is not free ==
Substituting a formula with a variable which is not free in that formula has no effect.<ref>[http://us.metamath.org/mpeuni/sbf.html sbf], metamath's set.mm, accessed July 20, 2010, except that the replacement is an object not a variable</ref>

<jh>
thm (NullSubstitution ((s x) (x φ)) () ((subst s x φ) ↔ φ) (
</jh>
We begin with <code>[s / x] φ → ∃ x (x = s ∧ φ)</code>.  The distinct variable constraint between <code>x</code> and <code>s</code> might not be needed.
<jh>
        s x φ SubstitutionThereExists
        eliminateBiconditionalReverse
</jh>
Since <code>x</code> is not free in <code>φ</code>, <code>∃ x (x = s ∧ φ)</code> in turn implies <code>∃ x x = s ∧ φ</code>
<jh>
        x ((value x) = s) φ ThereExistsConjunctionRightMovement
        eliminateBiconditionalReverse
        applySyllogism
</jh>
We can eliminate the left hand side of the consequent to get <code>[s / x] φ → φ</code>, which is the forward half of our desired result.
<jh>
        extractRightConjunction
</jh>
The reverse direction is easier. Generalization gets us <code>φ → ∀ x φ</code>, and <code>SpecializationToObject</code> turns that into <code>[ s / x ] φ</code>
<jh>
        φ x Generalization
        x φ s SpecializationToObject
        applySyllogism
</jh>
Combining the forward and reverse directions finishes the proof.
<jh>
        introduceBiconditionalFromImplications
))
</jh>

== Substitution can be moved across connectives and quantifiers ==
Substituting a formula consisting of a logical connective is equivalent to substituting each of the operands of that connective.

=== Negation ===
For negation, this is <code>[ s / x ] ¬ φ ↔ ¬ [ s / x ] φ</code>.<ref>[http://us.metamath.org/mpeuni/sbn.html sbn] in metamath's set.mm, accessed 2010, except that <code>s</code> is an <code>object</code> rather than a <code>variable</code></ref>

The proof consists of just moving negation around (via the following lemma) and applying <code>ThereExistsForAll</code>.

<jh>
thm (SubstNegationLemma () () 
  ((∀ x (((value x) = s) → (¬ φ))) ↔ (¬ (∃ x (((value x) = s) ∧ φ)))) (
        x s φ equs3
        transposeBiconditionalWithNegatedRight
))

thm (SubstNegation ((y x) (y s) (y φ)) () ((subst s x (¬ φ)) ↔ (¬ (subst s x φ))) (
        s x (¬ φ) y Subst

        y s (∃ x (((value x) = (value y)) ∧ (¬ φ))) ThereExistsForAll
        applyBiconditionalTransitivity

        x (value y) (¬ φ) ThereExistsForAll
        ((value y) = s) buildImplicationAntecedent
        y buildForAll
        applyBiconditionalTransitivity

        x (value y) φ SubstNegationLemma
        ((value y) = s) buildImplicationAntecedent
        y buildForAll
        applyBiconditionalTransitivity

        y s (∃ x (((value x) = (value y)) ∧ φ)) SubstNegationLemma
        applyBiconditionalTransitivity

        s x φ y Subst swapBiconditional
        addNegation
        applyBiconditionalTransitivity
))
</jh>

=== Disjunction ===
We can prove the ability to move substitution across a disjunction by expanding the definition and applying theorems which let us move ∃ and ∧ across disjunctions.
<jh>
thm (SubstDisjunction ( (y s) (y x) (y φ) (y ψ)) () ((subst s x (φ ∨ ψ)) ↔ ((subst s x φ) ∨ (subst s x ψ))) (
        s x (φ ∨ ψ) y Subst

        ((value x) = (value y)) φ ψ ConjunctionLeftDistribution
        x buildThereExists
        ((value y) = s) buildConjunctionLL
        y buildThereExists
        applyBiconditionalTransitivity

        x (((value x) = (value y)) ∧ φ) (((value x) = (value y)) ∧ ψ) ThereExistsDisjunction
        ((value y) = s) buildConjunctionLL
        y buildThereExists
        applyBiconditionalTransitivity

        ((value y) = s) (∃ x (((value x) = (value y)) ∧ φ)) (∃ x (((value x) = (value y)) ∧ ψ)) ConjunctionLeftDistribution
        y buildThereExists
        applyBiconditionalTransitivity

        y (((value y) = s) ∧ (∃ x (((value x) = (value y)) ∧ φ))) (((value y) = s) ∧ (∃ x (((value x) = (value y)) ∧ ψ))) ThereExistsDisjunction
        applyBiconditionalTransitivity

        s x φ y Subst
        s x ψ y Subst
        buildDisjunction
        swapBiconditional
        applyBiconditionalTransitivity
))
</jh>

=== Other connectives ===
The corresponding theorems for the other three connectives follow from those for negation and disjunction.
<jh>
thm (SubstConjunction () () ((subst s x (φ ∧ ψ)) ↔ ((subst s x φ) ∧ (subst s x ψ))) (
        φ ψ DeMorganNDN swapBiconditional
        s x buildSubst

        s x ((¬ φ) ∨ (¬ ψ)) SubstNegation
        applyBiconditionalTransitivity

        s x (¬ φ) (¬ ψ) SubstDisjunction
        addNegation
        applyBiconditionalTransitivity

        s x φ SubstNegation
        s x ψ SubstNegation
        buildDisjunction
        addNegation
        applyBiconditionalTransitivity

        (subst s x φ) (subst s x ψ) DeMorganNDN
        applyBiconditionalTransitivity
))

thm (SubstImplication () () ((subst s x (φ → ψ)) ↔ ((subst s x φ) → (subst s x ψ))) (
        φ ψ ImplicationDisjunction
        s x buildSubst

        s x (¬ φ) ψ SubstDisjunction
        applyBiconditionalTransitivity

        s x φ SubstNegation
        (subst s x ψ) buildDisjunctionRR
        applyBiconditionalTransitivity

        (subst s x φ) (subst s x ψ) ImplicationDisjunction
        swapBiconditional
        applyBiconditionalTransitivity
))

thm (SubstBiconditional () () ((subst s x (φ ↔ ψ)) ↔ ((subst s x φ) ↔ (subst s x ψ))) (
        φ ψ BiconditionalImplication
        s x buildSubst

        s x (φ → ψ) (ψ → φ) SubstConjunction
        applyBiconditionalTransitivity

        s x φ ψ SubstImplication
        s x ψ φ SubstImplication
        buildConjunction
        applyBiconditionalTransitivity

        (subst s x φ) (subst s x ψ) BiconditionalImplication
        swapBiconditional
        applyBiconditionalTransitivity
))
</jh>

=== Quantifiers ===
We can move substitution across a quantifier to a distinct variable: <code>[ s / x ] ∃ y φ ↔ ∃ y [ s / x ] φ</code>.<ref>[http://us.metamath.org/mpeuni/sbex.html sbex], metamath's set.mm</ref>
<jh>
thm (SubstThereExists ((x y s z) (z φ)) () ((subst s x (∃ y φ)) ↔ (∃ y (subst s x φ))) (
</jh>
To prove this, we simply expand the definition of <code>subst</code> and move <code>∃ y</code> across each piece of it. The expansion is <code>∃ z (z = s ∧ ∃ x (x = z ∧ ∃ y φ))</code>
<jh>
        s x (∃ y φ) z Subst

        y ((value x) = (value z)) φ ThereExistsConjunctionMovement
        x buildThereExists
        ((value z) = s) buildConjunctionLL
        z buildThereExists
        swapBiconditional
        applyBiconditionalTransitivity

        x y (((value x) = (value z)) ∧ φ) ThereExistsCommutation
        ((value z) = s) buildConjunctionLL
        z buildThereExists
        applyBiconditionalTransitivity

        y ((value z) = s) (∃ x (((value x) = (value z)) ∧ φ)) ThereExistsConjunctionMovement
        z buildThereExists
        swapBiconditional
        applyBiconditionalTransitivity

        z y (((value z) = s) ∧ (∃ x (((value x) = (value z)) ∧ φ))) ThereExistsCommutation
        applyBiconditionalTransitivity

        s x φ z Subst
        y buildThereExists
        swapBiconditional
        applyBiconditionalTransitivity
))
</jh>

== Composition ==
If we first substitute <code>y</code> for <code>x</code>, and then substitute <code>s</code> for <code>y</code>, the whole process is equivalent to substituting <code>s</code> for <code>x</code> (subject to some distinct variable constraints).<ref>sbcco in Raph Levien's [http://levien.com/garden/ghnew/peano/ Peano], accessed 12 Jun 2010. I don't know why the (x y) distinct variable constraint is missing from that version; the second invocation of sbc5 would seem to require it.</ref>
<jh>
thm (SubstitutionComposition ((φ y) (s y) (x y)) ()
  ((subst s y (subst (value y) x φ)) ↔ (subst s x φ)) (
</jh>
The proof consists of rewriting both of the substitutions on the left hand side via <code>SubstitutionThereExists</code>. First we show <code>[ s / y ] [ y / x ] φ ↔ ∃ y (y = s ∧ [ y / x ] φ)</code>.
<jh>
        s y (subst (value y) x φ) SubstitutionThereExists
</jh>
The second invocation of <code>SubstitutionThereExists</code> shows that the right hand side of that expression is equivalent to <code>∃ y (y = s ∧ ∃ x (x = y ∧ φ))</code>
<jh>
        (value y) x φ SubstitutionThereExists
        ((value y) = s) buildConjunctionLL
        y buildThereExists
        applyBiconditionalTransitivity
</jh>
But <code>∃ y (y = s ∧ ∃ x (x = y ∧ φ))</code> is <code>[ s / x ] φ</code>, by definition.
<jh>
        s x φ y Subst
        swapBiconditional applyBiconditionalTransitivity
))
</jh>

== Substitution of objects, with axiom of quantifiability ==
The axiom of quantifiability allows us to prove more substitution results because we can assume that a variable can take on a value corresponding to any object.

=== Substitution of a theorem remains a theorem ===
If we have a theorem, we can add a variable substitution onto it.

<jh>
thm (introduceSubst () ((H φ)) (subst s x φ) (
        H
        x generalize
        x φ s SpecializationToObject
        applyModusPonens
))
</jh>

=== Convert from implicit substitution ===
A statement of the form <code>x = s → (φ ↔ ψ)</code>, where <code>x</code> is not free in <code>ψ</code>, can be thought of as an ''implicit substitution'', as it can be used to relate a formula about <code>x</code> to a formula about <code>s</code>.

Although the distinct variable constraint between <code>x</code> and <code>s</code> should not be necessary (if we wanted to require that <code>x</code> and <code>s</code> are distinct we could have a simpler definition of <code>subst</code>), even the version with the constraint can be useful.

<jh>
thm (convertImplicitToSubst ((x s)  (y ψ) (x y) (y s) (y φ)) 
  ((HFREE (x is-not-free-in ψ))
   (HEQ (((value x) = s) → (φ ↔ ψ)))
  )
  ((subst s x φ) ↔ ψ) (
</jh>
The proof will basically consist of two applications of <code>ImplicitSubstitutionThereExists</code>.

First we rewrite <code>x = s → (φ ↔ ψ)</code> as <code>y = s → (x = y → (φ ↔ ψ))</code>
<jh>
        ((value y) = s) ((value x) = (value y)) ConjunctionCommutativity eliminateBiconditionalReverse
        (value x) (value y) s EqualityTransitivity
        applySyllogism

        HEQ
        applySyllogism

        export
</jh>
Now we add <code>∀ x</code> to the consequent:
<jh>
        x addForAllToConsequent
</jh>
The first application of <code>ImplicitSubstitutionThereExists</code> turns <code>∀ x (x = y → (φ ↔ ψ))</code> into <code>∃ x (x = y ∧ φ) ↔ ψ</code>:
<jh>
        HFREE
        (value y) φ ImplicitSubstitutionThereExists
</jh>
Combining these results gets <code>y = s → (∃x (x = y ∧ φ) ↔ ψ)</code>:
<jh>
        applySyllogism
</jh>
We then apply <code>ImplicitSubstitutionThereExists</code> again to get <code>∃ y (y = s ∧ ∃ x (x = y ∧ φ)) ↔ ψ)</code>, which is our desired result.
<jh>
        y generalize
        y ψ DistinctNotFree
        s (∃ x (((value x) = (value y)) ∧ φ)) ImplicitSubstitutionThereExists
        applyModusPonens
</jh>
Now we just need to apply the definition of <code>subst</code> and we are done:
<jh>
        swapBiconditional
        s x φ y Subst
        swapBiconditional
        applyBiconditionalTransitivity
        swapBiconditional
))

thm (makeSubstExplicit ((x s) (x ψ))
  ((H (((value x) = s) → (φ ↔ ψ))))
  ((subst s x φ) ↔ ψ) (
        x ψ DistinctNotFree
        H
        convertImplicitToSubst
))
</jh>

== Substituting one quantified variable for another ==
If we have a quantified formula, and we substitute the quantified variable for another (using <code>subst</code>), the formula holds with the substituted variable in the quantifier.  In symbols, this is <code>∀ x φ ↔ ∀ y [ y / x ] φ</code> and <code>∃ x φ ↔ ∃ y [ y / x ] φ</code>, where <code>y</code> is not free in <code>φ</code>.<ref>[http://us.metamath.org/mpeuni/sb8.html sb8] and [http://us.metamath.org/mpeuni/sb8e.html sb8e] in metamath's set.mm, accessed June 24, 2010</ref>

=== A theorem relating a substituted formula to equality ===
Here we prove <code>x = s → (φ ↔ [ s / x ] φ)</code>.<ref>[http://us.metamath.org/mpeuni/sbequ12.html sbequ12], metamath's set.mm, accessed October 6, 2010</ref> One way of understanding this theorem is to compare it with the following instance of <code>SubstBuilderReplacement</code>: <code>x = s → ([ x / x ] φ ↔ [ s / x ] φ)</code>. The similarity should be obvious (although we actually will prove <code>[ x / x ] φ ↔ φ</code> as a consequence of this result rather than the other way around).

First we prove the case where <code>x</code> and <code>s</code> are distinct (later we will be able to remove this limitation). We start with the forward direction.
<jh>
thm (EqualitySubstForward ((x s)  (z x) (z s) (z φ)) () (((value x) = s) → (φ → (subst s x φ))) (
</jh>
The proof consists of gradually building up the definition of <code>subst</code>. It is somewhat similar to the proof in metamath<ref>[http://us.metamath.org/mpeuni/sbequ1.html sbequ1]</ref> although the details are different because we have a different definition of <code>subst</code>.

We're going to start with <code>x = s ∧ φ → ∃ x (x = s ∧ φ)</code>, and then we want to change the innermost <code>s</code> to <code>z</code> (under the condition that <code>z = s</code>). We do this by using <code>(x = s ∧ φ) ∧ z = s</code> as an antecedent in both cases.
<jh>
        (((value x) = s) ∧ φ) ((value z) = s) ConjunctionRightElimination
        (((value x) = s) ∧ φ) x ThereExistsIntroduction
        applySyllogism
</jh>
The next bit is centered around the substitution <code>z = s → (∃ x (x = z ∧ φ) ↔ ∃ x (x = s ∧ φ))</code>. When combined with conjunction elimination and getting rid of half of the biconditional, it becomes <code>(x = s ∧ φ) ∧ z = s → (∃ x (x = s ∧ φ) → ∃ x (x = z ∧ φ))</code>.
<jh>
        (((value x) = s) ∧ φ) ((value z) = s) ConjunctionLeftElimination

        (value z) s (value x) EqualityBuilderLL
        φ buildConjunctionRRInConsequent
        x buildThereExistsInConsequent

        applySyllogism

        eliminateBiconditionalForwardInConsequent
</jh>
Combining those two formulas and exporting gives <code>x = s ∧ φ → (z = s → ∃ x (x = z ∧ φ))</code>.
<jh>
        applyModusPonensInConsequent
        export
</jh>
It is easy to add <code>∀ z</code> because <code>z</code> is distinct from everything else. This gives us <code>x = s ∧ φ → ∀ z (z = s → ∃ x (x = z ∧ φ))</code>.
<jh>
        z addForAllToConsequent
</jh>
Again, <code>z</code> being distinct makes life easy as we turn the consequent into the definition of subst and apply the definition.
<jh>
        z s (∃ x (((value x) = (value z)) ∧ φ)) ThereExistsForAll
        eliminateBiconditionalForward
        applySyllogism

        s x φ z Subst
        eliminateBiconditionalForward
        applySyllogism
</jh>
That gives us <code>x = s ∧ φ → [s / x] φ</code> which is just an export from our desired theorem.
<jh>
        export
))
</jh>

The reverse direction is basically a transposition away.
<jh>
thm (EqualitySubstReverse ((x s)) () (((value x) = s) → ((subst s x φ) → φ)) (
        x s (¬ φ) EqualitySubstForward

        s x φ SubstNegation
        transformImplicationImplicationConsequent

        (subst s x φ) φ Transposition
        eliminateBiconditionalForward
        applySyllogism
))

thm (EqualitySubstDistinct ((x s)) () (((value x) = s) → (φ ↔ (subst s x φ))) (
        x s φ EqualitySubstForward
        x s φ EqualitySubstReverse
        introduceBiconditionalFromImplicationsInConsequent
))
</jh>

=== Substituting a variable for itself ===
Here we prove <code>[ x / x ] φ ↔ φ</code>. Our proof is slightly more involved than metamath's, because we have a distinct variable constraint on <code>EqualitySubst</code> which is missing from the metamath equivalent thereof.<ref>[http://us.metamath.org/mpeuni/sbid.html sbid] in metamath's set.mm, accessed October 31, 2010</ref>
<jh>
thm (SubstItself ( (y x) (y φ) (y z) (z x) (z φ)) () ((subst (value x) x φ) ↔ φ) (
</jh>
Before we get started, we leave a statement on the proof stack for later.
<jh>
        y (value x) Quantifiability
</jh>
The first step is <code>y = x → (φ ↔ [ y / x ] φ)</code>.
<jh>
        (value y) (value x) EqualitySymmetry
        eliminateBiconditionalReverse

        x (value y) φ EqualitySubstDistinct
        applySyllogism
</jh>
The second step is <code>y = x → ([ y / x ] φ ↔ [ x / x ] φ)</code>.
<jh>
        (value y) (value x) x φ SubstBuilderReplacement
</jh>
The rest of the proof is just combining those two.
<jh>
        applyBiconditionalTransitivityInConsequent
</jh>
That gives us <code>y = x → (φ ↔ [ x / x ] φ)</code>. Because <code>y</code> is no longer found in the consequent, its value is arbitrary and we can remove it using <code>Quantifiability</code> (actually, the weaker <code>Existence</code> from [[Interface:Axioms of first-order logic]] would suffice, but we didn't bother to export that).
<jh>
        y addThereExists
        applyModusPonens

</jh>
Because [[Wikiproofs:JHilbert definition soundness|definitions in JHilbert]] are currently automatically expanded, we cannot just leave <code>[ x / x ] φ</code> as itself, but must expand it (so that we can give the variable <code>z</code> a name and declare the distinct variable constraint between <code>y</code> and <code>z</code>).
<jh>
        (value x) x φ z Subst
        φ buildBiconditionalLL
        y buildThereExists
        eliminateBiconditionalReverse
        applyModusPonens
</jh>
Now we can proceed to remove the quantifier.
<jh>
        removeThereExists

        swapBiconditional
))
</jh>

=== A version of EqualitySubst without the distinct variable requirement ===
Now that we have proved that <code>[ x / x ] φ ↔ φ</code>, we can use it to remove the distinct variable constraint from <code>EqualitySubst</code>.
<jh>
thm (EqualitySubst () () (((value x) = s) → (φ ↔ (subst s x φ))) (
</jh>
The first step is <code>x = s → ([ x / x ] φ ↔ [ s / x ] φ)</code>
<jh>
        (value x) s x φ SubstBuilderReplacement
</jh>
Now we turn <code>[ x / x ] φ</code> into <code>φ</code>.
<jh>
        x φ SubstItself
        transformImplicationBiconditionalLeft
))
</jh>

=== Change variable with explicit substitution ===
We can now prove the version of the change variable theorem with explicit substitutions.
<jh>
thm (ChangeVariableExplicitThereExists ((y φ) (x y)) () ((∃ x φ) ↔ (∃ y (subst (value y) x φ))) (
        x (value y) φ SubstNotFree
        y φ DistinctNotFree
        x (value y) φ EqualitySubst
        ChangeVariableThereExistsNotFree
))

thm (ChangeVariableExplicitForAll ((y φ) (x y)) () ((∀ x φ) ↔ (∀ y (subst (value y) x φ))) (
        x (value y) φ SubstNotFree
        y φ DistinctNotFree
        x (value y) φ EqualitySubst
        ChangeVariableForAllNotFree
))
</jh>

=== Changing the variable in a substitution ===
The variable in a substitution is bound like a quantified variable, and can be substituted in a similar way.
<jh>
thm (ChangeVariableSubstitution
  ((y φx) (x φy) (x y) (s x) (s y))
  ((H (((value x) = (value y)) → (φx ↔ φy))))
  ((subst s x φx) ↔ (subst s y φy)) (
</jh>
We rewrite <code>[ s / x ] φx</code> as <code>[ s / y ] [ y / x ] φx</code>.
<jh>
        s y x φx SubstitutionComposition
        swapBiconditional
</jh>
Our hypothesis implies that <code>[ y / x ] φx ↔ φy</code>, so we use this to change <code>[ s / y ] [ y / x ] φx</code> into <code>[ s / y ] φy</code>.
<jh>
        H
        makeSubstExplicit

        s y buildSubst

        applyBiconditionalTransitivity
))
</jh>

== Export ==
That gives us [[Interface:First-order logic with quantifiability]], which we now export.
<jh>
export (WITH_QUANTIFIABILITY Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
</jh>

== Footnotes ==
<references/>

== Cited works ==
Hirst, Holly P. and Hirst, Jeffry L. (2008-2009 Edition), ''[http://www.mathsci.appstate.edu/~jlh/primer/hirst.pdf A Primer for Logic and Proof]'', self-published on the web by [http://www.mathsci.appstate.edu/~jlh/ Jeff Hirst]

[[Category:Classical first-order logic]]