{{interfaces
| imports = [[Interface:Axioms of first-order logic in terms of variable substitution built on equality]]
| exports = [[Interface:First-order logic]]
}}

The purpose of this proof module is to prove first-order logic theorems from axioms. It closely follows [[First-order logic in terms of substitution built on equality]], differing in that it uses substitution of a variable for a variable, not a term for a variable.

We import some interfaces and define some variables:
<jh>
import (PROPOSITIONAL Interface:Classical_propositional_calculus () ())
import (AXIOMS Interface:Axioms_of_first-order_logic_in_terms_of_variable_substitution_built_on_equality (PROPOSITIONAL) ())

var (formula φ ψ χ θ φx φy φs ψy antecedent)
var (object s t u s0 s1 t0 t1)
var (variable x y z x0 x1 y0 y1)
</jh>

== A few rules based on axioms ==
Here is a rule form of <code>SpecializationToObject</code>.<ref>Theorem 17.1 in Margaris, page 74</ref>
<jh>
thm (specializeToVariable () ((H (∀ x φ))) (subst (value y) x φ) (
        H
        x φ y SpecializationToVariable
        applyModusPonens
))
</jh>

Here's another slight variant of that one.
<jh>
thm (specializeToVariableInConsequent () ((H (antecedent → (∀ x φ)))) (antecedent → (subst (value y) x φ)) (
        H
        x φ y SpecializationToVariable
        applySyllogism
))
</jh>

=== Builder for ∀ ===
For convenience, we define some rules concerning building up formulas. From <code>φ → ψ</code> we want to be able to get <code>∀ x φ → ∀ x ψ</code>.
<jh>
thm (addForAll () ((H (φ → ψ))) ((∀ x φ) → (∀ x ψ)) (
        H
        x generalize

        x φ ψ ForAllImplication

        applyModusPonens
))
</jh>

The builder for the biconditional follows trivially:
<jh>
thm (buildForAll () ((H (φ ↔ ψ))) ((∀ x φ) ↔ (∀ x ψ)) (
        H eliminateBiconditionalReverse x addForAll
        H eliminateBiconditionalForward x addForAll
        introduceBiconditionalFromImplications
))
</jh>

== Substitution ==

=== Distinct variable version of makeVariableSubstExplicitNotFree ===
<jh>
thm (makeVariableSubstExplicit ((x y) (x ψ))
  ((H (((value x) = (value y)) → (φ ↔ ψ))))
  ((subst (value y) x φ) ↔ ψ) (
        x ψ DistinctNotFree
        H
        makeVariableSubstExplicitNotFree
))
</jh>

=== Substitutions which replace equal terms ===
Replacing a variable with either of two terms has the same effect, if the two terms are equal. Since we are  assuming various builders for <code>subst</code> as axioms, we just need a rule form here.
<jh>
thm (buildVariableSubstReplacement () ((H ((value y0) = (value y1))))
  ((subst (value y0) x φ) ↔ (subst (value y1) x φ)) (
        H
        y0 y1 x φ VariableSubstBuilderReplacement
        applyModusPonens
))
</jh>

=== Builders ===
We assumed <code>VariableSubstAddition</code> as an axiom. We biconditionalize it and add some rules.
<jh>
thm (VariableSubstBuilder () () ((∀ x (φ ↔ ψ)) → ((subst (value y) x φ) ↔ (subst (value y) x ψ))) (
        φ ψ BiconditionalReverseElimination
        x addForAll

        x φ ψ y VariableSubstAddition
        applySyllogism

        φ ψ BiconditionalForwardElimination
        x addForAll

        x ψ φ y VariableSubstAddition
        applySyllogism

        introduceBiconditionalFromImplicationsInConsequent
))

thm (addVariableSubst () ((H (φ → ψ))) ((subst (value y) x φ) → (subst (value y) x ψ)) (
        H
        x generalize
        x φ ψ y VariableSubstAddition
        applyModusPonens
))

thm (buildVariableSubst () ((H (φ ↔ ψ))) ((subst (value y) x φ) ↔ (subst (value y) x ψ)) (
        H
        x generalize
        x φ ψ y VariableSubstBuilder
        applyModusPonens
))
</jh>

=== Composition ===
The ability to compose two substitutions is an easy consequence of <code>makeSubstExplicit</code> and <code>SubstBuilderReplacement</code>.

<jh>
thm (VariableSubstitutionComposition ((φ y) (z y) (x y)) ()
  ((subst (value z) y (subst (value y) x φ)) ↔ (subst (value z) x φ)) (
</jh>
We start with <code>y = z → ([ y / x ] φ ↔ [ z / x ] φ)</code>.
<jh>
        y z x φ VariableSubstBuilderReplacement
</jh>
That's all set up for <code>makeVariableSubstExplicit</code>.
<jh>
        makeVariableSubstExplicit
))
</jh>

=== Substituting a variable with something equal to itself ===
The following result follows directly from <code>SubstBuilderReplacement</code> and <code>SubstItself</code>.
<jh>
thm (EqualityVariableSubst () () (((value x) = (value y)) → (φ ↔ (subst (value y) x φ))) (
</jh>
The first step is <code>x = y → ([ x / x ] φ ↔ [ y / x ] φ)</code>
<jh>
        x y x φ VariableSubstBuilderReplacement
</jh>
Now we turn <code>[ x / x ] φ</code> into <code>φ</code>.
<jh>
        x φ SubstItself
        transformImplicationBiconditionalLeft
))
</jh>

=== Turning an equality-based builder into the ability to move substitution across a predicate or operation ===
Substitution can be moved in or out of a predicate or operation, provided the predicate or operation has a builder. Here we show how, for the case where the predicate is <code>¬</code> and the builder is the forward direction of <code>NegationFunction</code>.

We start with the special case in which the variable being substituted is distinct from its replacement.
<jh>
thm (VariableSubstNegationDistinct ((x y)) () ((subst (value y) x (¬ φ)) ↔ (¬ (subst (value y) x φ))) (
</jh>
A bit later we'll need <code>x is-not-free-in ¬ subst y x φ</code>, so we stick that on the proof stack.
<jh>
        x y φ VariableSubstNotFree
        negateNotFree
</jh>
We start with <code>x = y → (φ ↔ subst y x φ)</code>.
<jh>
        x y φ EqualityVariableSubst
</jh>
Now we add our predicate (here negation) to the right side, to get <code>x = y → (¬ φ ↔ ¬ subst y x φ)</code>.
<jh>
        φ (subst (value y) x φ) NegationFunction
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Making that substitution explicit gives us <code>subst y x ¬ φ ↔ ¬ subst y x φ</code>, which is what we need.
<jh>
        makeVariableSubstExplicitNotFree
))
</jh>

Removing the distinct variable constraint is a matter of first substituting for an intermediate variable (which is distinct from everything), and then substituting the original replacement.
<jh>
thm (VariableSubstNegation ( (y x) (y z) (y φ)) () ((subst (value z) x (¬ φ)) ↔ (¬ (subst (value z) x φ))) (
        z y x (¬ φ) VariableSubstitutionComposition
        swapBiconditional
</jh>
Now we have <code>[ z / y ] [ y / x ] ¬ φ</code>, which we first transform to <code>[ z / y ] ¬ [ y / x ] φ</code>,
<jh>
        y x φ VariableSubstNegationDistinct
        z y buildVariableSubst
        applyBiconditionalTransitivity
</jh>
and then <code>¬ [ z / y ] [ y / x ] φ</code>.
<jh>
        z y (subst (value y) x φ) VariableSubstNegationDistinct
        applyBiconditionalTransitivity
</jh>
Applying composition once more we are done.
<jh>
        z y x φ VariableSubstitutionComposition
        addNegation
        applyBiconditionalTransitivity
))
</jh>

=== Subst across implication ===
While we are here, we'll go ahead and prove the analogous result for the other connectives, starting with implication. The proof is very much like the one for negation, with the most obvious difference being that implication has two arguments instead of just one.

<jh>
thm (VariableSubstImplicationDistinct ((y x)) ()
  ((subst (value y) x (φ → ψ)) ↔ ((subst (value y) x φ) → (subst (value y) x ψ))) (
</jh>
A bit later we'll need <code>x is-not-free-in (subst y x φ → subst y x ψ)</code>, so we stick that on the proof stack.
<jh>
        x y φ VariableSubstNotFree
        x y ψ VariableSubstNotFree
        implicationNotFree
</jh>
We start with <code>x = y → ((subst x x φ → subst x x ψ) ↔ (subst y x φ → subst y x ψ))</code>,
<jh>
        x y x φ VariableSubstBuilderReplacement
        x y x ψ VariableSubstBuilderReplacement
        buildImplicationInConsequent
</jh>
and simplify to <code>x = y → ((φ → ψ) ↔ (subst y x φ → subst y x ψ))</code>.
<jh>
        x φ SubstItself
        x ψ SubstItself
        buildImplication
        transformImplicationBiconditionalLeft
</jh>
Making that substitution explicit gives us <code>subst y x (φ → ψ) ↔ (subst y x φ → subst y x ψ)</code>, which is what we need.
<jh>
        makeVariableSubstExplicitNotFree
))
</jh>

Removing the distinct variable constraint is analogous to what we did for negation.
<jh>
thm (VariableSubstImplication ( (y x) (y z) (y φ) (y ψ)) ()
  ((subst (value z) x (φ → ψ)) ↔ ((subst (value z) x φ) → (subst (value z) x ψ))) (
        z y x (φ → ψ) VariableSubstitutionComposition
        swapBiconditional

        y x φ ψ VariableSubstImplicationDistinct
        z y buildVariableSubst
        applyBiconditionalTransitivity

        z y (subst (value y) x φ) (subst (value y) x ψ) VariableSubstImplicationDistinct
        applyBiconditionalTransitivity

        z y x φ VariableSubstitutionComposition
        z y x ψ VariableSubstitutionComposition
        buildImplication
        applyBiconditionalTransitivity
))
</jh>

=== Subst across disjunction ===
Although we could prove similar results for the other three connectives in the same way, it will be slightly more convenient to just prove them from the two we already proved.
<jh>
thm (VariableSubstDisjunction () ()
  ((subst (value y) x (φ ∨ ψ)) ↔ ((subst (value y) x φ) ∨ (subst (value y) x ψ))) (
        φ ψ DisjunctionImplication
        y x buildVariableSubst

        y x (¬ φ) ψ VariableSubstImplication
        applyBiconditionalTransitivity

        y x φ VariableSubstNegation
        (subst (value y) x ψ) buildImplicationConsequent
        applyBiconditionalTransitivity

        (subst (value y) x φ) (subst (value y) x ψ) DisjunctionImplication
        swapBiconditional
        applyBiconditionalTransitivity
))

thm (VariableSubstConjunction () ()
  ((subst (value y) x (φ ∧ ψ)) ↔ ((subst (value y) x φ) ∧ (subst (value y) x ψ))) (
        φ ψ DeMorganNDN swapBiconditional
        y x buildVariableSubst

        y x ((¬ φ) ∨ (¬ ψ)) VariableSubstNegation
        applyBiconditionalTransitivity

        y x (¬ φ) (¬ ψ) VariableSubstDisjunction
        addNegation
        applyBiconditionalTransitivity

        y x φ VariableSubstNegation
        y x ψ VariableSubstNegation
        buildDisjunction
        addNegation
        applyBiconditionalTransitivity

        (subst (value y) x φ) (subst (value y) x ψ) DeMorganNDN
        applyBiconditionalTransitivity
))

thm (VariableSubstBiconditional () ()
  ((subst (value y) x (φ ↔ ψ)) ↔ ((subst (value y) x φ) ↔ (subst (value y) x ψ))) (
        φ ψ BiconditionalImplication
        y x buildVariableSubst

        y x (φ → ψ) (ψ → φ) VariableSubstConjunction
        applyBiconditionalTransitivity

        y x φ ψ VariableSubstImplication
        y x ψ φ VariableSubstImplication
        buildConjunction
        applyBiconditionalTransitivity

        (subst (value y) x φ) (subst (value y) x ψ) BiconditionalImplication
        swapBiconditional
        applyBiconditionalTransitivity
))
</jh>

== Existential quantification ==
We define <code>∃</code> in terms of <code>∀</code>.<ref>Margaris, page 49</ref>
<jh>
def ((∃ x φ) (¬ (∀ x (¬ φ))))
</jh>

== Existential Introduction ==
Introducing <code>∃</code> from a substitution is closely related to specializing <code>∀</code> to a substitution.

<jh>
thm (ThereExistsIntroductionFromVariable () () ((subst (value y) x φ) → (∃ x φ)) (
</jh>
We start with <code>∀ x ¬ φ → [ y / x ] ¬ φ</code>,
<jh>
        x (¬ φ) y SpecializationToVariable
</jh>
turn the consequent into <code>¬ [ y / x ] φ</code>,
<jh>
        y x φ VariableSubstNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh> 
and transpose to get <code>[ y / x ] φ → ¬ ∀ x ¬ φ<code>, which is what we want.
<jh>
        transposeWithNegatedConsequent
))
</jh>

Here's a rule form.
<jh>
thm (introduceThereExistsFromVariable () ((H (subst (value y) x φ))) (∃ x φ) (
        H
        y x φ ThereExistsIntroductionFromVariable
        applyModusPonens
))
</jh>

== Specialization and existential introduction without a substitution ==
If we substitute a variable for itself, we get the following special case of <code>SpecializationToObject</code>.

<jh>
thm (Specialization () () ((∀ x φ) → φ) (
        x φ x SpecializationToVariable

        x φ SubstItself
        eliminateBiconditionalReverse
        applySyllogism
))

thm (specialize () ((H (∀ x φ))) φ (
        H
        x φ Specialization
        applyModusPonens
))
</jh>

Likewise, <code>φ → ∃ x φ</code> is a special case of <code>[ s / x ] φ → ∃ x φ</code>.

<jh>
thm (ThereExistsIntroduction () () (φ → (∃ x φ)) (
        x φ SubstItself
        eliminateBiconditionalForward

        x x φ ThereExistsIntroductionFromVariable
        applySyllogism
))
</jh>

The previous results let us conclude <code>∀ x φ → ∃ x φ</code>.<ref>Theorem 17.6, Margaris, page 76</ref>
<jh>
thm (ForAllThereExists () () ((∀ x φ) → (∃ x φ)) (
        x φ Specialization
        φ x ThereExistsIntroduction
        applySyllogism
))
</jh>

== Quantifier commutation ==
We can exchange the order of universal quantifiers.<ref>Theorem 17.10, Margaris, page 78</ref> Margaris's proof doesn't quite work as-is, as it relies on the deduction theorem, but a fairly small variation of it avoids this problem.
<jh>
thm (ForAllCommutationImplication () () ((∀ x (∀ y φ)) → (∀ y (∀ x φ))) (
</jh>
First we add <code>∀ x</code> to the start of <code>∀ x ∀ y φ</code>.
<jh>
        x (∀ y φ) BoundForAllNotFree
        GeneralizationNotFree
</jh>
Then we add <code>∀ y</code> to the start.
<jh>
        y φ BoundForAllNotFree
        x addForAllNotFree
        x addForAllNotFree
        GeneralizationNotFree
        applySyllogism
</jh>
That gives us <code>∀ y ∀ x ∀ x ∀ y φ</code> and dropping the last two quantifiers we are done.
<jh>
        y φ Specialization
        x addForAll
        x addForAll
        y addForAll
        applySyllogism

        x φ Specialization
        x addForAll
        y addForAll
        applySyllogism
))
</jh>

The biconditional version follows trivially.<ref>Theorem 19.2, Margaris, page 91, which metamath cites as 19.5</ref>
<jh>
thm (ForAllCommutation () () ((∀ x (∀ y φ)) ↔ (∀ y (∀ x φ))) (
        x y φ ForAllCommutationImplication
        y x φ ForAllCommutationImplication
        introduceBiconditionalFromImplications
))
</jh>

== Adding and removing quantifiers ==
Although Margaris does not tackle the biconditionalized version of this theorem until later, it will be convenient to prove it now. It is that <code>∀ x φ ↔ φ</code>, if <code>x</code> is not free in <code>φ</code>.<ref>Theorem 19.1, Margaris, page 90, cited by metamath as 19.3</ref>

<jh>
thm (ForAllAddRemoveNotFree () ((XFREE (x is-not-free-in φ))) ((∀ x φ) ↔ φ) (
        x φ Specialization

        XFREE
        GeneralizationNotFree

        introduceBiconditionalFromImplications
))
</jh>

== Moving is-not-free-in across connectives ==
The idea that a variable which is not free in the left hand and right hand sides of a connective is not free in the connected formula is basic to the understanding of what it means for a variable to not be free in a formula. We adopted this as an axiom for negation and implication. Here we prove it from the other three connectives, which follow easily from the two axioms.

=== Disjunction ===
<jh>
thm (disjunctionNotFree ()
  ((HPHI (x is-not-free-in φ)) (HPSI (x is-not-free-in ψ)))
  (x is-not-free-in (φ ∨ ψ)) (
        HPHI
        negateNotFree

        HPSI
        implicationNotFree
</jh>
So far that's <code>x is-not-free-in (¬ φ → ψ)</code>. Turning the implication to a disjunction we are done.
<jh>
        φ ψ DisjunctionImplication
        x buildNotFree
        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

=== Conjunction ===
<jh>
thm (conjunctionNotFree ()
  ((HPHI (x is-not-free-in φ)) (HPSI (x is-not-free-in ψ)))
  (x is-not-free-in (φ ∧ ψ)) (
        HPHI
        negateNotFree

        HPSI
        negateNotFree

        disjunctionNotFree
        negateNotFree

        φ ψ DeMorganNDN
        x buildNotFree
        eliminateBiconditionalReverse
        applyModusPonens
))
</jh>

=== Biconditional ===
<jh>
thm (biconditionalNotFree ()
  ((HPHI (x is-not-free-in φ)) (HPSI (x is-not-free-in ψ)))
  (x is-not-free-in (φ ↔ ψ)) (
        HPHI
        HPSI
        implicationNotFree

        HPSI
        HPHI
        implicationNotFree

        conjunctionNotFree

        φ ψ BiconditionalImplication
        x buildNotFree
        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

=== Existential quantification ===
In a manner similar to the connectives, freeness for <code>∃</code> follows from the corresponding axioms for <code>∀</code>.
<jh>
thm (BoundThereExistsNotFree () () (x is-not-free-in (∃ x φ)) (
        x (¬ φ) BoundForAllNotFree
        negateNotFree
))

thm (addThereExistsNotFree () ((HFREE (x is-not-free-in φ))) (x is-not-free-in (∃ y φ)) (
        HFREE
        negateNotFree
        y addForAllNotFree
        negateNotFree
))
</jh>

== Adding existential quantification to the antecedent ==
Margaris expresses many of his proofs in terms of a rule which he calls ''Rule C''.<ref>Theorem 17.12, Margaris, page 79</ref> We give a few variants of rule C, one is that given <code>φ → ψ</code> we can conclude <code>∃ φ → ψ</code>, provided that <code>x</code> is not free in <code>Ψ</code>. Margaris' version basically combines this with the deduction theorem.

The first variation is Theorem 17.11 in Margaris.<ref>Margaris, page 78</ref>
<jh>
thm (ThereExistsAntecedentIntroductionNotFree ()
  ((HFREE (x is-not-free-in ψ)))
  ((∀ x (φ → ψ)) → ((∃ x φ) → ψ)) (
</jh>
We start with <code>∀ x (φ → ψ) → (∀ x ¬ ψ → ∀ x ¬ φ)</code>.
<jh>
        φ ψ Transposition
        eliminateBiconditionalReverse
        x addForAll

        x (¬ ψ) (¬ φ) ForAllImplication
        applySyllogism
</jh>
Now we change <code>∀ x ¬ ψ</code> to <code>¬ ψ</code>.
<jh>
        HFREE
        negateNotFree

        ForAllAddRemoveNotFree

        transformImplicationImplicationAntecedent
</jh>
Then we turn <code>¬ ψ → ∀ x ¬ φ</code> into <code>¬ ∀ x ¬ φ → ψ</code>, which is all we need.
<jh>
        ψ (∀ x (¬ φ)) TranspositionWithNegatedAntecedent
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

The other variations are direct consequences of this one.
<jh>
thm (addThereExistsToAntecedentNotFree ()
  ((HFREE (x is-not-free-in ψ)) (HIMP (φ → ψ)))
  ((∃ x φ) → ψ) (
        HIMP
        x generalize

        HFREE
        φ ThereExistsAntecedentIntroductionNotFree

        applyModusPonens
))

thm (addThereExistsToAntecedent ((x ψ))
  ((H (φ → ψ)))
  ((∃ x φ) → ψ) (
        x ψ DistinctNotFree
        H
        addThereExistsToAntecedentNotFree
))
</jh>

We now prove a number of theorems using the ability to add there exists to the antecedent.

=== There exists across a conjunction ===
There exists can be split across a conjunction.<ref>Theorem 17.14, Margaris, page 80</ref>
<jh>
thm (ThereExistsConjunction () () ((∃ x (φ ∧ ψ)) → ((∃ x φ) ∧ (∃ x ψ))) (
</jh>
We start with <code>x is-not-free-in (∃ x φ ∧ ∃ x ψ)</code>.
<jh>
        x φ BoundThereExistsNotFree
        x ψ BoundThereExistsNotFree
        conjunctionNotFree
</jh>
The other part of the proof is <code>φ ∧ ψ → ∃ x φ ∧ ∃ x ψ</code>.
<jh>
        φ ψ ConjunctionRightElimination

        φ x ThereExistsIntroduction
        applySyllogism

        φ ψ ConjunctionLeftElimination

        ψ x ThereExistsIntroduction
        applySyllogism

        composeConjunction

        addThereExistsToAntecedentNotFree
))
</jh>

=== Adding there exists to both sides of an implication ===
Here we prove <code>∀ x (φ → ψ) → (∃ x φ → ∃ x ψ)</code>.<ref>Theorem 17.15, Margaris, page 80</ref>
<jh>
thm (ForAllImplicationThereExists () () ((∀ x (φ → ψ)) → ((∃ x φ) → (∃ x ψ))) (
</jh>
We start with <code>∀ x (φ → ψ) → ∀ x (φ → ∃ x ψ)</code>.
<jh>
        ψ x ThereExistsIntroduction
        φ addCommonAntecedent
        x addForAll
</jh>
Combining that with <code>∀ x (φ → ∃ x ψ) → (∃ x φ → ∃ x ψ)</code> we are done.
<jh>
        x ψ BoundThereExistsNotFree
        φ ThereExistsAntecedentIntroductionNotFree

        applySyllogism
))
</jh>

The rule form will also be convenient.
<jh>
thm (addThereExists () ((H (φ → ψ))) ((∃ x φ) → (∃ x ψ)) (
        H
        x generalize
        x φ ψ ForAllImplicationThereExists
        applyModusPonens
))
</jh>

=== There exists commutation ===
The next theorem is <code>∃ x ∃ y φ → ∃ y ∃ x φ</code>.<ref>Theorem 17.17, Margaris, page 81</ref>  We could, of course, prove this as a consequence of the corresponding theorem for <code>∀</code>, but instead we follow Margaris's proof, which adds the quantifiers with <code>ThereExistsIntroduction</code> and removes them with <code>addThereExistsToAntecedentNotFree</code>.
<jh>
thm (ThereExistsCommutationImplication () () ((∃ x (∃ y φ)) → (∃ y (∃ x φ))) (
</jh>
When we invoke <code>addThereExistsToAntecedentNotFree</code>, it will expect the freeness hypotheses before the implications, so we start by sticking <code>x is-not-free-in ∃ y ∃ x φ</code> and <code>y is-not-free-in ∃ y ∃ x φ</code> onto the proof stack.
<jh>
        x φ BoundThereExistsNotFree
        y addThereExistsNotFree

        y (∃ x φ) BoundThereExistsNotFree
</jh>
Now we can prove <code>φ → ∃ y ∃ x φ</code> and then add the quantifiers to the antecedent.
<jh>
        φ x ThereExistsIntroduction

        (∃ x φ) y ThereExistsIntroduction
        applySyllogism

        addThereExistsToAntecedentNotFree

        addThereExistsToAntecedentNotFree
))
</jh>

The biconditional version follows trivially.<ref>Theorem scheme 11 on Margaris, page 89, which metamath cites as 19.11</ref>
<jh>
thm (ThereExistsCommutation () () ((∃ x (∃ y φ)) ↔ (∃ y (∃ x φ))) (
        x y φ ThereExistsCommutationImplication
        y x φ ThereExistsCommutationImplication
        introduceBiconditionalFromImplications
))
</jh>

== Equivalence and replacement ==
Although we don't develop a detailed theory of equivalence and replacement (involving substituting equals for equals) quite the way that Margaris presents it, many of the theorems in this chapter of Margaris apply here.

=== Adding for-all to the consequent ===
Here we prove <code>∀ x (φ → ψ) ↔ (φ → ∀ x ψ)</code>, where <code>x</code> is not free in <code>φ</code>,<ref>Theorem scheme 21 in Margaris, page 90, cited by metamath as 19.21</ref> and some related theorems and rules. Although Margaris does not emphasize this theorem, it forms the counterpart to adding there exists to the antecedent. That is, Margaris proofs which invoke Rule C can be translated fairly directly into proofs which invoke <code>addThereExistsToAntecedentNotFree</code>, and Margaris proofs which invoke generalization combined with the deduction theorem can be translated similarly into proofs which invoke <code>addForAllToConsequentNotFree</code>.

<jh>
thm (ForAllConsequentNotFreeForward ()
  ((HFREE (x is-not-free-in φ)))
  ((∀ x (φ → ψ)) → (φ → (∀ x ψ))) (
        x φ ψ ForAllImplication

        HFREE
        ForAllAddRemoveNotFree
        eliminateBiconditionalForward

        (∀ x ψ) addCommonConsequent

        applySyllogism
))

thm (addForAllToConsequentNotFree () ((HFREE (x is-not-free-in φ)) (HIMP (φ → ψ)))
  (φ → (∀ x ψ)) (
        HIMP
        x generalize

        HFREE
        ψ ForAllConsequentNotFreeForward

        applyModusPonens
))

thm (ForAllConsequentNotFreeReverse ()
  ((HFREE (x is-not-free-in φ)))
  ((φ → (∀ x ψ)) → (∀ x (φ → ψ))) (
</jh>
This proof is adapted from metamath.<ref>[http://us.metamath.org/mpeuni/19.21.html 19.21], metamath's set.mm, accessed Jan 2012</ref> We start with <code>x is-not-free-in (φ → ∀ x ψ)<code>.
<jh>
        HFREE
        x ψ BoundForAllNotFree
        implicationNotFree
</jh>
Now specialization and adding for all to the consequent finish the job.
<jh>
        x ψ Specialization
        φ addCommonAntecedent
        addForAllToConsequentNotFree
))

thm (ForAllConsequentNotFree ()
  ((HFREE (x is-not-free-in φ)))
  ((∀ x (φ → ψ)) ↔ (φ → (∀ x ψ))) (
        HFREE
        ψ ForAllConsequentNotFreeForward

        HFREE
        ψ ForAllConsequentNotFreeReverse

        introduceBiconditionalFromImplications
))

thm (addForAllToConsequent ((x φ))
  ((H (φ → ψ)))
  (φ → (∀ x ψ)) (
        x φ DistinctNotFree
        H
        addForAllToConsequentNotFree
))
</jh>

=== For all across a biconditional ===
We can distribute for all across a biconditional.<ref>Theorem 18.1, Margaris, page 83</ref> Although we probably could more or less follow Margaris's proof using <code>ForAllConsequentNotFree</code> and the like, there are some complications in translating that proof to our setup (which lacks the deduction theorem), so we opt for a simpler proof based more directly on <code>ForAllImplication</code>.
<jh>
thm (ForAllBiconditionalImplication () () ((∀ x (φ ↔ ψ)) → ((∀ x φ) → (∀ x ψ))) (
        φ ψ BiconditionalReverseElimination
        x addForAll

        x φ ψ ForAllImplication
        applySyllogism
))

thm (ForAllBiconditional () () ((∀ x (φ ↔ ψ)) → ((∀ x φ) ↔ (∀ x ψ))) (
        x φ ψ ForAllBiconditionalImplication

        φ ψ BiconditionalSymmetry
        eliminateBiconditionalReverse
        x addForAll

        x ψ φ ForAllBiconditionalImplication
        applySyllogism

        introduceBiconditionalFromImplicationsInConsequent
))
</jh>

=== Replacement ===
For Margaris, the ability to replace a formula with one which is equivalent to it is stated in terms of substituting a formula for a subformula of a larger formula. The equivalent for us can accomplish the same things, but is a bit more low-level, and consists of various theorems involving biconditionals. We have already seen <code>buildForAll</code> and similar theorems for propositional logic. Here is the counterpart for <code>∃</code>.
<jh>
thm (buildThereExists () ((H (φ ↔ ψ))) ((∃ x φ) ↔ (∃ x ψ)) (
        H
        addNegation
        x buildForAll
        addNegation
))
</jh>

=== Negation and quantifiers ===
Margaris next proves <code>∀ x φ ↔ ¬ ∃ x ¬ φ</code>, using replacement.<ref>Theorem 18.5, Margaris, page 85</ref> We don't need that particular theorem to export to [[Interface:First-order logic with quantifiability]], so we can demonstrate the same replacement-like reasoning with <code>∃ x ¬ φ ↔ ¬ ∀ x φ</code>.<ref>Theorem scheme 14, Margaris, page 90</ref> The proof starts with <code>φ ↔ ¬ ¬ φ</code>, but we then need to replace this formula within a quantifier and a negation, which in Margaris is done with the replacement theorem and in our case is done with <code>buildForAll</code> and <code>addNegation</code>.
<jh>
thm (NotForAll () () ((¬ (∀ x φ)) ↔ (∃ x (¬ φ))) (
        φ DoubleNegation
        x buildForAll
        addNegation
))
</jh>

=== Change of variable in ∀ ===
We now turn to changing the variable of quantification.

<jh>
thm (ChangeVariableForAllImplicationNotFree ((x y))
  ((HFREEX (x is-not-free-in φy))
   (HFREEY (y is-not-free-in φx))
   (H (((value x) = (value y)) → (φx ↔ φy)))
  )
  ((∀ x φx) → (∀ y φy)) (
</jh>
We start with <code>∀ x φx → [ y / x ] φx</code> and then add <code>∀ y</code> to the consequent.
<jh>
        HFREEY
        x addForAllNotFree
        x φx y SpecializationToVariable
        addForAllToConsequentNotFree
</jh>
Our hypothesis easily leads to <code>[ y / x ] φx ↔ φy</code>.
<jh>
        HFREEX
        H
        makeVariableSubstExplicitNotFree
</jh>
Combining those two results we are done.
<jh>
        eliminateBiconditionalReverse
        y addForAll
        applySyllogism
))

thm (ChangeVariableForAllNotFree ((x y))
  ((HFREEX (x is-not-free-in φy))
   (HFREEY (y is-not-free-in φx))
   (H (((value x) = (value y)) → (φx ↔ φy)))
  )
  ((∀ x φx) ↔ (∀ y φy)) (
</jh>
The forward implication is what we just proved.
<jh>
        HFREEX HFREEY H ChangeVariableForAllImplicationNotFree
</jh>
The reverse implication is much the same. We just need to start out by transforming the hypothesis into <code>y = x → (φy ↔ φx)</code>.
<jh>
        HFREEY HFREEX
        H
        x y VariableEqualitySymmetry
        transformAntecedent

        φx φy BiconditionalSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        ChangeVariableForAllImplicationNotFree

        introduceBiconditionalFromImplications
))
</jh>

A version with distinct variables instead of freeness hypotheses is, of course, a simple consequence.
<jh>
thm (ChangeVariableForAll ((y φx) (x φy) (x y))
  ((H (((value x) = (value y)) → (φx ↔ φy))))
  ((∀ x φx) ↔ (∀ y φy)) (
        x φy DistinctNotFree
        y φx DistinctNotFree
        H
        ChangeVariableForAllNotFree
))
</jh>

=== Change of variable in ∃ ===
Although it should be possible to provide the corresponding theorem for ∃ via <code>ThereExistsIntroductionFromObject</code> and the like (see [[Intuitionistic first-order logic]] for an example of that), to keep things simple we just follow Margaris' proof which derives it from the one for ∀.<ref>Theorem 18.8, Margaris, page 86</ref>
<jh>
thm (ChangeVariableThereExists
  ((y φx) (x φy) (x y))
  ((H (((value x) = (value y)) → (φx ↔ φy))))
  ((∃ x φx) ↔ (∃ y φy)) (
        H
        φx φy NegationFunction
        eliminateBiconditionalReverse
        applySyllogism

        ChangeVariableForAll
        addNegation
))

thm (ChangeVariableThereExistsNotFree
  ((x y))
  ((HFREEX (x is-not-free-in φy))
   (HFREEY (y is-not-free-in φx))
   (H (((value x) = (value y)) → (φx ↔ φy))))
  ((∃ x φx) ↔ (∃ y φy)) (
        HFREEX
        negateNotFree

        HFREEY
        negateNotFree

        H
        φx φy NegationFunction
        eliminateBiconditionalReverse
        applySyllogism

        ChangeVariableForAllNotFree
        addNegation
))
</jh>

=== Stating changes of variable in terms of explicit substitutions ===
Another way to express the change variable theorems is with explicit substitution (using <code>subst</code>).
<jh>
thm (ChangeVariableExplicitThereExists ((y φ) (x y)) () ((∃ x φ) ↔ (∃ y (subst (value y) x φ))) (
        x y φ VariableSubstNotFree
        y φ DistinctNotFree
        x y φ EqualityVariableSubst
        ChangeVariableThereExistsNotFree
))

thm (ChangeVariableExplicitForAll ((y φ) (x y)) () ((∀ x φ) ↔ (∀ y (subst (value y) x φ))) (
        x y φ VariableSubstNotFree
        y φ DistinctNotFree
        x y φ EqualityVariableSubst
        ChangeVariableForAllNotFree
))
</jh>

== Theorems stated in chapter 19 of Margaris ==
In chapter 19, Margaris restates a number of theorems already proved, proves a few additional ones, and states a number while leaving the proof as exercises.<ref>Margaris, page 89</ref> Here we prove those which we haven't proved yet and which we need to export to [[Interface:First-order logic with quantifiability]].

=== Negating there-exists ===
The theorem <code>¬ ∃ x φ ↔ ∀ x ¬ φ</code> is an easy consequence of our definition of ∃.<ref>Theorem 19.3, Margaris, page 91, cited by metamath as 19.7</ref>
<jh>
thm (NotThereExists () () ((¬ (∃ x φ)) ↔ (∀ x (¬ φ))) (
        (∀ x (¬ φ)) DoubleNegation
        swapBiconditional
))
</jh>

=== Adding and removing there exists ===
We already proved that <code>∀ x φ ↔ φ</code> if <code>x</code> is not free in <code>φ</code>. Here we prove the analogous result for <code>∃</code>.<ref>Theorem scheme 9, Margaris, page 89, cited by metamath as 19.9</ref>
<jh>
thm (ThereExistsAddRemoveNotFree () ((HFREE (x is-not-free-in φ))) ((∃ x φ) ↔ φ) (
        HFREE
        φ ImplicationReflexivity
        addThereExistsToAntecedentNotFree

        φ x ThereExistsIntroduction

        introduceBiconditionalFromImplications
))
</jh>

Here are a few variations of basically the same theorem.
<jh>
thm (NullThereExists ((x φ)) () ((∃ x φ) ↔ φ) (
        x φ DistinctNotFree
        ThereExistsAddRemoveNotFree
))

thm (removeThereExists ((x φ)) ((H (∃ x φ))) φ (
        H
        x φ NullThereExists
        eliminateBiconditionalReverse
        applyModusPonens
))

thm (removeThereExistsInConsequent ((x φ)) ((H (antecedent → (∃ x φ)))) (antecedent → φ) (
        H
        x φ NullThereExists
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

=== Commuting ∃ followed by ∀ ===
∃ followed by ∀ can be switched.<ref>Theorem 19.4, Margaris, page 91, cited by metamath as 19.12</ref>
<jh>
thm (ThereExistsForAllCommutation () () ((∃ x (∀ y φ)) → (∀ y (∃ x φ))) (
        y φ BoundForAllNotFree
        x addThereExistsNotFree

        x φ BoundThereExistsNotFree

        y φ Specialization
        φ x ThereExistsIntroduction
        applySyllogism

        addThereExistsToAntecedentNotFree

        addForAllToConsequentNotFree
))
</jh>

=== Biconditionalized version of ForAllImplicationThereExists ===
This is a biconditionalized variation of a theorem we already proved.<ref>Theorem 19.6, Margaris, page 91, cited by metamath as 19.18</ref>
<jh>
thm (ForAllBiconditionalThereExists () () ((∀ x (φ ↔ ψ)) → ((∃ x φ) ↔ (∃ x ψ))) (
        φ ψ BiconditionalReverseElimination
        x addForAll

        x φ ψ ForAllImplicationThereExists
        applySyllogism

        φ ψ BiconditionalForwardElimination
        x addForAll

        x ψ φ ForAllImplicationThereExists
        applySyllogism

        introduceBiconditionalFromImplicationsInConsequent
))
</jh>

=== Distribution of for-all over conjunction ===
Here we prove <code>∀ x (φ ∧ ψ) ↔ ∀ x φ ∧ ∀ x ψ</code>.<ref>Theorem 19.7, Margaris, page 92, cited by metamath as 19.26</ref> As Margaris does, we prove the forward and reverse directions separately.
<jh>
thm (ForAllConjunctionForward () () ((∀ x (φ ∧ ψ)) → ((∀ x φ) ∧ (∀ x ψ))) (
        φ ψ ConjunctionRightElimination
        x addForAll

        φ ψ ConjunctionLeftElimination
        x addForAll

        composeConjunction
))

thm (ForAllConjunctionReverse () () (((∀ x φ) ∧ (∀ x ψ)) → (∀ x (φ ∧ ψ))) (
</jh>
First is <code>x is-not-free-in (∀ x φ ∧ ∀ x ψ)</code>.
<jh>
        x φ BoundForAllNotFree
        x ψ BoundForAllNotFree
        conjunctionNotFree
</jh>
Next is <code>∀ x φ ∧ ∀ x ψ → φ ∧ ψ</code>.
<jh>
        (∀ x φ) (∀ x ψ) ConjunctionRightElimination
        x φ Specialization
        applySyllogism

        (∀ x φ) (∀ x ψ) ConjunctionLeftElimination
        x ψ Specialization
        applySyllogism

        composeConjunction
</jh>
Adding <code>∀ x</code> to the consequent finishes the job.
<jh>
        addForAllToConsequentNotFree
))

thm (ForAllConjunction () () ((∀ x (φ ∧ ψ)) ↔ ((∀ x φ) ∧ (∀ x ψ))) (
        x φ ψ ForAllConjunctionForward
        x φ ψ ForAllConjunctionReverse
        introduceBiconditionalFromImplications
))
</jh>

=== Distribution of there-exists across a disjunction ===
Here is <code>∃ x (φ ∨ ψ) ↔ ∃ x φ ∨ ∃ x ψ</code>.<ref>Theorem scheme 43, Margaris, page 90</ref> Margaris leaves the proof as an exercise, so we need to decide whether to derive it from <code>ForAllConjunction</code> using our definition of ∃ and DeMorgan's law, or derive it from other theorems which involve ∃. We elect the latter.
<jh>
thm (ThereExistsDisjunctionSplitting () () ((∃ x (φ ∨ ψ)) → ((∃ x φ) ∨ (∃ x ψ))) (
</jh>
A bit later we'll need <code>x is-not-free-in (∃ x φ ∨ ∃ x ψ)</code>
<jh>
        x φ BoundThereExistsNotFree
        x ψ BoundThereExistsNotFree
        disjunctionNotFree
</jh>
The key part of this proof is <code>φ → ∃ x φ</code> and likewise for <code>ψ</code>.
<jh>
        φ x ThereExistsIntroduction
        ψ x ThereExistsIntroduction
        disjoin
</jh>
Now we are ready to add <code>∃ x</code> to the antecedent.
<jh>
        addThereExistsToAntecedentNotFree
))

thm (ThereExistsDisjunctionCombining () () (((∃ x φ) ∨ (∃ x ψ)) → (∃ x (φ ∨ ψ))) (
        φ ψ DisjunctionRightIntroduction
        x addThereExists

        ψ φ DisjunctionLeftIntroduction
        x addThereExists

        composeDisjunction
))

thm (ThereExistsDisjunction () () ((∃ x (φ ∨ ψ)) ↔ ((∃ x φ) ∨ (∃ x ψ))) (
        x φ ψ ThereExistsDisjunctionSplitting
        x φ ψ ThereExistsDisjunctionCombining
        introduceBiconditionalFromImplications
))
</jh>

=== Distribution of there-exists across an implication ===
When distributing ∃ across an implication, the quantifier on the antecedent changes to ∀.<ref>Theorem 19.10, Margaris, page 93, cited by metamath as 19.35</ref> Margaris first proves the forward (easy) direction, and then gives two proofs of the reverse direction, which basically amount to rewriting the implication as either a conjunction or a disjunction with the suitable amount of negation. We pick disjunction, and use equivalences so that the proof also takes care of the forward direction too.
<jh>
thm (ThereExistsImplication () () ((∃ x (φ → ψ)) ↔ ((∀ x φ) → (∃ x ψ))) (
        φ ψ ImplicationDisjunction
        x buildThereExists

        x (¬ φ) ψ ThereExistsDisjunction
        applyBiconditionalTransitivity

        x φ NotForAll
        swapBiconditional
        (∃ x ψ) BiconditionalReflexivity
        buildDisjunction
        applyBiconditionalTransitivity

        (∀ x φ) (∃ x ψ) ImplicationDisjunction
        swapBiconditional
        applyBiconditionalTransitivity
))
</jh>

=== Movement ===
There are a variety of theorems which involve moving a formula in or out of the scope of a quantifier (where the variable being quantified is not free in the formula). Margaris does not discuss these at length, but he does list them in the theorem schemes in chapter 19.

==== There exists and conjunction ====
First is moving a conjunction into or out of existential quantification.<ref>Theorem scheme 42, Margaris, page 90, cited by metamath as 19.42</ref>
<jh>
thm (ThereExistsConjunctionMovementNotFree () ((HFREE (x is-not-free-in φ)))
  ((∃ x (φ ∧ ψ)) ↔ (φ ∧ (∃ x ψ))) (
</jh>
For the forward direction, we start with <code>∃ x (φ ∧ ψ) → ∃ x φ ∧ ∃ x ψ</code>.
<jh>
        x φ ψ ThereExistsConjunction
</jh>
Then we can remove the quantifier from <code>∃ x φ</code> to finish the forward direction.
<jh>
        HFREE
        ThereExistsAddRemoveNotFree
        eliminateBiconditionalReverse
        (∃ x ψ) conjoinRR
        applySyllogism
</jh>
The proof of the reverse direction is taken from metamath.<ref>[http://us.metamath.org/mpeuni/19.41.html 19.41], metamath's set.mm, 25 May 2011</ref>. It starts with <code>φ → (ψ → (φ ∧ ψ))</code>, and adds quantifiers to the consequent to get <code>φ → (∃ x ψ → ∃ x (φ ∧ ψ))</code>.
<jh>
        HFREE
        φ ψ ConjunctionRightIntroduction
        addForAllToConsequentNotFree

        x ψ (φ ∧ ψ) ForAllImplicationThereExists
        applySyllogism
</jh>
A bit of propositional logic and we are done.
<jh>
        import
        introduceBiconditionalFromImplications
))
</jh>

Here are two easy consequences stated in terms of distinct variables rather than freeness hypotheses.
<jh>
thm (ThereExistsConjunctionMovement ((x φ)) () ((∃ x (φ ∧ ψ)) ↔ (φ ∧ (∃ x ψ))) (
        x φ DistinctNotFree
        ψ ThereExistsConjunctionMovementNotFree
))

thm (ThereExistsConjunctionRightMovement ((x ψ)) () ((∃ x (φ ∧ ψ)) ↔ ((∃ x φ) ∧ ψ)) (
        φ ψ ConjunctionCommutativity
        x buildThereExists

        x ψ φ ThereExistsConjunctionMovement
        applyBiconditionalTransitivity

        ψ (∃ x φ) ConjunctionCommutativity
        applyBiconditionalTransitivity
))
</jh>

==== For all and implication ====
We can move an antecedent, which does not have the variable being quantified free, in or out of universal quantification.<ref>Theorem scheme 21, Margaris, page 90, cited by metamath as 19.21</ref>
<jh>
thm (ForAllImplicationAntecedentMovement () ((HFREE (x is-not-free-in φ))) ((∀ x (φ → ψ)) ↔ (φ → (∀ x ψ))) (
</jh>
The forward direction just distributes the quantifier over the implication and removes the unnecessary quantifier on the antecedent.
<jh>
        x φ ψ ForAllImplication

        HFREE
        GeneralizationNotFree
        (∀ x ψ) addCommonConsequent
        applySyllogism
</jh>
The reverse direction follows from <code>x is-not-free-in (φ → ∀ x ψ)</code> and <code>(φ → ∀ x ψ) → (φ → ψ)</code>.
<jh>
        HFREE
        x ψ BoundForAllNotFree
        implicationNotFree

        x ψ Specialization
        φ addCommonAntecedent

        addForAllToConsequentNotFree

        introduceBiconditionalFromImplications
))

thm (moveAntecedentOutOfForAll () ((H (∀ x (φ → ψ))) (HFREE (x is-not-free-in φ))) (φ → (∀ x ψ)) (
        H

        HFREE
        ψ ForAllImplicationAntecedentMovement
        eliminateBiconditionalReverse

        applyModusPonens
))

thm (moveAntecedentIntoForAll ()
  ((H (φ → (∀ x ψ))) (HFREE (x is-not-free-in φ)))
  (∀ x (φ → ψ)) (
        H

        HFREE
        ψ ForAllImplicationAntecedentMovement
        eliminateBiconditionalForward

        applyModusPonens
))
</jh>

==== Moving antecedent in or out of there exists ====
We can move the antecedent in or out of there exists.<ref>Theorem scheme 37, Margaris, page 90, cited by metamath as 19.37</ref>
<jh>
thm (ThereExistsAntecedentMovementNotFree () ((HFREE (x is-not-free-in φ))) ((∃ x (φ → ψ)) ↔ (φ → (∃ x ψ))) (
        x φ ψ ThereExistsImplication

        HFREE
        ForAllAddRemoveNotFree
        (∃ x ψ) buildImplicationConsequent

        applyBiconditionalTransitivity
))

thm (ThereExistsAntecedentMovement ((x φ)) () ((∃ x (φ → ψ)) ↔ (φ → (∃ x ψ))) (
        x φ DistinctNotFree
        ψ ThereExistsAntecedentMovementNotFree
))
</jh>

==== Moving the consequent in or out of for all ====
When we move the consequent out of <code>∀</code>, it changes to <code>∃</code>.<ref>Theorem scheme 23, Margaris, page 90, cited by metamath as 19.23</ref> The proof is based on the one in metamath.<ref>[http://us.metamath.org/mpeuni/19.23.html 19.23], metamath's set.mm, accessed 2 Feb 2012</ref>
<jh>
thm (ForAllImplicationConsequentMovement () ((HFREE (x is-not-free-in ψ))) ((∀ x (φ → ψ)) ↔ ((∃ x φ) → ψ)) (
</jh>
The forward direction is just a matter of distributing ∀ into two existential quantifiers and getting rid of the one which doesn't do anything.
<jh>
        x φ ψ ForAllImplicationThereExists

        HFREE
        ThereExistsAddRemoveNotFree
        eliminateBiconditionalReverse
        (∃ x φ) addCommonAntecedent
        applySyllogism
</jh>
The reverse direction is based on <code>φ → ∃ x φ</code> and that <code>x</code> is not free in <code>∃ x φ → ψ</code>.
<jh>
        x φ BoundThereExistsNotFree
        HFREE
        implicationNotFree

        φ x ThereExistsIntroduction
        ψ addCommonConsequent

        addForAllToConsequentNotFree

        introduceBiconditionalFromImplications
))
</jh>

==== Moving the consequent in or out of there exists ====
Similar to the previous one, but with ∃ and ∀ exchanged.<ref>Theorem scheme 36, Margaris, page 90, cited by metamath as 19.36</ref>
<jh>
thm (ThereExistsImplicationConsequentMovement () ((HFREE (x is-not-free-in ψ)))
  ((∃ x (φ → ψ)) ↔ ((∀ x φ) → ψ)) (
        x φ ψ ThereExistsImplication

        HFREE
        ThereExistsAddRemoveNotFree
        (∀ x φ) buildImplicationAntecedent

        applyBiconditionalTransitivity
))
</jh>

==== Disjunction movement ====
We can move a conjunct out of or into there exists.<ref>Theorem scheme 45, Margaris, page 90, cited by metamath as 19.45</ref>
<jh>
thm (ThereExistsDisjunctionMovementNotFree () ((HFREE (x is-not-free-in φ)))
  ((∃ x (φ ∨ ψ)) ↔ (φ ∨ (∃ x ψ))) (
        x φ ψ ThereExistsDisjunction

        HFREE
        ThereExistsAddRemoveNotFree
        (∃ x ψ) buildDisjunctionRR

        applyBiconditionalTransitivity
))

thm (ThereExistsDisjunctionMovement ((x φ)) () ((∃ x (φ ∨ ψ)) ↔ (φ ∨ (∃ x ψ))) (
        x φ DistinctNotFree
        ψ ThereExistsDisjunctionMovementNotFree
))

thm (ThereExistsDisjunctionRightMovementNotFree () ((HFREE (x is-not-free-in ψ)))
  ((∃ x (φ ∨ ψ)) ↔ ((∃ x φ) ∨ ψ)) (
        x φ ψ ThereExistsDisjunction

        HFREE
        ThereExistsAddRemoveNotFree
        (∃ x φ) buildDisjunctionLL

        applyBiconditionalTransitivity
))

thm (ThereExistsDisjunctionRightMovement ((x ψ)) () ((∃ x (φ ∨ ψ)) ↔ ((∃ x φ) ∨ ψ)) (
        x ψ DistinctNotFree
        φ ThereExistsDisjunctionRightMovementNotFree
))

</jh>

=== Combining one universal and one existential quantifier ===
Suppose we have one formula which holds for all values of a variable, and another which holds for some value. Then there is a value for which both hold. In symbols, <code>∀ x φ ∧ ∃ x ψ → ∃ x (φ ∧ ψ)</code>.<ref>Theorem scheme 29, Margaris, page 90, cited by metamath as 19.29</ref>
<jh>
thm (ThereExistsConjunctionCombining () ()
  (((∀ x φ) ∧ (∃ x ψ)) → (∃ x (φ ∧ ψ))) (
        x φ BoundForAllNotFree
        ψ ThereExistsConjunctionMovementNotFree
        eliminateBiconditionalForward

        x φ Specialization
        ψ conjoinRR
        x addThereExists
        applySyllogism
))
</jh>

It will also be convenient to have a commuted version, and a rule.
<jh>
thm (ThereExistsConjunctionRightCombining () ()
  (((∃ x φ) ∧ (∀ x ψ)) → (∃ x (φ ∧ ψ))) (
        (∃ x φ) (∀ x ψ) ConjunctionCommutativity
        eliminateBiconditionalReverse

        x ψ φ ThereExistsConjunctionCombining
        applySyllogism

        ψ φ ConjunctionCommutativity
        eliminateBiconditionalReverse
        x addThereExists
        applySyllogism
))

thm (combineThereExistsForAll () ((HEXISTS (∃ x φ)) (HALL (∀ x ψ))) (∃ x (φ ∧ ψ)) (
        HEXISTS
        HALL
        introduceConjunction

        x φ ψ ThereExistsConjunctionRightCombining
        applyModusPonens
))
</jh>

==== A few more movement rules ====
Here are a few rules, for convenience:
<jh>
thm (moveLeftConjunctIntoThereExistsInConsequent ((x φ))
  ((H (antecedent → (φ ∧ (∃ x ψ)))))
  (antecedent → (∃ x (φ ∧ ψ))) (
        H

        x φ ψ ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        applySyllogism
))

thm (moveRightConjunctIntoThereExistsInConsequent ((x ψ))
  ((H (antecedent → ((∃ x φ) ∧ ψ))))
  (antecedent → (∃ x (φ ∧ ψ))) (
        H

        x φ ψ ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applySyllogism
))

thm (repeatAntecedentThereExists ((x antecedent))
  ((H (antecedent → (∃ x ψ))))
  (antecedent → (∃ x (antecedent ∧ ψ))) (
        antecedent ImplicationReflexivity
        H
        composeConjunction
        moveLeftConjunctIntoThereExistsInConsequent
))
</jh>

==== Scattering and gathering ====
The rules and theorems we call ''scattering'' and ''gathering'' are just consequences of the movement theorems, and as such we can use the exact same proofs as in [[First-order logic]].
<jh>
thm (ThereExistsScattering ((φx y) (ψy x)) ()
  ((∃ x (∃ y (φx ∧ ψy))) ↔ ((∃ x φx) ∧ (∃ y ψy))) (
        (∃ x φx) (∃ y ψy) ConjunctionCommutativity

        x ψy DistinctNotFree
        y addThereExistsNotFree
        φx ThereExistsConjunctionMovementNotFree
        swapBiconditional
        applyBiconditionalTransitivity

        (∃ y ψy) φx ConjunctionCommutativity
        x buildThereExists
        applyBiconditionalTransitivity

        y φx ψy ThereExistsConjunctionMovement
        swapBiconditional
        x buildThereExists
        applyBiconditionalTransitivity

        swapBiconditional
))

thm (gatherThereExistsInConsequent ((φx y) (ψy x)) ((H (antecedent → ((∃ x φx) ∧ (∃ y ψy)))))
  (antecedent → (∃ x (∃ y (φx ∧ ψy)))) (
        H
        x y φx ψy ThereExistsScattering
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

== Other theorems ==
Here we present a few theorems which are convenience theorems, or other fairly simple deductions from theorems we have.
<jh>
thm (buildThereExistsInConsequent ((x φ))
  ((H (φ → (ψ ↔ χ))))
  (φ → ((∃ x ψ) ↔ (∃ x χ))) (
        H
        x addForAllToConsequent

        x ψ χ ForAllBiconditionalThereExists
        applySyllogism
))

thm (buildForAllInConsequent ((x φ))
  ((H (φ → (ψ ↔ χ))))
  (φ → ((∀ x ψ) ↔ (∀ x χ))) (
        H
        x addForAllToConsequent

        x ψ χ ForAllBiconditional
        applySyllogism
))

thm (Generalization ((x φ)) () (φ → (∀ x φ)) (
        x φ DistinctNotFree
        GeneralizationNotFree
))
</jh>

== Equality ==
Most of the theorems we have already adopted as axioms, but there are a variety of convenience theorems and the like to prove before we can export to [[Interface:First-order logic]].
<jh>
def ((≠ s t) (¬ (s = t)))

thm (swapVariableEquality () ((H ((value x) = (value y)))) ((value y) = (value x)) (
        H
        x y VariableEqualitySymmetry eliminateBiconditionalReverse
        applyModusPonens
))

thm (swapVariableEqualityInConsequent () ((H (φ → ((value x) = (value y))))) (φ → ((value y) = (value x))) (
        H
        x y VariableEqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism
))

thm (applyVariableEqualityTransitivity () ((H1 ((value x) = (value y))) (H2 ((value y) = (value z))))
  ((value x) = (value z)) (
        H1
        H2
        introduceConjunction
        x y z VariableEqualityTransitivity
        applyModusPonens
))

thm (applyEqualityTransitivityInConsequent ()
  ((H1 (φ → ((value x) = (value y)))) (H2 (φ → ((value y) = (value z)))))
  (φ → ((value x) = (value z))) (
        H1
        H2
        composeConjunction
        x y z VariableEqualityTransitivity
        applySyllogism
))

thm (VariableEqualityBuilderRR () ()
  (((value x0) = (value x1)) → (((value x0) = (value y)) ↔ ((value x1) = (value y)))) (
        x0 x1 VariableEqualitySymmetry
        eliminateBiconditionalReverse

        x1 x0 y VariableEqualityTransitivity
        export

        applySyllogism

        x0 x1 y VariableEqualityTransitivity
        export

        composeConjunction

        ((value x0) = (value y)) ((value x1) = (value y)) BiconditionalImplication eliminateBiconditionalForward
        applySyllogism
))

thm (commute2 () () ((((value x0) = (value y0)) ↔ ((value x1) = (value y1))) →
  (((value y0) = (value x0)) ↔ ((value y1) = (value x1)))) (
        x0 y0 VariableEqualitySymmetry
        x1 y1 VariableEqualitySymmetry
        buildBiconditional
        eliminateBiconditionalReverse
))

thm (VariableEqualityBuilderLL () ()
  (((value x0) = (value x1)) → (((value y) = (value x0)) ↔ ((value y) = (value x1)))) (
        x0 x1 y VariableEqualityBuilderRR
        x0 y x1 y commute2
        applySyllogism
))
</jh>

== Substitution ==
Although our axioms were based on substitution and we've proved many of the substitution theorems we need, here are a few more consequences and convenience theorems.

=== Substitution of a theorem remains a theorem ===
If we have a theorem, we can add a variable substitution onto it. This is just a generalization followed by specializeToVariable.
<jh>
thm (introduceVariableSubst () ((H φ)) (subst (value y) x φ) (
        H
        x generalize
        y specializeToVariable
))
</jh>

=== Moving substitution across quantifiers ===
We have already shown we can move substitution across connectives. We can also move it across quantifiers (when variables are distinct).
<jh>
thm (SubstThereExists ((x y z)) () ((subst (value z) x (∃ y φ)) ↔ (∃ y (subst (value z) x φ))) (
</jh>
First is <code>x is-not-free-in ∃ y [ z / x ] φ</code>
<jh>
        x z φ VariableSubstNotFree
        y addThereExistsNotFree
</jh>
Leaving that aside for now, we start with <code>x = z → (φ ↔ [ s / x ] φ)</code>,
<jh>
        x z φ EqualityVariableSubst
</jh>
add the quantifier to the two sides of the biconditional, and invoke <code>makeVariableSubstExplicitNotFree</code>.
<jh>
        y buildThereExistsInConsequent
        makeVariableSubstExplicitNotFree
))
</jh>

=== Substitution of a variable which does not appear ===
If a variable does not appear in a formula, substituting it for anything does not affect the truth of the formula.
<jh>
thm (NullVariableSubstitution ((x φ)) () ((subst (value y) x φ) ↔ φ) (
        y x φ ThereExistsIntroductionFromVariable
        removeThereExistsInConsequent

        φ x Generalization
        x φ y SpecializationToVariable
        applySyllogism

        introduceBiconditionalFromImplications
))
</jh>

=== A lemma regarding substitution and equality ===
Here we show <code>[ y / x ] x = y</code>.<ref>[http://us.metamath.org/mpeuni/equsb1.html equsb1]</ref>
<jh>
thm (VariableSubstEquality ((x y)) () (subst (value y) x ((value x) = (value y))) (
</jh>
We start with <code>y = y</code>.
<jh>
        y VariableEqualityReflexivity
</jh>
The elaboration begins with <code>[ y / x ] x = y ↔ y = y</code>,
<jh>
        x y y VariableEqualityBuilderRR
        makeVariableSubstExplicit
</jh>
which we then combine with <code>y = y</code> to give <code>[ y / x ] x = y</code>.
<jh>
        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

=== Change of variable in substitution ===
Changing the bound variable in a substitution is possible, much as we do for quantifiers.

We are trying to show that we can conclude <code>[ s / x ] φx ↔ [ s / y ] φy</code> from <code>x = y → (φx ↔ φy)</code> (where almost everything is distinct except that <code>φx</code> can contain <code>x</code> and <code>φy</code> can contain <code>y</code>). Without trying to sketch out the proof in detail right now, we will be adding <code>[ s / x ]</code> to the start of both sides of the implication, and likewise for <code>y</code>. The first lemma is a variation of <code>SubstEquality</code> which substitutes both sides of the equality, not just one.
<jh>
thm (ChangeVariableSubstitution-1
  ((x y) (z x) (z y)) ()
  (subst (value z) y (subst (value z) x ((value x) = (value y)))) (
        z x VariableSubstEquality
</jh>
Having substituted one side of the equality, we pull the same trick with <code>y</code>. The equivalence is <code>[ z / y ] [ z / x ] x = y ↔ [ z / x ] x = z</code>, which derives from <code>y = z → ([ z / x ] x = y ↔ [ z / x ] x = z)</code>.
<jh>
        y z x VariableEqualityBuilderLL
        x addForAllToConsequent

        x ((value x) = (value y)) ((value x) = (value z)) z VariableSubstBuilder
        applySyllogism

        makeVariableSubstExplicit
</jh>
Combining that with <code>[ s / x ] x = s</code> gives <code>[ s / y ] [ s / x ] x = y</code>, as desired.
<jh>
        eliminateBiconditionalForward
        applyModusPonens
))

thm (ChangeVariableSubstitution
  ((y φx) (x φy) (x y) (z x) (z y))
  ((H (((value x) = (value y)) → (φx ↔ φy))))
  ((subst (value z) x φx) ↔ (subst (value z) y φy)) (
</jh>
We'll stick our lemma on the proof stack for later.
<jh>
        z y x ChangeVariableSubstitution-1

        H
</jh>
We now have <code>x = y → (φx ↔ φy)</code>. We add a substitution for <code>x</code> everywhere, to get <code>[ z / x ] x = y → ([ z / x ] φx ↔ [ z / x ] φy)</code>
<jh>
        z x addVariableSubst

        z x φx φy VariableSubstBiconditional
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Now we add a substitution for <code>y</code> everywhere, to get <code>[ z / y ] [ z / x ] x = y → ([ z / y ] [ z / x ] φx ↔ [ z / y ] [ z / x ] φy)</code>.
<jh>
        z y addVariableSubst

        z y (subst (value z) x φx) (subst (value z) x φy) VariableSubstBiconditional
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Detaching the lemma we get <code>[ z / y ] [ z / x ] φx ↔ [ z / y ] [ z / x ] φy</code>.
<jh>
        applyModusPonens
</jh>
Because <code>y</code> does not occur in <code>[ z / x ] φx</code>, we can remove <code>[ z / y ]</code> from the left hand side.
<jh>
        swapBiconditional
        z y (subst (value z) x φx) NullVariableSubstitution
        applyBiconditionalTransitivity
        swapBiconditional
</jh>
Similarly, we remove <code>[ z / x ]</code> from the right hand side.
<jh>
        z x φy NullVariableSubstitution
        z y buildVariableSubst
        applyBiconditionalTransitivity
))
</jh>

=== Implicit substitution and universal quantification ===
One way to express a substitution is <code>∀ x (x = y → φ)</code>.
<jh>
thm (VariableImplicitForAll-1 ((x y) (x ψ)) ()
  ((subst (value y) x φ) → (∀ x (((value x) = (value y)) → φ))) (
</jh>
Later we'll need <code>x is-not-free in [ y / x ] φ</code>
<jh>
        x y φ VariableSubstNotFree
</jh>
We start with <code>[ y / x ] φ → (x = y → φ)</code>.
<jh>
        x y φ EqualityVariableSubst
        eliminateBiconditionalForwardInConsequent
        applyComm
</jh>
Adding for-all to the consequent we are finished.
<jh>
        addForAllToConsequentNotFree
))

thm (VariableImplicitForAll-2 ((x y) (x ψ)) ()
  ((∀ x (((value x) = (value y)) → φ)) → (subst (value y) x φ)) (
</jh>
We'll need <code>[ y / x ] x = y</code> shortly, so we put it on the proof stack.
<jh>
        y x VariableSubstEquality

        x (((value x) = (value y)) → φ) y SpecializationToVariable

        y x ((value x) = (value y)) φ VariableSubstImplication
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Now the consequent is <code>[ y / x ] x = y → [ y / x ] φ</code>. But <code>[ y / x ] x = y</code> is always true.
<jh>
        detachImplicationImplication
))

thm (VariableImplicitForAll ((x y) (x ψ)) ((H (((value x) = (value y)) → (φ ↔ ψ))))
  ((∀ x (((value x) = (value y)) → φ)) ↔ ψ) (
        x y φ VariableImplicitForAll-2
        y x φ VariableImplicitForAll-1
        introduceBiconditionalFromImplications

        H
        makeVariableSubstExplicit

        applyBiconditionalTransitivity
))
</jh>

=== Implicit substitution and existential quantification ===
There is another similar expression, involving <code>∃</code>, namely <code>∃ x (x = y ∧ φ)</code>.
<jh>
thm (VariableImplicitThereExists-1 ((x y)) ()
  ((subst (value y) x φ) → (∃ x (((value x) = (value y)) ∧ φ))) (
</jh>
We start with <code>[ y / x ] φ → [ y / x ] x = y ∧ [ y / x ] φ<code>.
<jh>
        (subst (value y) x φ) ImplicationReflexivity
        y x VariableSubstEquality
        introduceLeftConjunctToConsequent
</jh>
Combining the substitutions in the consequent and then using the presence of a substitution to imply existence finishes the proof.
<jh>
        y x ((value x) = (value y)) φ VariableSubstConjunction
        eliminateBiconditionalForward
        applySyllogism

        y x (((value x) = (value y)) ∧ φ) ThereExistsIntroductionFromVariable
        applySyllogism
))

thm (VariableImplicitThereExists-2 ((x y)) ()
  ((∃ x (((value x) = (value y)) ∧ φ)) → (subst (value y) x φ)) (
</jh>
In a few steps we'll need <code>x is-not-free-in [ y / x ] φ</code>.
<jh>
        x y φ VariableSubstNotFree
</jh>
We start with <code>x = y → (φ ↔ [ y / x ] φ)</code>,
<jh>
        x y φ EqualityVariableSubst
</jh>
and apply propositional logic to turn it into <code>x = y ∧ φ → [ y / x ] φ</code>.
<jh>
        eliminateBiconditionalReverseInConsequent
        import
</jh>
Adding <code>∃</code> to the antecedent we are done.
<jh>
        addThereExistsToAntecedentNotFree
))

thm (VariableImplicitThereExists ((x y) (x ψ)) ((H (((value x) = (value y)) → (φ ↔ ψ))))
  ((∃ x (((value x) = (value y)) ∧ φ)) ↔ ψ) (
        x y φ VariableImplicitThereExists-2
        y x φ VariableImplicitThereExists-1
        introduceBiconditionalFromImplications

        H
        makeVariableSubstExplicit

        applyBiconditionalTransitivity
))
</jh>

=== A quantified statement which starts with a proposition ===
Here we prove a few theorems concerning negation and, one the one hand, universal quantification of an implication or, on the other hand, existential quantification of a conjunction. They aren't used particularly often, but we need <code>equs3</code> to export to [[Interface:First-order logic]].
<jh>
thm (alinexa () () ((∀ x (φ → (¬ ψ))) ↔ (¬ (∃ x (φ ∧ ψ)))) (
        φ (¬ ψ) ImplicationDisjunction
        φ ψ DeMorganPCP swapBiconditional
        applyBiconditionalTransitivity

        x buildForAll
</jh>
That gives us <code>∀ x (φ → ¬ ψ) ↔ ∀ x ¬ (φ ∧ ψ)</code>.  Now we just need to apply <code>NotThereExists</code> to the right hand side:
<jh>
        x (φ ∧ ψ) NotThereExists swapBiconditional
        applyBiconditionalTransitivity
))
</jh>

The second theorem, <code>equs3</code>, is a special case which will be useful in dealing with substitution:<ref>[http://us.metamath.org/mpeuni/equs3.html equs3] in metamath's set.mm, accessed February 22, 2010</ref>

<jh>
thm (equs3 () ()
  ((∃ x (((value x) = s) ∧ φ)) ↔ (¬ (∀ x (((value x) = s) → (¬ φ))))) (
        x ((value x) = s) φ alinexa
        transposeBiconditionalWithNegatedRight
))
</jh>

== Export ==
We can export first-order logic now.
<jh>
# Commented out until we can straighten up ax6o and perhaps other loose ends
#export (FIRSTORDER Interface:First-order_logic (PROPOSITIONAL) ())
</jh>

== Freeness ==
Until now we have glossed over one fact, which is that <code>is-not-free-in</code> does not quite match the textbook definition of freeness given in sources like Margaris. Our axioms for <code>is-not-free-in</code> also imply that a variable is considered to not be free in a theorem. For example, we can prove <code>x is-not-free-in x = x</code>, whereas Margaris and other conventional treatments would consider <code>x</code> to be free in <code>x = x</code>. Therefore, <code>is-not-free-in</code> could perhaps be better read as "is effectively not free in" than "is not free in", although its function is close enough to the traditional definition for most purposes.<ref>[http://us.metamath.org/mpeuni/mmset.html#traditional Appendix 2: Traditional Textbook Axioms of Predicate Calculus with Equality], Metamath Proof Explorer, accessed February 20, 2010.</ref>

To demonstrate this property of <code>is-not-free-in</code>, we prove the following theorem.
<jh>
thm (TheoremNotFree () ((H φ)) (x is-not-free-in φ) (
</jh>
First we observe <code>x is-not-free-in ∀ x φ</code>.
<jh>
        x φ BoundForAllNotFree
</jh>
Next is <code>∀ x φ ↔ φ</code>.
<jh>
        H
        x generalize

        H

        introduceConjunction

        (∀ x φ) φ TruthBiconditional
        applyModusPonens
</jh>
Adding <code>x is-not-free-in</code> to both sides is basically all we need from here.
<jh>
        x buildNotFree
        eliminateBiconditionalReverse
        applyModusPonens
))
</jh>

== Metamath axiomization of first-order logic ==
We also export the metamath axiomization of first-order logic, to provide a the solution to a modified version of the problem stated at [http://us.metamath.org/award2003.html#17 17] on the metamath site.

First we need some alternate names or very slight rearrangements for some of our existing axioms or theorems.
<jh>
thm (QuantifiedImplication () () ( (∀ x (φ → ψ)) → ((∀ x φ) → (∀ x ψ)) ) (
        x φ ψ ForAllImplication
))

thm (QuantifierCommutation () () ( (∀ x (∀ y φ)) → (∀ y (∀ x φ)) ) (
        x y φ ForAllCommutation
        eliminateBiconditionalReverse
))
</jh>

We also need to export <code>QuantifiedNegation</code>, which is an easy consequence of our theory of free variables.
<jh>
thm (QuantifiedNegation () () ( (¬ (∀ x φ)) → (∀ x (¬ (∀ x φ))) ) (
        x φ BoundForAllNotFree
        negateNotFree

        ForAllAddRemoveNotFree
        eliminateBiconditionalForward
))
</jh>

Although metamath has <code>Existence</code> without <code>Quantifiability</code>, for our purposes we might just try to prove the former as a special case of the latter. {{cleanup|figuring out how ExistenceDistinct and ExistenceNotDistinct could be combined into a proof of Existence, or finding another proof}}
<jh>
thm (ExistenceDistinct ((x y)) () (¬ (∀ x (¬ ((value x) = (value y))))) (
</jh>
We stick <code>y = y</code> on the proof stack for later use.
<jh>
        y VariableEqualityReflexivity
</jh>
We start with <code>x = y → (x = y ↔ y = y)</code>.
<jh>
        x y y VariableEqualityBuilderRR
</jh>
That in turn implies <code>([ y / x ] y = x) ↔ y = y</code>, which of course implies <code>[ y / x ] y = x</code>.
<jh>
        makeVariableSubstExplicit
        eliminateBiconditionalForward
        applyModusPonens
</jh>
And that is enough to give us <code>∃ x x = y</code>
<jh>
        introduceThereExistsFromVariable
))

thm (ExistenceNotDistinct () () (¬ (∀ x (¬ ((value x) = (value x))))) (
        x VariableEqualityReflexivity
        ((value x) = (value x)) x ThereExistsIntroduction
        applyModusPonens
))
</jh>

{{cleanup|also proving Existence, QuantifierSubstitution and VariableSubstitution}}

Once we are done, here we would export the metamath axioms.

<jh>
#export (METAMATH Interface:Axioms_of_first-order_logic (PROPOSITIONAL) ())
</jh>

== References ==
<references/>

[[Category:Classical first-order logic]]
