{{header
 | title    = First-order logic
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = The purpose of this page is to prove the statements of [[Interface:First-order logic]] from [[Interface:Axioms of first-order logic]].

{{under construction}}
}}
{{interfaces
| imports = [[Interface:Axioms of first-order logic]]
| exports = eventually [[Interface:First-order logic]]
}}

We start with the [[Interface:Classical propositional calculus|theorems of propositional logic]] and [[Interface:Axioms of first-order logic]]:

<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (PRINCIPIA Interface:Axioms_of_first-order_logic (CLASSICAL) ())
</jh>

As usual, φ, ψ, χ, and θ are formulas and x, y, and z are objects:

<jh>
var (wff φ ψ χ θ)
var (object x y z)
</jh>

== Equality is reflexive and symmetric ==
The basic facts about equality are that it is reflexive, symmetric and transitive. Instead of supposing these as axioms, we have a single axiom which implies them (when combined with some of the other axioms).

We start with reflexivity.  The first two theorems are intermediate steps:

<jh>
thm (EqualityReflexivity-1 () () ((x = y) → (y = y)) (
        (x = y) ConjunctionIdempotence eliminateRightBiconditionalImplication

        x y y AxiomEquality
        import

        applySyllogism
))

thm (EqualityReflexivity-2 () () ((∀ x (¬ (y = y))) → (∀ x (¬ (x = y)))) (
        x y EqualityReflexivity-1
        introduceTransposition
        x generalize

        x (¬ (y = y)) (¬ (x = y)) QuantifiedImplication
        applyModusPonens
))
</jh>

The proof of reflexivity involves adding an extra variable <code>x</code>. We need to specify that this variable is distinct from y, but this doesn't affect the generality of the result. The variable <code>x</code> only appears in the proof, not in the theorem, and so the distinct variable constraint only needs to appear here, not in the statement of the theorem in [[Interface:First-order logic]].
<jh>
thm (EqualityReflexivity ((x y)) () (y = y) (
        x y Existence

        (¬ (y = y)) x Generalization
        x y EqualityReflexivity-2
        applySyllogism

        applyModusTollens
        eliminateDoubleNegation
))
</jh>

The proof of symmetry follows much more easily from reflexivity and the equality axiom. Most of what we need to do is just propositional logic.
<jh>
thm (applyNestedModusPonens () 
  ((H1 ψ) (H2 (φ → (ψ → χ))))
  (φ → χ) (
        H1

        H2
        import

        ψ φ ConjunctionCommutativity eliminateRightBiconditionalImplication
        χ addCommonConsequent
        applyModusPonens

        export
        applyModusPonens
))

thm (EqualitySymmetryImplication () () ((x = y) → (y = x)) (
        x EqualityReflexivity
        x y x AxiomEquality
        applyNestedModusPonens
))

thm (EqualitySymmetry () () ((x = y) ↔ (y = x)) (
        x y EqualitySymmetryImplication
        y x EqualitySymmetryImplication
        introduceBiconditionalFromImplications
))
</jh>

== Specification ==
We can remove a universal quantifier.

<jh>
#thm (Specialization () () ((∀ x φ) → φ) (
#        y x Existence
#        (¬ ((∀ x φ) → φ)) y Generalization
#        ... to be continue (ax4 in metamath set.mm)
#))
</jh>

== Builder for ∀ ==
<jh>
#thm (addForAll () (φ ↔ ψ) (∀xφ ↔ ∀xψ) (
#...19.20i in metamath set.mm
#))
</jh>

== Relationship between universal and existential quantification ==
The axioms are written in terms of just the universal quantifier ∀. We define the existential quantifier ∃ in terms of it:

<jh>
def ((∃ x φ) (¬ (∀ x (¬ φ))))
</jh>

and the following two theorems are immediate consequences from this definition:

<jh>
thm (NotThereExists () () ((¬ (∃ x φ)) ↔ (∀ x (¬ φ))) (
        (∃ x φ) BiconditionalReflexivity
        addNegation

        (∀ x (¬ φ)) DoubleNegation swapBiconditional
        applyBiconditionalTransitivity
))

# Think we need addForAll for this
#thm (NotForAll () () ((¬ (∀ x φ)) ↔ (∃ x (¬ φ))) (
#))
</jh>

This page is not yet done.  When it is, the following export to [[Interface:First-order logic]] can be uncommented:
<jh>
#export (FIRSTORDER Interface:First-order_logic (CLASSICAL) ())
</jh>

[[Category:Predicate logic]]