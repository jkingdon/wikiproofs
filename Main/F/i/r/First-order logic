{{header
 | title    = First-order logic
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = The purpose of this page is to prove the statements of [[Interface:First-order logic]] from [[Interface:Axioms of first-order logic]].
}}
{{interfaces
| imports = [[Interface:Axioms of first-order logic]]
| exports = [[Interface:First-order logic]]
}}

Many of the proofs on this page are adapted from metamath's set.mm, and theorems may be named after set.mm.  However, since set.mm names do change over time, do not count on this correspondence to be exact.

We start with the [[Interface:Classical propositional calculus|theorems of propositional logic]] and [[Interface:Axioms of first-order logic]]:

<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (AXIOMS Interface:Axioms_of_first-order_logic (CLASSICAL) ())
</jh>

As usual, φ, ψ, χ, and θ are formulas, x, y, and z are variables, and s, t, and u are objects:

<jh>
var (formula φ ψ χ θ)
var (object s t u s0 s1 t0 t1)
var (variable x y z x0 x1 y0 y1)
</jh>

We also define some variables which suggest which variables are likely to be included. For example, <code>φx</code> is likely to include the variable <code>x</code> (of course, it is the distinct variable constraints which really specify what variables are allowed). This is similar in intent to the notation <code>φ(x)</code> which is sometimes used in treatments of predicate logic.
<jh>
var (formula φx φy ψy)
</jh>

== ForAllImplication ==

The ∀ quantifier can be distributed across an implication. This is one of our axioms, so we just provide an additional name:

<jh>
thm (ForAllImplication () () ((∀ x (φ → ψ)) → ((∀ x φ) → (∀ x ψ))) (
        x φ ψ QuantifiedImplication
))
</jh>

=== Builder for ∀ ===
From <code>φ → ψ</code> we want to be able to get <code>∀ x φ → ∀ x ψ</code>.<ref>[http://us.metamath.org/mpeuni/19.20i.html 19.20i] in metamath's set.mm, accessed February 18, 2010</ref>
<jh>
thm (addForAll () ((H (φ → ψ))) ((∀ x φ) → (∀ x ψ)) (
        H
        x generalize

        x φ ψ ForAllImplication

        applyModusPonens
))
</jh>

The builder for the biconditional follows trivially:
<jh>
thm (buildForAll () ((H (φ ↔ ψ))) ((∀ x φ) ↔ (∀ x ψ)) (
        H eliminateBiconditionalReverse x addForAll
        H eliminateBiconditionalForward x addForAll
        introduceBiconditionalFromImplications
))
</jh>

== Equality ==

The basic facts about equality are that it is reflexive, symmetric and transitive. Since we have axioms for those properties, we just add a few rules:

<jh>
thm (swapEquality () ((H (s = t))) (t = s) (
        H
        s t EqualitySymmetry eliminateBiconditionalReverse
        applyModusPonens
))

thm (applyEqualityTransitivity () ((H1 (s = t)) (H2 (t = u))) (s = u) (
        H1
        H2
        introduceConjunction
        s t u EqualityTransitivity
        applyModusPonens
))

thm (applyEqualityTransitivityInConsequent () ((H1 (φ → (s = t))) (H2 (φ → (t = u)))) (φ → (s = u)) (
        H1
        H2
        composeConjunction
        s t u EqualityTransitivity
        applySyllogism
))
</jh>

=== Builder ===
<code>EqualityBuilder</code> can be derived from transitivity.  We start with a special case:

<jh>
thm (EqualityBuilderRR () () ((s0 = s1) → ((s0 = t) ↔ (s1 = t))) (
</jh>
The proof has two halves, each of which is proved by transitivity and an export.
The forward implication, <code>s0 = s1 → (s0 = t → s1 = t)</code>, also involves switching the order of the opening equality.
<jh>
        s0 s1 EqualitySymmetry
        eliminateBiconditionalReverse

        s1 s0 t EqualityTransitivity
        export

        applySyllogism

</jh>
The reverse implication, <code>s0 = s1 → (s1 = t → s0 = t)</code>, is even simpler:
<jh>
        s0 s1 t EqualityTransitivity
        export

</jh>
We then combine the two directions:
<jh>
        composeConjunction

        (s0 = t) (s1 = t) BiconditionalImplication eliminateBiconditionalForward
        applySyllogism
))
</jh>

We provide an analogous result with the order of the equalities changed, <code>EqualityBuilderLL</code>.
<jh>
thm (commute2 () () (((s0 = t0) ↔ (s1 = t1)) → ((t0 = s0) ↔ (t1 = s1))) (
        s0 t0 EqualitySymmetry
        s1 t1 EqualitySymmetry
        buildBiconditional
        eliminateBiconditionalReverse
))

thm (EqualityBuilderLL () () ((s0 = s1) → ((t = s0) ↔ (t = s1))) (
        s0 s1 t EqualityBuilderRR
        s0 t s1 t commute2
        applySyllogism
))
</jh>

Combining <code>EqualityBuilderLL</code> and <code>EqualityBuilderRR</code> gives us the full builder.

<jh>
thm (EqualityBuilder () () (((s0 = s1) ∧ (t0 = t1)) → ((s0 = t0) ↔ (s1 = t1))) (
        (s0 = s1) (t0 = t1) ConjunctionRightElimination
        s0 s1 t0 EqualityBuilderRR
        applySyllogism

        (s0 = s1) (t0 = t1) ConjunctionLeftElimination
        t0 t1 s1 EqualityBuilderLL
        applySyllogism

        composeConjunction

        (s0 = t0) (s1 = t0) (s1 = t1) BiconditionalTransitivity
        applySyllogism
))

thm (buildEquality () ((HX (s0 = s1)) (HY (t0 = t1))) ((s0 = t0) ↔ (s1 = t1)) (
        HX
        HY
        introduceConjunction
        s0 s1 t0 t1 EqualityBuilder
        applyModusPonens
))

thm (buildEqualityRR () ((H (s0 = s1))) ((s0 = t) ↔ (s1 = t)) (
        H
        t EqualityReflexivity
        introduceConjunction

        s0 s1 t t EqualityBuilder

        applyModusPonens
))

thm (buildEqualityLL () ((H (t0 = t1))) ((s = t0) ↔ (s = t1)) (
        s EqualityReflexivity
        H
        introduceConjunction

        s s t0 t1 EqualityBuilder

        applyModusPonens
))
</jh>

For convenience, we also supply builders in the consequent:

<jh>
thm (buildEqualityInConsequent ()
  ((HN (φ → (s0 = s1)))
   (HM (φ → (t0 = t1))))
  (φ → ((s0 = t0) ↔ (s1 = t1))) (
        HN HM composeConjunction
        s0 s1 t0 t1 EqualityBuilder
        applySyllogism
))

thm (buildEqualityRRInConsequent ()
  ((H (φ → (s0 = s1))))
  (φ → ((s0 = t) ↔ (s1 = t))) (
        H
        t EqualityReflexivity φ introduceAntecedent
        buildEqualityInConsequent
))

thm (buildEqualityLLInConsequent ()
  ((H (φ → (t0 = t1))))
  (φ → ((s = t0) ↔ (s = t1))) (
        s EqualityReflexivity φ introduceAntecedent
        H
        buildEqualityInConsequent
))
</jh>

=== Not equal ===
Although <code>≠</code> is just an abbreviation for negation and equality, we do need to repeat the definition in this file to be able to export to [[Interface:First-order logic]].
<jh>
def ((≠ s t) (¬ (s = t)))
</jh>

== Specialization ==
We can remove a universal quantifier. This is sometimes taken as an axiom but here we prove it from the other axioms via a number of intermediate steps.<ref>[http://us.metamath.org/mpeuni/ax4.html ax4] in metamath's set.mm, accessed February 18, 2010</ref> In many formulations of predicate logic, specialization is combined with substitution (and often a distinction between constants and variables), but we handle substitution later.  Constants in our system are represented by predicates with no arguments (for example, <code>(0)</code> in [[Interface:Basic arithmetic]]), and our substitution mechanisms will be able to handle them (as well as other kinds of terms).

<jh>
thm (Specialization-18 ((x y)) () 
  (((value y) = (value x)) → ((¬ φ) → (∀ x (((value x) = (value y)) → (¬ φ))))) (
        (value y) (value x) EqualitySymmetry eliminateBiconditionalReverse
        x y (¬ φ) VariableSubstitution
        applySyllogism
))

thm (Specialization-22 () () 
  ((∀ x (((value x) = (value y)) → (¬ φ))) → (∀ x (φ → (¬ ((value x) = (value y)))))) (
        ((value x) = (value y)) φ TranspositionWithNegatedConsequent
        eliminateBiconditionalReverse

        x addForAll
))

thm (Specialization-a () () ((∀ x (φ → (¬ ((value x) = (value y))))) → (¬ (∀ x φ))) (
        x φ (¬ ((value x) = (value y))) ForAllImplication

        x y Existence
        (∀ x φ) (∀ x (¬ ((value x) = (value y)))) Transposition eliminateBiconditionalReverse
        detachImplicationImplication

        applySyllogism
))

thm (Specialization-30 ((x y)) () ((¬ ((∀ x φ) → φ)) → (¬ ((value y) = (value x)))) (
        y x φ Specialization-18
        import

        x y φ Specialization-22
        applySyllogism

        x φ y Specialization-a
        applySyllogism
        export

        (∀ x φ) φ Transposition eliminateBiconditionalForward
        applySyllogism

        introduceTransposition
))

thm (Specialization-33 ((x y)) () 
  ((∀ y (¬ ((∀ x φ) → φ))) → (∀ y (¬ ((value y) = (value x))))) (
        x φ y Specialization-30
        y addForAll
))
</jh>

The proof of reflexivity involves adding an extra variable <code>y</code>. We need to specify that this variable is distinct from <code>x</code> and <code>φ</code>, but this doesn't affect the generality of the result. The variable <code>y</code> only appears in the proof, not in the theorem, and so the distinct variable constraint only needs to appear here, not in the statement of the theorem in [[Interface:First-order logic]].
<jh>
thm (Specialization ((x y) (y φ)) () ((∀ x φ) → φ) (
        y x Existence

        (¬ ((∀ x φ) → φ)) y Generalization
        y x φ Specialization-33
        applySyllogism

        applyModusTollens

        eliminateDoubleNegation
))

thm (specialize () ((H (∀ x φ))) φ (
        H
        x φ Specialization
        applyModusPonens
))
</jh>

== Doubling ∀ ==

If we have a universal quantifier, it doesn't change anything to apply it twice.  That is, <code>∀ x φ → ∀ x ∀ x φ</code>

<jh>
thm (ForAllDoubling-negation-lemma () () 
  ((∀ x (¬ (∀ x (¬ (∀ x φ))))) → (∀ x (∀ x φ))) (
        x φ QuantifiedNegation
        transposeWithNegatedAntecedent

        x addForAll
))

thm (ForAllDoubling () () ((∀ x φ) → (∀ x (∀ x φ))) (
        x (¬ (∀ x φ)) Specialization
        transposeWithNegatedConsequent

        x (¬ (∀ x φ)) QuantifiedNegation
        applySyllogism

        x φ ForAllDoubling-negation-lemma
        applySyllogism
))
</jh>

=== a5i ===
A consequence is a variant of <code>QuantifiedImplication</code>:
<jh>
thm (a5i () ((H ((∀ x φ) → ψ))) ((∀ x φ) → (∀ x ψ)) (
        x φ ForAllDoubling

        H
        x addForAll

        applySyllogism
))
</jh>

== Existential quantification ==
The axioms are written in terms of just the universal quantifier ∀. We define the existential quantifier ∃ in terms of it:

<jh>
def ((∃ x φ) (¬ (∀ x (¬ φ))))
</jh>

and the following two theorems are immediate consequences from this definition:

<jh>
thm (NotThereExists () () ((¬ (∃ x φ)) ↔ (∀ x (¬ φ))) (
        (∃ x φ) BiconditionalReflexivity
        addNegation

        (∀ x (¬ φ)) DoubleNegation swapBiconditional
        applyBiconditionalTransitivity
))

thm (NotForAll () () ((¬ (∀ x φ)) ↔ (∃ x (¬ φ))) (
        φ DoubleNegation
        x buildForAll
        addNegation
))
</jh>

=== Builders ===

The builders for ∃ follow from the builders for ∀:
<jh>
thm (addThereExists () ((H (φ → ψ))) ((∃ x φ) → (∃ x ψ)) (
        H
        introduceTransposition
        x addForAll
        introduceTransposition
))

thm (buildThereExists () ((H (φ ↔ ψ))) ((∃ x φ) ↔ (∃ x ψ)) (
        H
        addNegation
        x buildForAll
        addNegation
))
</jh>

=== Adding existential quantifier ===
We can add ∃ to the start of a formula:<ref>[http://us.metamath.org/mpeuni/19.8a.html 19.8a] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (ThereExistsIntroduction () () (φ → (∃ x φ)) (
        x (¬ φ) Specialization
        transposeWithNegatedConsequent
))
</jh>

=== Another for-all distribution law ===

If we have an implication quantified by ∀, we've already shown that <code>∀ x φ → ∀ x ψ</code> follows. It also will sometimes be useful to know that alternately <code>∃ x φ → ∃ x ψ</code> does.<ref>[http://us.metamath.org/mpeuni/19.22.html 19.22] in metamath's set.mm, accessed February 21, 2010</ref>
<jh>
thm (ForAllImplicationThereExists () () ((∀ x (φ → ψ)) → ((∃ x φ) → (∃ x ψ))) (
        φ ψ Transposition
        x buildForAll

        eliminateBiconditionalReverse
        x (¬ ψ) (¬ φ) ForAllImplication
        applySyllogism

        (∀ x (¬ ψ)) (∀ x (¬ φ)) Transposition
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

== Quantifier order ==
Being able to swap the order of two ∀ quantifiers is an axiom, so we just need to biconditionalize it:

<jh>
thm (ForAllCommutation () () ((∀ x (∀ y φ)) ↔ (∀ y (∀ x φ))) (
        x y φ QuantifierCommutation
        y x φ QuantifierCommutation
        introduceBiconditionalFromImplications
))
</jh>

The corresponding theorem for ∃ follows from it.  It may be easier to follow the proof below if you remember that 
 <code>∃ x ∃ y φ</code>
is equivalent to 
 <code>¬ ∀ x ¬ ¬ ∀ y ¬ φ</code>

<jh>
thm (ThereExistsCommutation () () ((∃ x (∃ y φ)) ↔ (∃ y (∃ x φ))) (
        (∀ y (¬ φ)) DoubleNegation swapBiconditional
        x buildForAll

        x y (¬ φ) ForAllCommutation
        applyBiconditionalTransitivity

        (∀ x (¬ φ)) DoubleNegation
        y buildForAll
        applyBiconditionalTransitivity

        addNegation
))
</jh>

== Combining quantified statements ==

=== For-all across a Conjunction ===
The ability to combine or split ∀ across a conjunction follows from <code>ForAllImplication</code> and some propositional logic.<ref>[http://us.metamath.org/mpeuni/19.26.html 19.26] in metamath's set.mm, accessed February 19, 2010</ref> We prove the forward and reverse implications separately.

<jh>
thm (ForAllConjunctionSplitting () () ((∀ x (φ ∧ ψ)) → ((∀ x φ) ∧ (∀ x ψ))) (
        φ ψ ConjunctionRightElimination
        x addForAll

        φ ψ ConjunctionLeftElimination
        x addForAll

        composeConjunction
))

thm (ForAllConjunctionCombining () () (((∀ x φ) ∧ (∀ x ψ)) → (∀ x (φ ∧ ψ))) (
        φ ψ ConjunctionRightIntroduction
        x addForAll

        x ψ (φ ∧ ψ) ForAllImplication
        applySyllogism

        import
))

thm (ForAllConjunction () () ((∀ x (φ ∧ ψ)) ↔ ((∀ x φ) ∧ (∀ x ψ))) (
        x φ ψ ForAllConjunctionSplitting
        x φ ψ ForAllConjunctionCombining
        introduceBiconditionalFromImplications
))
</jh>

=== There-exists across a disjunction ===

This one follows from <code>ForAllConjunction</code> via DeMorgan's law and a little bit of negation rearranging.
<jh>
thm (ThereExistsDisjunction () () ((∃ x (φ ∨ ψ)) ↔ ((∃ x φ) ∨ (∃ x ψ))) (
        φ ψ DeMorganPDP
        x buildForAll

        x (¬ φ) (¬ ψ) ForAllConjunction
        applyBiconditionalTransitivity

        (∀ x (¬ φ)) (∀ x (¬ ψ)) DeMorganNDN swapBiconditional
        applyBiconditionalTransitivity

        addNegation

        ((∃ x φ) ∨ (∃ x ψ)) DoubleNegation swapBiconditional
        applyBiconditionalTransitivity
))
</jh>

=== There-exists across a conjunction ===
In the last two sections we tackled ∀ across a conjunction and ∃ across a disjunction. The other two similar cases (∃ across a conjunction and ∀ across a disjunction) also hold, but only in one direction, not as biconditionals.<ref>[http://us.metamath.org/mpeuni/19.40.html 19.40] and [http://us.metamath.org/mpeuni/19.33.html 19.33] in metamath's set.mm, accessed January 3, 2011</ref>

Here we prove ∃ across a conjunction.
<jh>
thm (ThereExistsConjunction () () ((∃ x (φ ∧ ψ)) → ((∃ x φ) ∧ (∃ x ψ))) (
        φ ψ ConjunctionRightElimination
        x addThereExists

        φ ψ ConjunctionLeftElimination
        x addThereExists

        composeConjunction
))
</jh>

=== For-all across a biconditional ===
Distributing <code>∀</code> across an implication also works for the biconditional.  The proof is just expanding the biconditional into conjunctions and implications and distribution of <code>∀</code> across the conjunctions and implications.
<jh>
thm (ForAllBiconditional () () ((∀ x (φ ↔ ψ)) → ((∀ x φ) ↔ (∀ x ψ))) (
        φ ψ BiconditionalImplication eliminateBiconditionalReverse
        x addForAll

        x (φ → ψ) (ψ → φ) ForAllConjunction eliminateBiconditionalReverse
        applySyllogism

        x φ ψ ForAllImplication
        x ψ φ ForAllImplication
        conjoin
        applySyllogism

        (∀ x φ) (∀ x ψ) BiconditionalImplication eliminateBiconditionalForward
        applySyllogism
))
</jh>

=== There-exists across an implication ===

This is another proof which mostly consists of the definition of ∃ and propositional calculus.

<jh>
thm (ThereExistsImplication () () ((∃ x (φ → ψ)) ↔ ((∀ x φ) → (∃ x ψ))) (
        φ ψ ImplicationDisjunction
        addNegation
        φ ψ DeMorganNDP
        applyBiconditionalTransitivity
</jh>
So far, we have transformed <code>¬ (φ → ψ)</code> into <code>φ ∧ (¬ ψ)</code> which is now ripe for applying <code>ForAllConjunction</code> 
<jh>
        x buildForAll

        x φ (¬ ψ) ForAllConjunction
        applyBiconditionalTransitivity

        addNegation
</jh>
We're almost there.  The left hand side has been gradually built up into <code>(∃ x (φ → ψ))</code>. The right hand side is <code>(¬ ((∀ x φ) ∧ (∀ x (¬ ψ))))</code>, which just needs DeMorgan's law and transformation from disjunction to implication to become <code>((∀ x φ) → (∃ x ψ))</code>
<jh>
        (∀ x φ) (∀ x (¬ ψ)) DeMorganPCP
        applyBiconditionalTransitivity

        (∀ x φ) (¬ (∀ x (¬ ψ))) ImplicationDisjunction swapBiconditional
        applyBiconditionalTransitivity
))
</jh>

=== Combining ∀ and ∃ to prove ∃ on a conjunction ===
One way of thinking of the following theorem is that we want to find an <code>x</code> for which both <code>φ</code> and <code>ψ</code> hold. The second half of the antecedent (<code>∃ x ψ</code>) gives us such an <code>x</code>, which also holds for <code>φ</code> because <code>φ</code> holds for any value of <code>x</code>.<ref>[http://us.metamath.org/mpeuni/19.29.html 19.29] in metamath's set.mm, accessed 2010</ref>
<jh>
thm (ThereExistsConjunctionCombining () () (((∀ x φ) ∧ (∃ x ψ)) → (∃ x (φ ∧ ψ))) (
        x φ (¬ ψ) ForAllImplication
</jh>
That gives us <code>∀ x (φ → ¬ ψ) → (∀ x φ → ∀ x ¬ ψ)</code>. We first transform <code>∀ x ¬ ψ</code> into <code>¬ ∃ x ψ</code>.
<jh>
        x ψ NotThereExists eliminateBiconditionalForward
        (∀ x φ) addCommonAntecedent
        (∀ x (φ → (¬ ψ))) addCommonAntecedent
        applyModusPonens
</jh>
Transposing this gives us <code>¬ (∀ x φ → ¬ ∃ x ψ) → ¬ ∀ x (φ → ¬ ψ)</code>.
<jh>
        introduceTransposition
</jh>
We are going to transform both sides of this with <code>ConjunctionImplication</code>.  First, the left side directly converts to <code>∀ x φ ∧ ∃ x ψ</code>.
<jh>
        (∀ x φ) (∃ x ψ) ConjunctionImplication swapBiconditional
        transformAntecedent
</jh>
The right side, <code>¬ ∀ x (φ → ¬ ψ)</code>, is only slightly more complicated.
<jh>
        x (φ → (¬ ψ)) NotForAll

        φ ψ ConjunctionImplication swapBiconditional
        x buildThereExists
        applyBiconditionalTransitivity

        eliminateBiconditionalReverse applySyllogism
))
</jh>

It will also be convenient to have a commuted version,
<jh>
thm (ThereExistsConjunctionRightCombining () ()
  (((∃ x φ) ∧ (∀ x ψ)) → (∃ x (φ ∧ ψ))) (
        (∃ x φ) (∀ x ψ) ConjunctionCommutativity
        eliminateBiconditionalReverse

        x ψ φ ThereExistsConjunctionCombining
        applySyllogism

        ψ φ ConjunctionCommutativity
        eliminateBiconditionalReverse
        x addThereExists
        applySyllogism
))
</jh>

and a rule.
<jh>
thm (combineThereExistsForAll () ((HEXIST (∃ x φ)) (HALL (∀ x ψ))) (∃ x (φ ∧ ψ)) (
        HEXIST
        HALL
        introduceConjunction
        x φ ψ ThereExistsConjunctionRightCombining
        applyModusPonens
))
</jh>

== Negation ==
This relationship between quantification and negation is sometimes taken as an axiom instead of our <code>QuantifiedNegation</code>, but we prove it here:<ref>[http://us.metamath.org/mpeuni/ax6o.html ax6o] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (ax6o () () ((¬ (∀ x (¬ (∀ x φ)))) → φ) (
        x φ QuantifiedNegation
        transposeWithNegatedAntecedent

        x φ Specialization

        applySyllogism
))
</jh>

== Free variables ==
The conventional treatment of [[w:free variable|free variables]] is syntactic; variables are defined as free depending on where they occur in a formula relative to the quantifiers over that variable. JHilbert (following metamath before it) does not contain the ability to analyze formulas this way, and we instead define free variables based on whether generalization is possible:

<jh>
def ((is-not-free-in x φ) (φ → (∀ x φ)))
</jh>

This differs slightly from the syntactic definition of free variables, and so might better be termed ''effectively free'' than simply ''free''. For example, this definition does not consider <code>x</code> to be free in <code>x = x</code>.<ref>[http://us.metamath.org/mpeuni/mmset.html#traditional Appendix 2: Traditional Textbook Axioms of Predicate Calculus with Equality], Metamath Proof Explorer, accessed February 20, 2010.</ref> In fact, this relationship is true of any theorem.<ref>[http://us.metamath.org/mpeuni/hbth.html hbth] in metamath's set.mm, accessed February 20, 2010.</ref> There is little need to actually use <code>TheoremNotFree</code> for anything, but we show it here to demonstrate the implications of our definition.
<jh>
thm (TheoremNotFree () ((H φ)) (x is-not-free-in φ) (
        H
        x generalize
        φ introduceAntecedent
))
</jh>

Our next two results just restate axioms or theorems we already have. The first one can be thought of as saying that a variable is not free in an expression in which it does not occur:

<jh>
thm (DistinctNotFree ((x φ)) () (x is-not-free-in φ) (
        φ x Generalization
))
</jh>

And the second states that a universal quantifier makes the variable not free (that is, the variable is ''bound'' by a quantifier):<ref>[http://us.metamath.org/mpeuni/hba1.html hba1] in metamath's set.mm, accessed February 20, 2010. In case your font doesn't make it clear, this is hba followed by the number 1.</ref>
<jh>
thm (BoundForAllNotFree () () (x is-not-free-in (∀ x φ)) (
        x φ ForAllDoubling
))
</jh>

There's another result for universal quantifiers, this one about adding a quantifier for a (possibly) different variable:<ref>[http://us.metamath.org/mpeuni/hbal.html hbal] in metamath's set.mm, accessed February 20, 2010.  In case your font doesn't make it clear, this is hba followed by the lowercase letter l.</ref>
<jh>
thm (addForAllNotFree () ((H (x is-not-free-in φ))) (x is-not-free-in (∀ y φ)) (
        H
        y addForAll

        y x φ ForAllCommutation eliminateBiconditionalReverse
        applySyllogism
))
</jh>

Next, if a variable is not free in <code>φ</code>, it is not free in <code>¬ φ</code>. We first prove an implication version:<ref>[http://us.metamath.org/mpeuni/hbnt.html hbnt] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (NegationNotFree () () ((∀ x (x is-not-free-in φ)) → (x is-not-free-in (¬ φ))) (
        φ (∀ x φ) Transposition eliminateBiconditionalReverse
        x addForAll

        x (¬ (∀ x φ)) (¬ φ) ForAllImplication
        applySyllogism

</jh>
At this point we have <code>∀ x (φ → ∀ x φ) → (∀ x ¬ ∀ x φ → ∀ x ¬ φ)</code>. Together with <code>¬ φ → ∀ x ¬ ∀ x φ</code> (which is the transposition of <code>ax6o</code>), we will get our desired result of <code>∀ x (φ → ∀ x φ) → (¬ φ → ∀ x ¬ φ)</code>.
<jh>
        x φ ax6o
        transposeWithNegatedAntecedent

        (∀ x (¬ φ)) addCommonConsequent

        applySyllogism
))
</jh>

The rule form does not need the extra quantifier:<ref>[http://us.metamath.org/mpeuni/hbn.html hbn] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (negateNotFree () ((H (x is-not-free-in φ))) (x is-not-free-in (¬ φ)) (
        H
        x generalize

        x φ NegationNotFree

        applyModusPonens
))
</jh>

Having negation makes it easy to prove the analogues to <code>BoundForAllNotFree</code> and <code>addForAllNotFree</code> for ∃:<ref>[http://us.metamath.org/mpeuni/hbex.html hbex] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (BoundThereExistsNotFree () () (x is-not-free-in (∃ x φ)) (
        x (¬ φ) BoundForAllNotFree
        negateNotFree
))

thm (addThereExistsNotFree () ((H (x is-not-free-in φ))) (x is-not-free-in (∃ y φ)) (
        H
        negateNotFree
        y addForAllNotFree
        negateNotFree
))
</jh>

The following builder is analogous to our builders for other formulas:

<jh>
thm (buildNotFree () ((H (φ ↔ ψ))) ((x is-not-free-in φ) ↔ (x is-not-free-in ψ)) (
        H
        H x buildForAll
        buildImplication
))
</jh>

=== Adding ∀ to the consequent of a theorem ===

Here is a result, a variation of one direction of ForAllImplicationAntecedentMovement, which we are able to prove now and which will help us later:<ref>[http://us.metamath.org/mpeuni/19.21ai.html 19.21ai] in metamath's set.mm, accessed 2010</ref>
<jh>
thm (addForAllToConsequentNotFree () ((HFREE (x is-not-free-in φ)) (HIMP (φ → ψ))) (φ → (∀ x ψ)) (
        HFREE

        HIMP
        x addForAll

        applySyllogism
))

thm (addForAllToConsequent ((φ x))
  ((H (φ → ψ)))
  (φ → (∀ x ψ)) (
        x φ DistinctNotFree
        H
        addForAllToConsequentNotFree
))
</jh>

=== Free variables and connectives ===
If a variable is not free in either of two propositions, it is not free in the implication of the two:<ref>[http://us.metamath.org/mpeuni/hbim.html hbim] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (principia*2.21 () () ((¬ φ) → (φ → ψ)) (
        (¬ φ) ψ DisjunctionRightIntroduction
        φ ψ ImplicationDisjunction eliminateBiconditionalForward
        applySyllogism
))

thm (implicationNotFree () 
  ((HPHI (x is-not-free-in φ)) (HPSI (x is-not-free-in ψ)))
  (x is-not-free-in (φ → ψ)) (
</jh>
Implication to disjunction we'll need at the end of the proof:
<jh>
        φ ψ ImplicationDisjunction eliminateBiconditionalReverse
</jh>
The first part of the proof is to derive <code>¬ φ → ∀ x (φ → ψ)</code>:
<jh>
        HPHI
        negateNotFree
        φ ψ principia*2.21
        addForAllToConsequentNotFree
</jh>
The second part of the proof is to derive <code>ψ → ∀ x (φ → ψ)</code>:
<jh>
        HPSI
        ψ φ AntecedentIntroduction
        addForAllToConsequentNotFree
</jh>
Now we combine the two parts:
<jh>
        composeDisjunction
        applySyllogism
))
</jh>

The same is true of the other connectives:
<jh>
thm (disjunctionNotFree () 
  ((HPHI (x is-not-free-in φ)) (HPSI (x is-not-free-in ψ)))
  (x is-not-free-in (φ ∨ ψ)) (
        HPHI negateNotFree
        HPSI
        implicationNotFree
</jh>
We've shown <code>x is-not-free-in (¬ φ → ψ)</code>. Now we just need to convert the implication to the equivalent disjunction
<jh>

        φ ψ DisjunctionImplication
        x buildNotFree

        eliminateBiconditionalForward
        applyModusPonens
))

thm (conjunctionNotFree ()
  ((HPHI (x is-not-free-in φ)) (HPSI (x is-not-free-in ψ)))
  (x is-not-free-in (φ ∧ ψ)) (
        HPHI negateNotFree
        HPSI negateNotFree
        disjunctionNotFree
        negateNotFree

        φ ψ DeMorganNDN
        x buildNotFree

        eliminateBiconditionalReverse
        applyModusPonens
))

thm (biconditionalNotFree ()
  ((HPHI (x is-not-free-in φ)) (HPSI (x is-not-free-in ψ)))
  (x is-not-free-in (φ ↔ ψ)) (
        HPHI HPSI implicationNotFree
        HPSI HPHI implicationNotFree
        conjunctionNotFree

        φ ψ BiconditionalImplication
        x buildNotFree

        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

=== Quantification of a variable which isn't free ===

Quantifying with ∃ over a variable which is not free in a formula has no effect:<ref>[http://us.metamath.org/mpeuni/19.9.html 19.9] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (ThereExistsAddRemoveNotFree () ((H (x is-not-free-in φ))) ((∃ x φ) ↔ φ) (
        H
        negateNotFree
        transposeWithNegatedAntecedent

        φ x ThereExistsIntroduction

        introduceBiconditionalFromImplications
))

thm (NullThereExists ((x φ)) () ((∃ x φ) ↔ φ) (
        x φ DistinctNotFree
        ThereExistsAddRemoveNotFree
))

thm (removeThereExists ((x φ)) ((H (∃ x φ))) φ (
        H
        x φ NullThereExists eliminateBiconditionalReverse
        applyModusPonens
))

var (formula antecedent)
thm (removeThereExistsInConsequent ((x φ)) ((H (antecedent → (∃ x φ)))) (antecedent → φ) (
        H
        x φ NullThereExists eliminateBiconditionalReverse
        applySyllogism
))
</jh>

The same is true of ∀:<ref>[http://us.metamath.org/mpeuni/19.3.html 19.3] in metamath's set.mm, accessed February 21, 2010</ref>
<jh>
thm (ForAllAddRemoveNotFree () ((H (x is-not-free-in φ))) ((∀ x φ) ↔ φ) (
        x φ Specialization
        H
        introduceBiconditionalFromImplications
))
</jh>

=== Moving formulas in and out of quantification ===

The results in this section all have to do with being able to move around formulas relative to quantifiers, given that the quantified variable is not free in the formula being moved.

==== Implication ====
The forward direction of the next theorem just combines a few of our previous results.<ref>[http://us.metamath.org/mpeuni/19.21.html 19.21] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (ForAllImplicationAntecedentMovement () ((H (x is-not-free-in φ))) ((∀ x (φ → ψ)) ↔ (φ → (∀ x ψ))) (
        x φ ψ ForAllImplication
        H (∀ x ψ) addCommonConsequent
        applySyllogism

</jh>
The reverse direction is slightly more novel.
<jh>
        H
        x ψ BoundForAllNotFree
        implicationNotFree
</jh>
That gives us <code>x is-not-free-in (φ → ∀ x ψ)</code>
<jh>
        x ψ Specialization
        φ addCommonAntecedent
        x addForAll

        applySyllogism

        introduceBiconditionalFromImplications
))

thm (moveAntecedentOutOfForAll () ((H (∀ x (φ → ψ))) (HFREE (x is-not-free-in φ))) (φ → (∀ x ψ)) (
        H

        HFREE
        ψ ForAllImplicationAntecedentMovement
        eliminateBiconditionalReverse

        applyModusPonens
))

thm (moveAntecedentIntoForAll () 
  ((H (φ → (∀ x ψ))) (HFREE (x is-not-free-in φ))) 
  (∀ x (φ → ψ)) (
        H

        HFREE
        ψ ForAllImplicationAntecedentMovement
        eliminateBiconditionalForward

        applyModusPonens
))
</jh>

The corresponding theorem for ∃ is similar:<ref>[http://us.metamath.org/mpeuni/19.37.html 19.37] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (ThereExistsAntecedentMovementNotFree () ((H (x is-not-free-in φ))) ((∃ x (φ → ψ)) ↔ (φ → (∃ x ψ))) (
        x φ ψ ThereExistsImplication

        H ForAllAddRemoveNotFree
        (∃ x ψ) BiconditionalReflexivity
        buildImplication

        applyBiconditionalTransitivity
))
</jh>

The two theorems which involve moving the consequent result in changing ∃ to ∀ or vice versa. We name them after the quantifier which appears on the combined half of the equivalence. We'll first prove the for-all one.<ref>[http://us.metamath.org/mpeuni/19.23.html 19.23] in metamath's set.mm, accessed February 21, 2010</ref>
<jh>
thm (ForAllImplicationConsequentMovement () ((H (x is-not-free-in ψ))) ((∀ x (φ → ψ)) ↔ ((∃ x φ) → ψ)) (
</jh>
For the forward direction we first distribute to <code>∃ x φ → ∃ x ψ</code> and then remove the quantifier on <code>ψ</code>.
<jh>
        x φ ψ ForAllImplicationThereExists
        H ThereExistsAddRemoveNotFree eliminateBiconditionalReverse
        (∃ x φ) addCommonAntecedent
        applySyllogism
</jh>
The reverse direction is somewhat more complicated.  We start by proving <code>x is-not-free-in (∃ x φ → ψ)</code>:
<jh>
        x φ BoundThereExistsNotFree
        H
        implicationNotFree
</jh>
Then we show that <code>(∃ x φ → ψ) → (φ → ψ)</code>
<jh>
        φ x ThereExistsIntroduction
        ψ addCommonConsequent

</jh>
Because x is not free in the antecedent, we can conclude <code>(∃ x φ → ψ) → ∀ x (φ → ψ)</code>:
<jh>
        addForAllToConsequentNotFree

</jh>
Now we just need to combine the forward and reverse implications:
<jh>
        introduceBiconditionalFromImplications
))
</jh>

And closing out this section is the corresponding result for ∃:<ref>[http://us.metamath.org/mpeuni/19.36.html 19.36] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (ThereExistsImplicationConsequentMovement () ((H (x is-not-free-in ψ))) ((∃ x (φ → ψ)) ↔ ((∀ x φ) → ψ)) (
        x φ ψ ThereExistsImplication

        (∀ x φ) BiconditionalReflexivity
        H ThereExistsAddRemoveNotFree
        buildImplication

        applyBiconditionalTransitivity
))
</jh>

==== Disjunction ====
There are similar theorems moving disjunctions and conjuncts. To move a disjunct in or out of ∀:<ref>[http://us.metamath.org/mpeuni/19.32.html 19.32] in metamath's set.mm, accessed February 26, 2010</ref>

<jh>
thm (ForAllDisjunctionMovement () ((H (x is-not-free-in φ))) ((∀ x (φ ∨ ψ)) ↔ (φ ∨ (∀ x ψ))) (
        φ ψ DisjunctionImplication x buildForAll

        H negateNotFree
        ψ ForAllImplicationAntecedentMovement applyBiconditionalTransitivity

        φ (∀ x ψ) DisjunctionImplication swapBiconditional applyBiconditionalTransitivity
))
</jh>

To move a disjunct in or out of ∃:<ref>[http://us.metamath.org/mpeuni/19.45.html 19.45] in metamath's set.mm, accessed March 17, 2010</ref>

<jh>
thm (ThereExistsDisjunctionMovementNotFree () ((H (x is-not-free-in φ))) ((∃ x (φ ∨ ψ)) ↔ (φ ∨ (∃ x ψ))) (
        φ ψ DisjunctionImplication x buildThereExists

        H negateNotFree
        ψ ThereExistsAntecedentMovementNotFree applyBiconditionalTransitivity

        φ (∃ x ψ) DisjunctionImplication swapBiconditional applyBiconditionalTransitivity
))

thm (ThereExistsDisjunctionMovement ((x φ)) () ((∃ x (φ ∨ ψ)) ↔ (φ ∨ (∃ x ψ))) (
        x φ DistinctNotFree
        ψ ThereExistsDisjunctionMovementNotFree
))

thm (ThereExistsDisjunctionRightMovement ((x ψ)) () ((∃ x (φ ∨ ψ)) ↔ ((∃ x φ) ∨ ψ)) (
        φ ψ DisjunctionCommutativity
        x buildThereExists

        x ψ φ ThereExistsDisjunctionMovement
        applyBiconditionalTransitivity

        ψ (∃ x φ) DisjunctionCommutativity
        applyBiconditionalTransitivity
))
</jh>

==== Conjunction ====
The theorems for conjunctions are similar. For ∀:<ref>[http://us.metamath.org/mpeuni/19.28.html 19.28] in metamath's set.mm, accessed March 18, 2010</ref>

<jh>
thm (ForAllConjunctionMovement () ((H (x is-not-free-in φ))) ((∀ x (φ ∧ ψ)) ↔ (φ ∧ (∀ x ψ))) (
        x φ ψ ForAllConjunction

        H
        ForAllAddRemoveNotFree
        (∀ x ψ) BiconditionalReflexivity
        buildConjunction

        applyBiconditionalTransitivity
))
</jh>

For ∃:<ref>[http://us.metamath.org/mpeuni/19.42.html 19.42] in metamath's set.mm, accessed May 31, 2010</ref>

<jh>
thm (ThereExistsConjunctionMovementNotFree () ((H (x is-not-free-in φ))) ((∃ x (φ ∧ ψ)) ↔ (φ ∧ (∃ x ψ))) (
</jh>
We first note that the definition of ∃ makes <code>∃ x (φ ∧ ψ)</code> equivalent to <code>¬ ∀ x ¬ (φ ∧ ψ)</code> and apply DeMorgan's law to make it <code>¬ ∀ x (¬ φ ∨ ¬ ψ)</code>
<jh>
        φ ψ DeMorganPCP
        x buildForAll
        addNegation
</jh>
Now we can move <code>¬ φ</code> out of the scope of the quantifier, to get <code>¬ (¬ φ ∨ ∀ x ¬ ψ)</code>:
<jh>
        H negateNotFree
        (¬ ψ) ForAllDisjunctionMovement
        addNegation
        applyBiconditionalTransitivity
</jh>
We now turn <code>∀ x ¬ ψ</code> into <code>¬ ∃ x ψ</code>:
<jh>
        x ψ NotThereExists swapBiconditional
        (¬ φ) buildDisjunctionLL
        addNegation
        applyBiconditionalTransitivity
</jh>
Applying DeMorgan's law again, to get back to a conjunction, finishes our proof:
<jh>
        φ (∃ x ψ) DeMorganNDN
        applyBiconditionalTransitivity
))
</jh>

=== Distinct variable versions of movement theorems ===
Although the concept of <code>x is-not-free-in φ</code> is more general than saying that <code>x</code> does not appear in <code>φ</code> at all, most often the latter is the situation and it will be convenient to have versions of the above theorems which have distinct variable constraints rather than explicit freeness hypotheses.
<jh>
thm (ThereExistsConjunctionMovement ((x φ)) () ((∃ x (φ ∧ ψ)) ↔ (φ ∧ (∃ x ψ))) (
        x φ DistinctNotFree
        ψ ThereExistsConjunctionMovementNotFree
))

thm (ThereExistsConjunctionRightMovement ((x ψ)) () ((∃ x (φ ∧ ψ)) ↔ ((∃ x φ) ∧ ψ)) (
        φ ψ ConjunctionCommutativity
        x buildThereExists

        x ψ φ ThereExistsConjunctionMovement
        applyBiconditionalTransitivity

        ψ (∃ x φ) ConjunctionCommutativity
        applyBiconditionalTransitivity
))

thm (ThereExistsAntecedentMovement ((x φ)) () ((∃ x (φ → ψ)) ↔ (φ → (∃ x ψ))) (
        x φ DistinctNotFree
        ψ ThereExistsAntecedentMovementNotFree
))
</jh>

Here are a few rules, for convenience:
<jh>
thm (moveLeftConjunctIntoThereExistsInConsequent ((x φ))
  ((H (antecedent → (φ ∧ (∃ x ψ)))))
  (antecedent → (∃ x (φ ∧ ψ))) (
        H

        x φ ψ ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        applySyllogism
))

thm (moveRightConjunctIntoThereExistsInConsequent ((x ψ))
  ((H (antecedent → ((∃ x φ) ∧ ψ))))
  (antecedent → (∃ x (φ ∧ ψ))) (
        H

        x φ ψ ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applySyllogism
))

thm (repeatAntecedentThereExists ((x antecedent))
  ((H (antecedent → (∃ x ψ))))
  (antecedent → (∃ x (antecedent ∧ ψ))) (
        antecedent ImplicationReflexivity
        H
        composeConjunction
        moveLeftConjunctIntoThereExistsInConsequent
))
</jh>

=== Adding ∃ to the antecedent of a theorem ===

A consequence of <code>ForAllImplicationConsequentMovement</code> is that if we have a theorem which is an implication, we can add ∃ to the antecedent (provided the consequent does not contain the variable we are quantifying over).
<jh>
thm (addThereExistsToAntecedent ((x ψ))
  ((H (φ → ψ)))
  ((∃ x φ) → ψ) (
        H x generalize

        x ψ DistinctNotFree
        φ ForAllImplicationConsequentMovement
        eliminateBiconditionalReverse

        applyModusPonens
))
</jh>

=== Scattering and gathering ===
This is a variation of movement of formulas in and out of quantification.<ref>[http://us.metamath.org/mpeuni/eeanv.html eeanv], metamath's set.mm, accessed September 13, 2010</ref>
<jh>
thm (ThereExistsScattering ((φx y) (ψy x)) ()
  ((∃ x (∃ y (φx ∧ ψy))) ↔ ((∃ x φx) ∧ (∃ y ψy))) (
</jh>
We first show <code>(∃ x φx ∧ ∃ y ψy) ↔ ∃ x (φx ∧ ∃ y ψy)</code>:
<jh>
        (∃ x φx) (∃ y ψy) ConjunctionCommutativity

        x ψy DistinctNotFree
        y addThereExistsNotFree
        φx ThereExistsConjunctionMovementNotFree
        swapBiconditional
        applyBiconditionalTransitivity

        (∃ y ψy) φx ConjunctionCommutativity
        x buildThereExists
        applyBiconditionalTransitivity
</jh>
Then we pull much the same trick with <code>y</code> (but it is easier as there is no commuting to do):
<jh>
        y φx ψy ThereExistsConjunctionMovement
        swapBiconditional
        x buildThereExists
        applyBiconditionalTransitivity

        swapBiconditional
))
</jh>

Here is a rule form.
<jh>
thm (gatherThereExistsInConsequent ((φx y) (ψy x)) ((H (antecedent → ((∃ x φx) ∧ (∃ y ψy)))))
  (antecedent → (∃ x (∃ y (φx ∧ ψy)))) (
        H
        x y φx ψy ThereExistsScattering
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

== Distinctors ==
So far we've just dealt with distinct variables via distinct variable constraints, and in fact that is sufficient for everything we need. Here we sketch out how we could introduce a formula <code>x is-distinct-from y</code>. We would define it to <code>¬ ∀x x = y</code>.<ref>See ax10o and other theorems in the section "Axioms ax-10 and ax-11" of metamath's set.mm, accessed 2011</ref>. Then we could prove theorems like <code>x is-distinct-from y ↔ y is-distinct-from x</code><ref>easy consequence of ax10, metamath's set.mm</ref> or <code>¬ x is-distinct-from y → x is-not-free-in ∀ y φ</code>.<ref>follows readily from ax10o, metamath's set.mm</ref> Such a development is interesting if one wishes to avoid distinct variable constraints, but the convenience of distinct variable constraints is large enough that we prefer to use them when we can.

== Quantifier order: ∃ x ∀ y to ∀ y ∃ x ==
We put aside switching the order of quantifiers for a while, but <code>is-not-free-in</code> enables us to make some more progress on it.<ref>[http://us.metamath.org/mpeuni/19.12.html 19.12] in metamath's set.mm, accessed February 22, 2010</ref>
<jh>
thm (ThereExistsForAllCommutation () () ((∃ x (∀ y φ)) → (∀ y (∃ x φ))) (
        y φ BoundForAllNotFree
        x addThereExistsNotFree
</jh>
At this point we have (expanding the definition of <code>is-not-free-in</code>) <code>∃ x ∀ y φ → ∀ y ∃ x ∀ y φ</code>.  We just need to get rid of the inner ∀ on the right hand side:
<jh>
        y φ Specialization
        x addThereExists
        y addForAll

        applySyllogism
))
</jh>

The converse does not in general hold. Metamath includes one particular case where it does,<ref>[http://us.metamath.org/mpeuni/19.12vv.html 19.12vv] in metamath's set.mm, accessed January 22, 2012</ref> although it is a curiosity more than anything which is needed in proofs.

== Quantifiers and equality ==
Here we prove a number of results involving equality and quantifiers.  Many of them will pave the way for results involving explicit (<code>subst</code>) substitution.

=== ax9o ===
First is a variant of the <code>Existence</code> axiom:<ref>[http://us.metamath.org/mpeuni/ax9o.html ax9o] in metamath's set.mm, accessed February 22, 2010</ref>

<jh>
thm (ax9o () () ((∀ x (((value x) = (value y)) → (∀ x φ))) → φ) (
        x y Existence
        x ((value x) = (value y)) (∀ x φ) ForAllImplicationThereExists
</jh>
This gives us <code>∀ x (x = y → ∀ x φ) → (∃ x x = y → ∃ x ∀ x φ)</code>, which can be simplified to our desired result.  The first step is to note that <code>∃ x x = y</code> is just the <code>Existence</code> axiom, and can therefore be removed:
<jh>
        detachImplicationImplication
</jh>
Now we need to reduce <code>∃ x ∀ x φ</code> to <code>φ</code>:
<jh>
        x φ ax6o
        applySyllogism
))
</jh>

=== A quantified statement which starts with a proposition ===
It is common for a quantifier to be followed by some kind of condition.  For example "for every ε > 0, (¬ ψ)" or "there exists a δ > 0 such that ψ".  Despite the similar wording, the former is formalized as <code>∀ ε (ε > 0 → ¬ ψ)</code> (with an implication) and the latter is formalized as <code>∃ δ (δ > 0 ∧ ψ)</code> (with a conjunction).  The first theorem in this section expresses this relationship:<ref>[http://us.metamath.org/mpeuni/alinexa.html alinexa] in metamath's set.mm, accessed February 22, 2010</ref>

<jh>
thm (alinexa () () ((∀ x (φ → (¬ ψ))) ↔ (¬ (∃ x (φ ∧ ψ)))) (
        φ (¬ ψ) ImplicationDisjunction
        φ ψ DeMorganPCP swapBiconditional
        applyBiconditionalTransitivity

        x buildForAll
</jh>
That gives us <code>∀ x (φ → ¬ ψ) ↔ ∀ x ¬ (φ ∧ ψ)</code>.  Now we just need to apply <code>NotThereExists</code> to the right hand side:
<jh>
        x (φ ∧ ψ) NotThereExists swapBiconditional
        applyBiconditionalTransitivity
))
</jh>

The second theorem, <code>equs3</code>, is a special case which will be useful in dealing with substitution:<ref>[http://us.metamath.org/mpeuni/equs3.html equs3] in metamath's set.mm, accessed February 22, 2010</ref>

<jh>
thm (equs3 () () 
  ((∃ x (((value x) = s) ∧ φ)) ↔ (¬ (∀ x (((value x) = s) → (¬ φ))))) (
        x ((value x) = s) φ alinexa
        transposeBiconditionalWithNegatedRight
))
</jh>

== Change variable ==
We can change the variable in a quantifier and the expression which it quantifies. For example, in [[Basic arithmetic]] we will need to prove <code>∃ n a + n = b ↔ ∃ m a + m = b</code>. Here we state a theorem which lets us do this: given <code>x = y → (φx ↔ φy)</code>, where <code>x</code> is not free in <code>φy</code> and <code>y</code> is not free in <code>φx</code>, conclude <code>∃ x φx ↔ ∃ y φy</code>.

We start by proving <code>∃ y φy → ∃ x φx</code> (subject to the same hypotheses).<ref>The proof is based on exalpha1 in [http://code.google.com/p/ghilbert/ ghilbert]'s [http://code.google.com/p/ghilbert/source/browse/trunk/peano/peano_thms.gh peano_thms.gh], accessed October 12, 2010</ref>
<jh>
thm (ChangeVariableThereExistsReverseNotFree
  ((x y))
  ((HFREEX (x is-not-free-in φy))
   (HFREEY (y is-not-free-in φx))
   (H (((value x) = (value y)) → (φx ↔ φy))))
  ((∃ y φy) → (∃ x φx)) (
        HFREEX

        H
        eliminateBiconditionalForwardInConsequent
        applyComm
</jh>
That gives us <code>φy → (x = y → φx)</code>. Adding ∀ to the consequent gives <code>φy → ∀ x (x = y → φx)</code>.
<jh>
        addForAllToConsequentNotFree
</jh>
The next part of the proof derives <code>∀ x (x = y → φx) → ∃ x φx</code>. The first step is to go from <code>∃ x x = y</code> (by the <code>Existence</code> axiom) to <code>∃ x ((x = y → φx) → φx)</code>.
<jh>
        x y Existence

        ((value x) = (value y)) φx ModusPonens
        export
        x addThereExists

        applyModusPonens
</jh>
Now we just distribute the quantification to get <code>∀ x (x = y → φx) → ∃ x φx</code>.
<jh>
        x (((value x) = (value y)) → φx) φx ThereExistsImplication
        eliminateBiconditionalReverse
        applyModusPonens
</jh>
Combining this with the previous result gives <code>φy → ∃ x φx</code>
<jh>
        applySyllogism
</jh>
Adding ∃ to the antecedent finishes the proof.
<jh>
        y generalize

        HFREEY
        x addThereExistsNotFree
        φy ForAllImplicationConsequentMovement
        eliminateBiconditionalReverse

        applyModusPonens
))
</jh>

The other direction is an easy consequence, but to prove it we do need to commute the equality and the biconditional.
<jh>
thm (ChangeVariableThereExistsForwardNotFree ((x y))
  ((HFREEX (x is-not-free-in φy))
   (HFREEY (y is-not-free-in φx))
   (H (((value x) = (value y)) → (φx ↔ φy))))
  ((∃ x φx) → (∃ y φy)) (
        HFREEY HFREEX

        H

        (value x) (value y) EqualitySymmetry
        φx φy BiconditionalSymmetry
        buildImplication

        eliminateBiconditionalReverse
        applyModusPonens

        ChangeVariableThereExistsReverseNotFree
))

thm (ChangeVariableThereExistsNotFree
  ((x y))
  ((HFREEX (x is-not-free-in φy))
   (HFREEY (y is-not-free-in φx))
   (H (((value x) = (value y)) → (φx ↔ φy))))
  ((∃ x φx) ↔ (∃ y φy)) (
        HFREEX HFREEY H
        ChangeVariableThereExistsForwardNotFree

        HFREEX HFREEY H
        ChangeVariableThereExistsReverseNotFree

        introduceBiconditionalFromImplications
))

thm (ChangeVariableThereExists
  ((y φx) (x φy) (x y))
  ((H (((value x) = (value y)) → (φx ↔ φy))))
  ((∃ x φx) ↔ (∃ y φy)) (
        x φy DistinctNotFree
        y φx DistinctNotFree
        H
        ChangeVariableThereExistsNotFree
))
</jh>

The corresponding result for ∀ is an easy consequence. The proof consists of the usual technique of pushing negations around until all the ∃ turn into ∀.
<jh>
thm (ChangeVariableForAllNotFree ((x y))
  ((HFREEX (x is-not-free-in φy))
   (HFREEY (y is-not-free-in φx))
   (H (((value x) = (value y)) → (φx ↔ φy))))
  ((∀ x φx) ↔ (∀ y φy)) (
        HFREEX
        negateNotFree

        HFREEY
        negateNotFree

        H

        φx φy NegationFunction
        eliminateBiconditionalReverse
        applySyllogism

        ChangeVariableThereExistsNotFree

        y φy NotForAll
        swapBiconditional
        applyBiconditionalTransitivity

        swapBiconditional
        x φx NotForAll
        swapBiconditional
        applyBiconditionalTransitivity

        removeNegation

        swapBiconditional
))

thm (ChangeVariableForAll ((y φx) (x φy) (x y))
  ((H (((value x) = (value y)) → (φx ↔ φy))))
  ((∀ x φx) ↔ (∀ y φy)) (
        x φy DistinctNotFree
        y φx DistinctNotFree
        H
        ChangeVariableForAllNotFree
))
</jh>

== Substitution of variables ==
We now move to proper substitution via <code>substVariable</code>.

This section only covers the case where we substitute one variable for another, not where we substitute an object for a variable. The latter is more general and is treated in [[First-order logic with quantifiability]]. This section, on <code>substVariable</code>, is of interest mainly for theories which do not want to accept the [[Interface:Axiom of quantifiability]]. It is not yet fully developed.

=== Definition ===
Our definition of <code>substVariable</code> is somewhat complicated, mainly in order to handle the case in which y and x are not distinct.<ref>[http://us.metamath.org/mpeuni/df-sb.html df-sb] in metamath's set.mm, accessed February 22, 2010</ref>
<jh>
def ((substVariable y x φ) ((((value x) = (value y)) → φ) ∧ (∃ x (((value x) = (value y)) ∧ φ))))
</jh>

=== Proving substitution from (∀ x ((x = y) → φ)) ===
Given the definition we have adopted, our first order of business is making it a bit easier to prove a substitution formula.<ref>[http://us.metamath.org/mpeuni/sb2.html sb2] in metamath's set.mm, accessed February 22, 2010</ref>

The following lemma's consequent is half of the definition of <code>substVariable</code>:<ref>[http://us.metamath.org/mpeuni/equs4.html equs4] in metamath's set.mm, accessed February 22, 2010</ref>

<jh>
thm (equs4 () () ((∀ x (((value x) = (value y)) → φ)) → (∃ x (((value x) = (value y)) ∧ φ))) (
        (∀ x (((value x) = (value y)) → φ)) ((value x) = (value y)) ConjunctionLeftElimination

        x (((value x) = (value y)) → φ) Specialization
        import

        composeConjunction

        ((value x) = (value y)) φ ConjunctionImplication
        eliminateBiconditionalReverse
        applySyllogism
</jh>
That gives us <code>((∀ x ((x = y) → φ)) ∧ x = y) → (¬ ((x = y) → (¬ φ)))</code>. We transform the consequent to <code>(¬ (∀ x ((x = y) → (¬ φ))))</code>:
<jh>
        x (((value x) = (value y)) → (¬ φ)) Specialization
        introduceTransposition
        applySyllogism
</jh>
And then we add <code>∀x</code> to the front of that consequent:
<jh>
        x (((value x) = (value y)) → (¬ φ)) BoundForAllNotFree
        negateNotFree
        applySyllogism
</jh>
We export and add one more ∀x:
<jh>
        export
        a5i
</jh>
which gives us <code>(∀x(x = y → φ) → ∀x(x = y → ∀x ¬ ∀x(x = y → ¬ φ)))</code>.  The consequent of that is just what we need to apply ax9o:
<jh>
        x y (¬ (∀ x (((value x) = (value y)) → (¬ φ)))) ax9o
        applySyllogism
</jh>
so we have simplified the consequent to <code>¬ ∀x(x = y → ¬ φ))</code>. We merely apply <code>equs3</code> to that and we're done.
<jh>
        x (value y) φ equs3 eliminateBiconditionalForward
        applySyllogism
))
</jh>

Now we're ready for our first theorem to help us prove a substituted formula:
<jh>
thm (sb2 () () ((∀ x (((value x) = (value y)) → φ)) → (substVariable y x φ)) (
        x (((value x) = (value y)) → φ) Specialization
        x y φ equs4
        composeConjunction
))
</jh>

=== Substitution implies ∃ x (x = y ∧ φ) ===

Although being able to prove a formula involving <code>substVariable</code> is our first order of business, some of the theorems below also do the reverse. Here is a lemma to help turn <code>substVariable</code> into something else (it is just extracting half of the definition):<ref>[http://us.metamath.org/mpeuni/sb1.html sb1] in metamath's set.mm, accessed February 24, 2010</ref>
<jh>
thm (sb1 () () ((substVariable y x φ) → (∃ x (((value x) = (value y)) ∧ φ))) (
        (((value x) = (value y)) → φ) (∃ x (((value x) = (value y)) ∧ φ)) ConjunctionLeftElimination
))
</jh>

=== Substitution applied to an equality ===
This theorem is basically just equality reflexivity, except that one side has been substituted with the object on the other side.<ref>[http://us.metamath.org/mpeuni/equsb1.html equsb1] in metamath's set.mm, accessed February 22, 2010</ref>

<jh>
thm (SubstitutionEquality () () (substVariable y x ((value x) = (value y))) (
        ((value x) = (value y)) ImplicationReflexivity
        x generalize

        x y ((value x) = (value y)) sb2

        applyModusPonens
))
</jh>

=== Substitution of a theorem remains a theorem ===
If we have a theorem, we can add a variable substitution onto it.<ref>[http://us.metamath.org/mpeuni/sbt.html sbt] in metamath's set.mm, accessed February 24, 2010</ref>
<jh>
thm (introduceSubstVariable () ((H φ)) (substVariable y x φ) (
        H
        ((value x) = (value y)) introduceAntecedent
        x generalize

        x y φ sb2

        applyModusPonens
))
</jh>

=== Convert from implicit substitution ===
A statement of the form <code>x = y → (φ ↔ ψ)</code>, where <code>x</code> is not free in <code>ψ</code>, can be thought of as an ''implicit substitution'', as it can be used to relate a formula about <code>x</code> to a formula about <code>y</code>. It also provides one of the ways to construct a statement using <code>subst</code>.<ref>[http://us.metamath.org/mpeuni/sbie.html sbie] in metamath's set.mm, accessed February 24, 2010</ref>

We break up the proof into several steps:

<jh>
thm (sbie-1 () ((H (((value x) = (value y)) → (φ ↔ ψ)))) ((((value x) = (value y)) ∧ φ) → ψ) (
        H
        φ ψ BiconditionalReverseElimination
        applySyllogism
        import
))

thm (sbie-2 () ((H ((((value x) = (value y)) ∧ φ) → ψ))) ((substVariable y x φ) → (∃ x ψ)) (
        y x φ sb1

        H
        x addThereExists

        applySyllogism
))

thm (sbie-forward ()
  ((HFREE (x is-not-free-in ψ))
   (HEQ (((value x) = (value y)) → (φ ↔ ψ)))
  )
  ((substVariable y x φ) → ψ) (
        HEQ
        sbie-1
        sbie-2

        HFREE
        ThereExistsAddRemoveNotFree
        eliminateBiconditionalReverse
        applySyllogism
))

thm (sbie-reverse ()
  ((HFREE (x is-not-free-in ψ))
   (HEQ (((value x) = (value y)) → (φ ↔ ψ)))
  )
  (ψ → (substVariable y x φ)) (
</jh>
The first line we'll use at the very end.
<jh>
        HFREE

        HEQ
        φ ψ BiconditionalForwardElimination
        applySyllogism

        applyComm
</jh>
We now have <code>ψ → (x = y → φ)</code>.  The consequent of that is almost <code>∀ x (x = y → φ)</code>, which is what we'll need for <code>sb2</code>.
<jh>

        x addForAll

        x y φ sb2
        applySyllogism
</jh>
That gives us <code>∀ x ψ → substVariable y x φ</code>; we just need to remove the initial quantifier.
<jh>

        applySyllogism
))

thm (sbie () 
  ((HFREE (x is-not-free-in ψ))
   (HEQ (((value x) = (value y)) → (φ ↔ ψ)))
  )
  ((substVariable y x φ) ↔ ψ) (
        HFREE HEQ sbie-forward
        HFREE HEQ sbie-reverse
        introduceBiconditionalFromImplications
))

thm (makeSubstVariableExplicit ((x ψ))
  ((H (((value x) = (value y)) → (φ ↔ ψ))))
  ((substVariable y x φ) ↔ ψ) (
        x ψ DistinctNotFree
        H
        sbie
))
</jh>

=== sbequ12 ===
Another relationship between <code>substVariable</code> and equality is <code>x = y → (φ ↔ [y / x]φ)</code>.<ref>[http://us.metamath.org/mpeuni/sbequ12.html sbequ12] in metamath's set.mm, accessed February 26, 2010</ref>  We prove each direction of the biconditional separately.
<jh>
thm (sbequ1 () () (((value x) = (value y)) → (φ → (substVariable y x φ))) (
</jh>
The proof is going to show that <code>x = y ∧ φ</code> implies <code>(substVariable y x φ)</code>. We show this for the two halves of the definition of <code>substVariable</code>. The first half of the <code>subst</code> definition is <code>x = y → φ</code>:
<jh>
        ((value x) = (value y)) φ ConjunctionLeftElimination
        φ ((value x) = (value y)) AntecedentIntroduction
        applySyllogism
</jh>
The other half is <code>∃ x (x = y ∧ φ)</code>:
<jh>
        (((value x) = (value y)) ∧ φ) x ThereExistsIntroduction
</jh>
Now we combine the two:
<jh>
        composeConjunction
        export
))
</jh>

The other direction is also simple:
<jh>
thm (sbequ2 () () (((value x) = (value y)) → ((substVariable y x φ) → φ)) (
        (((value x) = (value y)) → φ) (∃ x (((value x) = (value y)) ∧ φ)) ConjunctionRightElimination
        applyComm
))
</jh>

We now combine the two to get <code>sbequ12</code>:
<jh>
thm (sbequ12 () () (((value x) = (value y)) → (φ ↔ (substVariable y x φ))) (
        x y φ sbequ1
        x y φ sbequ2
        composeConjunction

        φ (substVariable y x φ) BiconditionalImplication eliminateBiconditionalForward
        applySyllogism
))
</jh>

=== Implication builder ===
Analogous to our other implication builders, this theorem takes an implication and lets us add <code>substVariable</code> to both sides.<ref>[http://us.metamath.org/mpeuni/sbimi.html sbimi] in metamath's set.mm, accessed February 24, 2010</ref>
<jh>
thm (addSubstVariable  () ((H (φ → ψ))) ((substVariable y x φ) → (substVariable y x ψ)) (
</jh>
The left half of the conjunction defining <code>substVariable</code> is <code>x = y → φ</code>.  So we first show that the one for <code>φ</code> implies the one for <code>ψ</code>:
<jh>
        H ((value x) = (value y)) addCommonAntecedent
</jh>
The right half of the conjunction defining <code>substVariable</code> is <code>∃ x (x = y ∧ φ)</code>.  Showing the relevant implication is only slightly more difficult:
<jh>
        H ((value x) = (value y)) conjoinLL
        x addThereExists
</jh>
We now combine the two halves:
<jh>
        conjoin
))
</jh>

=== Biconditional builder ===
The builder for the biconditional is very similar to the implication builder.  It could be proved much the way we proved the implication builder, but we derive it from the implication builder.<ref>[http://us.metamath.org/mpeuni/sbbii.html sbbii] in metamath's set.mm, accessed February 24, 2010</ref>

<jh>
thm (buildSubstVariable () ((H (φ ↔ ψ))) ((substVariable y x φ) ↔ (substVariable y x ψ)) (
        H eliminateBiconditionalReverse
        y x addSubstVariable 
        H eliminateBiconditionalForward
        y x addSubstVariable 
        introduceBiconditionalFromImplications
))
</jh>

== More builders ==
These builders are similar in spirit to the convenience builders of propositional logic, although they are (slightly) harder to derive.

First, a biconditionalized version of <code>ForAllImplicationThereExists</code>.<ref>[http://us.metamath.org/mpeuni/19.18.html 19.18] in metamath's set.mm, accessed June 12, 2010</ref>
<jh>
thm (ForAllBiconditionalThereExists () ()
  ((∀ x (φ ↔ ψ)) → ((∃ x φ) ↔ (∃ x ψ))) (
        φ ψ BiconditionalReverseElimination x addForAll
        x φ ψ ForAllImplicationThereExists applySyllogism

        φ ψ BiconditionalForwardElimination x addForAll
        x ψ φ ForAllImplicationThereExists applySyllogism

        composeConjunction
        (∃ x φ) (∃ x ψ) BiconditionalImplication
        eliminateBiconditionalForward applySyllogism
))
</jh>

Now, builders.

<jh>
thm (buildThereExistsInConsequent ((x φ)) 
  ((H (φ → (ψ ↔ χ))))
  (φ → ((∃ x ψ) ↔ (∃ x χ))) (
        H
        x addForAllToConsequent

        x ψ χ ForAllBiconditionalThereExists
        applySyllogism
))

thm (buildForAllInConsequent ((x φ))
  ((H (φ → (ψ ↔ χ))))
  (φ → ((∀ x ψ) ↔ (∀ x χ))) (
        H
        x addForAllToConsequent

        x ψ χ ForAllBiconditional
        applySyllogism
))
</jh>

== Export ==
We've now proved all the theorems in [[Interface:First-order logic]], so we export them.
<jh>
export (FIRSTORDER Interface:First-order_logic (CLASSICAL) ())
</jh>

== References ==
<references/>

[[Category:Classical first-order logic]]