{{header
 | title    = First-order logic
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = The purpose of this page is to prove the statements of [[Interface:First-order logic]] from [[Interface:Axioms of first-order logic]].

{{under construction}}
}}
{{interfaces
| imports = [[Interface:Axioms of first-order logic]]
| exports = eventually [[Interface:First-order logic]]
}}

Many of the proofs on this page are adapted from metamath's set.mm, and theorems may be named after set.mm.  However, since set.mm names do change over time, do not count on this correspondence to be exact.

We start with the [[Interface:Classical propositional calculus|theorems of propositional logic]] and [[Interface:Axioms of first-order logic]]:

<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (PRINCIPIA Interface:Axioms_of_first-order_logic (CLASSICAL) ())
</jh>

As usual, φ, ψ, χ, and θ are formulas and x, y, and z are objects:

<jh>
var (formula φ ψ χ θ)
var (object x y z)
</jh>

== ForAllImplication ==

The ∀ quantifier can be distributed across an implication. This is one of our axioms, so we just provide an additional name and a rule:

<jh>
thm (ForAllImplication () () ((∀ x (φ → ψ)) → ((∀ x φ) → (∀ x ψ))) (
        x φ ψ QuantifiedImplication
))

thm (distributeForAllImplication () ((H (∀ x (φ → ψ)))) ((∀ x φ) → (∀ x ψ)) (
        H
        x φ ψ QuantifiedImplication
        applyModusPonens
))
</jh>

== Equality is reflexive and symmetric ==
The basic facts about equality are that it is reflexive, symmetric and transitive. Instead of supposing these as axioms, we have a single axiom which implies them (when combined with some of the other axioms).

We start with reflexivity.  The first two theorems are intermediate steps:

<jh>
thm (EqualityReflexivity-1 () () ((x = y) → (y = y)) (
        (x = y) ConjunctionIdempotence eliminateBiconditionalReverse

        x y y AxiomEquality
        import

        applySyllogism
))

thm (EqualityReflexivity-2 () () ((∀ x (¬ (y = y))) → (∀ x (¬ (x = y)))) (
        x y EqualityReflexivity-1
        introduceTransposition
        x generalize

        x (¬ (y = y)) (¬ (x = y)) QuantifiedImplication
        applyModusPonens
))
</jh>

The proof of reflexivity involves adding an extra variable <code>x</code>. We need to specify that this variable is distinct from y, but this doesn't affect the generality of the result. The variable <code>x</code> only appears in the proof, not in the theorem, and so the distinct variable constraint only needs to appear here, not in the statement of the theorem in [[Interface:First-order logic]].
<jh>
thm (EqualityReflexivity ((x y)) () (y = y) (
        x y Existence

        (¬ (y = y)) x Generalization
        x y EqualityReflexivity-2
        applySyllogism

        applyModusTollens
        eliminateDoubleNegation
))
</jh>

The proof of symmetry follows much more easily from reflexivity and the equality axiom. Most of what we need to do is just propositional logic.
<jh>
thm (applyNestedModusPonens () 
  ((H1 ψ) (H2 (φ → (ψ → χ))))
  (φ → χ) (
        H1

        H2
        import

        ψ φ ConjunctionCommutativity eliminateBiconditionalReverse
        χ addCommonConsequent
        applyModusPonens

        export
        applyModusPonens
))

thm (EqualitySymmetryImplication () () ((x = y) → (y = x)) (
        x EqualityReflexivity
        x y x AxiomEquality
        applyNestedModusPonens
))

thm (EqualitySymmetry () () ((x = y) ↔ (y = x)) (
        x y EqualitySymmetryImplication
        y x EqualitySymmetryImplication
        introduceBiconditionalFromImplications
))
</jh>

== Specification ==
We can remove a universal quantifier. This is sometimes taken as an axiom but here we prove it from the other axioms via a number of intermediate steps.<ref>[http://us.metamath.org/mpeuni/ax4.html ax4] in metamath's set.mm, accessed February 18, 2010</ref>

<jh>
thm (Specialization-18 ((y φ)) () ((y = x) → ((¬ φ) → (∀ x ((x = y) → (¬ φ))))) (
        y x EqualitySymmetry eliminateBiconditionalReverse
        x y (¬ φ) VariableSubstitution
        applySyllogism

        (¬ φ) y Generalization
        (∀ x ((x = y) → (¬ φ))) addCommonConsequent
        applySyllogism
))

thm (Specialization-22 () () ((∀ x ((x = y) → (¬ φ))) → (∀ x (φ → (¬ (x = y))))) (
        (x = y) φ TranspositionWithNegatedConsequent
        eliminateBiconditionalReverse

        x generalize

        distributeForAllImplication
))

thm (Specialization-a () () ((∀ x (φ → (¬ (x = y)))) → (¬ (∀ x φ))) (
        x φ (¬ (x = y)) ForAllImplication

        x y Existence
        (∀ x φ) (∀ x (¬ (x = y))) Transposition eliminateBiconditionalReverse
        applyNestedModusPonens

        applySyllogism
))

thm (Specialization-30 ((y φ)) () ((¬ ((∀ x φ) → φ)) → (¬ (y = x))) (
        y x φ Specialization-18
        import

        x y φ Specialization-22
        applySyllogism

        x φ y Specialization-a
        applySyllogism
        export

        (∀ x φ) φ Transposition eliminateBiconditionalForward
        applySyllogism

        introduceTransposition
))

thm (Specialization-33 ((y φ)) () 
  ((∀ y (¬ ((∀ x φ) → φ))) → (∀ y (¬ (y = x)))) (
        x φ y Specialization-30
        y generalize
        distributeForAllImplication
))
</jh>

As before, the distinct variable constraints don't get exported, as they all contain <code>y</code>.
<jh>
thm (Specialization ((x y) (y φ)) () ((∀ x φ) → φ) (
        y x Existence

        (¬ ((∀ x φ) → φ)) y Generalization
        y x φ Specialization-33
        applySyllogism

        applyModusTollens

        eliminateDoubleNegation
))
</jh>

== Doubling ∀ ==

If we have a universal quantifier, it doesn't change anything to apply it twice.  That is, <code>(∀ x φ) → (∀ x (∀ x φ))</code>

<jh>
thm (ForAllDoubling-negation-lemma () () 
  ((∀ x (¬ (∀ x (¬ (∀ x φ))))) → (∀ x (∀ x φ))) (
        x φ QuantifiedNegation
        transposeWithNegatedAntecedent

        x generalize

        distributeForAllImplication
))

thm (ForAllDoubling () () ((∀ x φ) → (∀ x (∀ x φ))) (
        x (¬ (∀ x φ)) Specialization
        transposeWithNegatedConsequent

        x (¬ (∀ x φ)) QuantifiedNegation
        applySyllogism

        x φ ForAllDoubling-negation-lemma
        applySyllogism
))
</jh>

== Builder for ∀ ==
From <code>φ → ψ</code> we want to be able to get <code>(∀ x φ) → (∀ x ψ)</code>.  The easier part of this is geting the quantifier onto the antecedent:<ref>[http://us.metamath.org/mpeuni/a4s.html a4s] in metamath's set.mm, accessed February 18, 2010</ref>

<jh>
thm (a4s () ((H (φ → ψ))) ((∀ x φ) → ψ) (
        x φ Specialization
        H
        applySyllogism
))
</jh>

We get the quantifier onto the consequent via this lemma:
<jh>

thm (ax5o () () ((∀ x ((∀ x φ) → ψ)) → ((∀ x φ) → (∀ x ψ))) (
        x (∀ x φ) ψ QuantifiedImplication

        x φ ForAllDoubling
        (∀ x ψ) addCommonConsequent

        applySyllogism
))
</jh>

Then our builder for implication is:<ref>[http://us.metamath.org/mpeuni/19.20i.html 19.20i] in metamath's set.mm, accessed February 18, 2010</ref>
<jh>
thm (addForAll () ((H (φ → ψ))) ((∀ x φ) → (∀ x ψ)) (
        H x a4s

        x generalize
        x φ ψ ax5o

        applyModusPonens
))
</jh>

The builder for the biconditional follows trivially:
<jh>
thm (buildForAll () ((H (φ ↔ ψ))) ((∀ x φ) ↔ (∀ x ψ)) (
        H eliminateBiconditionalReverse x addForAll
        H eliminateBiconditionalForward x addForAll
        introduceBiconditionalFromImplications
))
</jh>

== Existential quantification ==
The axioms are written in terms of just the universal quantifier ∀. We define the existential quantifier ∃ in terms of it:

<jh>
def ((∃ x φ) (¬ (∀ x (¬ φ))))
</jh>

and the following two theorems are immediate consequences from this definition:

<jh>
thm (NotThereExists () () ((¬ (∃ x φ)) ↔ (∀ x (¬ φ))) (
        (∃ x φ) BiconditionalReflexivity
        addNegation

        (∀ x (¬ φ)) DoubleNegation swapBiconditional
        applyBiconditionalTransitivity
))

thm (NotForAll () () ((¬ (∀ x φ)) ↔ (∃ x (¬ φ))) (
        φ DoubleNegation
        x buildForAll
        addNegation
))
</jh>

=== Builders ===

The builders for ∃ follow from the builders for ∀:
<jh>
thm (addThereExists () ((H (φ → ψ))) ((∃ x φ) → (∃ x ψ)) (
        H
        introduceTransposition
        x addForAll
        introduceTransposition
))

thm (buildThereExists () ((H (φ ↔ ψ))) ((∃ x φ) ↔ (∃ x ψ)) (
        H
        addNegation
        x buildForAll
        addNegation
))
</jh>

== Quantifier order ==
Being able to swap the order of two ∀ quantifiers is an axiom, so we just need to biconditionalize it:

<jh>
thm (ForAllCommutation () () ((∀ x (∀ y φ)) ↔ (∀ y (∀ x φ))) (
        x y φ QuantifierCommutation
        y x φ QuantifierCommutation
        introduceBiconditionalFromImplications
))
</jh>

The corresponding theorem for ∃ follows from it.  It may be easier to follow the proof below if you remember that 
 <code>(∃ x (∃ y φ))</code>
is equivalent to 
 <code>(¬ (∀ x (¬ (¬ (∀ y (¬ φ))))))</code>

<jh>
thm (ThereExistsCommutation () () ((∃ x (∃ y φ)) ↔ (∃ y (∃ x φ))) (
        (∀ y (¬ φ)) DoubleNegation swapBiconditional
        x buildForAll

        x y (¬ φ) ForAllCommutation
        applyBiconditionalTransitivity

        (∀ x (¬ φ)) DoubleNegation
        y buildForAll
        applyBiconditionalTransitivity

        addNegation
))
</jh>

== Combining quantified statements ==

=== For-all across a Conjunction ===
The ability to combine or split ∀ across a conjunction follows from <code>ForAllImplication</code> and some propositional logic.<ref>[http://us.metamath.org/mpeuni/19.26.html 19.26] in metamath's set.mm, accessed February 19, 2010</ref> We prove the forward and reverse implications separately.

<jh>
thm (ForAllConjunctionSplitting () () ((∀ x (φ ∧ ψ)) → ((∀ x φ) ∧ (∀ x ψ))) (
        φ ψ ConjunctionRightElimination
        x generalize
        distributeForAllImplication

        φ ψ ConjunctionLeftElimination
        x generalize
        distributeForAllImplication

        composeConjunction
))

thm (ForAllConjunctionCombining () () (((∀ x φ) ∧ (∀ x ψ)) → (∀ x (φ ∧ ψ))) (
        φ ψ ConjunctionRightIntroduction
        x generalize
        distributeForAllImplication

        x ψ (φ ∧ ψ) ForAllImplication
        applySyllogism

        import
))

thm (ForAllConjunction () () ((∀ x (φ ∧ ψ)) ↔ ((∀ x φ) ∧ (∀ x ψ))) (
        x φ ψ ForAllConjunctionSplitting
        x φ ψ ForAllConjunctionCombining
        introduceBiconditionalFromImplications
))
</jh>

== Export ==
This page is not yet done.  When it is, the following export to [[Interface:First-order logic]] can be uncommented:
<jh>
#export (FIRSTORDER Interface:First-order_logic (CLASSICAL) ())
</jh>

== References ==
<references/>

[[Category:Classical first-order logic]]