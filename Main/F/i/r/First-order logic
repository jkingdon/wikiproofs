{{header
 | title    = First-order logic
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = The purpose of this page is to prove the statements of [[Interface:First-order logic]] from [[Interface:Axioms of first-order logic]].

{{under construction}}
}}
{{interfaces
| imports = [[Interface:Axioms of first-order logic]]
| exports = [[Interface:First-order logic]]
}}

Many of the proofs on this page are adapted from metamath's set.mm, and theorems may be named after set.mm.  However, since set.mm names do change over time, do not count on this correspondence to be exact.

We start with the [[Interface:Classical propositional calculus|theorems of propositional logic]] and [[Interface:Axioms of first-order logic]]:

<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (AXIOMS Interface:Axioms_of_first-order_logic (CLASSICAL) ())
</jh>

As usual, φ, ψ, χ, and θ are formulas and x, y, and z are objects:

<jh>
var (formula φ ψ χ θ)
var (object x y z)
</jh>

== ForAllImplication ==

The ∀ quantifier can be distributed across an implication. This is one of our axioms, so we just provide an additional name and a rule:

<jh>
thm (ForAllImplication () () ((∀ x (φ → ψ)) → ((∀ x φ) → (∀ x ψ))) (
        x φ ψ QuantifiedImplication
))

thm (distributeForAllImplication () ((H (∀ x (φ → ψ)))) ((∀ x φ) → (∀ x ψ)) (
        H
        x φ ψ QuantifiedImplication
        applyModusPonens
))
</jh>

== Equality is reflexive, symmetric, and transitive ==
The basic facts about equality are that it is reflexive, symmetric and transitive. Instead of supposing these as axioms, we have a single axiom which implies them (when combined with some of the other axioms).

We start with reflexivity.  The first two theorems are intermediate steps:

<jh>
thm (EqualityReflexivity-1 () () ((x = y) → (y = y)) (
        (x = y) ConjunctionIdempotence eliminateBiconditionalReverse

        x y y AxiomEquality
        import

        applySyllogism
))

thm (EqualityReflexivity-2 () () ((∀ x (¬ (y = y))) → (∀ x (¬ (x = y)))) (
        x y EqualityReflexivity-1
        introduceTransposition
        x generalize

        x (¬ (y = y)) (¬ (x = y)) QuantifiedImplication
        applyModusPonens
))
</jh>

The proof of reflexivity involves adding an extra variable <code>x</code>. We need to specify that this variable is distinct from y, but this doesn't affect the generality of the result. The variable <code>x</code> only appears in the proof, not in the theorem, and so the distinct variable constraint only needs to appear here, not in the statement of the theorem in [[Interface:First-order logic]].
<jh>
thm (EqualityReflexivity ((x y)) () (y = y) (
        x y Existence

        (¬ (y = y)) x Generalization
        x y EqualityReflexivity-2
        applySyllogism

        applyModusTollens
        eliminateDoubleNegation
))
</jh>

The proof of symmetry follows much more easily from reflexivity and the equality axiom. Most of what we need to do is just propositional logic.
<jh>
thm (applyNestedModusPonens () 
  ((H1 ψ) (H2 (φ → (ψ → χ))))
  (φ → χ) (
        H1

        H2
        import

        ψ φ ConjunctionCommutativity eliminateBiconditionalReverse
        χ addCommonConsequent
        applyModusPonens

        export
        applyModusPonens
))

thm (EqualitySymmetryImplication () () ((x = y) → (y = x)) (
        x EqualityReflexivity
        x y x AxiomEquality
        applyNestedModusPonens
))

thm (EqualitySymmetry () () ((x = y) ↔ (y = x)) (
        x y EqualitySymmetryImplication
        y x EqualitySymmetryImplication
        introduceBiconditionalFromImplications
))
</jh>

Transitivity is now just a rearangement of our equality axiom:
<jh>
thm (EqualityTransitivity () () (((x = y) ∧ (y = z)) → (x = z)) (
        x y EqualitySymmetryImplication
        y x z AxiomEquality
        applySyllogism
        import
))
</jh>

== Specialization ==
We can remove a universal quantifier. This is sometimes taken as an axiom but here we prove it from the other axioms via a number of intermediate steps.<ref>[http://us.metamath.org/mpeuni/ax4.html ax4] in metamath's set.mm, accessed February 18, 2010</ref>

<jh>
thm (Specialization-18 ((y φ)) () ((y = x) → ((¬ φ) → (∀ x ((x = y) → (¬ φ))))) (
        y x EqualitySymmetry eliminateBiconditionalReverse
        x y (¬ φ) VariableSubstitution
        applySyllogism

        (¬ φ) y Generalization
        (∀ x ((x = y) → (¬ φ))) addCommonConsequent
        applySyllogism
))

thm (Specialization-22 () () ((∀ x ((x = y) → (¬ φ))) → (∀ x (φ → (¬ (x = y))))) (
        (x = y) φ TranspositionWithNegatedConsequent
        eliminateBiconditionalReverse

        x generalize

        distributeForAllImplication
))

thm (Specialization-a () () ((∀ x (φ → (¬ (x = y)))) → (¬ (∀ x φ))) (
        x φ (¬ (x = y)) ForAllImplication

        x y Existence
        (∀ x φ) (∀ x (¬ (x = y))) Transposition eliminateBiconditionalReverse
        applyNestedModusPonens

        applySyllogism
))

thm (Specialization-30 ((y φ)) () ((¬ ((∀ x φ) → φ)) → (¬ (y = x))) (
        y x φ Specialization-18
        import

        x y φ Specialization-22
        applySyllogism

        x φ y Specialization-a
        applySyllogism
        export

        (∀ x φ) φ Transposition eliminateBiconditionalForward
        applySyllogism

        introduceTransposition
))

thm (Specialization-33 ((y φ)) () 
  ((∀ y (¬ ((∀ x φ) → φ))) → (∀ y (¬ (y = x)))) (
        x φ y Specialization-30
        y generalize
        distributeForAllImplication
))
</jh>

As before, the distinct variable constraints don't get exported, as they all contain <code>y</code>.
<jh>
thm (Specialization ((x y) (y φ)) () ((∀ x φ) → φ) (
        y x Existence

        (¬ ((∀ x φ) → φ)) y Generalization
        y x φ Specialization-33
        applySyllogism

        applyModusTollens

        eliminateDoubleNegation
))
</jh>

== Doubling ∀ ==

If we have a universal quantifier, it doesn't change anything to apply it twice.  That is, <code>(∀ x φ) → (∀ x (∀ x φ))</code>

<jh>
thm (ForAllDoubling-negation-lemma () () 
  ((∀ x (¬ (∀ x (¬ (∀ x φ))))) → (∀ x (∀ x φ))) (
        x φ QuantifiedNegation
        transposeWithNegatedAntecedent

        x generalize

        distributeForAllImplication
))

thm (ForAllDoubling () () ((∀ x φ) → (∀ x (∀ x φ))) (
        x (¬ (∀ x φ)) Specialization
        transposeWithNegatedConsequent

        x (¬ (∀ x φ)) QuantifiedNegation
        applySyllogism

        x φ ForAllDoubling-negation-lemma
        applySyllogism
))
</jh>

== Builder for ∀ ==
From <code>φ → ψ</code> we want to be able to get <code>(∀ x φ) → (∀ x ψ)</code>.  The easier part of this is geting the quantifier onto the antecedent:<ref>[http://us.metamath.org/mpeuni/a4s.html a4s] in metamath's set.mm, accessed February 18, 2010</ref>

<jh>
thm (a4s () ((H (φ → ψ))) ((∀ x φ) → ψ) (
        x φ Specialization
        H
        applySyllogism
))
</jh>

We get the quantifier onto the consequent via this lemma:
<jh>

thm (ax5o () () ((∀ x ((∀ x φ) → ψ)) → ((∀ x φ) → (∀ x ψ))) (
        x (∀ x φ) ψ QuantifiedImplication

        x φ ForAllDoubling
        (∀ x ψ) addCommonConsequent

        applySyllogism
))
</jh>

Then our builder for implication is:<ref>[http://us.metamath.org/mpeuni/19.20i.html 19.20i] in metamath's set.mm, accessed February 18, 2010</ref>
<jh>
thm (addForAll () ((H (φ → ψ))) ((∀ x φ) → (∀ x ψ)) (
        H x a4s

        x generalize
        x φ ψ ax5o

        applyModusPonens
))
</jh>

The builder for the biconditional follows trivially:
<jh>
thm (buildForAll () ((H (φ ↔ ψ))) ((∀ x φ) ↔ (∀ x ψ)) (
        H eliminateBiconditionalReverse x addForAll
        H eliminateBiconditionalForward x addForAll
        introduceBiconditionalFromImplications
))
</jh>

== Existential quantification ==
The axioms are written in terms of just the universal quantifier ∀. We define the existential quantifier ∃ in terms of it:

<jh>
def ((∃ x φ) (¬ (∀ x (¬ φ))))
</jh>

and the following two theorems are immediate consequences from this definition:

<jh>
thm (NotThereExists () () ((¬ (∃ x φ)) ↔ (∀ x (¬ φ))) (
        (∃ x φ) BiconditionalReflexivity
        addNegation

        (∀ x (¬ φ)) DoubleNegation swapBiconditional
        applyBiconditionalTransitivity
))

thm (NotForAll () () ((¬ (∀ x φ)) ↔ (∃ x (¬ φ))) (
        φ DoubleNegation
        x buildForAll
        addNegation
))
</jh>

=== Builders ===

The builders for ∃ follow from the builders for ∀:
<jh>
thm (addThereExists () ((H (φ → ψ))) ((∃ x φ) → (∃ x ψ)) (
        H
        introduceTransposition
        x addForAll
        introduceTransposition
))

thm (buildThereExists () ((H (φ ↔ ψ))) ((∃ x φ) ↔ (∃ x ψ)) (
        H
        addNegation
        x buildForAll
        addNegation
))
</jh>

=== Adding existential quantifier ===
We can add ∃ to the start of a formula:<ref>[http://us.metamath.org/mpeuni/19.8a.html 19.8a] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (19.8a () () (φ → (∃ x φ)) (
        x (¬ φ) Specialization
        transposeWithNegatedConsequent
))
</jh>

== Quantifier order ==
Being able to swap the order of two ∀ quantifiers is an axiom, so we just need to biconditionalize it:

<jh>
thm (ForAllCommutation () () ((∀ x (∀ y φ)) ↔ (∀ y (∀ x φ))) (
        x y φ QuantifierCommutation
        y x φ QuantifierCommutation
        introduceBiconditionalFromImplications
))
</jh>

The corresponding theorem for ∃ follows from it.  It may be easier to follow the proof below if you remember that 
 <code>(∃ x (∃ y φ))</code>
is equivalent to 
 <code>(¬ (∀ x (¬ (¬ (∀ y (¬ φ))))))</code>

<jh>
thm (ThereExistsCommutation () () ((∃ x (∃ y φ)) ↔ (∃ y (∃ x φ))) (
        (∀ y (¬ φ)) DoubleNegation swapBiconditional
        x buildForAll

        x y (¬ φ) ForAllCommutation
        applyBiconditionalTransitivity

        (∀ x (¬ φ)) DoubleNegation
        y buildForAll
        applyBiconditionalTransitivity

        addNegation
))
</jh>

== Combining quantified statements ==

=== For-all across a Conjunction ===
The ability to combine or split ∀ across a conjunction follows from <code>ForAllImplication</code> and some propositional logic.<ref>[http://us.metamath.org/mpeuni/19.26.html 19.26] in metamath's set.mm, accessed February 19, 2010</ref> We prove the forward and reverse implications separately.

<jh>
thm (ForAllConjunctionSplitting () () ((∀ x (φ ∧ ψ)) → ((∀ x φ) ∧ (∀ x ψ))) (
        φ ψ ConjunctionRightElimination
        x generalize
        distributeForAllImplication

        φ ψ ConjunctionLeftElimination
        x generalize
        distributeForAllImplication

        composeConjunction
))

thm (distributeForAllConjunction () ((H (∀ x (φ ∧ ψ)))) ((∀ x φ) ∧ (∀ x ψ)) (
        H
        x φ ψ ForAllConjunctionSplitting
        applyModusPonens
))

thm (ForAllConjunctionCombining () () (((∀ x φ) ∧ (∀ x ψ)) → (∀ x (φ ∧ ψ))) (
        φ ψ ConjunctionRightIntroduction
        x generalize
        distributeForAllImplication

        x ψ (φ ∧ ψ) ForAllImplication
        applySyllogism

        import
))

thm (collectForAllConjunction () ((HLEFT (∀ x φ)) (HRIGHT (∀ x ψ))) (∀ x (φ ∧ ψ)) (
        HLEFT
        HRIGHT
        introduceConjunction

        x φ ψ ForAllConjunctionCombining

        applyModusPonens
))

thm (ForAllConjunction () () ((∀ x (φ ∧ ψ)) ↔ ((∀ x φ) ∧ (∀ x ψ))) (
        x φ ψ ForAllConjunctionSplitting
        x φ ψ ForAllConjunctionCombining
        introduceBiconditionalFromImplications
))
</jh>

=== There-exists across a disjunction ===

This one follows from <code>ForAllConjunction</code> via DeMorgan's law and a little bit of negation rearranging.
<jh>
thm (ThereExistsDisjunction () () ((∃ x (φ ∨ ψ)) ↔ ((∃ x φ) ∨ (∃ x ψ))) (
        φ ψ DeMorganPDP
        x buildForAll

        x (¬ φ) (¬ ψ) ForAllConjunction
        applyBiconditionalTransitivity

        (∀ x (¬ φ)) (∀ x (¬ ψ)) DeMorganNDN swapBiconditional
        applyBiconditionalTransitivity

        addNegation

        ((∃ x φ) ∨ (∃ x ψ)) DoubleNegation swapBiconditional
        applyBiconditionalTransitivity
))

thm (distributeThereExistsDisjunction () ((H (∃ x (φ ∨ ψ))))  ((∃ x φ) ∨ (∃ x ψ)) (
        H
        x φ ψ ThereExistsDisjunction eliminateBiconditionalReverse
        applyModusPonens
))

thm (collectThereExistsDisjunction () ((H ((∃ x φ) ∨ (∃ x ψ)))) (∃ x (φ ∨ ψ)) (
        H
        x φ ψ ThereExistsDisjunction eliminateBiconditionalForward
        applyModusPonens
))

</jh>

== There-exists across an implication ==

This is another proof which mostly consists of the definition of ∃ and propositional calculus.

<jh>
thm (ThereExistsImplication () () ((∃ x (φ → ψ)) ↔ ((∀ x φ) → (∃ x ψ))) (
        φ ψ ImplicationDisjunction
        addNegation
        φ ψ DeMorganNDP
        applyBiconditionalTransitivity
</jh>
So far, we have transformed <code>¬ (φ → ψ)</code> into <code>φ ∧ (¬ ψ)</code> which is now ripe for applying <code>ForAllConjunction</code> 
<jh>
        x buildForAll

        x φ (¬ ψ) ForAllConjunction
        applyBiconditionalTransitivity

        addNegation
</jh>
We're almost there.  The left hand side has been gradually built up into <code>(∃ x (φ → ψ))</code>. The right hand side is <code>(¬ ((∀ x φ) ∧ (∀ x (¬ ψ))))</code>, which just needs DeMorgan's law and transformation from disjunction to implication to become <code>((∀ x φ) → (∃ x ψ))</code>
<jh>
        (∀ x φ) (∀ x (¬ ψ)) DeMorganPCP
        applyBiconditionalTransitivity

        (∀ x φ) (¬ (∀ x (¬ ψ))) ImplicationDisjunction swapBiconditional
        applyBiconditionalTransitivity
))

thm (distributeThereExistsImplication () ((H (∃ x (φ → ψ)))) ((∀ x φ) → (∃ x ψ)) (
        H
        x φ ψ ThereExistsImplication eliminateBiconditionalReverse
        applyModusPonens
))

thm (collectThereExistsImplication () ((H ((∀ x φ) → (∃ x ψ)))) (∃ x (φ → ψ)) (
        H
        x φ ψ ThereExistsImplication eliminateBiconditionalForward
        applyModusPonens
))
</jh>

== Negation ==
This relationship between quantification and negation is sometimes taken as an axiom instead of our <code>QuantifiedNegation</code>, but we prove it here:<ref>[http://us.metamath.org/mpeuni/ax6o.html ax6o] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (ax6o () () ((¬ (∀ x (¬ (∀ x φ)))) → φ) (
        x φ QuantifiedNegation
        transposeWithNegatedAntecedent

        x φ Specialization

        applySyllogism
))
</jh>

== Free variables ==
The conventional treatment of [[w:free variable|free variables]] is syntactic; variables are defined as free depending on where they occur in a formula relative to the quantifiers over that variable. JHilbert (following metamath before it) does not contain the ability to analyze formulas this way, and we instead define free variables based on whether generalization is possible:

<jh>
def ((is-not-free-in x φ) (φ → (∀ x φ)))
</jh>

This differs slightly from the syntactic definition of free variables, and so might better be termed ''effectively free'' than simply ''free''. For example, this definition does not consider <code>x</code> to be free in <code>x = x</code>.<ref>[http://us.metamath.org/mpeuni/mmset.html#traditional Appendix 2: Traditional Textbook Axioms of Predicate Calculus with Equality], Metamath Proof Explorer, accessed February 20, 2010.</ref> In fact, this relationship is true of any theorem:<ref>[http://us.metamath.org/mpeuni/hbth.html hbth] in metamath's set.mm, accessed February 20, 2010.</ref>
<jh>
thm (TheoremNotFree () ((H φ)) (x is-not-free-in φ) (
        H
        x generalize
        φ introduceAntecedent
))
</jh>

Our next two results just restate axioms or theorems we already have. The first one can be thought of as saying that a variable is not free in an expression in which it does not occur:

<jh>
thm (DistinctNotFree ((x φ)) () (x is-not-free-in φ) (
        φ x Generalization
))
</jh>

And the second states that a universal quantifier makes the variable not free (that is, the variable is ''bound'' by a quantifier):<ref>[http://us.metamath.org/mpeuni/hba1.html hba1] in metamath's set.mm, accessed February 20, 2010. In case your font doesn't make it clear, this is hba followed by the number 1.</ref>
<jh>
thm (BoundForAllNotFree () () (x is-not-free-in (∀ x φ)) (
        x φ ForAllDoubling
))
</jh>

There's another result for universal quantifiers, this one about adding a quantifier for a (possibly) different variable:<ref>[http://us.metamath.org/mpeuni/hbal.html hbal] in metamath's set.mm, accessed February 20, 2010.  In case your font doesn't make it clear, this is hba followed by the lowercase letter l.</ref>
<jh>
thm (addForAllNotFree () ((H (x is-not-free-in φ))) (x is-not-free-in (∀ y φ)) (
        H
        y addForAll

        y x φ ForAllCommutation eliminateBiconditionalReverse
        applySyllogism
))
</jh>

Next, if a variable is not free in <code>φ</code>, it is not free in <code>(¬ φ)</code>. We first prove an implication version:<ref>[http://us.metamath.org/mpeuni/hbnt.html hbnt] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (NegationNotFree () () ((∀ x (x is-not-free-in φ)) → (x is-not-free-in (¬ φ))) (
        φ (∀ x φ) Transposition eliminateBiconditionalReverse
        x generalize
        distributeForAllImplication

        x (¬ (∀ x φ)) (¬ φ) ForAllImplication
        applySyllogism

</jh>
At this point we have <code>(∀x(φ → ∀xφ) → (∀x ¬ ∀xφ → ∀x ¬ φ))</code>. Together with <code>(¬ φ → ∀x ¬ ∀xφ)</code> (which is the transposition of <code>ax6o</code>), we will get our desired result of <code>(∀x(φ → ∀xφ) → (¬ φ → ∀x ¬ φ))</code>.
<jh>
        x φ ax6o
        transposeWithNegatedAntecedent

        (∀ x (¬ φ)) addCommonConsequent

        applySyllogism
))
</jh>

The rule form does not need the extra quantifier:<ref>[http://us.metamath.org/mpeuni/hbn.html hbn] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (negateNotFree () ((H (x is-not-free-in φ))) (x is-not-free-in (¬ φ)) (
        H
        x generalize

        x φ NegationNotFree

        applyModusPonens
))
</jh>

Having negation makes it easy to prove the analogue to <code>addForAllNotFree</code> for ∃:<ref>[http://us.metamath.org/mpeuni/hbex.html hbex] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (addThereExistsNotFree () ((H (x is-not-free-in φ))) (x is-not-free-in (∃ y φ)) (
        H
        negateNotFree
        y addForAllNotFree
        negateNotFree
))
</jh>

=== Implications ===

We prove a variety of results concerning free variables and implications.
<jh>
thm (19.21ai () ((HFREE (x is-not-free-in φ)) (HIMP (φ → ψ))) (φ → (∀ x ψ)) (
        HFREE

        HIMP
        x addForAll

        applySyllogism
))
</jh>

If a variable is not free in either of two propositions, it is not free in the implication of the two:<ref>[http://us.metamath.org/mpeuni/hbim.html hbim] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (principia*2.21 () () ((¬ φ) → (φ → ψ)) (
        (¬ φ) ψ DisjunctionRightIntroduction
        φ ψ ImplicationDisjunction eliminateBiconditionalForward
        applySyllogism
))

thm (implicationNotFree () 
  ((HPHI (x is-not-free-in φ)) (HPSI (x is-not-free-in ψ)))
  (x is-not-free-in (φ → ψ)) (
</jh>
Implication to disjunction we'll need at the end of the proof:
<jh>
        φ ψ ImplicationDisjunction eliminateBiconditionalReverse
</jh>
The first part of the proof is to derive <code>(¬ φ) → (∀ x (φ → ψ))</code>:
<jh>
        HPHI
        negateNotFree
        φ ψ principia*2.21
        19.21ai
</jh>
The second part of the proof is to derive <code>ψ → (∀ x (φ → ψ))</code>:
<jh>
        HPSI
        ψ φ AntecedentIntroduction
        19.21ai
</jh>
Now we combine the two parts:
<jh>
        composeDisjunction
        applySyllogism
))
</jh>

The forward direction of the next theorem just combines a few of our previous results.<ref>[http://us.metamath.org/mpeuni/19.21.html 19.21] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (19.21 () ((H (x is-not-free-in φ))) ((∀ x (φ → ψ)) ↔ (φ → (∀ x ψ))) (
        x φ ψ ForAllImplication
        H (∀ x ψ) addCommonConsequent
        applySyllogism

</jh>
The reverse direction is slightly more novel.
<jh>
        H
        x ψ BoundForAllNotFree
        implicationNotFree
</jh>
That gives us <code>(x is-not-free-in (φ → (∀ x ψ)))</code>
<jh>
        x ψ Specialization
        φ addCommonAntecedent
        x addForAll

        applySyllogism

        introduceBiconditionalFromImplications
))
</jh>

Quantifying with ∃ over a variable which is not free in a formula has no effect:<ref>[http://us.metamath.org/mpeuni/19.9.html 19.9] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (19.9 () ((H (x is-not-free-in φ))) ((∃ x φ) ↔ φ) (
        H
        negateNotFree
        transposeWithNegatedAntecedent

        φ x 19.8a

        introduceBiconditionalFromImplications
))
</jh>

The next theorem is kind of like 19.21 but it concerns existential quantification over a variable which is not free in the consequent (19.21 was universal quantification over a variable not free in the antecedent).<ref>[http://us.metamath.org/mpeuni/19.36.html 19.36] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (19.36 () ((H (x is-not-free-in ψ))) ((∃ x (φ → ψ)) ↔ ((∀ x φ) → ψ)) (
        x φ ψ ThereExistsImplication

        (∀ x φ) BiconditionalReflexivity
        H 19.9
        buildImplication

        applyBiconditionalTransitivity
))
</jh>

== Quantifier order: ∃x∀y to ∀y∃x ==
We put aside switching the order of quantifiers for a while, but <code>is-not-free-in</code> enables us to make some more progress on it.
<jh>
thm (ThereExistsForAllCommutation () () ((∃ x (∀ y φ)) → (∀ y (∃ x φ))) (
        y φ BoundForAllNotFree
        x addThereExistsNotFree
</jh>
At this point we have (expanding the definition of <code>is-not-free-in</code>) <code>(∃ x (∀ y φ)) → (∀ y (∃ x (∀ y φ)))</code>.  We just need to get rid of the inner ∀ on the right hand side:
<jh>
        y φ Specialization
        x addThereExists
        y addForAll

        applySyllogism
))
</jh>

== Quantifier order: ∀y∃x to ∃x∀y (sometimes) ==
We also prove one case in which ∀y∃x can be switched to ∃x∀y, but it is subject to various discrete variable constraints.

<jh>
thm (ForAllThereExistsImplicationCommutation ((x y) (ψ x) (φ y)) ()
  ((∃ x (∀ y (φ → ψ))) ↔ (∀ y (∃ x (φ → ψ)))) (
        y φ DistinctNotFree
        ψ 19.21

        x buildThereExists
</jh>
The left hand side is now <code>(∃ x (∀ y (φ → ψ)))</code>.  We will be transforming the right hand side through a series of equivalences.  So far we have <code>(∃ x (φ → (∀ y ψ))))</code>.
<jh>
        x (∀ y ψ) DistinctNotFree
        φ 19.36
        applyBiconditionalTransitivity
</jh>
That gets us to <code>(∀ x φ) → (∀ y ψ)</code>
<jh>
        y (∀ x φ) DistinctNotFree
        ψ 19.21 swapBiconditional
        applyBiconditionalTransitivity
</jh>
which gives us <code>(∀ y ((∀ x φ) → ψ))</code>
<jh>
        x ψ DistinctNotFree
        φ 19.36 swapBiconditional
        y buildForAll

        applyBiconditionalTransitivity
))
</jh>

== Export ==
We've now proved all the theorems in [[Interface:First-order logic]], so we export them.
<jh>
export (FIRSTORDER Interface:First-order_logic (CLASSICAL) ())
</jh>

== References ==
<references/>

[[Category:Classical first-order logic]]