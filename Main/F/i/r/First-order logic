{{header
 | title    = First-order logic
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = The purpose of this page is to prove the statements of [[Interface:First-order logic]] from [[Interface:Axioms of first-order logic]].

{{under construction}}
}}
{{interfaces
| imports = [[Interface:Axioms of first-order logic]]
| exports = [[Interface:First-order logic]]
}}

Many of the proofs on this page are adapted from metamath's set.mm, and theorems may be named after set.mm.  However, since set.mm names do change over time, do not count on this correspondence to be exact.

We start with the [[Interface:Classical propositional calculus|theorems of propositional logic]] and [[Interface:Axioms of first-order logic]]:

<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (AXIOMS Interface:Axioms_of_first-order_logic (CLASSICAL) ())
</jh>

As usual, φ, ψ, χ, and θ are formulas and x, y, and z are objects:

<jh>
var (formula φ ψ χ θ)
var (object x y z)
</jh>

== ForAllImplication ==

The ∀ quantifier can be distributed across an implication. This is one of our axioms, so we just provide an additional name and a rule:

<jh>
thm (ForAllImplication () () ((∀ x (φ → ψ)) → ((∀ x φ) → (∀ x ψ))) (
        x φ ψ QuantifiedImplication
))

thm (distributeForAllImplication () ((H (∀ x (φ → ψ)))) ((∀ x φ) → (∀ x ψ)) (
        H
        x φ ψ QuantifiedImplication
        applyModusPonens
))
</jh>

== Equality is reflexive, symmetric, and transitive ==
The basic facts about equality are that it is reflexive, symmetric and transitive. Instead of supposing these as axioms, we have a single axiom which implies them (when combined with some of the other axioms).

We start with reflexivity.  The first two theorems are intermediate steps:

<jh>
thm (EqualityReflexivity-1 () () ((x = y) → (y = y)) (
        (x = y) ConjunctionIdempotence eliminateBiconditionalReverse

        x y y AxiomEquality
        import

        applySyllogism
))

thm (EqualityReflexivity-2 () () ((∀ x (¬ (y = y))) → (∀ x (¬ (x = y)))) (
        x y EqualityReflexivity-1
        introduceTransposition
        x generalize

        x (¬ (y = y)) (¬ (x = y)) QuantifiedImplication
        applyModusPonens
))
</jh>

The proof of reflexivity involves adding an extra variable <code>x</code>. We need to specify that this variable is distinct from y, but this doesn't affect the generality of the result. The variable <code>x</code> only appears in the proof, not in the theorem, and so the distinct variable constraint only needs to appear here, not in the statement of the theorem in [[Interface:First-order logic]].
<jh>
thm (EqualityReflexivity ((x y)) () (y = y) (
        x y Existence

        (¬ (y = y)) x Generalization
        x y EqualityReflexivity-2
        applySyllogism

        applyModusTollens
        eliminateDoubleNegation
))
</jh>

The proof of symmetry follows much more easily from reflexivity and the equality axiom. Most of what we need to do is just propositional logic.
<jh>
thm (applyNestedModusPonens () 
  ((HIMP (φ → (ψ → χ))) (H ψ))
  (φ → χ) (
        HIMP

        H
        ψ χ ModusPonens
        export
        applyModusPonens

        applySyllogism
))

thm (EqualitySymmetryImplication () () ((x = y) → (y = x)) (
        x y x AxiomEquality
        x EqualityReflexivity
        applyNestedModusPonens
))

thm (EqualitySymmetry () () ((x = y) ↔ (y = x)) (
        x y EqualitySymmetryImplication
        y x EqualitySymmetryImplication
        introduceBiconditionalFromImplications
))
</jh>

Transitivity is now just a rearangement of our equality axiom:
<jh>
thm (EqualityTransitivity () () (((x = y) ∧ (y = z)) → (x = z)) (
        x y EqualitySymmetryImplication
        y x z AxiomEquality
        applySyllogism
        import
))
</jh>

== Specialization ==
We can remove a universal quantifier. This is sometimes taken as an axiom but here we prove it from the other axioms via a number of intermediate steps.<ref>[http://us.metamath.org/mpeuni/ax4.html ax4] in metamath's set.mm, accessed February 18, 2010</ref>

<jh>
thm (Specialization-18 ((y φ)) () ((y = x) → ((¬ φ) → (∀ x ((x = y) → (¬ φ))))) (
        y x EqualitySymmetry eliminateBiconditionalReverse
        x y (¬ φ) VariableSubstitution
        applySyllogism

        (¬ φ) y Generalization
        (∀ x ((x = y) → (¬ φ))) addCommonConsequent
        applySyllogism
))

thm (Specialization-22 () () ((∀ x ((x = y) → (¬ φ))) → (∀ x (φ → (¬ (x = y))))) (
        (x = y) φ TranspositionWithNegatedConsequent
        eliminateBiconditionalReverse

        x generalize

        distributeForAllImplication
))

thm (Specialization-a () () ((∀ x (φ → (¬ (x = y)))) → (¬ (∀ x φ))) (
        x φ (¬ (x = y)) ForAllImplication

        (∀ x φ) (∀ x (¬ (x = y))) Transposition eliminateBiconditionalReverse
        x y Existence
        applyNestedModusPonens

        applySyllogism
))

thm (Specialization-30 ((y φ)) () ((¬ ((∀ x φ) → φ)) → (¬ (y = x))) (
        y x φ Specialization-18
        import

        x y φ Specialization-22
        applySyllogism

        x φ y Specialization-a
        applySyllogism
        export

        (∀ x φ) φ Transposition eliminateBiconditionalForward
        applySyllogism

        introduceTransposition
))

thm (Specialization-33 ((y φ)) () 
  ((∀ y (¬ ((∀ x φ) → φ))) → (∀ y (¬ (y = x)))) (
        x φ y Specialization-30
        y generalize
        distributeForAllImplication
))
</jh>

As before, the distinct variable constraints don't get exported, as they all contain <code>y</code>.
<jh>
thm (Specialization ((x y) (y φ)) () ((∀ x φ) → φ) (
        y x Existence

        (¬ ((∀ x φ) → φ)) y Generalization
        y x φ Specialization-33
        applySyllogism

        applyModusTollens

        eliminateDoubleNegation
))
</jh>

== Doubling ∀ ==

If we have a universal quantifier, it doesn't change anything to apply it twice.  That is, <code>(∀ x φ) → (∀ x (∀ x φ))</code>

<jh>
thm (ForAllDoubling-negation-lemma () () 
  ((∀ x (¬ (∀ x (¬ (∀ x φ))))) → (∀ x (∀ x φ))) (
        x φ QuantifiedNegation
        transposeWithNegatedAntecedent

        x generalize

        distributeForAllImplication
))

thm (ForAllDoubling () () ((∀ x φ) → (∀ x (∀ x φ))) (
        x (¬ (∀ x φ)) Specialization
        transposeWithNegatedConsequent

        x (¬ (∀ x φ)) QuantifiedNegation
        applySyllogism

        x φ ForAllDoubling-negation-lemma
        applySyllogism
))
</jh>

=== a5i ===
A consequence is a variant of <code>QuantifiedImplication</code>:
<jh>
thm (a5i () ((H ((∀ x φ) → ψ))) ((∀ x φ) → (∀ x ψ)) (
        x φ ForAllDoubling

        H x generalize
        distributeForAllImplication

        applySyllogism
))
</jh>

== Builder for ∀ ==
From <code>φ → ψ</code> we want to be able to get <code>(∀ x φ) → (∀ x ψ)</code>.  The easier part of this is geting the quantifier onto the antecedent:<ref>[http://us.metamath.org/mpeuni/a4s.html a4s] in metamath's set.mm, accessed February 18, 2010</ref>

<jh>
thm (a4s () ((H (φ → ψ))) ((∀ x φ) → ψ) (
        x φ Specialization
        H
        applySyllogism
))
</jh>

We get the quantifier onto the consequent via this lemma:
<jh>

thm (ax5o () () ((∀ x ((∀ x φ) → ψ)) → ((∀ x φ) → (∀ x ψ))) (
        x (∀ x φ) ψ QuantifiedImplication

        x φ ForAllDoubling
        (∀ x ψ) addCommonConsequent

        applySyllogism
))
</jh>

Then our builder for implication is:<ref>[http://us.metamath.org/mpeuni/19.20i.html 19.20i] in metamath's set.mm, accessed February 18, 2010</ref>
<jh>
thm (addForAll () ((H (φ → ψ))) ((∀ x φ) → (∀ x ψ)) (
        H x a4s

        x generalize
        x φ ψ ax5o

        applyModusPonens
))
</jh>

The builder for the biconditional follows trivially:
<jh>
thm (buildForAll () ((H (φ ↔ ψ))) ((∀ x φ) ↔ (∀ x ψ)) (
        H eliminateBiconditionalReverse x addForAll
        H eliminateBiconditionalForward x addForAll
        introduceBiconditionalFromImplications
))
</jh>

== Existential quantification ==
The axioms are written in terms of just the universal quantifier ∀. We define the existential quantifier ∃ in terms of it:

<jh>
def ((∃ x φ) (¬ (∀ x (¬ φ))))
</jh>

and the following two theorems are immediate consequences from this definition:

<jh>
thm (NotThereExists () () ((¬ (∃ x φ)) ↔ (∀ x (¬ φ))) (
        (∃ x φ) BiconditionalReflexivity
        addNegation

        (∀ x (¬ φ)) DoubleNegation swapBiconditional
        applyBiconditionalTransitivity
))

thm (NotForAll () () ((¬ (∀ x φ)) ↔ (∃ x (¬ φ))) (
        φ DoubleNegation
        x buildForAll
        addNegation
))
</jh>

=== Builders ===

The builders for ∃ follow from the builders for ∀:
<jh>
thm (addThereExists () ((H (φ → ψ))) ((∃ x φ) → (∃ x ψ)) (
        H
        introduceTransposition
        x addForAll
        introduceTransposition
))

thm (buildThereExists () ((H (φ ↔ ψ))) ((∃ x φ) ↔ (∃ x ψ)) (
        H
        addNegation
        x buildForAll
        addNegation
))
</jh>

=== Adding existential quantifier ===
We can add ∃ to the start of a formula:<ref>[http://us.metamath.org/mpeuni/19.8a.html 19.8a] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (19.8a () () (φ → (∃ x φ)) (
        x (¬ φ) Specialization
        transposeWithNegatedConsequent
))
</jh>

=== Another for-all distribution law ===

If we have an implication quantified by ∀, we've already shown that <code>(∀ x φ) → (∀ x ψ)</code> follows. It also will sometimes be useful to know that alternately <code>(∃ x φ) → (∃ x ψ)</code> does.<ref>[http://us.metamath.org/mpeuni/19.22.html 19.22] in metamath's set.mm, accessed February 21, 2010</ref>
<jh>
thm (ForAllImplicationThereExists () () ((∀ x (φ → ψ)) → ((∃ x φ) → (∃ x ψ))) (
        φ ψ Transposition
        x buildForAll

        eliminateBiconditionalReverse
        x (¬ ψ) (¬ φ) ForAllImplication
        applySyllogism

        (∀ x (¬ ψ)) (∀ x (¬ φ)) Transposition
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

== Quantifier order ==
Being able to swap the order of two ∀ quantifiers is an axiom, so we just need to biconditionalize it:

<jh>
thm (ForAllCommutation () () ((∀ x (∀ y φ)) ↔ (∀ y (∀ x φ))) (
        x y φ QuantifierCommutation
        y x φ QuantifierCommutation
        introduceBiconditionalFromImplications
))
</jh>

The corresponding theorem for ∃ follows from it.  It may be easier to follow the proof below if you remember that 
 <code>(∃ x (∃ y φ))</code>
is equivalent to 
 <code>(¬ (∀ x (¬ (¬ (∀ y (¬ φ))))))</code>

<jh>
thm (ThereExistsCommutation () () ((∃ x (∃ y φ)) ↔ (∃ y (∃ x φ))) (
        (∀ y (¬ φ)) DoubleNegation swapBiconditional
        x buildForAll

        x y (¬ φ) ForAllCommutation
        applyBiconditionalTransitivity

        (∀ x (¬ φ)) DoubleNegation
        y buildForAll
        applyBiconditionalTransitivity

        addNegation
))
</jh>

== Combining quantified statements ==

=== For-all across a Conjunction ===
The ability to combine or split ∀ across a conjunction follows from <code>ForAllImplication</code> and some propositional logic.<ref>[http://us.metamath.org/mpeuni/19.26.html 19.26] in metamath's set.mm, accessed February 19, 2010</ref> We prove the forward and reverse implications separately.

<jh>
thm (ForAllConjunctionSplitting () () ((∀ x (φ ∧ ψ)) → ((∀ x φ) ∧ (∀ x ψ))) (
        φ ψ ConjunctionRightElimination
        x generalize
        distributeForAllImplication

        φ ψ ConjunctionLeftElimination
        x generalize
        distributeForAllImplication

        composeConjunction
))

thm (distributeForAllConjunction () ((H (∀ x (φ ∧ ψ)))) ((∀ x φ) ∧ (∀ x ψ)) (
        H
        x φ ψ ForAllConjunctionSplitting
        applyModusPonens
))

thm (ForAllConjunctionCombining () () (((∀ x φ) ∧ (∀ x ψ)) → (∀ x (φ ∧ ψ))) (
        φ ψ ConjunctionRightIntroduction
        x generalize
        distributeForAllImplication

        x ψ (φ ∧ ψ) ForAllImplication
        applySyllogism

        import
))

thm (collectForAllConjunction () ((HLEFT (∀ x φ)) (HRIGHT (∀ x ψ))) (∀ x (φ ∧ ψ)) (
        HLEFT
        HRIGHT
        introduceConjunction

        x φ ψ ForAllConjunctionCombining

        applyModusPonens
))

thm (ForAllConjunction () () ((∀ x (φ ∧ ψ)) ↔ ((∀ x φ) ∧ (∀ x ψ))) (
        x φ ψ ForAllConjunctionSplitting
        x φ ψ ForAllConjunctionCombining
        introduceBiconditionalFromImplications
))
</jh>

=== There-exists across a disjunction ===

This one follows from <code>ForAllConjunction</code> via DeMorgan's law and a little bit of negation rearranging.
<jh>
thm (ThereExistsDisjunction () () ((∃ x (φ ∨ ψ)) ↔ ((∃ x φ) ∨ (∃ x ψ))) (
        φ ψ DeMorganPDP
        x buildForAll

        x (¬ φ) (¬ ψ) ForAllConjunction
        applyBiconditionalTransitivity

        (∀ x (¬ φ)) (∀ x (¬ ψ)) DeMorganNDN swapBiconditional
        applyBiconditionalTransitivity

        addNegation

        ((∃ x φ) ∨ (∃ x ψ)) DoubleNegation swapBiconditional
        applyBiconditionalTransitivity
))

thm (distributeThereExistsDisjunction () ((H (∃ x (φ ∨ ψ))))  ((∃ x φ) ∨ (∃ x ψ)) (
        H
        x φ ψ ThereExistsDisjunction eliminateBiconditionalReverse
        applyModusPonens
))

thm (collectThereExistsDisjunction () ((H ((∃ x φ) ∨ (∃ x ψ)))) (∃ x (φ ∨ ψ)) (
        H
        x φ ψ ThereExistsDisjunction eliminateBiconditionalForward
        applyModusPonens
))

</jh>

=== There-exists across an implication ===

This is another proof which mostly consists of the definition of ∃ and propositional calculus.

<jh>
thm (ThereExistsImplication () () ((∃ x (φ → ψ)) ↔ ((∀ x φ) → (∃ x ψ))) (
        φ ψ ImplicationDisjunction
        addNegation
        φ ψ DeMorganNDP
        applyBiconditionalTransitivity
</jh>
So far, we have transformed <code>¬ (φ → ψ)</code> into <code>φ ∧ (¬ ψ)</code> which is now ripe for applying <code>ForAllConjunction</code> 
<jh>
        x buildForAll

        x φ (¬ ψ) ForAllConjunction
        applyBiconditionalTransitivity

        addNegation
</jh>
We're almost there.  The left hand side has been gradually built up into <code>(∃ x (φ → ψ))</code>. The right hand side is <code>(¬ ((∀ x φ) ∧ (∀ x (¬ ψ))))</code>, which just needs DeMorgan's law and transformation from disjunction to implication to become <code>((∀ x φ) → (∃ x ψ))</code>
<jh>
        (∀ x φ) (∀ x (¬ ψ)) DeMorganPCP
        applyBiconditionalTransitivity

        (∀ x φ) (¬ (∀ x (¬ ψ))) ImplicationDisjunction swapBiconditional
        applyBiconditionalTransitivity
))

thm (distributeThereExistsImplication () ((H (∃ x (φ → ψ)))) ((∀ x φ) → (∃ x ψ)) (
        H
        x φ ψ ThereExistsImplication eliminateBiconditionalReverse
        applyModusPonens
))

thm (collectThereExistsImplication () ((H ((∀ x φ) → (∃ x ψ)))) (∃ x (φ → ψ)) (
        H
        x φ ψ ThereExistsImplication eliminateBiconditionalForward
        applyModusPonens
))
</jh>

== Negation ==
This relationship between quantification and negation is sometimes taken as an axiom instead of our <code>QuantifiedNegation</code>, but we prove it here:<ref>[http://us.metamath.org/mpeuni/ax6o.html ax6o] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (ax6o () () ((¬ (∀ x (¬ (∀ x φ)))) → φ) (
        x φ QuantifiedNegation
        transposeWithNegatedAntecedent

        x φ Specialization

        applySyllogism
))
</jh>

== Free variables ==
The conventional treatment of [[w:free variable|free variables]] is syntactic; variables are defined as free depending on where they occur in a formula relative to the quantifiers over that variable. JHilbert (following metamath before it) does not contain the ability to analyze formulas this way, and we instead define free variables based on whether generalization is possible:

<jh>
def ((is-not-free-in x φ) (φ → (∀ x φ)))
</jh>

This differs slightly from the syntactic definition of free variables, and so might better be termed ''effectively free'' than simply ''free''. For example, this definition does not consider <code>x</code> to be free in <code>x = x</code>.<ref>[http://us.metamath.org/mpeuni/mmset.html#traditional Appendix 2: Traditional Textbook Axioms of Predicate Calculus with Equality], Metamath Proof Explorer, accessed February 20, 2010.</ref> In fact, this relationship is true of any theorem:<ref>[http://us.metamath.org/mpeuni/hbth.html hbth] in metamath's set.mm, accessed February 20, 2010.</ref>
<jh>
thm (TheoremNotFree () ((H φ)) (x is-not-free-in φ) (
        H
        x generalize
        φ introduceAntecedent
))
</jh>

Our next two results just restate axioms or theorems we already have. The first one can be thought of as saying that a variable is not free in an expression in which it does not occur:

<jh>
thm (DistinctNotFree ((x φ)) () (x is-not-free-in φ) (
        φ x Generalization
))
</jh>

And the second states that a universal quantifier makes the variable not free (that is, the variable is ''bound'' by a quantifier):<ref>[http://us.metamath.org/mpeuni/hba1.html hba1] in metamath's set.mm, accessed February 20, 2010. In case your font doesn't make it clear, this is hba followed by the number 1.</ref>
<jh>
thm (BoundForAllNotFree () () (x is-not-free-in (∀ x φ)) (
        x φ ForAllDoubling
))
</jh>

There's another result for universal quantifiers, this one about adding a quantifier for a (possibly) different variable:<ref>[http://us.metamath.org/mpeuni/hbal.html hbal] in metamath's set.mm, accessed February 20, 2010.  In case your font doesn't make it clear, this is hba followed by the lowercase letter l.</ref>
<jh>
thm (addForAllNotFree () ((H (x is-not-free-in φ))) (x is-not-free-in (∀ y φ)) (
        H
        y addForAll

        y x φ ForAllCommutation eliminateBiconditionalReverse
        applySyllogism
))
</jh>

Next, if a variable is not free in <code>φ</code>, it is not free in <code>(¬ φ)</code>. We first prove an implication version:<ref>[http://us.metamath.org/mpeuni/hbnt.html hbnt] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (NegationNotFree () () ((∀ x (x is-not-free-in φ)) → (x is-not-free-in (¬ φ))) (
        φ (∀ x φ) Transposition eliminateBiconditionalReverse
        x generalize
        distributeForAllImplication

        x (¬ (∀ x φ)) (¬ φ) ForAllImplication
        applySyllogism

</jh>
At this point we have <code>(∀x(φ → ∀xφ) → (∀x ¬ ∀xφ → ∀x ¬ φ))</code>. Together with <code>(¬ φ → ∀x ¬ ∀xφ)</code> (which is the transposition of <code>ax6o</code>), we will get our desired result of <code>(∀x(φ → ∀xφ) → (¬ φ → ∀x ¬ φ))</code>.
<jh>
        x φ ax6o
        transposeWithNegatedAntecedent

        (∀ x (¬ φ)) addCommonConsequent

        applySyllogism
))
</jh>

The rule form does not need the extra quantifier:<ref>[http://us.metamath.org/mpeuni/hbn.html hbn] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (negateNotFree () ((H (x is-not-free-in φ))) (x is-not-free-in (¬ φ)) (
        H
        x generalize

        x φ NegationNotFree

        applyModusPonens
))
</jh>

Having negation makes it easy to prove the analogues to <code>BoundForAllNotFree</code> and <code>addForAllNotFree</code> for ∃:<ref>[http://us.metamath.org/mpeuni/hbex.html hbex] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (BoundThereExistsNotFree () () (x is-not-free-in (∃ x φ)) (
        x (¬ φ) BoundForAllNotFree
        negateNotFree
))

thm (addThereExistsNotFree () ((H (x is-not-free-in φ))) (x is-not-free-in (∃ y φ)) (
        H
        negateNotFree
        y addForAllNotFree
        negateNotFree
))
</jh>

The following builder is analogous to our builders for other formulas:

<jh>
thm (buildNotFree () ((H (φ ↔ ψ))) ((x is-not-free-in φ) ↔ (x is-not-free-in ψ)) (
        H
        H x buildForAll
        buildImplication
))
</jh>

=== 19.21ai ===

Here is a result, a variation of one direction of ForAllImplicationAntecedentMovement, which we are able to prove now and which will help us later:
<jh>
thm (19.21ai () ((HFREE (x is-not-free-in φ)) (HIMP (φ → ψ))) (φ → (∀ x ψ)) (
        HFREE

        HIMP
        x addForAll

        applySyllogism
))
</jh>

=== Free variables and connectives ===
If a variable is not free in either of two propositions, it is not free in the implication of the two:<ref>[http://us.metamath.org/mpeuni/hbim.html hbim] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (principia*2.21 () () ((¬ φ) → (φ → ψ)) (
        (¬ φ) ψ DisjunctionRightIntroduction
        φ ψ ImplicationDisjunction eliminateBiconditionalForward
        applySyllogism
))

thm (implicationNotFree () 
  ((HPHI (x is-not-free-in φ)) (HPSI (x is-not-free-in ψ)))
  (x is-not-free-in (φ → ψ)) (
</jh>
Implication to disjunction we'll need at the end of the proof:
<jh>
        φ ψ ImplicationDisjunction eliminateBiconditionalReverse
</jh>
The first part of the proof is to derive <code>(¬ φ) → (∀ x (φ → ψ))</code>:
<jh>
        HPHI
        negateNotFree
        φ ψ principia*2.21
        19.21ai
</jh>
The second part of the proof is to derive <code>ψ → (∀ x (φ → ψ))</code>:
<jh>
        HPSI
        ψ φ AntecedentIntroduction
        19.21ai
</jh>
Now we combine the two parts:
<jh>
        composeDisjunction
        applySyllogism
))
</jh>

The same is true of the other connectives:
<jh>
thm (disjunctionNotFree () 
  ((HPHI (x is-not-free-in φ)) (HPSI (x is-not-free-in ψ)))
  (x is-not-free-in (φ ∨ ψ)) (
        HPHI negateNotFree
        HPSI
        implicationNotFree
</jh>
We've shown <code>(x is-not-free-in ((¬ φ) → ψ))</code>. Now we just need to convert the implication to the equivalent disjunction
<jh>

        φ ψ DisjunctionImplication
        x buildNotFree

        eliminateBiconditionalForward
        applyModusPonens
))

thm (conjunctionNotFree ()
  ((HPHI (x is-not-free-in φ)) (HPSI (x is-not-free-in ψ)))
  (x is-not-free-in (φ ∧ ψ)) (
        HPHI negateNotFree
        HPSI negateNotFree
        disjunctionNotFree
        negateNotFree

        φ ψ DeMorganNDN
        x buildNotFree

        eliminateBiconditionalReverse
        applyModusPonens
))

thm (biconditionalNotFree ()
  ((HPHI (x is-not-free-in φ)) (HPSI (x is-not-free-in ψ)))
  (x is-not-free-in (φ ↔ ψ)) (
        HPHI HPSI implicationNotFree
        HPSI HPHI implicationNotFree
        conjunctionNotFree

        φ ψ BiconditionalImplication
        x buildNotFree

        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

=== Quantification of a variable which isn't free ===

Quantifying with ∃ over a variable which is not free in a formula has no effect:<ref>[http://us.metamath.org/mpeuni/19.9.html 19.9] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (ThereExistsAddRemove () ((H (x is-not-free-in φ))) ((∃ x φ) ↔ φ) (
        H
        negateNotFree
        transposeWithNegatedAntecedent

        φ x 19.8a

        introduceBiconditionalFromImplications
))
</jh>

The same is true of ∀:<ref>[http://us.metamath.org/mpeuni/19.3.html 19.3] in metamath's set.mm, accessed February 21, 2010</ref>
<jh>
thm (ForAllAddRemove () ((H (x is-not-free-in φ))) ((∀ x φ) ↔ φ) (
        x φ Specialization
        H
        introduceBiconditionalFromImplications
))
</jh>

=== Moving formulas in and out of quantification ===

The results in this section all have to do with being able to move around formulas relative to quantifiers, given that the quantified variable is not free in the formula being moved.

==== Implication ====
The forward direction of the next theorem just combines a few of our previous results.<ref>[http://us.metamath.org/mpeuni/19.21.html 19.21] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (ForAllImplicationAntecedentMovement () ((H (x is-not-free-in φ))) ((∀ x (φ → ψ)) ↔ (φ → (∀ x ψ))) (
        x φ ψ ForAllImplication
        H (∀ x ψ) addCommonConsequent
        applySyllogism

</jh>
The reverse direction is slightly more novel.
<jh>
        H
        x ψ BoundForAllNotFree
        implicationNotFree
</jh>
That gives us <code>(x is-not-free-in (φ → (∀ x ψ)))</code>
<jh>
        x ψ Specialization
        φ addCommonAntecedent
        x addForAll

        applySyllogism

        introduceBiconditionalFromImplications
))
</jh>

The corresponding theorem for ∃ is similar:<ref>[http://us.metamath.org/mpeuni/19.37.html 19.37] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (ThereExistsImplicationAntecedentMovement () ((H (x is-not-free-in φ))) ((∃ x (φ → ψ)) ↔ (φ → (∃ x ψ))) (
        x φ ψ ThereExistsImplication

        H ForAllAddRemove
        (∃ x ψ) BiconditionalReflexivity
        buildImplication

        applyBiconditionalTransitivity
))
</jh>

The two theorems which involve moving the consequent result in changing ∃ to ∀ or vice versa. We name them after the quantifier which appears on the combined half of the equivalence. We'll first prove the for-all one.<ref>[http://us.metamath.org/mpeuni/19.23.html 19.23] in metamath's set.mm, accessed February 21, 2010</ref>
<jh>
thm (ForAllImplicationConsequentMovement () ((H (x is-not-free-in ψ))) ((∀ x (φ → ψ)) ↔ ((∃ x φ) → ψ)) (
</jh>
For the forward direction we first distribute to <code>(∃ x φ) → (∃ x ψ)</code> and then remove the quantifier on <code>ψ</code>.
<jh>
        x φ ψ ForAllImplicationThereExists
        H ThereExistsAddRemove eliminateBiconditionalReverse
        (∃ x φ) addCommonAntecedent
        applySyllogism
</jh>
The reverse direction is somewhat more complicated.  We start by proving <code>(x is-not-free-in ((∃ x φ) → ψ))</code>:
<jh>
        x φ BoundThereExistsNotFree
        H
        implicationNotFree
</jh>
Then we show that <code>((∃ x φ) → ψ) → (φ → ψ)</code>
<jh>
        φ x 19.8a
        ψ addCommonConsequent

</jh>
Because x is not free in the antecedent, we can conclude <code>((∃ x φ) → ψ) → (∀ x (φ → ψ))</code>:
<jh>
        19.21ai

</jh>
Now we just need to combine the forward and reverse implications:
<jh>
        introduceBiconditionalFromImplications
))
</jh>

And closing out this section is the corresponding result for ∃:<ref>[http://us.metamath.org/mpeuni/19.36.html 19.36] in metamath's set.mm, accessed February 20, 2010</ref>
<jh>
thm (ThereExistsImplicationConsequentMovement () ((H (x is-not-free-in ψ))) ((∃ x (φ → ψ)) ↔ ((∀ x φ) → ψ)) (
        x φ ψ ThereExistsImplication

        (∀ x φ) BiconditionalReflexivity
        H ThereExistsAddRemove
        buildImplication

        applyBiconditionalTransitivity
))
</jh>

== Quantifier order: ∃x∀y to ∀y∃x ==
We put aside switching the order of quantifiers for a while, but <code>is-not-free-in</code> enables us to make some more progress on it.<ref>[http://us.metamath.org/mpeuni/19.12.html 19.12] in metamath's set.mm, accessed February 22, 2010</ref>
<jh>
thm (ThereExistsForAllCommutation () () ((∃ x (∀ y φ)) → (∀ y (∃ x φ))) (
        y φ BoundForAllNotFree
        x addThereExistsNotFree
</jh>
At this point we have (expanding the definition of <code>is-not-free-in</code>) <code>(∃ x (∀ y φ)) → (∀ y (∃ x (∀ y φ)))</code>.  We just need to get rid of the inner ∀ on the right hand side:
<jh>
        y φ Specialization
        x addThereExists
        y addForAll

        applySyllogism
))
</jh>

== Quantifier order: ∀y∃x to ∃x∀y (sometimes) ==
We also prove one case in which ∀y∃x can be switched to ∃x∀y, but it is subject to various discrete variable constraints.<ref>[http://us.metamath.org/mpeuni/19.12vv.html 19.12vv] in metamath's set.mm, accessed February 22, 2010</ref>

<jh>
thm (ForAllThereExistsImplicationCommutation ((x y) (ψ x) (φ y)) ()
  ((∃ x (∀ y (φ → ψ))) ↔ (∀ y (∃ x (φ → ψ)))) (
        y φ DistinctNotFree
        ψ ForAllImplicationAntecedentMovement

        x buildThereExists
</jh>
The left hand side is now <code>(∃ x (∀ y (φ → ψ)))</code>.  We will be transforming the right hand side through a series of equivalences.  So far we have <code>(∃ x (φ → (∀ y ψ))))</code>.
<jh>
        x (∀ y ψ) DistinctNotFree
        φ ThereExistsImplicationConsequentMovement
        applyBiconditionalTransitivity
</jh>
That gets us to <code>(∀ x φ) → (∀ y ψ)</code>
<jh>
        y (∀ x φ) DistinctNotFree
        ψ ForAllImplicationAntecedentMovement swapBiconditional
        applyBiconditionalTransitivity
</jh>
which gives us <code>(∀ y ((∀ x φ) → ψ))</code>
<jh>
        x ψ DistinctNotFree
        φ ThereExistsImplicationConsequentMovement swapBiconditional
        y buildForAll

        applyBiconditionalTransitivity
))
</jh>

== Quantifiers and equality ==
Here we prove a number of results involving equality and quantifiers.  Many of them will pave the way for results involving explicit (<code>subst</code>) substitution.

=== ax9o ===
First is a variant of the <code>Existence</code> axiom:<ref>[http://us.metamath.org/mpeuni/ax9o.html ax9o] in metamath's set.mm, accessed February 22, 2010</ref>

<jh>
thm (ax9o () () ((∀ x ((x = y) → (∀ x φ))) → φ) (
        x (x = y) (∀ x φ) ForAllImplicationThereExists
</jh>
This gives us <code>∀x(x = y → ∀xφ) → (∃x x = y → ∃x∀xφ)</code>, which can be simplified to our desired result.  The first step is to note that <code>∃x x = y</code> is just the <code>Existence</code> axiom, and can therefore be removed:
<jh>
        x y Existence
        applyNestedModusPonens
</jh>
Now we need to reduce <code>∃x∀xφ</code> to <code>φ</code>:
<jh>
        x φ ax6o
        applySyllogism
))
</jh>

=== A quantified statement which starts with a proposition ===
It is common for a quantifier to be followed by some kind of condition.  For example "for every ε > 0, (¬ ψ)" or "there exists a δ > 0 such that ψ".  Despite the similar wording, the former is formalized as <code>∀ε ((ε > 0) → (¬ ψ))</code> (with an implication) and the latter is formalized as <code>∃ δ ((δ > 0) ∧ ψ)</code> (with a conjunction).  The first theorem in this section expresses this relationship:<ref>[http://us.metamath.org/mpeuni/alinexa.html alinexa] in metamath's set.mm, accessed February 22, 2010</ref>

<jh>
thm (alinexa () () ((∀ x (φ → (¬ ψ))) ↔ (¬ (∃ x (φ ∧ ψ)))) (
        φ (¬ ψ) ImplicationDisjunction
        φ ψ DeMorganPCP swapBiconditional
        applyBiconditionalTransitivity

        x buildForAll
</jh>
That gives us <code>∀x(φ → ¬ ψ) ↔ ∀x ¬ (φ ∧ ψ)</code>.  Now we just need to apply <code>NotThereExists</code> to the right hand side:
<jh>
        x (φ ∧ ψ) NotThereExists swapBiconditional
        applyBiconditionalTransitivity
))
</jh>

The second theorem is a special case which will be useful in dealing with substitution:<ref>[http://us.metamath.org/mpeuni/equs3.html equs3] in metamath's set.mm, accessed February 22, 2010</ref>

<jh>
thm (transposeBiconditionalWithNegatedRight () ((H (φ ↔ (¬ ψ)))) (ψ ↔ (¬ φ)) (
        H eliminateBiconditionalReverse
        transposeWithNegatedConsequent

        H eliminateBiconditionalForward
        transposeWithNegatedAntecedent

        introduceBiconditionalFromImplications
))

thm (equs3 () () ((∃ x ((x = y) ∧ φ)) ↔ (¬ (∀ x ((x = y) → (¬ φ))))) (
        x (x = y) φ alinexa
        transposeBiconditionalWithNegatedRight
))
</jh>

== Substitution ==
We now move to substitution via <code>subst</code>.

In some formulations of predicate logic, this kind of substitution (known as ''proper substitution'' as there are some rules about what kinds of substitution are valid) is performed syntactically and the rules governing it are expressed in English or a meta-theory.  JHilbert does not have a feature to do syntactic proper substitution, but we are able to build up equivalent mechanisms from equality. The theorems in [[Interface:First-order logic]] could be proven from either the syntactic definition or ours.

=== Definition ===
Our definition of substitution is somewhat complicated, mainly in order to handle the case in which y and x are not distinct.<ref>[http://us.metamath.org/mpeuni/df-sb.html df-sb] in metamath's set.mm, accessed February 22, 2010</ref>

<jh>
def ((subst y x φ) (((x = y) → φ) ∧ (∃ x ((x = y) ∧ φ))))
</jh>

=== Proving substitution from (∀ x ((x = y) → φ)) ===
Given the definition we have adopted, our first order of business is making it a bit easier to prove a substitution formula.<ref>[http://us.metamath.org/mpeuni/sb2.html sb2] in metamath's set.mm, accessed February 22, 2010</ref>

First, a propositional logic theorem:<ref>[http://us.metamath.org/mpeuni/jc.html jc] in metamath's set.mm, accessed February 22, 2010</ref>
<jh>
thm (joinConsequents ()
  ((H1 (φ → ψ)) (H2 (φ → χ)))
  (φ → (¬ (ψ → (¬ χ)))) (
        H1 H2 composeConjunction
        ψ χ DeMorganNDN eliminateBiconditionalForward
        applySyllogism

        ψ (¬ χ) ImplicationDisjunction
        addNegation
        eliminateBiconditionalForward

        applySyllogism
))
</jh>

The following lemma is half of the result we are working towards:<ref>[http://us.metamath.org/mpeuni/equs4.html equs4] in metamath's set.mm, accessed February 22, 2010</ref>

<jh>
thm (equs4 () () ((∀ x ((x = y) → φ)) → (∃ x ((x = y) ∧ φ))) (
        (∀ x ((x = y) → φ)) (x = y) ConjunctionLeftElimination

        x ((x = y) → φ) Specialization
        import

        joinConsequents
</jh>
That gives us <code>((∀ x ((x = y) → φ)) ∧ x = y) → (¬ ((x = y) → (¬ φ)))</code>. We transform the consequent to <code>(¬ (∀ x ((x = y) → (¬ φ))))</code>:
<jh>
        x ((x = y) → (¬ φ)) Specialization
        introduceTransposition
        applySyllogism
</jh>
And then we add <code>∀x</code> to the front of that consequent:
<jh>
        x ((x = y) → (¬ φ)) BoundForAllNotFree
        negateNotFree
        applySyllogism
</jh>
We export and add one more ∀x:
<jh>
        export
        a5i
</jh>
which gives us <code>(∀x(x = y → φ) → ∀x(x = y → ∀x ¬ ∀x(x = y → ¬ φ)))</code>.  The consequent of that is just what we need to apply ax9o:
<jh>
        x y (¬ (∀ x ((x = y) → (¬ φ)))) ax9o
        applySyllogism
</jh>
so we have simplified the consequent to <code>¬ ∀x(x = y → ¬ φ))</code>. We merely apply <code>equs3</code> to that and we're done.
<jh>
        x y φ equs3 eliminateBiconditionalForward
        applySyllogism
))
</jh>

Now we're ready for our first theorem to help us prove a substituted formula:
<jh>
thm (sb2 () () ((∀ x ((x = y) → φ)) → (subst y x φ)) (
        x ((x = y) → φ) Specialization
        x y φ equs4
        composeConjunction
))
</jh>

== Export ==
We've now proved all the theorems in [[Interface:First-order logic]], so we export them.
<jh>
export (FIRSTORDER Interface:First-order_logic (CLASSICAL) ())
</jh>

== References ==
<references/>

[[Category:Classical first-order logic]]