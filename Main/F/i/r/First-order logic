{{header
 | title    = First-order logic
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = The purpose of this page is to prove the statements of [[Interface:First-order logic]] from [[Interface:Axioms of first-order logic]].

{{under construction}}
}}
{{interfaces
| imports = [[Interface:Axioms of first-order logic]]
| exports = eventually [[Interface:First-order logic]]
}}

We start with the [[Interface:Classical propositional calculus|theorems of propositional logic]] and [[Interface:Axioms of first-order logic]]:

<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (PRINCIPIA Interface:Axioms_of_first-order_logic (CLASSICAL) ())
</jh>

As usual, φ, ψ, χ, and θ are formulas and x, y, and z are objects:

<jh>
var (formula φ ψ χ θ)
var (object x y z)
</jh>

== ForAllImplication ==

The ∀ quantifier can be distributed across an implication. This is one of our axioms, so we just provide an additional name and a rule:

<jh>
thm (ForAllImplication () () ((∀ x (φ → ψ)) → ((∀ x φ) → (∀ x ψ))) (
        x φ ψ QuantifiedImplication
))

thm (distributeForAllImplication () ((H (∀ x (φ → ψ)))) ((∀ x φ) → (∀ x ψ)) (
        H
        x φ ψ QuantifiedImplication
        applyModusPonens
))
</jh>

== Equality is reflexive and symmetric ==
The basic facts about equality are that it is reflexive, symmetric and transitive. Instead of supposing these as axioms, we have a single axiom which implies them (when combined with some of the other axioms).

We start with reflexivity.  The first two theorems are intermediate steps:

<jh>
thm (EqualityReflexivity-1 () () ((x = y) → (y = y)) (
        (x = y) ConjunctionIdempotence eliminateBiconditionalReverse

        x y y AxiomEquality
        import

        applySyllogism
))

thm (EqualityReflexivity-2 () () ((∀ x (¬ (y = y))) → (∀ x (¬ (x = y)))) (
        x y EqualityReflexivity-1
        introduceTransposition
        x generalize

        x (¬ (y = y)) (¬ (x = y)) QuantifiedImplication
        applyModusPonens
))
</jh>

The proof of reflexivity involves adding an extra variable <code>x</code>. We need to specify that this variable is distinct from y, but this doesn't affect the generality of the result. The variable <code>x</code> only appears in the proof, not in the theorem, and so the distinct variable constraint only needs to appear here, not in the statement of the theorem in [[Interface:First-order logic]].
<jh>
thm (EqualityReflexivity ((x y)) () (y = y) (
        x y Existence

        (¬ (y = y)) x Generalization
        x y EqualityReflexivity-2
        applySyllogism

        applyModusTollens
        eliminateDoubleNegation
))
</jh>

The proof of symmetry follows much more easily from reflexivity and the equality axiom. Most of what we need to do is just propositional logic.
<jh>
thm (applyNestedModusPonens () 
  ((H1 ψ) (H2 (φ → (ψ → χ))))
  (φ → χ) (
        H1

        H2
        import

        ψ φ ConjunctionCommutativity eliminateBiconditionalReverse
        χ addCommonConsequent
        applyModusPonens

        export
        applyModusPonens
))

thm (EqualitySymmetryImplication () () ((x = y) → (y = x)) (
        x EqualityReflexivity
        x y x AxiomEquality
        applyNestedModusPonens
))

thm (EqualitySymmetry () () ((x = y) ↔ (y = x)) (
        x y EqualitySymmetryImplication
        y x EqualitySymmetryImplication
        introduceBiconditionalFromImplications
))
</jh>

== Specification ==
We can remove a universal quantifier. This is sometimes taken as an axiom but here we prove it from the other axioms via a number of intermediate steps.<ref>[http://us.metamath.org/mpeuni/ax4.html ax4] in metamath's set.mm, accessed February 18, 2010</ref>

<jh>
thm (Specialization-18 ((y φ)) () ((y = x) → ((¬ φ) → (∀ x ((x = y) → (¬ φ))))) (
        y x EqualitySymmetry eliminateBiconditionalReverse
        x y (¬ φ) VariableSubstitution
        applySyllogism

        (¬ φ) y Generalization
        (∀ x ((x = y) → (¬ φ))) addCommonConsequent
        applySyllogism
))

thm (Specialization-22 () () ((∀ x ((x = y) → (¬ φ))) → (∀ x (φ → (¬ (x = y))))) (
        (x = y) φ TranspositionWithNegatedConsequent
        eliminateBiconditionalReverse

        x generalize

        distributeForAllImplication
))

thm (Specialization-a () () ((∀ x (φ → (¬ (x = y)))) → (¬ (∀ x φ))) (
        x φ (¬ (x = y)) ForAllImplication

        x y Existence
        (∀ x φ) (∀ x (¬ (x = y))) Transposition eliminateBiconditionalReverse
        applyNestedModusPonens

        applySyllogism
))

thm (Specialization-30 ((y φ)) () ((¬ ((∀ x φ) → φ)) → (¬ (y = x))) (
        y x φ Specialization-18
        import

        x y φ Specialization-22
        applySyllogism

        x φ y Specialization-a
        applySyllogism
        export

        (∀ x φ) φ Transposition eliminateBiconditionalForward
        applySyllogism

        introduceTransposition
))

thm (Specialization-33 ((y φ)) () 
  ((∀ y (¬ ((∀ x φ) → φ))) → (∀ y (¬ (y = x)))) (
        x φ y Specialization-30
        y generalize
        distributeForAllImplication
))
</jh>

As before, the distinct variable constraints don't get exported, as they all contain <code>y</code>.
<jh>
thm (Specialization ((x y) (y φ)) () ((∀ x φ) → φ) (
        y x Existence

        (¬ ((∀ x φ) → φ)) y Generalization
        y x φ Specialization-33
        applySyllogism

        applyModusTollens

        eliminateDoubleNegation
))
</jh>

== Builder for ∀ ==
From <code>φ → ψ</code> we want to be able to get  <code>∀xφ → ∀xψ</code>.  The easier part of this is geting the quantifier onto the antecedent:<ref>[http://us.metamath.org/mpeuni/a4s.html a4s] in metamath's set.mm, accessed February 18, 2010</ref>

<jh>
thm (a4s () ((H (φ → ψ))) ((∀ x φ) → ψ) (
        x φ Specialization
        H
        applySyllogism
))
</jh>

We get the quantifier onto the consequent via this lemma:
<jh>
#thm (ax5o () () (∀x(∀xφ → ψ) → (∀xφ → ∀xψ)) (
#))
</jh>

<jh>
#thm (addForAll () (φ ↔ ψ) (∀xφ ↔ ∀xψ) (
#...19.20i in metamath set.mm
#))
</jh>

== Relationship between universal and existential quantification ==
The axioms are written in terms of just the universal quantifier ∀. We define the existential quantifier ∃ in terms of it:

<jh>
def ((∃ x φ) (¬ (∀ x (¬ φ))))
</jh>

and the following two theorems are immediate consequences from this definition:

<jh>
thm (NotThereExists () () ((¬ (∃ x φ)) ↔ (∀ x (¬ φ))) (
        (∃ x φ) BiconditionalReflexivity
        addNegation

        (∀ x (¬ φ)) DoubleNegation swapBiconditional
        applyBiconditionalTransitivity
))

# Think we need addForAll for this
#thm (NotForAll () () ((¬ (∀ x φ)) ↔ (∃ x (¬ φ))) (
#))
</jh>

This page is not yet done.  When it is, the following export to [[Interface:First-order logic]] can be uncommented:
<jh>
#export (FIRSTORDER Interface:First-order_logic (CLASSICAL) ())
</jh>

== References ==
<references/>

[[Category:Classical first-order logic]]