{{interfaces
| imports = [[Interface:Axioms of first-order logic in terms of substitution built on equality]]
| exports = [[Interface:First-order logic with quantifiability]]
}}

We import some interfaces and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (AXIOMS Interface:Axioms_of_first-order_logic_in_terms_of_substitution_built_on_equality (CLASSICAL) ())

var (formula φ ψ χ θ)
var (object s t u s0 s1 t0 t1)
var (variable x y z x0 x1 y0 y1)
</jh>

== Rule form of specialization ==
Here is a rule form of <code>SpecializationToObject</code>.<ref>Theorem 17.1 in Margaris, page 74</ref>
<jh>
thm (specializeToObject () ((H (∀ x φ))) (subst s x φ) (
        H
        x φ s SpecializationToObject
        applyModusPonens
))
</jh>

== Existential quantification ==
We define <code>∃</code> in terms of <code>∀</code>.<ref>Margaris, page 49</ref>
<jh>
def ((∃ x φ) (¬ (∀ x (¬ φ))))
</jh>

== Existential Introduction ==
Introducing <code>∃</code> from a substitution is closely related to specializing <code>∀</code> to a substitution.<ref>Theorem 17.3, Margaris, page 75</ref>

<jh>
#thm (ThereExistsIntroductionFromObject () () ((subst s x φ) → (∃ x φ)) (
</jh>
We start with <code>∀ x ¬ φ → [ s / x ] ¬ φ</code>,
<jh>
#        x (¬ φ) s SpecializationToObject
</jh>
turn the consequent into <code>¬ [ s / x ] φ</code>,
<jh>
# HERE A MIRACLE OCCURS
</jh> 
and transpose to get <code>[ s / x ] φ → ¬ ∀ x ¬ φ<code>, which is what we want.
<jh>
#        transposeWithNegatedConsequent
#))
</jh>

== Export ==
<jh>
#export (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
</jh>

== References ==
<references/>

[[Category:Classical first-order logic]]
