{{interfaces
| imports = [[Interface:Axioms of first-order logic in terms of substitution built on equality]]
| exports = [[Interface:First-order logic with quantifiability]]
}}

We import some interfaces and define some variables:
<jh>
import (PROPOSITIONAL Interface:Classical_propositional_calculus () ())
import (AXIOMS Interface:Axioms_of_first-order_logic_in_terms_of_substitution_built_on_equality (PROPOSITIONAL) ())

var (formula φ ψ χ θ)
var (object s t u s0 s1 t0 t1)
var (variable x y z x0 x1 y0 y1)
</jh>

== Rule form of specialization ==
Here is a rule form of <code>SpecializationToObject</code>.<ref>Theorem 17.1 in Margaris, page 74</ref>
<jh>
thm (specializeToObject () ((H (∀ x φ))) (subst s x φ) (
        H
        x φ s SpecializationToObject
        applyModusPonens
))
</jh>

== Existential quantification ==
We define <code>∃</code> in terms of <code>∀</code>.<ref>Margaris, page 49</ref>
<jh>
def ((∃ x φ) (¬ (∀ x (¬ φ))))
</jh>

== Existential Introduction ==
Introducing <code>∃</code> from a substitution is closely related to specializing <code>∀</code> to a substitution.<ref>Theorem 17.3, Margaris, page 75</ref>

<jh>
thm (ThereExistsIntroductionFromObject () () ((subst s x φ) → (∃ x φ)) (
</jh>
We start with <code>∀ x ¬ φ → [ s / x ] ¬ φ</code>,
<jh>
        x (¬ φ) s SpecializationToObject
</jh>
turn the consequent into <code>¬ [ s / x ] φ</code>,
<jh>
        s x φ SubstNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh> 
and transpose to get <code>[ s / x ] φ → ¬ ∀ x ¬ φ<code>, which is what we want.
<jh>
        transposeWithNegatedConsequent
))
</jh>

Here's a rule form.<ref>Theorem 17.4, Margaris, page 75</ref>
<jh>
thm (introduceThereExistsFromObject () ((H (subst s x φ))) (∃ x φ) (
        H
        s x φ ThereExistsIntroductionFromObject
        applyModusPonens
))
</jh>

== Specialization without a substitution ==
If we substitute a variable for itself, we get the following special case of substitution, which Margaris calls "An important special case".<ref>Margaris, page 76</ref>

<jh>
thm (Specialization () () ((∀ x φ) → φ) (
        x φ (value x) SpecializationToObject

        x φ SubstItself
        eliminateBiconditionalReverse
        applySyllogism
))

thm (specialize () ((H (∀ x φ))) φ (
        H
        x φ Specialization
        applyModusPonens
))
</jh>

== Export ==
<jh>
#export (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
</jh>

== References ==
<references/>

[[Category:Classical first-order logic]]
