{{interfaces
| imports = [[Interface:Axioms of first-order logic in terms of substitution built on equality]]
| exports = [[Interface:First-order logic with quantifiability]]
}}

We import some interfaces and define some variables:
<jh>
import (PROPOSITIONAL Interface:Classical_propositional_calculus () ())
import (AXIOMS Interface:Axioms_of_first-order_logic_in_terms_of_substitution_built_on_equality (PROPOSITIONAL) ())

var (formula φ ψ χ θ)
var (object s t u s0 s1 t0 t1)
var (variable x y z x0 x1 y0 y1)
</jh>

== A few rules based on axioms ==
Here is a rule form of <code>SpecializationToObject</code>.<ref>Theorem 17.1 in Margaris, page 74</ref>
<jh>
thm (specializeToObject () ((H (∀ x φ))) (subst s x φ) (
        H
        x φ s SpecializationToObject
        applyModusPonens
))
</jh>

=== Builder for ∀ ===
For convenience, we define some rules concerning building up formulas. From <code>φ → ψ</code> we want to be able to get <code>∀ x φ → ∀ x ψ</code>.
<jh>
thm (addForAll () ((H (φ → ψ))) ((∀ x φ) → (∀ x ψ)) (
        H
        x generalize

        x φ ψ ForAllImplication

        applyModusPonens
))
</jh>

The builder for the biconditional follows trivially:
<jh>
thm (buildForAll () ((H (φ ↔ ψ))) ((∀ x φ) ↔ (∀ x ψ)) (
        H eliminateBiconditionalReverse x addForAll
        H eliminateBiconditionalForward x addForAll
        introduceBiconditionalFromImplications
))
</jh>

== Existential quantification ==
We define <code>∃</code> in terms of <code>∀</code>.<ref>Margaris, page 49</ref>
<jh>
def ((∃ x φ) (¬ (∀ x (¬ φ))))
</jh>

== Existential Introduction ==
Introducing <code>∃</code> from a substitution is closely related to specializing <code>∀</code> to a substitution.<ref>Theorem 17.3, Margaris, page 75</ref>

<jh>
thm (ThereExistsIntroductionFromObject () () ((subst s x φ) → (∃ x φ)) (
</jh>
We start with <code>∀ x ¬ φ → [ s / x ] ¬ φ</code>,
<jh>
        x (¬ φ) s SpecializationToObject
</jh>
turn the consequent into <code>¬ [ s / x ] φ</code>,
<jh>
        s x φ SubstNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh> 
and transpose to get <code>[ s / x ] φ → ¬ ∀ x ¬ φ<code>, which is what we want.
<jh>
        transposeWithNegatedConsequent
))
</jh>

Here's a rule form.<ref>Theorem 17.4, Margaris, page 75</ref>
<jh>
thm (introduceThereExistsFromObject () ((H (subst s x φ))) (∃ x φ) (
        H
        s x φ ThereExistsIntroductionFromObject
        applyModusPonens
))
</jh>

== Specialization and existential introduction without a substitution ==
If we substitute a variable for itself, we get the following special case of substitution, which Margaris calls "An important special case".<ref>Margaris, page 76</ref>

<jh>
thm (Specialization () () ((∀ x φ) → φ) (
        x φ (value x) SpecializationToObject

        x φ SubstItself
        eliminateBiconditionalReverse
        applySyllogism
))

thm (specialize () ((H (∀ x φ))) φ (
        H
        x φ Specialization
        applyModusPonens
))
</jh>

Likewise, <code>φ → ∃ x φ</code> is a special case of <code>[ s / x ] φ → ∃ x φ</code>.<ref>Margaris, page 76</ref>

<jh>
thm (ThereExistsIntroduction () () (φ → (∃ x φ)) (
        x φ SubstItself
        eliminateBiconditionalForward

        (value x) x φ ThereExistsIntroductionFromObject
        applySyllogism
))
</jh>

The previous results let us conclude <code>∀ x φ → ∃ x φ</code>.<ref>Theorem 17.6, Margaris, page 76</ref>
<jh>
thm (ForAllThereExists () () ((∀ x φ) → (∃ x φ)) (
        x φ Specialization
        φ x ThereExistsIntroduction
        applySyllogism
))
</jh>

== Quantifier commutation ==
We can exchange the order of universal quantifiers.<ref>Theorem 17.10, Margaris, page 78</ref> Margaris's proof doesn't quite work as-is, as it relies on the deduction theorem, but a fairly small variation of it avoids this problem.
<jh>
thm (ForAllCommutationImplication () () ((∀ x (∀ y φ)) → (∀ y (∀ x φ))) (
</jh>
First we add <code>∀ x</code> to the start of <code>∀ x ∀ y φ</code>.
<jh>
        x (∀ y φ) BoundForAllNotFree
        GeneralizationNotFree
</jh>
Then we add <code>∀ y</code> to the start.
<jh>
        y φ BoundForAllNotFree
        x addForAllNotFree
        x addForAllNotFree
        GeneralizationNotFree
        applySyllogism
</jh>
That gives us <code>∀ y ∀ x ∀ x ∀ y φ</code> and dropping the last two quantifiers we are done.
<jh>
        y φ Specialization
        x addForAll
        x addForAll
        y addForAll
        applySyllogism

        x φ Specialization
        x addForAll
        y addForAll
        applySyllogism
))
</jh>

The biconditional version follows trivially.<ref>Theorem 19.2, Margaris, page 91, which metamath cites as 19.5</ref>
<jh>
thm (ForAllCommutation () () ((∀ x (∀ y φ)) ↔ (∀ y (∀ x φ))) (
        x y φ ForAllCommutationImplication
        y x φ ForAllCommutationImplication
        introduceBiconditionalFromImplications
))
</jh>

== Export ==
<jh>
#export (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
</jh>

== References ==
<references/>

[[Category:Classical first-order logic]]
