{{interfaces
| imports = [[Interface:Axioms of first-order logic in terms of substitution built on equality]]
| exports = [[Interface:First-order logic with quantifiability]]
}}

We import some interfaces and define some variables:
<jh>
import (PROPOSITIONAL Interface:Classical_propositional_calculus () ())
import (AXIOMS Interface:Axioms_of_first-order_logic_in_terms_of_substitution_built_on_equality (PROPOSITIONAL) ())

var (formula φ ψ χ θ φx φy)
var (object s t u s0 s1 t0 t1)
var (variable x y z x0 x1 y0 y1)
</jh>

== A few rules based on axioms ==
Here is a rule form of <code>SpecializationToObject</code>.<ref>Theorem 17.1 in Margaris, page 74</ref>
<jh>
thm (specializeToObject () ((H (∀ x φ))) (subst s x φ) (
        H
        x φ s SpecializationToObject
        applyModusPonens
))
</jh>

=== Builder for ∀ ===
For convenience, we define some rules concerning building up formulas. From <code>φ → ψ</code> we want to be able to get <code>∀ x φ → ∀ x ψ</code>.
<jh>
thm (addForAll () ((H (φ → ψ))) ((∀ x φ) → (∀ x ψ)) (
        H
        x generalize

        x φ ψ ForAllImplication

        applyModusPonens
))
</jh>

The builder for the biconditional follows trivially:
<jh>
thm (buildForAll () ((H (φ ↔ ψ))) ((∀ x φ) ↔ (∀ x ψ)) (
        H eliminateBiconditionalReverse x addForAll
        H eliminateBiconditionalForward x addForAll
        introduceBiconditionalFromImplications
))
</jh>

== Existential quantification ==
We define <code>∃</code> in terms of <code>∀</code>.<ref>Margaris, page 49</ref>
<jh>
def ((∃ x φ) (¬ (∀ x (¬ φ))))
</jh>

== Existential Introduction ==
Introducing <code>∃</code> from a substitution is closely related to specializing <code>∀</code> to a substitution.<ref>Theorem 17.3, Margaris, page 75</ref>

<jh>
thm (ThereExistsIntroductionFromObject () () ((subst s x φ) → (∃ x φ)) (
</jh>
We start with <code>∀ x ¬ φ → [ s / x ] ¬ φ</code>,
<jh>
        x (¬ φ) s SpecializationToObject
</jh>
turn the consequent into <code>¬ [ s / x ] φ</code>,
<jh>
        s x φ SubstNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh> 
and transpose to get <code>[ s / x ] φ → ¬ ∀ x ¬ φ<code>, which is what we want.
<jh>
        transposeWithNegatedConsequent
))
</jh>

Here's a rule form.<ref>Theorem 17.4, Margaris, page 75</ref>
<jh>
thm (introduceThereExistsFromObject () ((H (subst s x φ))) (∃ x φ) (
        H
        s x φ ThereExistsIntroductionFromObject
        applyModusPonens
))
</jh>

== Specialization and existential introduction without a substitution ==
If we substitute a variable for itself, we get the following special case of substitution, which Margaris calls "An important special case".<ref>Margaris, page 76</ref>

<jh>
thm (Specialization () () ((∀ x φ) → φ) (
        x φ (value x) SpecializationToObject

        x φ SubstItself
        eliminateBiconditionalReverse
        applySyllogism
))

thm (specialize () ((H (∀ x φ))) φ (
        H
        x φ Specialization
        applyModusPonens
))
</jh>

Likewise, <code>φ → ∃ x φ</code> is a special case of <code>[ s / x ] φ → ∃ x φ</code>.<ref>Margaris, page 76</ref>

<jh>
thm (ThereExistsIntroduction () () (φ → (∃ x φ)) (
        x φ SubstItself
        eliminateBiconditionalForward

        (value x) x φ ThereExistsIntroductionFromObject
        applySyllogism
))
</jh>

The previous results let us conclude <code>∀ x φ → ∃ x φ</code>.<ref>Theorem 17.6, Margaris, page 76</ref>
<jh>
thm (ForAllThereExists () () ((∀ x φ) → (∃ x φ)) (
        x φ Specialization
        φ x ThereExistsIntroduction
        applySyllogism
))
</jh>

== Quantifier commutation ==
We can exchange the order of universal quantifiers.<ref>Theorem 17.10, Margaris, page 78</ref> Margaris's proof doesn't quite work as-is, as it relies on the deduction theorem, but a fairly small variation of it avoids this problem.
<jh>
thm (ForAllCommutationImplication () () ((∀ x (∀ y φ)) → (∀ y (∀ x φ))) (
</jh>
First we add <code>∀ x</code> to the start of <code>∀ x ∀ y φ</code>.
<jh>
        x (∀ y φ) BoundForAllNotFree
        GeneralizationNotFree
</jh>
Then we add <code>∀ y</code> to the start.
<jh>
        y φ BoundForAllNotFree
        x addForAllNotFree
        x addForAllNotFree
        GeneralizationNotFree
        applySyllogism
</jh>
That gives us <code>∀ y ∀ x ∀ x ∀ y φ</code> and dropping the last two quantifiers we are done.
<jh>
        y φ Specialization
        x addForAll
        x addForAll
        y addForAll
        applySyllogism

        x φ Specialization
        x addForAll
        y addForAll
        applySyllogism
))
</jh>

The biconditional version follows trivially.<ref>Theorem 19.2, Margaris, page 91, which metamath cites as 19.5</ref>
<jh>
thm (ForAllCommutation () () ((∀ x (∀ y φ)) ↔ (∀ y (∀ x φ))) (
        x y φ ForAllCommutationImplication
        y x φ ForAllCommutationImplication
        introduceBiconditionalFromImplications
))
</jh>

== Adding and removing quantifiers ==
Although Margaris does not tackle the biconditionalized version of this theorem until later, it will be convenient to prove it now. It is that <code>∀ x φ ↔ φ</code>, if <code>x</code> is not free in <code>φ</code>.<ref>Theorem 19.1, Margaris, page 90, cited by metamath as 19.3</ref>

<jh>
thm (ForAllAddRemoveNotFree () ((XFREE (x is-not-free-in φ))) ((∀ x φ) ↔ φ) (
        x φ Specialization

        XFREE
        GeneralizationNotFree

        introduceBiconditionalFromImplications
))
</jh>

== Moving is-not-free-in across connectives ==
The idea that a variable which is not free in the left hand and right hand sides of a connective is not free in the connected formula is basic to the understanding of what it means for a variable to not be free in a formula. We adopted this as an axiom for negation and implication. Here we prove it from the other three connectives, which follow easily from the two axioms.

=== Disjunction ===
<jh>
thm (disjunctionNotFree ()
  ((HPHI (x is-not-free-in φ)) (HPSI (x is-not-free-in ψ)))
  (x is-not-free-in (φ ∨ ψ)) (
        HPHI
        negateNotFree

        HPSI
        implicationNotFree
</jh>
So far that's <code>x is-not-free-in (¬ φ → ψ)</code>. Turning the implication to a disjunction we are done.
<jh>
        φ ψ DisjunctionImplication
        x buildNotFree
        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

=== Conjunction ===
<jh>
thm (conjunctionNotFree ()
  ((HPHI (x is-not-free-in φ)) (HPSI (x is-not-free-in ψ)))
  (x is-not-free-in (φ ∧ ψ)) (
        HPHI
        negateNotFree

        HPSI
        negateNotFree

        disjunctionNotFree
        negateNotFree

        φ ψ DeMorganNDN
        x buildNotFree
        eliminateBiconditionalReverse
        applyModusPonens
))
</jh>

=== Biconditional ===
<jh>
thm (biconditionalNotFree ()
  ((HPHI (x is-not-free-in φ)) (HPSI (x is-not-free-in ψ)))
  (x is-not-free-in (φ ↔ ψ)) (
        HPHI
        HPSI
        implicationNotFree

        HPSI
        HPHI
        implicationNotFree

        conjunctionNotFree

        φ ψ BiconditionalImplication
        x buildNotFree
        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

=== Existential quantification ===
In a manner similar to the connectives, freeness for <code>∃</code> follows from the corresponding axioms for <code>∀</code>.
<jh>
thm (BoundThereExistsNotFree () () (x is-not-free-in (∃ x φ)) (
        x (¬ φ) BoundForAllNotFree
        negateNotFree
))

thm (addThereExistsNotFree () ((HFREE (x is-not-free-in φ))) (x is-not-free-in (∃ y φ)) (
        HFREE
        negateNotFree
        y addForAllNotFree
        negateNotFree
))
</jh>

== Adding existential quantification to the antecedent ==
Margaris expresses many of his proofs in terms of a rule which he calls ''Rule C''.<ref>Theorem 17.12, Margaris, page 79</ref> We give a few variants of rule C, one is that given <code>φ → ψ</code> we can conclude <code>∃ φ → ψ</code>, provided that <code>x</code> is not free in <code>Ψ</code>. Margaris' version basically combines this with the deduction theorem.

The first variation is Theorem 17.11 in Margaris.<ref>Margaris, page 78</ref>
<jh>
thm (ThereExistsAntecedentIntroductionNotFree ()
  ((HFREE (x is-not-free-in ψ)))
  ((∀ x (φ → ψ)) → ((∃ x φ) → ψ)) (
</jh>
We start with <code>∀ x (φ → ψ) → (∀ x ¬ ψ → ∀ x ¬ φ)</code>.
<jh>
        φ ψ Transposition
        eliminateBiconditionalReverse
        x addForAll

        x (¬ ψ) (¬ φ) ForAllImplication
        applySyllogism
</jh>
Now we change <code>∀ x ¬ ψ</code> to <code>¬ ψ</code>.
<jh>
        HFREE
        negateNotFree

        ForAllAddRemoveNotFree

        transformImplicationImplicationAntecedent
</jh>
Then we turn <code>¬ ψ → ∀ x ¬ φ</code> into <code>¬ ∀ x ¬ φ → ψ</code>, which is all we need.
<jh>
        ψ (∀ x (¬ φ)) TranspositionWithNegatedAntecedent
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

The other variations are direct consequences of this one.
<jh>
thm (addThereExistsToAntecedentNotFree ()
  ((HFREE (x is-not-free-in ψ)) (HIMP (φ → ψ)))
  ((∃ x φ) → ψ) (
        HIMP
        x generalize

        HFREE
        φ ThereExistsAntecedentIntroductionNotFree

        applyModusPonens
))

thm (addThereExistsToAntecedent ((x ψ))
  ((H (φ → ψ)))
  ((∃ x φ) → ψ) (
        x ψ DistinctNotFree
        H
        addThereExistsToAntecedentNotFree
))
</jh>

We now prove a number of theorems using the ability to add there exists to the antecedent.

=== There exists across a conjunction ===
There exists can be split across a conjunction.<ref>Theorem 17.14, Margaris, page 80</ref>
<jh>
thm (ThereExistsConjunction () () ((∃ x (φ ∧ ψ)) → ((∃ x φ) ∧ (∃ x ψ))) (
</jh>
We start with <code>x is-not-free-in (∃ x φ ∧ ∃ x ψ)</code>.
<jh>
        x φ BoundThereExistsNotFree
        x ψ BoundThereExistsNotFree
        conjunctionNotFree
</jh>
The other part of the proof is <code>φ ∧ ψ → ∃ x φ ∧ ∃ x ψ</code>.
<jh>
        φ ψ ConjunctionRightElimination

        φ x ThereExistsIntroduction
        applySyllogism

        φ ψ ConjunctionLeftElimination

        ψ x ThereExistsIntroduction
        applySyllogism

        composeConjunction

        addThereExistsToAntecedentNotFree
))
</jh>

=== Adding there exists to both sides of an implication ===
Here we prove <code>∀ x (φ → ψ) → (∃ x φ → ∃ x ψ)</code>.<ref>Theorem 17.15, Margaris, page 80</ref>
<jh>
thm (ForAllImplicationThereExists () () ((∀ x (φ → ψ)) → ((∃ x φ) → (∃ x ψ))) (
</jh>
We start with <code>∀ x (φ → ψ) → ∀ x (φ → ∃ x ψ)</code>.
<jh>
        ψ x ThereExistsIntroduction
        φ addCommonAntecedent
        x addForAll
</jh>
Combining that with <code>∀ x (φ → ∃ x ψ) → (∃ x φ → ∃ x ψ)</code> we are done.
<jh>
        x ψ BoundThereExistsNotFree
        φ ThereExistsAntecedentIntroductionNotFree

        applySyllogism
))
</jh>

=== There exists commutation ===
The next theorem is <code>∃ x ∃ y φ → ∃ y ∃ x φ</code>.<ref>Theorem 17.17, Margaris, page 81</ref>  We could, of course, prove this as a consequence of the corresponding theorem for <code>∀</code>, but instead we follow Margaris's proof, which adds the quantifiers with <code>ThereExistsIntroduction</code> and removes them with <code>addThereExistsToAntecedentNotFree</code>.
<jh>
thm (ThereExistsCommutationImplication () () ((∃ x (∃ y φ)) → (∃ y (∃ x φ))) (
</jh>
When we invoke <code>addThereExistsToAntecedentNotFree</code>, it will expect the freeness hypotheses before the implications, so we start by sticking <code>x is-not-free-in ∃ y ∃ x φ</code> and <code>y is-not-free-in ∃ y ∃ x φ</code> onto the proof stack.
<jh>
        x φ BoundThereExistsNotFree
        y addThereExistsNotFree

        y (∃ x φ) BoundThereExistsNotFree
</jh>
Now we can prove <code>φ → ∃ y ∃ x φ</code> and then add the quantifiers to the antecedent.
<jh>
        φ x ThereExistsIntroduction

        (∃ x φ) y ThereExistsIntroduction
        applySyllogism

        addThereExistsToAntecedentNotFree

        addThereExistsToAntecedentNotFree
))
</jh>

The biconditional version follows trivially.<ref>Theorem scheme 11 on Margaris, page 89, which metamath cites as 19.11</ref>
<jh>
thm (ThereExistsCommutation () () ((∃ x (∃ y φ)) ↔ (∃ y (∃ x φ))) (
        x y φ ThereExistsCommutationImplication
        y x φ ThereExistsCommutationImplication
        introduceBiconditionalFromImplications
))
</jh>

== Equivalence and replacement ==
Although we don't develop a detailed theory of equivalence and replacement (involving substituting equals for equals) quite the way that Margaris presents it, many of the theorems in this chapter of Margaris apply here.

=== Adding for-all to the consequent ===
Here we prove <code>∀ x (φ → ψ) ↔ (φ → ∀ x ψ)</code>, where <code>x</code> is not free in <code>φ</code>,<ref>Theorem scheme 21 in Margaris, page 90, cited by metamath as 19.21</ref> and some related theorems and rules. Although Margaris does not emphasize this theorem, it forms the counterpart to adding there exists to the antecedent. That is, Margaris proofs which invoke Rule C can be translated fairly directly into proofs which invoke <code>addThereExistsToAntecedentNotFree</code>, and Margaris proofs which invoke generalization combined with the deduction theorem can be translated similarly into proofs which invoke <code>addForAllToConsequentNotFree</code>.

<jh>
thm (ForAllConsequentNotFreeForward ()
  ((HFREE (x is-not-free-in φ)))
  ((∀ x (φ → ψ)) → (φ → (∀ x ψ))) (
        x φ ψ ForAllImplication

        HFREE
        ForAllAddRemoveNotFree
        eliminateBiconditionalForward

        (∀ x ψ) addCommonConsequent

        applySyllogism
))

thm (addForAllToConsequentNotFree () ((HFREE (x is-not-free-in φ)) (HIMP (φ → ψ)))
  (φ → (∀ x ψ)) (
        HIMP
        x generalize

        HFREE
        ψ ForAllConsequentNotFreeForward

        applyModusPonens
))

thm (ForAllConsequentNotFreeReverse ()
  ((HFREE (x is-not-free-in φ)))
  ((φ → (∀ x ψ)) → (∀ x (φ → ψ))) (
</jh>
This proof is adapted from metamath.<ref>[http://us.metamath.org/mpeuni/19.21.html 19.21], metamath's set.mm, accessed Jan 2012</ref> We start with <code>x is-not-free-in (φ → ∀ x ψ)<code>.
<jh>
        HFREE
        x ψ BoundForAllNotFree
        implicationNotFree
</jh>
Now specialization and adding for all to the consequent finish the job.
<jh>
        x ψ Specialization
        φ addCommonAntecedent
        addForAllToConsequentNotFree
))

thm (ForAllConsequentNotFree ()
  ((HFREE (x is-not-free-in φ)))
  ((∀ x (φ → ψ)) ↔ (φ → (∀ x ψ))) (
        HFREE
        ψ ForAllConsequentNotFreeForward

        HFREE
        ψ ForAllConsequentNotFreeReverse

        introduceBiconditionalFromImplications
))

thm (addForAllToConsequent ((x φ))
  ((H (φ → ψ)))
  (φ → (∀ x ψ)) (
        x φ DistinctNotFree
        H
        addForAllToConsequentNotFree
))
</jh>

=== For all across a biconditional ===
We can distribute for all across a biconditional.<ref>Theorem 18.1, Margaris, page 83</ref> Although we probably could more or less follow Margaris's proof using <code>ForAllConsequentNotFree</code> and the like, there are some complications in translating that proof to our setup (which lacks the deduction theorem), so we opt for a simpler proof based more directly on <code>ForAllImplication</code>.
<jh>
thm (ForAllBiconditionalImplication () () ((∀ x (φ ↔ ψ)) → ((∀ x φ) → (∀ x ψ))) (
        φ ψ BiconditionalReverseElimination
        x addForAll

        x φ ψ ForAllImplication
        applySyllogism
))

thm (ForAllBiconditional () () ((∀ x (φ ↔ ψ)) → ((∀ x φ) ↔ (∀ x ψ))) (
        x φ ψ ForAllBiconditionalImplication

        φ ψ BiconditionalSymmetry
        eliminateBiconditionalReverse
        x addForAll

        x ψ φ ForAllBiconditionalImplication
        applySyllogism

        introduceBiconditionalFromImplicationsInConsequent
))
</jh>

=== Replacement ===
For Margaris, the ability to replace a formula with one which is equivalent to it is stated in terms of substituting a formula for a subformula of a larger formula. The equivalent for us can accomplish the same things, but is a bit more low-level, and consists of various theorems involving biconditionals. We have already seen <code>buildForAll</code> and similar theorems for propositional logic. Here is the counterpart for <code>∃</code>.
<jh>
thm (buildThereExists () ((H (φ ↔ ψ))) ((∃ x φ) ↔ (∃ x ψ)) (
        H
        addNegation
        x buildForAll
        addNegation
))
</jh>

=== Negation and quantifiers ===
Margaris next proves <code>∀ x φ ↔ ¬ ∃ x ¬ φ</code>, using replacement.<ref>Theorem 18.5, Margaris, page 85</ref> We don't need that particular theorem to export to [[Interface:First-order logic with quantifiability]], so we can demonstrate the same replacement-like reasoning with <code>∃ x ¬ φ ↔ ¬ ∀ x φ</code>.<ref>Theorem scheme 14, Margaris, page 90</ref> The proof starts with <code>φ ↔ ¬ ¬ φ</code>, but we then need to replace this formula within a quantifier and a negation, which in Margaris is done with the replacement theorem and in our case is done with <code>buildForAll</code> and <code>addNegation</code>.
<jh>
thm (NotForAll () () ((¬ (∀ x φ)) ↔ (∃ x (¬ φ))) (
        φ DoubleNegation
        x buildForAll
        addNegation
))
</jh>

=== Change of variable in ∀ ===
We now turn to changing the variable of quantification. Margaris explains this in terms of whether two formulas <code>φ(x)</code> and <code>φ(y)</code> are ''similar''. Our equivalent is fairly close; the distinct variable constraint between <code>x</code> and <code>y</code> corresponds to Margaris' requirement of two distinct variables; the distinct variable constraints <code>(y φx) (x φy)</code> correspond to Margaris' statement that <code>x</code> must not be free in <code>φ(y)</code> and <code>y</code> must not be free in <code>φ(x)</code>. Margaris' requirement that <code>φ(x)</code> be the same as <code>[ x / y ] φ(y)</code> and that <code>φ(y)</code> be the same as <code>[ y / x ] φ(x)</code> correspond to the hypothesis <code>x = y → (φx ↔ φy)</code>. These definitions in Margaris can be found on page 86, which also contains Margaris' statement of <code>ChangeVariableForAll<code>, which is Theorem 18.6.

<jh>
thm (ChangeVariableForAllImplication ((y φx) (x φy) (x y))
  ((H (((value x) = (value y)) → (φx ↔ φy))))
  ((∀ x φx) → (∀ y φy)) (
</jh>
We start with <code>∀ x φx → [ y / x ] φx</code> and then add <code>∀ y</code> to the consequent.
<jh>
        x φx (value y) SpecializationToObject
        y addForAllToConsequent
</jh>
Our hypothesis easily leads to <code>[ y / x ] φx ↔ φy</code>.
<jh>
        H
        makeSubstExplicit
</jh>
Combining those two results we are done.
<jh>
        eliminateBiconditionalReverse
        y addForAll
        applySyllogism
))

thm (ChangeVariableForAll ((y φx) (x φy) (x y))
  ((H (((value x) = (value y)) → (φx ↔ φy))))
  ((∀ x φx) ↔ (∀ y φy)) (
</jh>
The forward implication is what we just proved.
<jh>
        H ChangeVariableForAllImplication

</jh>
The reverse implication is much the same. We just need to start out by transforming the hypothesis into <code>y = x → (φy ↔ φx)</code>.
<jh>
        H
        (value x) (value y) EqualitySymmetry
        transformAntecedent

        φx φy BiconditionalSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        ChangeVariableForAllImplication

        introduceBiconditionalFromImplications
))
</jh>

=== Change of variable in ∃ ===
Although it should be possible to provide the corresponding theorem for ∃ via <code>ThereExistsIntroductionFromObject</code> and the like, to keep things simple we just follow Margaris' proof which derives it from the one for ∀.<ref>Theorem 18.8, Margaris, page 86</ref>
<jh>
thm (ChangeVariableThereExists
  ((y φx) (x φy) (x y))
  ((H (((value x) = (value y)) → (φx ↔ φy))))
  ((∃ x φx) ↔ (∃ y φy)) (
        H
        φx φy NegationFunction
        eliminateBiconditionalReverse
        applySyllogism

        ChangeVariableForAll
        addNegation
))
</jh>

== Equality ==
Margaris considers equality in chapter 21.<ref>Margaris, page 104</ref> Most of the theorems there we have already adopted as axioms, but there are a variety of convenience theorems and the like to prove before we can export to [[Interface:First-order logic with quantifiability]].
<jh>
def ((≠ s t) (¬ (s = t)))
</jh>

== Export ==
<jh>
#export (FIRSTORDER Interface:First-order_logic_with_quantifiability (PROPOSITIONAL) ())
</jh>

== References ==
<references/>

[[Category:Classical first-order logic]]
