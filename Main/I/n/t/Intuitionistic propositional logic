{{header
 | title    = Intuitionistic propositional logic
 | subtitle =
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = The purpose of this page is to prove the statements of [[Interface:Intuitionistic propositional logic]] from the [[Interface:Axioms of intuitionistic propositional logic]].
}}
{{interfaces
| imports = [[Interface:Axioms of intuitionistic propositional logic]]
| exports = [[Interface:Intuitionistic propositional logic]]
}}

<jh>
import (AXIOMS Interface:Axioms_of_intuitionistic_propositional_logic () ())
</jh>
We define some variables for [[w:well-formed formula|well-formed formula]]s:
<jh>
var (formula p q r s)
</jh>

Some of the proofs here are adapted, or even entirely copy-pasted, from pages such as [[Principia Mathematica propositional logic]] or [[Standard axioms imply Principia Mathematica axioms]]. It would be possible to reduce this duplication by having some of the other pages build on [[Interface:Intuitionistic propositional logic]], but the presentation might become less clear in other ways (certainly it would less closely track the way things are developed in ''Principia''), so we do not currently have the intuitionistic tail wag the classical dog.

Some proofs are taken from metamath's set.mm.  In particular, metamath's section "Logical implication" makes use only of the two axioms <code>Simp</code> and <code>Frege</code>, and thus is entirely valid in an intuitionistic context.<ref>[http://us.metamath.org/mpeuni/mmtheorems.html#mm2b Propositional calculus], from Metamath Proof Explorer, accessed February 26, 2010</ref>

== Implication ==

=== Rule for antecedent distribution ===

It will be convenient to have the ''Frege'' axiom as a rule:
<jh>
thm (distributeAntecedent () ((H (p → (q → r)))) ((p → q) → (p → r)) (
        H
        p q r Frege
        applyModusPonens
))
</jh>

=== Syllogism ===

Next we derive the syllogism, which allows us to combine several implications.
<jh>
thm (applySyllogism () ((H1 (p → q)) (H2 (q → r))) (p → r) (
        H1

</jh>
First we turn <code>q → r</code> into <code>p → (q → r)</code>:
<jh>
        H2
        (q → r) p Simp
        applyModusPonens

</jh>
Then we turn that into <code>(p → q) → (p → r)</code>:
<jh>
        distributeAntecedent

</jh>
Now we can apply modus ponens to get our desired result:
<jh>
        applyModusPonens
))
</jh>

=== Implication reflexivity ===

Any proposition implies itself:
<jh>
thm (Id () () (p → p) (
        p p Simp

        p (p → p) Simp
        p (p → p) p Frege
        applyModusPonens

        applyModusPonens
))

# Alternate name for the same theorem:
thm (ImplicationReflexivity () () (p → p) (
        p Id
))
</jh>

=== More common operations ===
Given a nested implication we often want to exchange the two antecedents:
<jh>
thm (applyComm () ((H (p → (q → r)))) (q → (p → r)) (
        q p Simp

        H
        distributeAntecedent

        applySyllogism
))
</jh>

If we have an implication, adding a common term to the antecedent and the consequent yields a new theorem:
<jh>
thm (CommonAntecedentAddition () () ((p → q) → ((r → p) → (r → q))) (
        (p → q) r Simp
        r p q Frege
        applySyllogism
))

thm (addCommonAntecedent () ((H (p → q))) ((r → p) → (r → q)) (
        H
        (p → q) r Simp
        applyModusPonens

        distributeAntecedent
))
</jh>

The analogous operation adding consequents swaps the initial antecedent and consequent:
<jh>
thm (CommonConsequentAddition () () 
  ((p → q) → ((q → r) → (p → r))) (
        q r p CommonAntecedentAddition
        applyComm
))

thm (addCommonConsequent () ((H (p → q))) ((q → r) → (p → r)) (
        H

        p q r CommonConsequentAddition

        applyModusPonens
))
</jh>

Here's a theorem form of <code>applyComm</code>:
<jh>
thm (Comm () () ((p → (q → r)) → (q → (p → r))) (
        p q r Frege

        q p Simp
        (p → r) addCommonConsequent

        applySyllogism
))
</jh>

=== Absorb redundant antecedent ===

We can absorb a redundant antecedent:
<jh>
thm (RedundantAntecedentAbsorption () ()
  ((p → (p → q)) → (p → q)) (
        p Id

        p p q Frege
        applyComm

        applyModusPonens
))

thm (absorbRedundantAntecedent () ((H (p → (p → q)))) (p → q) (
        p Id

        H
        distributeAntecedent

        applyModusPonens
))
</jh>

=== Antecedent introduction ===
We provide another name and a rule form for the <code>Simp</code> axiom:
<jh>
thm (AntecedentIntroduction () () (p → (q → p)) (
        p q Simp
))

thm (introduceAntecedent () ((H p)) (q → p) (
        H
        p q AntecedentIntroduction
        applyModusPonens
))
</jh>

=== Converse of antecedent distribution ===
The converse of the <code>Frege</code> axiom also holds.<ref>[http://us.metamath.org/mpeuni/pm2.86.html pm2.86] in metamath's set.mm, accessed May 14, 2010</ref>
<jh>
thm (FregeConverse () () (((p → q) → (p → r)) → (p → (q → r))) (
</jh>
We start with <code>q → (p → q)</code>:
<jh>
        q p Simp
</jh>
Adding a common consequent gets us most of the way, to <code>((p → q) → (p → r)) → (q → (p → r))</code>:
<jh>
        (p → r) addCommonConsequent
</jh>
Now we just switch <code>p</code> and <code>q</code> in <code>q → (p → r)</code> and we're done:
<jh>
        q p r Comm
        applySyllogism
))

thm (collectAntecedent () ((H ((p → q) → (p → r)))) (p → (q → r)) (
        H
        p q r FregeConverse
        applyModusPonens
))
</jh>

=== Syllogism in the consequent ===
This theorem is similar to syllogism, but where each piece has a common antecedent.
<jh>
thm (SyllogismInConsequent () () ((p → (q → r)) → ((p → (r → s)) → (p → (q → s)))) (
        q r s CommonConsequentAddition
        p addCommonAntecedent

        p (r → s) (q → s) Frege
        applySyllogism
))

thm (applySyllogismInConsequent () ((H1 (p → (q → r))) (H2 (p → (r → s)))) (p → (q → s)) (
        H2
        H1
        p q r s SyllogismInConsequent
        applyModusPonens
        applyModusPonens
))
</jh>

== Conjunction ==

=== Rules ===
If we can prove two propositions, the conjunction of the two follows (this is just a rule form of the <code>ConjunctionRightIntroduction</code> axiom):
<jh>
thm (introduceConjunction ()
  ((HLEFT p) (HRIGHT q))
  (p ∧ q) (
        HRIGHT
        HLEFT
        p q ConjunctionRightIntroduction
        applyModusPonens
        applyModusPonens
))
</jh>

Here are rules for the <code>ConjunctionLeftElimination</code> and <code>ConjunctionRightElimination</code> axioms:
<jh>
thm (eliminateLeftConjunct () ((H (p ∧ q))) q (
        H
        p q ConjunctionLeftElimination
        applyModusPonens
))

thm (eliminateRightConjunct () ((H (p ∧ q))) p (
        H
        p q ConjunctionRightElimination
        applyModusPonens
))
</jh>

=== Left introduction ===
Most of the introduction and elimination statements we need to provide are axioms, but this one is a simple consequence of the axioms:
<jh>
thm (ConjunctionLeftIntroduction () () (p → (q → (q ∧ p))) (
        q p ConjunctionRightIntroduction
        applyComm
))
</jh>

=== Conjunction composition ===
Our first major theorem relating conjunction to implication is composition: from <code>p → q</code> and <code>p → r</code>, we can conclude <code>p → (q ∧ r)</code>.
<jh>
thm (ConjunctionComposition1 () () ((p → q) → ((p → r) → (p → (q ∧ r)))) (
</jh>
The proof starts with <code>q → (r → (q ∧ r))</code>:
<jh>
        q r ConjunctionRightIntroduction
</jh>
and then adds <code>p</code> as an antecedent to each of <code>q</code>, <code>r</code>, and <code>q ∧ r</code>:
<jh>
        p addCommonAntecedent

        p r (q ∧ r) Frege
        applySyllogism
))

thm (composeConjunction () ((HQ (p → q)) (HR (p → r))) (p → (q ∧ r)) (
        HR
        HQ
        p q r ConjunctionComposition1
        applyModusPonens
        applyModusPonens
))
</jh>

We also prove a version of the converse:
<jh>
thm (ConjunctionCompositionReverse () () ((p → (q ∧ r)) → ((p → q) ∧ (p → r))) (
</jh>
We start with <code>(p → (q ∧ r)) → (p → q)</code>:
<jh>
        q r ConjunctionRightElimination
        p addCommonAntecedent
</jh>
And the analogue for <code>r</code>, <code>(p → (q ∧ r)) → (p → r)</code>:
<jh>
        q r ConjunctionLeftElimination
        p addCommonAntecedent
</jh>
Combining the two gives us our result:
<jh>
        composeConjunction
))

thm (extractLeftConjunction () ((H (p → (q ∧ r)))) (p → q) (
        H
        q r ConjunctionRightElimination
        applySyllogism
))

thm (extractRightConjunction () ((H (p → (q ∧ r)))) (p → r) (
        H
        q r ConjunctionLeftElimination
        applySyllogism
))
</jh>

=== Export and import ===
The import and export theorems from classical propositional logic also hold in intuitionistic logic. We start with export, <code>(p ∧ q → r) → (p → (q → r))</code>. The proof is based around a variant of CommonConsequentAddition which has two antecedents, rather than one.

<jh>
var (formula common)
thm (CommonConsequentAdditionToNestedImplication () ()
  ((p → (q → r)) → ((r → common) → (p → (q → common)))) (
        r common q CommonAntecedentAddition
        (q → r) (q → common) p CommonAntecedentAddition
        applySyllogism

        applyComm
))

thm (Exportation () () (((p ∧ q) → r) → (p → (q → r))) (
        p q ConjunctionRightIntroduction
        p q (p ∧ q) r CommonConsequentAdditionToNestedImplication
        applyModusPonens
))

thm (export () ((H ((p ∧ q) → r))) (p → (q → r)) (
        H
        p q r Exportation
        applyModusPonens
))
</jh>

The proof of export was based around having a conjunction as a consequent, that is <code>p → (q → p ∧ q)</code>.  The proof of import is based around <code>p ∧ q → p</code> (and likewise for <code>q</code>). The following lemma is what we'll use to glue together the different parts of the proof, and is basically a gussied up variant of applySyllogism:

<jh>
var (formula P Q R)
thm (ImportLemma () 
  ((H1 (P → (Q → R))) (H2 (R → (Q → r))))
  (P → (Q → r)) (
        H1

        H2
        Q addCommonAntecedent

        applySyllogism
</jh>
Now we have <code>P → (Q → (Q → r))</code>, and just need to remove the extra <code>Q</code>:
<jh>
        Q r RedundantAntecedentAbsorption
        applySyllogism
))

thm (Importation () () ((p → (q → r)) → ((p ∧ q) → r)) (
        p q ConjunctionRightElimination
        (q → r) addCommonConsequent

        p q ConjunctionLeftElimination
        r addCommonConsequent

        ImportLemma
))

thm (import () ((H (p → (q → r)))) ((p ∧ q) → r) (
        H
        p q r Importation
        applyModusPonens
))
</jh>

=== Implication transitivity and other consequences of import ====
The form of the syllogism in [[Interface:Intuitionistic propositional logic]] is easy now that we have import:

<jh>
thm (ImplicationTransitivity () () 
  (((p → q) ∧ (q → r)) → (p → r)) (
        p q r CommonConsequentAddition
        import
))
</jh>

Likewise, we restate <code>ConjunctionComposition1</code> using the new tool:
<jh>
thm (ConjunctionCompositionForward () () (((p → q) ∧ (p → r)) → (p → (q ∧ r))) (
        p q r ConjunctionComposition1
        import
))
</jh>

=== Commutativity ===
<jh>
thm (ConjunctionCommutativityImplication () () ((p ∧ q) → (q ∧ p)) (
        p q ConjunctionLeftElimination
        p q ConjunctionRightElimination
        composeConjunction
))

thm (swapConjunction () ((H (p ∧ q))) (q ∧ p) (
        H
        p q ConjunctionCommutativityImplication
        applyModusPonens
))
</jh>

=== Builders ===

==== ConjunctionMultiplicationRR ====

Our first major builder lets us add a common conjunct to both sides of an implication.  We start with a few lemmas, and then prove the main theorem.

<jh>
thm (ConjunctionMultiplicationRX-q () () ((p → q) → ((p ∧ common) → q)) (
        p common ConjunctionRightElimination
        q addCommonConsequent
))

thm (ConjunctionMultiplicationRX-common () () ((p → q) → ((p ∧ common) → common)) (
        p common ConjunctionLeftElimination
        (p → q) introduceAntecedent
))

thm (ConjunctionMultiplicationRR () () ((p → q) → ((p ∧ common) → (q ∧ common))) (
        p q common ConjunctionMultiplicationRX-q
        p q common ConjunctionMultiplicationRX-common
        composeConjunction

        (p ∧ common) q common ConjunctionCompositionForward
        applySyllogism
))

thm (conjoinRR () ((H (p → q))) ((p ∧ r) → (q ∧ r)) (
        H
        p q r ConjunctionMultiplicationRR
        applyModusPonens
))
</jh>

==== Other builders ====
The rest of the <code>ConjunctionMultiplication</code> variants follow from the first one, just like in [[Principia Mathematica propositional logic]].

<jh>
thm (ConjunctionMultiplication () () (((p → r) ∧ (q → s)) → ((p ∧ q) → (r ∧ s))) (
        (p → r) (q → s) ConjunctionRightElimination
        p r q ConjunctionMultiplicationRR
        applySyllogism
        r q ConjunctionCommutativityImplication
        (p ∧ q) introduceAntecedent distributeAntecedent
        applySyllogism

        (p → r) (q → s) ConjunctionLeftElimination
        q s r ConjunctionMultiplicationRR
        applySyllogism
        s r ConjunctionCommutativityImplication
        (q ∧ r) introduceAntecedent distributeAntecedent
        applySyllogism
        applySyllogismInConsequent
))

thm (conjoin () ((H1 (p → r)) (H2 (q → s))) ((p ∧ q) → (r ∧ s)) (
        H1 H2 introduceConjunction
        p r q s ConjunctionMultiplication
        applyModusPonens
))

thm (ConjunctionMultiplicationLL () () ((p → q) → ((r ∧ p) → (r ∧ q))) (
        r ImplicationReflexivity

        r r p q ConjunctionMultiplication
        export

        applyModusPonens
))

thm (ConjunctionMultiplicationLR () () ((p → q) → ((r ∧ p) → (q ∧ r))) (
        p q r ConjunctionMultiplicationLL

        r q ConjunctionCommutativityImplication
        (p → q) introduceAntecedent

        applySyllogismInConsequent
))

thm (ConjunctionMultiplicationRL () () ((p → q) → ((p ∧ r) → (r ∧ q))) (
        p q r ConjunctionMultiplicationRR

        q r ConjunctionCommutativityImplication
        (p → q) introduceAntecedent

        applySyllogismInConsequent
))

thm (conjoinLL () ((H (p → q))) ((r ∧ p) → (r ∧ q)) (
        H
        p q r ConjunctionMultiplicationLL
        applyModusPonens
))

thm (conjoinLR () ((H (p → q))) ((r ∧ p) → (q ∧ r)) (
        H
        p q r ConjunctionMultiplicationLR
        applyModusPonens
))

thm (conjoinRL () ((H (p → q))) ((p ∧ r) → (r ∧ q)) (
        H
        p q r ConjunctionMultiplicationRL
        applyModusPonens
))
</jh>

== Disjunction ==
We provide a variation of the disjunction composition axiom, and a rule form:
<jh>
thm (DisjunctionCompositionReverse () () (((p ∨ q) → r) → ((p → r) ∧ (q → r))) (
        p q DisjunctionRightIntroduction
        r addCommonConsequent

        q p DisjunctionLeftIntroduction
        r addCommonConsequent

        composeConjunction
))

thm (composeDisjunction () ((HP (p → r)) (HQ (q → r))) ((p ∨ q) → r) (
        HQ
        HP
        p r q DisjunctionCompositionAxiom
        applyModusPonens
        applyModusPonens
))
</jh>

Here are a few other rules corresponding to axioms.
<jh>
thm (introduceLeftDisjunction () ((H p)) (q ∨ p) (
        H
        p q DisjunctionLeftIntroduction
        applyModusPonens
))

thm (introduceRightDisjunction () ((H p)) (p ∨ q) (
        H
        p q DisjunctionRightIntroduction
        applyModusPonens
))

thm (extractLeftDisjunction () ((H ((p ∨ q) → r))) (p → r) (
        p q DisjunctionRightIntroduction
        H
        applySyllogism
))

thm (extractRightDisjunction () ((H ((p ∨ q) → r))) (q → r) (
        q p DisjunctionLeftIntroduction
        H
        applySyllogism
))
</jh>

=== Commutativity ===
<jh>
thm (DisjunctionCommutativityImplication () () ((p ∨ q) → (q ∨ p)) (
        q p DisjunctionRightIntroduction
        p q DisjunctionLeftIntroduction
        p (q ∨ p) q DisjunctionCompositionAxiom
        applyModusPonens
        applyModusPonens
))

thm (swapDisjunction () ((H (p ∨ q))) (q ∨ p) (
        H
        p q DisjunctionCommutativityImplication
        applyModusPonens
))
</jh>

=== Builders ===

==== DisjunctionSummationRL ====

Our first disjunction builder is proved analogously to <code>ConjunctionMultiplicationRR</code>.

<jh>
thm (DisjunctionSummationXL-p () () ((p → q) → (p → (common ∨ q))) (
        q common DisjunctionLeftIntroduction
        p addCommonAntecedent
))

thm (DisjunctionSummationXL-common () () ((p → q) → (common → (common ∨ q))) (
        common q DisjunctionRightIntroduction
        (p → q) introduceAntecedent
))

thm (DisjunctionSummationRL () () ((p → q) → ((p ∨ common) → (common ∨ q))) (
        p q common DisjunctionSummationXL-p
        p q common DisjunctionSummationXL-common
        composeConjunction

        p (common ∨ q) common DisjunctionCompositionAxiom
        import
        applySyllogism
))

thm (disjoinRL () ((H (p → q))) ((p ∨ r) → (r ∨ q)) (
        H
        p q r DisjunctionSummationRL
        applyModusPonens
))
</jh>

==== DisjunctionSummation ====

This theorem follows exactly as <code>ConjunctionMultiplication</code>, except that we use <code>DisjunctionSummationRL</code> instead of <code>ConjunctionMultiplicationRR</code> and <code>ConjunctionCommutativity</code>.

<jh>
thm (DisjunctionSummation () () (((p → r) ∧ (q → s)) → ((p ∨ q) → (r ∨ s))) (
        (p → r) (q → s) ConjunctionRightElimination
        p r q DisjunctionSummationRL
        applySyllogism
        (p → r) (q → s) ConjunctionLeftElimination
        q s r DisjunctionSummationRL
        applySyllogism
        applySyllogismInConsequent
))

thm (disjoin () ((H1 (p → r)) (H2 (q → s))) ((p ∨ q) → (r ∨ s)) (
        H1 H2 introduceConjunction
        p r q s DisjunctionSummation
        applyModusPonens
))
</jh>

==== DisjunctionSummation variations ====
We could prove the <code>DisjunctionSummationLL</code>, <code>DisjunctionSummationRR</code>, and <code>DisjunctionSummationLR</code> the same way that we proved <code>DisjunctionSummationRL</code>, but here we prove them as special cases of <code>DisjunctionSummation</code>.

<jh>
thm (DisjunctionSummationLL () () ((p → q) → ((r ∨ p) → (r ∨ q))) (
        r ImplicationReflexivity

        r r p q DisjunctionSummation
        export

        applyModusPonens
))

thm (DisjunctionSummationLR () () ((p → q) → ((r ∨ p) → (q ∨ r))) (
        p q r DisjunctionSummationLL

        r q DisjunctionCommutativityImplication
        (p → q) introduceAntecedent

        applySyllogismInConsequent
))

thm (DisjunctionSummationRR () () ((p → q) → ((p ∨ r) → (q ∨ r))) (
        r ImplicationReflexivity

        p q r r DisjunctionSummation
        export
        applyComm

        applyModusPonens
))

thm (disjoinLL () ((H (p → q))) ((r ∨ p) → (r ∨ q)) (
        H
        p q r DisjunctionSummationLL
        applyModusPonens
))

thm (disjoinLR () ((H (p → q))) ((r ∨ p) → (q ∨ r)) (
        H
        p q r DisjunctionSummationLR
        applyModusPonens
))

thm (disjoinRR () ((H (p → q))) ((p ∨ r) → (q ∨ r)) (
        H
        p q r DisjunctionSummationRR
        applyModusPonens
))
</jh>

== Biconditional ==

We define the biconditional as the conjunction of two implications:
<jh>
def ((↔ p q) ((p → q) ∧ (q → p)))
</jh>

And one way to prove a biconditional is to prove both of the implications:
<jh>
thm (introduceBiconditionalFromImplications () 
  ((HFORWARD (p → q)) (HREVERSE (q → p))) 
  (p ↔ q) (
        HFORWARD
        HREVERSE
        introduceConjunction
))
</jh>

We can eliminate one of the implications of a biconditional:
<jh>
thm (BiconditionalForwardElimination () () ((p ↔ q) → (q → p)) (
        (p → q) (q → p) ConjunctionLeftElimination
))

thm (BiconditionalReverseElimination () () ((p ↔ q) → (p → q)) (
        (p → q) (q → p) ConjunctionRightElimination
))

thm (eliminateBiconditionalForward () ((H (p ↔ q))) (q → p) (
        H eliminateLeftConjunct
))

thm (eliminateBiconditionalReverse () ((H (p ↔ q))) (p → q) (
        H eliminateRightConjunct
))
</jh>

=== Biconditionalized versions of some theorems we've already proved ===
We've proved both directions of each of the following theorems, so the biconditional immediately follows:
<jh>
thm (AntecedentDistribution () () ((p → (q → r)) ↔ ((p → q) → (p → r))) (
        p q r Frege
        p q r FregeConverse
        introduceBiconditionalFromImplications
))

thm (Transportation () () ((p → (q → r)) ↔ ((p ∧ q) → r)) (
        p q r Importation
        p q r Exportation
        introduceBiconditionalFromImplications
))

thm (ConjunctionComposition () () (((p → q) ∧ (p → r)) ↔ (p → (q ∧ r))) (
        p q r ConjunctionComposition1
        import

        p q r ConjunctionCompositionReverse

        introduceBiconditionalFromImplications
))

thm (DisjunctionComposition () () (((p → r) ∧ (q → r)) ↔ ((p ∨ q) → r)) (
        p r q DisjunctionCompositionAxiom
        import

        p q r DisjunctionCompositionReverse
        introduceBiconditionalFromImplications
))
</jh>

=== Reflexive, symmetric, and transitive ===

The biconditional has these three properties (which correspond to those defining an [[w:equivalence relation|equivalence relation]]). The proofs here are taken directly from [[Principia Mathematica propositional logic]], as they are also valid in intuitionistic logic.

<jh>
thm (BiconditionalReflexivity () () (p ↔ p) (
        p Id
        p Id
        introduceBiconditionalFromImplications
))

thm (BiconditionalSymmetryImplication () () ((p ↔ q) → (q ↔ p)) (
        (p → q) (q → p) ConjunctionCommutativityImplication
))

thm (BiconditionalSymmetry () () ((p ↔ q) ↔ (q ↔ p)) (
        p q BiconditionalSymmetryImplication
        q p BiconditionalSymmetryImplication
        introduceBiconditionalFromImplications
))

thm (swapBiconditional () ((H (p ↔ q))) (q ↔ p) (
        H
        p q BiconditionalSymmetryImplication
        applyModusPonens
))

thm (BiconditionalTransitivity () () (((p ↔ q) ∧ (q ↔ r)) → (p ↔ r)) (
        (p ↔ q) (q ↔ r) ConjunctionRightElimination
        (p → q) (q → p) ConjunctionRightElimination
        applySyllogism

        (p ↔ q) (q ↔ r) ConjunctionLeftElimination
        (q → r) (r → q) ConjunctionRightElimination
        applySyllogism
        applySyllogismInConsequent

        (p ↔ q) (q ↔ r) ConjunctionLeftElimination
        (q → r) (r → q) ConjunctionLeftElimination
        applySyllogism

        (p ↔ q) (q ↔ r) ConjunctionRightElimination
        (p → q) (q → p) ConjunctionLeftElimination
        applySyllogism
        applySyllogismInConsequent
        composeConjunction
))

thm (applyBiconditionalTransitivity () ((H1 (p ↔ q)) (H2 (q ↔ r))) (p ↔ r) (
        H1 H2 introduceConjunction
        p q r BiconditionalTransitivity
        applyModusPonens
))
</jh>

=== Relating biconditional to implications ===

The following just restate the definition of the biconditional.
<jh>
thm (BiconditionalImplication () () ((p ↔ q) ↔ ((p → q) ∧ (q → p))) (
        (p ↔ q) BiconditionalReflexivity
))

thm (convertFromBiconditionalToImplications () ((H (p ↔ q))) ((p → q) ∧ (q → p)) (
        H
))

thm (convertToBiconditionalFromImplications () ((H ((p → q) ∧ (q → p)))) (p ↔ q) (
        H
))
</jh>

=== Algebraic laws for disjunction and conjunction ===
Most of the theorems of the propositional calculus which are analagous to those of other [[w:Abstract algebra|algebras]], showing properties such as commutivity and associativity, also hold for intuitionistic logic.

==== Conjunction idempotence ====
<jh>
thm (ConjunctionIdempotenceForward () () (p → (p ∧ p)) (
        p p ConjunctionRightIntroduction
        absorbRedundantAntecedent
))

thm (ConjunctionIdempotenceReverse () () ((p ∧ p) → p) (
        p p ConjunctionLeftElimination
))

thm (ConjunctionIdempotence () () (p ↔ (p ∧ p)) (
        p ConjunctionIdempotenceForward
        p ConjunctionIdempotenceReverse
        introduceBiconditionalFromImplications
))

thm (cloneAsConjunction () ((H p)) (p ∧ p) (
        H
        p ConjunctionIdempotence eliminateBiconditionalReverse
        applyModusPonens
))

thm (conflateConjunction () ((H (p ∧ p))) p (
        H
        p ConjunctionIdempotence eliminateBiconditionalForward
        applyModusPonens
))
</jh>

==== Conjunction commutativity ====
<jh>
thm (ConjunctionCommutativity () () ((p ∧ q) ↔ (q ∧ p)) (
        p q ConjunctionCommutativityImplication
        q p ConjunctionCommutativityImplication
        introduceBiconditionalFromImplications
))
</jh>

==== Conjunction associativity ====
To prove associativity for conjunctions, <code>(p ∧ q) ∧ r → p ∧ (q ∧ r)</code>, we first put onto the proof stack the statements that the left hand side implies each of <code>p</code>, <code>q</code>, and <code>r</code>.
<jh>
thm (ConjunctionRightAssociation () () (((p ∧ q) ∧ r) → (p ∧ (q ∧ r))) (
</jh>
<code>p</code>:
<jh>
        (p ∧ q) r ConjunctionRightElimination
        p q ConjunctionRightElimination
        applySyllogism
</jh>
<code>q</code>:
<jh>
        (p ∧ q) r ConjunctionRightElimination
        p q ConjunctionLeftElimination
        applySyllogism
</jh>
<code>r</code>:
<jh>
        (p ∧ q) r ConjunctionLeftElimination
</jh>
Now we compose <code>q ∧ r</code>:
<jh>
        composeConjunction
</jh>
And <code>p ∧ (q ∧ r)</code>:
<jh>
        composeConjunction
))
</jh>

The proof for associating left is similar.
<jh>
thm (ConjunctionLeftAssociation () () ((p ∧ (q ∧ r)) → ((p ∧ q) ∧ r)) (
</jh>
<code>p</code>:
<jh>
        p (q ∧ r) ConjunctionRightElimination
</jh>
<code>q</code>:
<jh>
        p (q ∧ r) ConjunctionLeftElimination
        q r ConjunctionRightElimination
        applySyllogism
</jh>
Composing <code>p ∧ q</code>:
<jh>
        composeConjunction
</jh>
<code>r</code>:
<jh>
        p (q ∧ r) ConjunctionLeftElimination
        q r ConjunctionLeftElimination
        applySyllogism
</jh>
Composing <code>(p ∧ q) ∧ r</code>:
<jh>
        composeConjunction
))

thm (ConjunctionAssociativity () () (((p ∧ q) ∧ r) ↔ (p ∧ (q ∧ r))) (
        p q r ConjunctionRightAssociation
        p q r ConjunctionLeftAssociation
        introduceBiconditionalFromImplications
))

thm (groupConjunctionRight () ((H ((p ∧ q) ∧ r))) (p ∧ (q ∧ r)) (
        H
        p q r ConjunctionAssociativity
        eliminateBiconditionalReverse
        applyModusPonens
))

thm (groupConjunctionLeft () ((H (p ∧ (q ∧ r)))) ((p ∧ q) ∧ r) (
        H
        p q r ConjunctionAssociativity
        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

==== Disjunction idempotence ====
<jh>
thm (DisjunctionIdempotenceForward () () (p → (p ∨ p)) (
        p p DisjunctionRightIntroduction
))

thm (DisjunctionIdempotenceReverse () () ((p ∨ p) → p) (
        p ImplicationReflexivity
        p ImplicationReflexivity
        p p p DisjunctionCompositionAxiom
        applyModusPonens
        applyModusPonens
))

thm (DisjunctionIdempotence () () (p ↔ (p ∨ p)) (
        p DisjunctionIdempotenceForward
        p DisjunctionIdempotenceReverse
        introduceBiconditionalFromImplications
))

thm (cloneAsDisjunction () ((H p)) (p ∨ p) (
        H
        p DisjunctionIdempotence eliminateBiconditionalReverse
        applyModusPonens
))

thm (conflateDisjunction () ((H (p ∨ p))) p (
        H
        p DisjunctionIdempotence eliminateBiconditionalForward
        applyModusPonens
))
</jh>

==== Disjunction commutativity ====
<jh>
thm (DisjunctionCommutativity () () ((p ∨ q) ↔ (q ∨ p)) (
        p q DisjunctionCommutativityImplication
        q p DisjunctionCommutativityImplication
        introduceBiconditionalFromImplications
))
</jh>

==== Disjunction associativity ====
Proving associativity for disjunction is very much analogous to conjunction, with conjunction elimination and composition changed to disjunction introduction and composition.
<jh>
thm (DisjunctionRightAssociation () () (((p ∨ q) ∨ r) → (p ∨ (q ∨ r))) (
</jh>
<code>p</code> implies <code>p ∨ (q ∨ r)</code>:
<jh>
        p (q ∨ r) DisjunctionRightIntroduction
</jh>
Likewise for <code>q</code>:
<jh>
        q r DisjunctionRightIntroduction
        (q ∨ r) p DisjunctionLeftIntroduction
        applySyllogism
</jh>
Composing <code>p ∨ q</code>:
<jh>
        composeDisjunction
</jh>
<code>r</code>:
<jh>
        r q DisjunctionLeftIntroduction
        (q ∨ r) p DisjunctionLeftIntroduction
        applySyllogism
</jh>
Composing <code>(p ∨ q) ∨ r</code>:
<jh>
        composeDisjunction
))

thm (DisjunctionLeftAssociation () () ((p ∨ (q ∨ r)) → ((p ∨ q) ∨ r)) (
</jh>
<code>p</code> implies <code>(p ∨ q) ∨ r</code>:
<jh>
        p q DisjunctionRightIntroduction
        (p ∨ q) r DisjunctionRightIntroduction
        applySyllogism
</jh>
<code>q</code>:
<jh>
        q p DisjunctionLeftIntroduction
        (p ∨ q) r DisjunctionRightIntroduction
        applySyllogism
</jh>
<code>r</code>:
<jh>
        r (p ∨ q) DisjunctionLeftIntroduction
</jh>
Composing <code>q ∨ r</code>:
<jh>
        composeDisjunction
</jh>
Composing <code>p ∨ (q ∨ r)</code>:
<jh>
        composeDisjunction
))

thm (DisjunctionAssociativity () () (((p ∨ q) ∨ r) ↔ (p ∨ (q ∨ r))) (
        p q r DisjunctionRightAssociation
        p q r DisjunctionLeftAssociation
        introduceBiconditionalFromImplications
))

thm (groupDisjunctionLeft () ((H (p ∨ (q ∨ r)))) ((p ∨ q) ∨ r) (
        H
        p q r DisjunctionLeftAssociation
        applyModusPonens
))

thm (groupDisjunctionRight () ((H ((p ∨ q) ∨ r))) (p ∨ (q ∨ r)) (
        H
        p q r DisjunctionRightAssociation
        applyModusPonens
))
</jh>

=== Builders ===

The builders for conjunction and disjunction can be proved using the proofs in [[Principia Mathematica propositional logic]].

==== Conjunction ====

<jh>
thm (ConjunctionFunction-1 () () (((p ∧ q) ∧ (r ∧ s)) → ((p ∧ r) ∧ (q ∧ s))) (
        p q (r ∧ s) ConjunctionAssociativity
        eliminateBiconditionalReverse

        p Id
        q r s ConjunctionAssociativity
        eliminateBiconditionalForward
        conjoin

        applySyllogism

        p Id
        q r ConjunctionCommutativity
        eliminateBiconditionalReverse
        s Id 
        conjoin
        conjoin

        applySyllogism

        p Id
        r q s ConjunctionAssociativity
        eliminateBiconditionalReverse
        conjoin

        applySyllogism

        p r (q ∧ s) ConjunctionAssociativity
        eliminateBiconditionalForward

        applySyllogism
))

thm (ConjunctionFunction () () (((p ↔ q) ∧ (r ↔ s)) → ((p ∧ r) ↔ (q ∧ s))) ( # *4.38
        (p → q) (q → p) (r → s) (s → r) ConjunctionFunction-1
        
        p q r s ConjunctionMultiplication
        q p s r ConjunctionMultiplication
        conjoin

        applySyllogism
))

thm (buildConjunction () (
  (H1 (p ↔ q))
  (H2 (r ↔ s)))
  ((p ∧ r) ↔ (q ∧ s)) (
        H1 H2 introduceConjunction
        p q r s ConjunctionFunction
        applyModusPonens
))
</jh>

==== Disjunction ====
This is just like the theorem for conjunction, except that we build on the partial builder theorem <code>DisjunctionSummation</code> instead of <code>ConjunctionMultiplication</code>:

<jh>
thm (DisjunctionFunction () () (((p ↔ q) ∧ (r ↔ s)) → ((p ∨ r) ↔ (q ∨ s))) ( # *4.39
        (p → q) (q → p) (r → s) (s → r) ConjunctionFunction-1
        
        p q r s DisjunctionSummation
        q p s r DisjunctionSummation
        conjoin

        applySyllogism
))

thm (buildDisjunction () (
  (H1 (p ↔ q))
  (H2 (r ↔ s)))
  ((p ∨ r) ↔ (q ∨ s)) (
        H1 H2 introduceConjunction
        p q r s DisjunctionFunction
        applyModusPonens
))
</jh>

=== Distributivity ===
Here we take up distributivity of disjunction over conjunction, and conjunction over disjunction.  Most of the proofs given in [[Principia Mathematica propositional logic]] apply for intuitionistic logic, as they are fairly straightforward applications of disjunction and conjunction composition.  The tough one is <code>((p ∨ q) ∧ (p ∨ r)) → p ∨ (q ∧ r)</code> (because it has a conjunction in the antecedent and a disjunction in the consequent, it won't yield to straightforward composition tricks).  ''Principia'' proves it from the equivalence of <code>p ∨ q</code> and <code>¬ p → q</code> (which does not hold in both directions in intuitionistic logic).  We prove it from import and builders.

The first step is a lemma which will let us harmlessly apply builders more than once.
<jh>
thm (RedundantDisjunctionAbsorption () () ((p ∨ (p ∨ q)) → (p ∨ q)) (
        p p q DisjunctionAssociativity
        eliminateBiconditionalForward

        p DisjunctionIdempotence
        eliminateBiconditionalForward
        q disjoinRR

        applySyllogism
))
</jh>

Now we are ready for the proof of the tough distributivity case.
<jh>
thm (DisjunctionLeftDistribution-reverse () () (((p ∨ q) ∧ (p ∨ r)) → (p ∨ (q ∧ r))) (
</jh>
We start with <code>r → (q → (q ∧ r))</code>, and disjoin <code>p</code> to both sides of the second implication.
<jh>
        r q ConjunctionLeftIntroduction
        q (q ∧ r) p DisjunctionSummationLL
        applySyllogism
</jh>
That gives us <code>r → (p ∨ q → p ∨ (q ∧ r))</code>. We commute antecedents and disjoin <code>p</code> again.
<jh>
        applyComm
        r (p ∨ (q ∧ r)) p DisjunctionSummationLL
        applySyllogism
</jh>
We now have <code>p ∨ q → (p ∨ r → p ∨ (p ∨ (q ∧ r)))</code>.  We just need to import, remove the redundant <code>p</code>, and we are done.
<jh>
        import
        p (q ∧ r) RedundantDisjunctionAbsorption
        applySyllogism
))
</jh>

The rest of this section contains proofs taken from [[Principia Mathematica propositional logic]].

<jh>
thm (ConjunctionLeftDistribution-forward () () 
  ((p ∧ (q ∨ r)) → ((p ∧ q) ∨ (p ∧ r))) (
        p q ConjunctionRightIntroduction
        p r ConjunctionRightIntroduction
        composeConjunction

        q (p ∧ q) r (p ∧ r) DisjunctionSummation
        applySyllogism

        import
))

thm (ConjunctionLeftDistribution-reverse () ()
  (((p ∧ q) ∨ (p ∧ r)) → (p ∧ (q ∨ r))) (
        p q ConjunctionRightElimination
        p r ConjunctionRightElimination
        composeDisjunction

        p q ConjunctionLeftElimination
        p r ConjunctionLeftElimination
        disjoin

        composeConjunction
))

thm (ConjunctionLeftDistribution () () ((p ∧ (q ∨ r)) ↔ ((p ∧ q) ∨ (p ∧ r))) (
        p q r ConjunctionLeftDistribution-forward
        p q r ConjunctionLeftDistribution-reverse
        introduceBiconditionalFromImplications
))

thm (DisjunctionLeftDistribution-forward () () ((p ∨ (q ∧ r)) → ((p ∨ q) ∧ (p ∨ r))) (
        q r ConjunctionRightElimination
        p disjoinLL

        q r ConjunctionLeftElimination
        p disjoinLL

        composeConjunction
))

thm (DisjunctionLeftDistribution () () ((p ∨ (q ∧ r)) ↔ ((p ∨ q) ∧ (p ∨ r))) (
        p q r DisjunctionLeftDistribution-forward
        p q r DisjunctionLeftDistribution-reverse
        introduceBiconditionalFromImplications
))
</jh>

Also from [[Principia Mathematica propositional logic]] are commuted versions of both laws and some rules:

<jh>
thm (DisjunctionRightDistribution () () (((p ∧ q) ∨ r) ↔ ((p ∨ r) ∧ (q ∨ r))) (
        (p ∧ q) r DisjunctionCommutativity
        r p q DisjunctionLeftDistribution
        applyBiconditionalTransitivity

        r p DisjunctionCommutativity
        r q DisjunctionCommutativity
        buildConjunction

        applyBiconditionalTransitivity
))

thm (ConjunctionRightDistribution () () (((p ∨ q) ∧ r) ↔ ((p ∧ r) ∨ (q ∧ r))) (
        (p ∨ q) r ConjunctionCommutativity
        r p q ConjunctionLeftDistribution
        applyBiconditionalTransitivity

        r p ConjunctionCommutativity
        r q ConjunctionCommutativity
        buildDisjunction

        applyBiconditionalTransitivity
))

thm (distributeLeftDisjunction () ((H (p ∨ (q ∧ r)))) ((p ∨ q) ∧ (p ∨ r)) (
        H
        p q r DisjunctionLeftDistribution
        eliminateBiconditionalReverse
        applyModusPonens
))

thm (collectLeftDisjunction () ((H ((p ∨ q) ∧ (p ∨ r)))) (p ∨ (q ∧ r)) (
        H
        p q r DisjunctionLeftDistribution
        eliminateBiconditionalForward
        applyModusPonens
))

thm (distributeRightDisjunction () ((H ((p ∧ q) ∨ r))) ((p ∨ r) ∧ (q ∨ r)) (
        H
        p q r DisjunctionRightDistribution
        eliminateBiconditionalReverse
        applyModusPonens
))

thm (collectRightDisjunction () ((H ((p ∨ r) ∧ (q ∨ r)))) ((p ∧ q) ∨ r) (
        H
        p q r DisjunctionRightDistribution
        eliminateBiconditionalForward
        applyModusPonens
))

thm (distributeLeftConjunction () ((H (p ∧ (q ∨ r)))) ((p ∧ q) ∨ (p ∧ r)) (
        H
        p q r ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        applyModusPonens
))

thm (collectLeftConjunction () ((H ((p ∧ q) ∨ (p ∧ r)))) (p ∧ (q ∨ r)) (
        H
        p q r ConjunctionLeftDistribution
        eliminateBiconditionalForward
        applyModusPonens
))

thm (distributeRightConjunction () ((H ((p ∨ q) ∧ r))) ((p ∧ r) ∨ (q ∧ r)) (
        H
        p q r ConjunctionRightDistribution
        eliminateBiconditionalReverse
        applyModusPonens
))

thm (collectRightConjunction () ((H ((p ∧ r) ∨ (q ∧ r)))) ((p ∨ q) ∧ r) (
        H
        p q r ConjunctionRightDistribution
        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

=== Biconditional and conjunction ===
A true conjunct does not affect the truth of a proposition. The proof from [[Principia Mathematica propositional logic]] is valid intuitionistically without change.

<jh>
thm (*4.7 () () ((p → q) ↔ (p → (p ∧ q))) (
        p ImplicationReflexivity
        p p q ConjunctionCompositionForward

        export
        applyModusPonens

        p q ConjunctionLeftElimination
        p addCommonAntecedent

        introduceBiconditionalFromImplications
))

thm (*4.71 () () ((p → q) ↔ (p ↔ (p ∧ q))) (
        p q *4.7

        p q ConjunctionRightElimination

        ((p ∧ q) → p) (p → (p ∧ q)) ConjunctionLeftIntroduction
        applyModusPonens

        p (p ∧ q) BiconditionalReverseElimination
        introduceBiconditionalFromImplications

        applyBiconditionalTransitivity
))

thm (BiconditionalConjunct () () (q → (p ↔ (p ∧ q))) ( # *4.73
        q p AntecedentIntroduction

        p q *4.71
        eliminateBiconditionalReverse

        applySyllogism
))
</jh>

== Modus Ponens ==
This is just an implication corresponding to the modus ponens rule:
<jh>
thm (ModusPonens () () ((p ∧ (p → q)) → q) (
        (p → q) ImplicationReflexivity
        applyComm
        import
))
</jh>

== Negation ==

=== Transposition ===
Although intuitionistic logic does not allow removing transposition, it does allow introducing it.
<jh>
thm (TranspositionIntroduction () () ((p → q) → ((¬ q) → (¬ p))) (
</jh>
The <code>ProofByContradiction</code> axiom is <code>(p → q) → ((p → ¬ q) → ¬ p)</code>.  That is, if <code>p</code> implies both <code>q</code> and its negation, <code>p</code> cannot be true. What we are trying to prove can be thought of as a weaker form of this, which is that if <code>p</code> implies <code>q</code>, and the negation of q holds (without worrying about <code>p</code>), then <code>p</code> cannot be true, or in symbols <code>(p → q) → (¬ q → ¬ p)</code>.
<jh>
        p q ProofByContradiction

        (¬ q) p AntecedentIntroduction
        (¬ p) addCommonConsequent
        (p → q) addCommonAntecedent

        applyModusPonens
))

thm (introduceTransposition () ((H (p → q))) ((¬ q) → (¬ p)) (
        H
        p q TranspositionIntroduction
        applyModusPonens
))
</jh>

Modus tollens is an easy consequence of transposition introduction.

<jh>
thm (ModusTollens () () (((¬ q) ∧ (p → q)) → (¬ p)) (
        p q TranspositionIntroduction
        (¬ q) conjoinLL

        (¬ q) (¬ p) ModusPonens
        applySyllogism
))

thm (applyModusTollens () ((H (¬ q)) (HIMP (p → q))) (¬ p) (
        H
        HIMP
        introduceConjunction

        q p ModusTollens

        applyModusPonens
))
</jh>

=== Double Negation ===
Double negation introduction follows fairly directly from our first negation axiom.
<jh>
thm (DoubleNegationIntroduction () () (p → (¬ (¬ p))) (
</jh>
The key step in the proof will be <code>(¬p → p) ∧ (¬p → ¬p) → ¬¬p</code> (which follows from the <code>ProofByContradiction</code> axiom). Taking the pieces of that formula one at a time, <code>p</code> implies <code>¬p → p</code>
<jh>
        p (¬ p) AntecedentIntroduction
</jh>
and <code>¬p → ¬p</code> is a theorem.
<jh>
         (¬ p) ImplicationReflexivity
         p introduceAntecedent
</jh>
Now we assemble the result.
<jh>
        composeConjunction

        (¬ p) p ProofByContradiction
        import
        applySyllogism
))

thm (introduceDoubleNegation () ((H p)) (¬ (¬ p)) (
        H
        p DoubleNegationIntroduction
        applyModusPonens
))
</jh>

=== Triple negation ===
In intuitionistic logic, <code>¬ ¬ p</code> is not equivalent to <code>p</code> itself. Triple negation, however, is equivalent to single negation, so one merely needs to worry about formulas without negation, with single negation, or with double negation, not greater amounts of negation.
<jh>
thm (TripleNegation () () ((¬ (¬ (¬ p))) ↔ (¬ p)) (
</jh>
We prove the forward direction by taking <code>p → ¬ ¬ p</code> and transposing it.
<jh>
        p DoubleNegationIntroduction
        introduceTransposition
</jh>
The reverse direction is even easier, as <code>¬ p → ¬ ¬ ¬ p</code> is an instance of the <code>DoubleNegationIntroduction</code> theorem.
<jh>
        (¬ p) DoubleNegationIntroduction

        introduceBiconditionalFromImplications
))

thm (eliminateTripleNegation () ((H (¬ (¬ (¬ p))))) (¬ p) (
        H
        p TripleNegation
        eliminateBiconditionalReverse
        applyModusPonens
))
</jh>

=== Disjunctive syllogism ===
[[w:Disjunctive syllogism|Disjunctive syllogism]]:
<jh>
thm (DisjunctiveSyllogismLemma () () ((p → q) → ((p ∨ q) → q)) (
</jh>
The key to the proof of this lemma is <code>(p → q) → ((q → q) → (p ∨ q → q))</code>, which holds by disjunction composition. Once we have that, we just need to remove the <code>q → q</code>.
<jh>
        q ImplicationReflexivity

        p q q DisjunctionCompositionAxiom
        applyComm

        applyModusPonens
))

thm (DisjunctiveSyllogism () () (((¬ p) ∧ (p ∨ q)) → q) (
        p q Explosion
        applyComm

        p q DisjunctiveSyllogismLemma
        applySyllogism

        import
))
</jh>

=== DeMorgan's laws ===

The first two of DeMorgan's laws are straightforward:
<jh>
thm (NegationDistributionPDP () () ((¬ (p ∨ q)) → ((¬ p) ∧ (¬ q))) (
        p q DisjunctionRightIntroduction
        introduceTransposition

        q p DisjunctionLeftIntroduction
        introduceTransposition

        composeConjunction
))

thm (NegationCollectionNDN () () (((¬ p) ∨ (¬ q)) → (¬ (p ∧ q))) (
        p q ConjunctionRightElimination
        introduceTransposition

        p q ConjunctionLeftElimination
        introduceTransposition

        composeDisjunction
))
</jh>

To prove the converse of <code>NegationDistributionPDP</code>, we start with a lemma which is a rearrangement of <code>DisjunctiveSyllogism</code> plus transposition.
<jh>
thm (NegationCollectionNCNLemma () () ((¬ p) → ((¬ q) → (¬ (p ∨ q)))) (
        p q DisjunctiveSyllogism
        export

        (p ∨ q) q TranspositionIntroduction
        applySyllogism
))
</jh>

This lemma is, however, just an import away from the desired result.
<jh>
thm (NegationCollectionNCN () () (((¬ p) ∧ (¬ q)) → (¬ (p ∨ q))) (
        p q NegationCollectionNCNLemma
        import
))
</jh>

Combining the forward and reverse directions we get <code>NegationCollectionNCNDistributionPDP</code>:
<jh>
thm (NegationCollectionNCNDistributionPDP () () (((¬ p) ∧ (¬ q)) ↔ (¬ (p ∨ q))) (
        p q NegationCollectionNCN
        p q NegationDistributionPDP
        introduceBiconditionalFromImplications
))
</jh>

The following result follows from double negation introduction and <code>NegationCollectionNCNDistributionPDP</code>.
<jh>
thm (NegationCollectionPCP () () ((p ∧ q) → (¬ ((¬ p) ∨ (¬ q)))) (
        p DoubleNegationIntroduction
        q DoubleNegationIntroduction
        conjoin

        (¬ p) (¬ q) NegationCollectionNCNDistributionPDP
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

We can pull the same trick for disjunction to get our final version of DeMorgan's law.
<jh>
thm (NegationCollectionPDP () () ((p ∨ q) → (¬ ((¬ p) ∧ (¬ q)))) (
        p DoubleNegationIntroduction
        q DoubleNegationIntroduction
        disjoin

        (¬ p) (¬ q) NegationCollectionNDN
        applySyllogism
))
</jh>

Rules:
<jh>
thm (collectNegationPCP () ((H (p ∧ q))) (¬ ((¬ p) ∨ (¬ q))) (
        H
        p q NegationCollectionPCP
        applyModusPonens
))

thm (collectNegationPDP () ((H (p ∨ q))) (¬ ((¬ p) ∧ (¬ q))) (
        H
        p q NegationCollectionPDP
        applyModusPonens
))

thm (collectNegationNDN () ((H ((¬ p) ∨ (¬ q)))) (¬ (p ∧ q)) (
        H
        p q NegationCollectionNDN
        applyModusPonens
))

thm (collectNegationNCN () ((H ((¬ p) ∧ (¬ q)))) (¬ (p ∨ q)) (
        H
        p q NegationCollectionNCNDistributionPDP
        eliminateBiconditionalReverse
        applyModusPonens
))

thm (distributeNegationPDP () ((H (¬ (p ∨ q)))) ((¬ p) ∧ (¬ q)) (
        H
        p q NegationCollectionNCNDistributionPDP
        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

=== Double negation and connectives ===
The first two of these relationships between double negation and conjunction or disjunction are easy consequences of transposition.
<jh>
thm (DoubleNegatedConjunctionReverse () () ((¬ (¬ (p ∧ q))) → ((¬ (¬ p)) ∧ (¬ (¬ q)))) (
        p q ConjunctionRightElimination
        introduceTransposition
        introduceTransposition

        p q ConjunctionLeftElimination
        introduceTransposition
        introduceTransposition

        composeConjunction
))

thm (DoubleNegatedDisjunction () () (((¬ (¬ p)) ∨ (¬ (¬ q))) → (¬ (¬ (p ∨ q)))) (
        p q DisjunctionRightIntroduction
        introduceTransposition
        introduceTransposition

        q p DisjunctionLeftIntroduction
        introduceTransposition
        introduceTransposition

        composeDisjunction
))
</jh>

The converse of <code>DoubleNegatedConjunctionReverse</code> we can prove via the following lemma which introduces double negation to all three formulas of a nested implication.
<jh>
thm (addDoubleNegationImplicationImplication () ((H (p → (q → r))))
  ((¬ (¬ p)) → ((¬ (¬ q)) → (¬ (¬ r)))) (
        H
        q r TranspositionIntroduction
        applySyllogism

        applyComm
        p (¬ q) TranspositionIntroduction
        applySyllogism

        applyComm
        (¬ r) (¬ p) TranspositionIntroduction
        applySyllogism

        applyComm
))

thm (DoubleNegatedConjunctionForward () () (((¬ (¬ p)) ∧ (¬ (¬ q))) → (¬ (¬ (p ∧ q)))) (
        p q ConjunctionRightIntroduction
        addDoubleNegationImplicationImplication
        import
))

thm (DoubleNegatedConjunction () () (((¬ (¬ p)) ∧ (¬ (¬ q))) ↔ (¬ (¬ (p ∧ q)))) (
        p q DoubleNegatedConjunctionForward
        p q DoubleNegatedConjunctionReverse
        introduceBiconditionalFromImplications
))
</jh>

=== No contradictions ===
The <code>Explosion</code> axiom amounts to denying that a proposition and its negation can both hold. Here we express this idea as a theorem (which is also found as *3.24 in [[Principia Mathematica propositional logic]]).
<jh>
thm (NoContradiction () () (¬ (p ∧ (¬ p))) (
</jh>
The proof is based on <code>¬ q → ¬ (p ∧ ¬ p)</code>, which is a rearrangment of <code>Explosion</code>.  To apply this we just need a theorem (any theorem) which starts with a negation, to plug in for <code>¬ q</code>.  The double negation of <code>Id</code> will do.
<jh>
        r Id
        introduceDoubleNegation

        p (¬ (r → r)) Explosion
        import
        introduceTransposition

        applyModusPonens
))
</jh>

== Case elimination ==
Proving a theorem by cases, as in <code>CaseElimination</code> of [[Interface:Classical propositional calculus]], is not, in general, allowed in intuitionism/constructivism. For example, there is a well-known non-constructive proof that an irrational number raised to an irrational power can be rational that proceeds by handling the cases where √2<sup>√2</sup> is rational or irrational, without establishing which one holds. A constructive proof, on the other hand, would need to establish whether √2<sup>√2</sup> was rational first.<ref>Su, Francis E., et al. "[http://www.math.hmc.edu/funfacts/ffiles/10004.3-5.shtml Rational Irrational Power]," [http://www.math.hmc.edu/funfacts Mudd Math Fun Facts], accessed 3 Jul 2010</ref>  We do note that <code>p ∨ q</code>, which is stronger than <code>¬ p → q</code> in intuitionistic logic, can be used for case elimination. This is more of a curiosity than a way of proving anything, as proving <code>p ∨ q</code> in intuitionistic logic would tend to be as hard as proving <code>q</code>.
<jh>
thm (DisjunctiveCaseElimination () () (((p ∨ q) ∧ ((¬ p) ∨ q)) → q) (
</jh>
We start by collecting the <code>q</code> from the left side to get <code>(p ∧ ¬ p) ∨ q</code>.
<jh>
        p (¬ p) q DisjunctionRightDistribution
        eliminateBiconditionalForward
</jh>
Because <code>¬ (p ∧ ¬ p)</code> is a theorem, disjunctive syllogism gives us <code>(p ∧ ¬ p) ∨ q → q</code>.
<jh>
        p NoContradiction
        (p ∧ (¬ p)) q DisjunctiveSyllogism
        export
        applyModusPonens
</jh>
And this is just a syllogism away from our desired result.
<jh>
        applySyllogism
))
</jh>

== More builders ==
Now that we've proved some results involving negation, we are ready to tackle the rest of the builders.

=== Negation ===
The negation builder is an easy consequence of transposition introduction (we just need to biconditionalize it).
<jh>
thm (NegationBuilder () () ((p ↔ q) → ((¬ p) ↔ (¬ q))) (
        p q BiconditionalImplication
        eliminateBiconditionalReverse

        (p → q) (q → p) ConjunctionCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        q p TranspositionIntroduction
        p q TranspositionIntroduction
        conjoin
        applySyllogism

        (¬ p) (¬ q) BiconditionalImplication eliminateBiconditionalForward
        applySyllogism
))

thm (addNegation () ((H (p ↔ q))) ((¬ p) ↔ (¬ q)) (
        H
        p q NegationBuilder
        applyModusPonens
))
</jh>

=== Implication ===
The proof of the implication builder is analogous to the way we proved <code>ConjunctionMultiplication</code>. We base it on <code>CommonConsequentAddition</code> and <code>CommonAntecedentAddition</code>.

<jh>
thm (ImplicationFunction-1 () () (((p ↔ q) ∧ (r ↔ s)) → ((p → r) → (q → r))) (
        (p ↔ q) (r ↔ s) ConjunctionRightElimination
        p q BiconditionalForwardElimination
        applySyllogism

        q p r CommonConsequentAddition
        applySyllogism
))

thm (ImplicationFunction-2 () () (((p ↔ q) ∧ (r ↔ s)) → ((q → r) → (q → s))) (
        (p ↔ q) (r ↔ s) ConjunctionLeftElimination
        r s BiconditionalReverseElimination
        applySyllogism

        r s q CommonAntecedentAddition
        applySyllogism
))

thm (ImplicationFunction-3 () () (((p ↔ q) ∧ (r ↔ s)) → ((p → r) → (q → s))) (
        p q r s ImplicationFunction-1
        p q r s ImplicationFunction-2
        applySyllogismInConsequent
))

thm (ImplicationFunction () () (((p ↔ q) ∧ (r ↔ s)) → ((p → r) ↔ (q → s))) (
        p q r s ImplicationFunction-3

        p q BiconditionalSymmetry
        r s BiconditionalSymmetry
        buildConjunction
        eliminateBiconditionalReverse
        q p s r ImplicationFunction-3
        applySyllogism

        composeConjunction

        (p → r) (q → s) BiconditionalImplication
        eliminateBiconditionalForward
        applySyllogism
))

thm (buildImplication () ((HPQ (p ↔ q)) (HRS (r ↔ s))) ((p → r) ↔ (q → s)) (
        HPQ
        HRS
        introduceConjunction
        p q r s ImplicationFunction
        applyModusPonens
))
</jh>

=== Biconditional ===
We derive the biconditional builder from the implication builder, just as in [[Principia Mathematica propositional logic]].
<jh>
thm (BiconditionalFunction () () (((p ↔ q) ∧ (r ↔ s)) → ((p ↔ r) ↔ (q ↔ s))) (
        p q r s ImplicationFunction

        (p ↔ q) (r ↔ s) ConjunctionCommutativity
        eliminateBiconditionalReverse
        r s p q ImplicationFunction
        applySyllogism

        composeConjunction

        (p → r) (q → s) (r → p) (s → q) ConjunctionFunction
        applySyllogism
))

thm (buildBiconditional () ((HPQ (p ↔ q)) (HRS (r ↔ s))) ((p ↔ r) ↔ (q ↔ s)) (
        HPQ HRS introduceConjunction
        p q r s BiconditionalFunction
        applyModusPonens
))
</jh>

== Distribution of implication over biconditional ==

The proof of this result from [[Principia Mathematica propositional logic]] applies verbatim.
<jh>
thm (ImplicationDistributionOverBiconditional () () ((p → (q ↔ r)) ↔ ((p → q) ↔ (p → r))) (
        (p → q) (p → r) BiconditionalImplication

        p q r AntecedentDistribution swapBiconditional
        p r q AntecedentDistribution swapBiconditional

        buildConjunction

        applyBiconditionalTransitivity

        p (q → r) (r → q) ConjunctionComposition
        applyBiconditionalTransitivity

        p BiconditionalReflexivity
        q r BiconditionalImplication swapBiconditional
        buildImplication
        applyBiconditionalTransitivity

        swapBiconditional
))

thm (distributeImplicationOverBiconditional () ((H (p → (q ↔ r)))) ((p → q) ↔ (p → r)) (
        H
        p q r ImplicationDistributionOverBiconditional eliminateBiconditionalReverse
        applyModusPonens
))
</jh>

== Relationships between connectives ==

=== Conjunction and implication ===
Analogous to DeMorgan's law, there are four relationships between conjunction and implication, which differ depending on where the negations are placed. They are:
 p ∧ q → ¬ (p → ¬ q)
 (p → q) → ¬ (p ∧ ¬ q)
 p ∧ ¬ q → ¬ (p → q)
 p → ¬ q ↔ ¬ (p ∧ q)

For now, we only prove the third one.

<jh>
thm (ConjunctionImplication3 () () ((p ∧ (¬ q)) → (¬ (p → q))) (
        p q ModusPonens export
        (p → q) q TranspositionIntroduction
        applySyllogism
        import
))
</jh>

=== Disjunction and implication ===
<jh>
thm (DisjunctionImplicationForward () () ((p ∨ q) → ((¬ p) → q)) (
</jh>
This one looks a lot like <code>DisjunctiveSyllogism</code>, modulo a commutation and an export.
<jh>
        (p ∨ q) (¬ p) ConjunctionCommutativity
        eliminateBiconditionalReverse

        p q DisjunctiveSyllogism
        applySyllogism

        export
))

thm (convertFromDisjunctionToImplication () ((H (p ∨ q))) ((¬ p) → q) (
        H
        p q DisjunctionImplicationForward
        applyModusPonens
))
</jh>

The following implication/disjunction theorems are easy consequences of this one.
<jh>
thm (ImplicationDisjunctionReverse () () (((¬ p) ∨ q) → (p → q)) (
        (¬ p) q DisjunctionImplicationForward

        p DoubleNegationIntroduction
        q addCommonConsequent
        applySyllogism
))

thm (convertToImplicationFromDisjunction () ((H ((¬ p) ∨ q))) (p → q) (
        H
        p q ImplicationDisjunctionReverse
        applyModusPonens
))

thm (NotImplicationDisjunction () () ((¬ (p → q)) → (¬ ((¬ p) ∨ q))) (
        p q ImplicationDisjunctionReverse
        introduceTransposition
))

thm (NotDisjunctionImplicationReverse () () ((¬ ((¬ p) → q)) → (¬ (p ∨ q))) (
        p q DisjunctionImplicationForward
        introduceTransposition
))
</jh>

The converse of <code>NotDisjunctionImplicationReverse</code> also holds, but is a bit more difficult. 

<jh>
thm (NotDisjunctionImplicationForward () () ((¬ (p ∨ q)) → (¬ ((¬ p) → q))) (
        p q NegationCollectionNCNDistributionPDP eliminateBiconditionalForward

        (¬ p) q ConjunctionImplication3
        applySyllogism
))

thm (NotDisjunctionImplication () () ((¬ (p ∨ q)) ↔ (¬ ((¬ p) → q))) (
        p q NotDisjunctionImplicationForward
        p q NotDisjunctionImplicationReverse
        introduceBiconditionalFromImplications
))
</jh>

=== Proving a biconditional from two disjunctions ===

Since a suitably negated disjunction implies an implication, the antecedent of this theorem readily reduces to <code>p → q</code> and <code>q → p</code>, which is what we need to prove <code>p ↔ q</code>.
<jh>
thm (BiconditionalConjunctionReverse () () ((((¬ p) ∨ q) ∧ (p ∨ (¬ q))) → (p ↔ q)) (
        p q ImplicationDisjunctionReverse

        p (¬ q) DisjunctionCommutativity
        eliminateBiconditionalReverse
        q p ImplicationDisjunctionReverse
        applySyllogism

        conjoin
))

thm (convertToBiconditionalFromConjunction () ((H (((¬ p) ∨ q) ∧ (p ∨ (¬ q))))) (p ↔ q) (
        H
        p q BiconditionalConjunctionReverse
        applyModusPonens
))

thm (introduceBiconditionalFromDisjunctions () ((HPQ ((¬ p) ∨ q)) (HQP (p ∨ (¬ q)))) (p ↔ q) (
        HPQ HQP introduceConjunction
        p q BiconditionalConjunctionReverse
        applyModusPonens
))
</jh>

== True and false connectives ==
We define true (⊤) as a theorem (any theorem would do), and false (⊥) as a statement whose negation is a theorem.

<jh>
def ((⊤) (¬ (p ∧ (¬ p))))
def ((⊥) (p ∧ (¬ p)))
</jh>

Proving <code>TautologyId</code> is straightforward; the proof from [[Principia Mathematica propositional logic]] works with only the obvious changes for the difference between <code>Tautology</code> and <code>TautologyId</code>.

<jh>
thm (*3.4 () () ((p ∧ q) → (p → q)) (
        p q ConjunctionLeftElimination
        q p AntecedentIntroduction
        applySyllogism
))

thm (TruthBiconditional () () ((p ∧ q) → (p ↔ q)) ( # *5.1
        p q *3.4

        p q ConjunctionCommutativity
        eliminateBiconditionalReverse
        q p *3.4
        applySyllogism

        composeConjunction
))

thm (TautologyId () () ((p → p) ↔ (⊤)) (
        p Id
        q NoContradiction
        introduceConjunction

        (p → p) (¬ (q ∧ (¬ q))) TruthBiconditional
        applyModusPonens
))
</jh>

The <code>Contradiction</code> theorem also holds.  To prove it the same way as <code>TautologyId</code> would require <code>¬ p ∧ ¬ q → (p ↔ q)</code> (*5.21 in [[Principia Mathematica propositional logic]]). Since we don't have that, we can prove it in an even more direct way: a contradiction implies anything, including the consequent of each of the implications in this theorem.
<jh>
thm (ContradictionLemma () () ((p ∧ (¬ p)) → (q ∧ (¬ q))) (
        p (q ∧ (¬ q)) Explosion
        import
))

thm (Contradiction () () ((p ∧ (¬ p)) ↔ (⊥)) (
        p q ContradictionLemma
        q p ContradictionLemma
        introduceBiconditionalFromImplications
))
</jh>

The next two are trivial.
<jh>
thm (True () () (⊤) (
        p NoContradiction
))

thm (NotFalse () () (¬ (⊥)) (
        p NoContradiction
))
</jh>

=== Negation and ⊥ ===

Here we show that <code>¬ p</code> is equivalent to <code>p → ⊥</code>.  In some axiomizations of intuitionistic logic, this is the definition of negation.  For us, it is a theorem.

<jh>
thm (NegationImplicationForward () () ((¬ p) → (p → (⊥))) (
        (¬ p) p ConjunctionCommutativity
        eliminateBiconditionalReverse

        p Contradiction
        eliminateBiconditionalReverse

        applySyllogism

        export
))

thm (NegationImplicationReverse () () ((p → (⊥)) → (¬ p)) (
        q Contradiction eliminateBiconditionalForward
        p addCommonAntecedent

        p q (¬ q) ConjunctionComposition eliminateBiconditionalForward
        applySyllogism

        p q ProofByContradiction
        import
        applySyllogism
))

thm (NegationImplication () () ((¬ p) ↔ (p → (⊥))) (
        p NegationImplicationForward
        p NegationImplicationReverse
        introduceBiconditionalFromImplications
))

thm (convertFromNegationToImplication () ((H (¬ p))) (p → (⊥)) (
        H
        p NegationImplication
        eliminateBiconditionalReverse
        applyModusPonens
))

thm (convertToNegationFromImplication () ((H (p → (⊥)))) (¬ p) (
        H
        p NegationImplication
        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

== Export ==
We have proved everything in [[Interface:Basic intuitionistic propositional logic]]. There are additional theorems in [[Interface:Intuitionistic propositional logic]], but those are proved in [[Convenience theorems of intuitionistic propositional logic]].
<jh>
export (INTUITIONISTIC Interface:Basic_intuitionistic_propositional_logic () ())
</jh>

== References ==

<references />

[[Category:Subsystems of classical logic|{{PAGENAME}}]]
