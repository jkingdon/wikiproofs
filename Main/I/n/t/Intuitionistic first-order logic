{{header
 | title    = Intuitionistic first-order logic
 | subtitle =
 | left     =
 | right    =
 | shortcut =
 | notes    = The purpose of this page is to prove the statements of [[Interface:Intuitionistic first-order logic]] from the [[Interface:Axioms of intuitionistic first-order logic]].
}}
{{interfaces
| imports = [[Interface:Axioms of intuitionistic first-order logic]]
| exports = [[Interface:Intuitionistic first-order logic]]
}}

We start with propositional logic and our axioms.

<jh>
import (PROPOSITIONAL Interface:Intuitionistic_propositional_logic () ())
import (AXIOMS Interface:Axioms_of_intuitionistic_first-order_logic (PROPOSITIONAL) ())
</jh>

As usual, φ and ψ are formulas, x, y, and z are variables, and s, t, and u are terms:

<jh>
var (formula φ ψ φx φy φs antecedent)
var (object s t u s0 s1 t0 t1)
var (variable x y z x0 x1 y0 y1)
</jh>

We largely follow the development from [[First-order logic in terms of substitution built on equality]] although some of the details are different and of course we don't prove quite all the theorems.

== Substitution ==
As with [[First-order logic in terms of substitution built on equality]] (slightly more so, even), substitution is central to our proofs, so we start with some substitution theorems.

=== Rule forms of substitution axioms ===
Here are some rules which are convenience forms of axioms, just as in [[First-order logic in terms of substitution built on equality]].
<jh>
thm (specializeToObject () ((H (∀ x φ))) (subst s x φ) (
        H
        x φ s SpecializationToObject
        applyModusPonens
))

thm (specializeToObjectInConsequent () ((H (antecedent → (∀ x φ)))) (antecedent → (subst s x φ)) (
        H
        x φ s SpecializationToObject
        applySyllogism
))

thm (makeSubstExplicit ((x s) (x ψ))
  ((H (((value x) = s) → (φ ↔ ψ))))
  ((subst s x φ) ↔ ψ) (
        x ψ DistinctNotFree
        H
        makeSubstExplicitNotFree
))

thm (buildSubstReplacement () ((H (s = t)))
  ((subst s x φ) ↔ (subst t x φ)) (
        H
        s t x φ SubstBuilderReplacement
        applyModusPonens
))
</jh>

=== Composition ===
Substitution composition works just as in [[First-order logic in terms of substitution built on equality]].

<jh>
thm (SubstitutionComposition ((φ y) (s y) (x y)) ()
  ((subst s y (subst (value y) x φ)) ↔ (subst s x φ)) (
        (value y) s x φ SubstBuilderReplacement
        makeSubstExplicit
))
</jh>

=== EqualitySubst ===
Similarly, the proof from [[First-order logic in terms of substitution built on equality]] of <code>EqualitySubst</code> works here too.
<jh>
thm (EqualitySubst () () (((value x) = s) → (φ ↔ (subst s x φ))) (
        (value x) s x φ SubstBuilderReplacement
        x φ SubstItself
        transformImplicationBiconditionalLeft
))
</jh>

== Specialization and existential introduction without a substitution ==
The theorems <code>∀ x φ → φ</code> and <code>φ → ∃ x φ</code> (which are special cases of the corresponding axioms which include substitutions) follow using the same proofs as in [[First-order logic in terms of substitution built on equality]].
<jh>
thm (Specialization () () ((∀ x φ) → φ) (
        x φ (value x) SpecializationToObject

        x φ SubstItself
        eliminateBiconditionalReverse
        applySyllogism
))

thm (specialize () ((H (∀ x φ))) φ (
        H
        x φ Specialization
        applyModusPonens
))

thm (ThereExistsIntroduction () () (φ → (∃ x φ)) (
        x φ SubstItself
        eliminateBiconditionalForward

        (value x) x φ ThereExistsIntroductionFromObject
        applySyllogism
))
</jh>

The previous results let us conclude <code>∀ x φ → ∃ x φ</code>.
<jh>
thm (ForAllThereExists () () ((∀ x φ) → (∃ x φ)) (
        x φ Specialization
        φ x ThereExistsIntroduction
        applySyllogism
))
</jh>

== Generalization ==
Here we show that <code>φ → ∀ x φ</code>, provided that <code>x</code> is not free in <code>φ</code>.
<jh>
thm (GeneralizationNotFree () ((HFREE (x is-not-free-in φ))) (φ → (∀ x φ)) (
        HFREE
        φ ImplicationReflexivity
        addForAllToConsequentNotFree
))
</jh>

We also can generalize a theorem, even if the variable is free in it. The proof proceeds by turning <code>φ</code> into <code>⊤ → φ</code>, adding the quantifier to the consequent, and then removing the antecedent.
<jh>
thm (generalize () ((H φ)) (∀ x φ) (
        True

        x (⊤) DistinctNotFree

        H
        (⊤) introduceAntecedent

        addForAllToConsequentNotFree

        applyModusPonens
))
</jh>

== Building for-all across implication ==
Here we differ from [[First-order logic in terms of substitution built on equality]] mainly because our axiom set is a bit different from the axioms used there, not primarily because of any differences between intuitionistic logic and classical logic. In particular, we don't have an axiom for <code>∀ x (φ → ψ) → (∀ x φ → ∀ x ψ)</code> and related theorems, but need to derive them from <code>addForAllToConsequentNotFree</code> and the like. We start with the rule which lets us add <code>∀</code> to both sides of an implication.
<jh>
thm (addForAll () ((H (φ → ψ))) ((∀ x φ) → (∀ x ψ)) (
        x φ BoundForAllNotFree

        x φ Specialization
        H
        applySyllogism

        addForAllToConsequentNotFree
))
</jh>

The builder for the biconditional follows trivially:
<jh>
thm (buildForAll () ((H (φ ↔ ψ))) ((∀ x φ) ↔ (∀ x ψ)) (
        H eliminateBiconditionalReverse x addForAll
        H eliminateBiconditionalForward x addForAll
        introduceBiconditionalFromImplications
))
</jh>

== Export ==
Having proved everything in [[Interface:Intuitionistic first-order logic]], we export to it.
<jh>
#export (RESULT Interface:Intuitionistic_first-order_logic (PROPOSITIONAL) ())
</jh>

[[Category:Subsystems of classical logic|${PAGENAME}]]
