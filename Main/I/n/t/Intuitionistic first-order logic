{{header
 | title    = Intuitionistic first-order logic
 | subtitle =
 | left     =
 | right    =
 | shortcut =
 | notes    = The purpose of this page is to prove the statements of [[Interface:Intuitionistic first-order logic]] from the [[Interface:Axioms of intuitionistic first-order logic]].
}}
{{interfaces
| imports = [[Interface:Axioms of intuitionistic first-order logic]]
| exports = [[Interface:Intuitionistic first-order logic]]
}}

We start with propositional logic and our axioms.

<jh>
import (PROPOSITIONAL Interface:Intuitionistic_propositional_logic () ())
import (AXIOMS Interface:Axioms_of_intuitionistic_first-order_logic (PROPOSITIONAL) ())
</jh>

As usual, φ and ψ are formulas, x, y, and z are variables, and s, t, and u are terms:

<jh>
var (formula φ ψ φx φy φs antecedent)
var (object s t u s0 s1 t0 t1)
var (variable x y z x0 x1 y0 y1)
</jh>

We largely follow the development from [[First-order logic in terms of substitution built on equality]] although some of the details are different and of course we don't prove quite all the theorems, as not all of them hold in intuitionistic logic.

== Substitution ==
As with [[First-order logic in terms of substitution built on equality]] (slightly more so, even), substitution is central to our proofs, so we start with some substitution theorems.

=== Rule forms of substitution axioms ===
Here are some rules which are convenience forms of axioms, just as in [[First-order logic in terms of substitution built on equality]].
<jh>
thm (specializeToObject () ((H (∀ x φ))) (subst s x φ) (
        H
        x φ s SpecializationToObject
        applyModusPonens
))

thm (specializeToObjectInConsequent () ((H (antecedent → (∀ x φ)))) (antecedent → (subst s x φ)) (
        H
        x φ s SpecializationToObject
        applySyllogism
))

thm (makeSubstExplicit ((x s) (x ψ))
  ((H (((value x) = s) → (φ ↔ ψ))))
  ((subst s x φ) ↔ ψ) (
        x ψ DistinctNotFree
        H
        makeSubstExplicitNotFree
))

thm (buildSubstReplacement () ((H (s = t)))
  ((subst s x φ) ↔ (subst t x φ)) (
        H
        s t x φ SubstBuilderReplacement
        applyModusPonens
))
</jh>

=== Composition ===
Substitution composition works just as in [[First-order logic in terms of substitution built on equality]].

<jh>
thm (SubstitutionComposition ((φ y) (s y) (x y)) ()
  ((subst s y (subst (value y) x φ)) ↔ (subst s x φ)) (
        (value y) s x φ SubstBuilderReplacement
        makeSubstExplicit
))
</jh>

=== EqualitySubst ===
Similarly, the proof from [[First-order logic in terms of substitution built on equality]] of <code>EqualitySubst</code> works here too.
<jh>
thm (EqualitySubst () () (((value x) = s) → (φ ↔ (subst s x φ))) (
        (value x) s x φ SubstBuilderReplacement
        x φ SubstItself
        transformImplicationBiconditionalLeft
))
</jh>

== Specialization and existential introduction without a substitution ==
The theorems <code>∀ x φ → φ</code> and <code>φ → ∃ x φ</code> (which are special cases of the corresponding axioms which include substitutions) follow using the same proofs as in [[First-order logic in terms of substitution built on equality]].
<jh>
thm (Specialization () () ((∀ x φ) → φ) (
        x φ (value x) SpecializationToObject

        x φ SubstItself
        eliminateBiconditionalReverse
        applySyllogism
))

thm (specialize () ((H (∀ x φ))) φ (
        H
        x φ Specialization
        applyModusPonens
))

thm (ThereExistsIntroduction () () (φ → (∃ x φ)) (
        x φ SubstItself
        eliminateBiconditionalForward

        (value x) x φ ThereExistsIntroductionFromObject
        applySyllogism
))
</jh>

The previous results let us conclude <code>∀ x φ → ∃ x φ</code>.
<jh>
thm (ForAllThereExists () () ((∀ x φ) → (∃ x φ)) (
        x φ Specialization
        φ x ThereExistsIntroduction
        applySyllogism
))
</jh>

== Generalization ==
Here we show that <code>φ → ∀ x φ</code>, provided that <code>x</code> is not free in <code>φ</code>.
<jh>
thm (GeneralizationNotFree () ((HFREE (x is-not-free-in φ))) (φ → (∀ x φ)) (
        HFREE
        φ ImplicationReflexivity
        addForAllToConsequentNotFree
))
</jh>

We also can generalize a theorem, even if the variable is free in it. The proof proceeds by turning <code>φ</code> into <code>⊤ → φ</code>, adding the quantifier to the consequent, and then removing the antecedent.
<jh>
thm (generalize () ((H φ)) (∀ x φ) (
        True

        x (⊤) DistinctNotFree

        H
        (⊤) introduceAntecedent

        addForAllToConsequentNotFree

        applyModusPonens
))
</jh>

== Building for-all across implication ==
Here we differ from [[First-order logic in terms of substitution built on equality]] mainly because our axiom set is a bit different from the axioms used there, not primarily because of any differences between intuitionistic logic and classical logic. In particular, we don't have an axiom for <code>∀ x (φ → ψ) → (∀ x φ → ∀ x ψ)</code> and related theorems, but need to derive them from <code>addForAllToConsequentNotFree</code> and the like. We start with the rule which lets us add <code>∀</code> to both sides of an implication.
<jh>
thm (addForAll () ((H (φ → ψ))) ((∀ x φ) → (∀ x ψ)) (
        x φ BoundForAllNotFree

        x φ Specialization
        H
        applySyllogism

        addForAllToConsequentNotFree
))
</jh>

The builder for the biconditional follows trivially:
<jh>
thm (buildForAll () ((H (φ ↔ ψ))) ((∀ x φ) ↔ (∀ x ψ)) (
        H eliminateBiconditionalReverse x addForAll
        H eliminateBiconditionalForward x addForAll
        introduceBiconditionalFromImplications
))
</jh>

== More substitution ==
Now that we have proved builders, we can return to some more substitution results.

=== Builders ===
Here are some builders for which the proof from [[First-order logic in terms of substitution built on equality]] works verbatim.
<jh>
thm (SubstBuilder () () ((∀ x (φ ↔ ψ)) → ((subst s x φ) ↔ (subst s x ψ))) (
        φ ψ BiconditionalReverseElimination
        x addForAll

        x φ ψ s SubstAddition
        applySyllogism

        φ ψ BiconditionalForwardElimination
        x addForAll

        x ψ φ s SubstAddition
        applySyllogism

        introduceBiconditionalFromImplicationsInConsequent
))

thm (addSubst () ((H (φ → ψ))) ((subst s x φ) → (subst s x ψ)) (
        H
        x generalize
        x φ ψ s SubstAddition
        applyModusPonens
))

thm (buildSubst () ((H (φ ↔ ψ))) ((subst s x φ) ↔ (subst s x ψ)) (
        H
        x generalize
        x φ ψ s SubstBuilder
        applyModusPonens
))
</jh>

=== Moving substitution across negation ===
Substitution can be moved in or out of a predicate or operation, provided the predicate or operation has a builder. We start with the case where the predicate is <code>¬</code> and the builder <code>NegationBuilder</code>. Other than changing <code>NegationFunction</code> to <code>NegationBuilder</code>, the proof is as in [[First-order logic in terms of substitution built on equality]], where it is explained in more detail.

We start with the special case in which the variable being substituted is distinct from its replacement.
<jh>
thm (SubstNegationDistinct ((x s)) () ((subst s x (¬ φ)) ↔ (¬ (subst s x φ))) (
        x s φ SubstNotFree
        negateNotFree

        x s φ EqualitySubst

        φ (subst s x φ) NegationBuilder
        applySyllogism

        makeSubstExplicitNotFree
))

thm (SubstNegation ( (y x) (y s) (y φ)) () ((subst s x (¬ φ)) ↔ (¬ (subst s x φ))) (
        s y x (¬ φ) SubstitutionComposition
        swapBiconditional

        (value y) x φ SubstNegationDistinct
        s y buildSubst
        applyBiconditionalTransitivity

        s y (subst (value y) x φ) SubstNegationDistinct
        applyBiconditionalTransitivity

        s y x φ SubstitutionComposition
        addNegation
        applyBiconditionalTransitivity
))
</jh>

=== Moving substitution across implication ===
The proof for other connectives is similar and also matches what we did in [[First-order logic in terms of substitution built on equality]].
<jh>
thm (SubstImplicationDistinct ((s x)) () ((subst s x (φ → ψ)) ↔ ((subst s x φ) → (subst s x ψ))) (
        x s φ SubstNotFree
        x s ψ SubstNotFree
        implicationNotFree

        (value x) s x φ SubstBuilderReplacement
        (value x) s x ψ SubstBuilderReplacement
        buildImplicationInConsequent

        x φ SubstItself
        x ψ SubstItself
        buildImplication
        transformImplicationBiconditionalLeft

        makeSubstExplicitNotFree
))

thm (SubstImplication ( (y x) (y s) (y φ) (y ψ)) () ((subst s x (φ → ψ)) ↔ ((subst s x φ) → (subst s x ψ))) (
        s y x (φ → ψ) SubstitutionComposition
        swapBiconditional

        (value y) x φ ψ SubstImplicationDistinct
        s y buildSubst
        applyBiconditionalTransitivity

        s y (subst (value y) x φ) (subst (value y) x ψ) SubstImplicationDistinct
        applyBiconditionalTransitivity

        s y x φ SubstitutionComposition
        s y x ψ SubstitutionComposition
        buildImplication
        applyBiconditionalTransitivity
))
</jh>

=== Subst across disjunction, conjunction, and biconditional ===
Disjunction and conjunction are not related to implication and negation in as simple a manner as in classical logic, so we just prove the disjunction and conjunction results the same way we proved the implication and negation ones.
<jh>
thm (SubstDisjunctionDistinct ((s x)) () ((subst s x (φ ∨ ψ)) ↔ ((subst s x φ) ∨ (subst s x ψ))) (
        x s φ SubstNotFree
        x s ψ SubstNotFree
        disjunctionNotFree

        (value x) s x φ SubstBuilderReplacement
        (value x) s x ψ SubstBuilderReplacement
        buildDisjunctionInConsequent

        x φ SubstItself
        x ψ SubstItself
        buildDisjunction
        transformImplicationBiconditionalLeft

        makeSubstExplicitNotFree
))

thm (SubstDisjunction ( (y x) (y s) (y φ) (y ψ)) ()
  ((subst s x (φ ∨ ψ)) ↔ ((subst s x φ) ∨ (subst s x ψ))) (
        s y x (φ ∨ ψ) SubstitutionComposition
        swapBiconditional

        (value y) x φ ψ SubstDisjunctionDistinct
        s y buildSubst
        applyBiconditionalTransitivity

        s y (subst (value y) x φ) (subst (value y) x ψ) SubstDisjunctionDistinct
        applyBiconditionalTransitivity

        s y x φ SubstitutionComposition
        s y x ψ SubstitutionComposition
        buildDisjunction
        applyBiconditionalTransitivity
))

thm (SubstConjunctionDistinct ((s x)) () ((subst s x (φ ∧ ψ)) ↔ ((subst s x φ) ∧ (subst s x ψ))) (
        x s φ SubstNotFree
        x s ψ SubstNotFree
        conjunctionNotFree

        (value x) s x φ SubstBuilderReplacement
        (value x) s x ψ SubstBuilderReplacement
        buildConjunctionInConsequent

        x φ SubstItself
        x ψ SubstItself
        buildConjunction
        transformImplicationBiconditionalLeft

        makeSubstExplicitNotFree
))

thm (SubstConjunction ( (y x) (y s) (y φ) (y ψ)) ()
  ((subst s x (φ ∧ ψ)) ↔ ((subst s x φ) ∧ (subst s x ψ))) (
        s y x (φ ∧ ψ) SubstitutionComposition
        swapBiconditional

        (value y) x φ ψ SubstConjunctionDistinct
        s y buildSubst
        applyBiconditionalTransitivity

        s y (subst (value y) x φ) (subst (value y) x ψ) SubstConjunctionDistinct
        applyBiconditionalTransitivity

        s y x φ SubstitutionComposition
        s y x ψ SubstitutionComposition
        buildConjunction
        applyBiconditionalTransitivity
))
</jh>

The biconditional, on the other hand, can be defined in terms of implication and conjunction, as in classical logic. Therefore, it is more convenient to prove the corresponding theorem for the biconditional in terms of the theorems for implication and conjunction.

<jh>
thm (SubstBiconditional () () ((subst s x (φ ↔ ψ)) ↔ ((subst s x φ) ↔ (subst s x ψ))) (
        φ ψ BiconditionalImplication
        s x buildSubst

        s x (φ → ψ) (ψ → φ) SubstConjunction
        applyBiconditionalTransitivity

        s x φ ψ SubstImplication
        s x ψ φ SubstImplication
        buildConjunction
        applyBiconditionalTransitivity

        (subst s x φ) (subst s x ψ) BiconditionalImplication
        swapBiconditional
        applyBiconditionalTransitivity
))
</jh>

== Quantifier commutation ==
Being able to exchange the order of universal quantifiers is proved just as in [[First-order logic in terms of substitution built on equality]].
<jh>
thm (ForAllCommutationImplication () () ((∀ x (∀ y φ)) → (∀ y (∀ x φ))) (

        x (∀ y φ) BoundForAllNotFree
        GeneralizationNotFree

        y φ BoundForAllNotFree
        x addForAllNotFree
        x addForAllNotFree
        GeneralizationNotFree
        applySyllogism

        y φ Specialization
        x addForAll
        x addForAll
        y addForAll
        applySyllogism

        x φ Specialization
        x addForAll
        y addForAll
        applySyllogism
))

thm (ForAllCommutation () () ((∀ x (∀ y φ)) ↔ (∀ y (∀ x φ))) (
        x y φ ForAllCommutationImplication
        y x φ ForAllCommutationImplication
        introduceBiconditionalFromImplications
))
</jh>

== Adding and removing quantifiers ==
The biconditionalized thereorem <code>∀ x φ ↔ φ</code> works just as in [[First-order logic in terms of substitution built on equality]].

<jh>
thm (ForAllAddRemoveNotFree () ((XFREE (x is-not-free-in φ))) ((∀ x φ) ↔ φ) (
        x φ Specialization

        XFREE
        GeneralizationNotFree

        introduceBiconditionalFromImplications
))
</jh>

== Moving is-not-free-in across connectives ==
We've adopted as axioms the ability the move <code>is-not-free-in</code> across most connectives. The one remaining is the biconditional, which follows from the axioms for implication and conjunction.

<jh>
thm (biconditionalNotFree ()
  ((HPHI (x is-not-free-in φ)) (HPSI (x is-not-free-in ψ)))
  (x is-not-free-in (φ ↔ ψ)) (
        HPHI
        HPSI
        implicationNotFree

        HPSI
        HPHI
        implicationNotFree

        conjunctionNotFree

        φ ψ BiconditionalImplication
        x buildNotFree
        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

== TODO ==
{{cleanup|handling these theorems somehow}}
* ThereExistsAntecedentIntroductionNotFree: similar to addThereExistsToAntecedent in spirit but not easily derivable from it. Perhaps more closely related to ForAllImplication.

== Export ==
Having proved everything in [[Interface:Intuitionistic first-order logic]], we export to it.
<jh>
#export (RESULT Interface:Intuitionistic_first-order_logic (PROPOSITIONAL) ())
</jh>

[[Category:Subsystems of classical logic|${PAGENAME}]]
