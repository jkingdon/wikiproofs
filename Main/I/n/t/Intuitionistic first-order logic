{{header
 | title    = Intuitionistic first-order logic
 | subtitle =
 | left     =
 | right    =
 | shortcut =
 | notes    = The purpose of this page is to prove the statements of [[Interface:Intuitionistic first-order logic]] from the [[Interface:Axioms of intuitionistic first-order logic]].
}}
{{interfaces
| imports = [[Interface:Axioms of intuitionistic first-order logic]]
| exports = [[Interface:Intuitionistic first-order logic]]
}}

We start with propositional logic and our axioms.

<jh>
import (PROPOSITIONAL Interface:Intuitionistic_propositional_logic () ())
import (AXIOMS Interface:Axioms_of_intuitionistic_first-order_logic (PROPOSITIONAL) ())
</jh>

As usual, φ and ψ are formulas, x, y, and z are variables, and s, t, and u are terms:

<jh>
var (formula φ ψ φx φy φs antecedent)
var (object s t u s0 s1 t0 t1)
var (variable x y z x0 x1 y0 y1)
</jh>

We largely follow the development from [[First-order logic in terms of substitution built on equality]] although some of the details are different and of course we don't prove quite all the theorems, as not all of them hold in intuitionistic logic.

== Substitution ==
As with [[First-order logic in terms of substitution built on equality]] (slightly more so, even), substitution is central to our proofs, so we start with some substitution theorems.

=== Rule forms of substitution axioms ===
Here are some rules which are convenience forms of axioms, just as in [[First-order logic in terms of substitution built on equality]].
<jh>
thm (specializeToObject () ((H (∀ x φ))) (subst s x φ) (
        H
        x φ s SpecializationToObject
        applyModusPonens
))

thm (specializeToObjectInConsequent () ((H (antecedent → (∀ x φ)))) (antecedent → (subst s x φ)) (
        H
        x φ s SpecializationToObject
        applySyllogism
))

thm (makeSubstExplicit ((x s) (x ψ))
  ((H (((value x) = s) → (φ ↔ ψ))))
  ((subst s x φ) ↔ ψ) (
        x ψ DistinctNotFree
        H
        makeSubstExplicitNotFree
))

thm (buildSubstReplacement () ((H (s = t)))
  ((subst s x φ) ↔ (subst t x φ)) (
        H
        s t x φ SubstBuilderReplacement
        applyModusPonens
))
</jh>

=== Composition ===
Substitution composition works just as in [[First-order logic in terms of substitution built on equality]].

<jh>
thm (SubstitutionComposition ((φ y) (s y) (x y)) ()
  ((subst s y (subst (value y) x φ)) ↔ (subst s x φ)) (
        (value y) s x φ SubstBuilderReplacement
        makeSubstExplicit
))
</jh>

=== EqualitySubst ===
Similarly, the proof from [[First-order logic in terms of substitution built on equality]] of <code>EqualitySubst</code> works here too.
<jh>
thm (EqualitySubst () () (((value x) = s) → (φ ↔ (subst s x φ))) (
        (value x) s x φ SubstBuilderReplacement
        x φ SubstItself
        transformImplicationBiconditionalLeft
))
</jh>

== Specialization and existential introduction without a substitution ==
The theorems <code>∀ x φ → φ</code> and <code>φ → ∃ x φ</code> (which are special cases of the corresponding axioms which include substitutions) follow using the same proofs as in [[First-order logic in terms of substitution built on equality]].
<jh>
thm (Specialization () () ((∀ x φ) → φ) (
        x φ (value x) SpecializationToObject

        x φ SubstItself
        eliminateBiconditionalReverse
        applySyllogism
))

thm (specialize () ((H (∀ x φ))) φ (
        H
        x φ Specialization
        applyModusPonens
))

thm (ThereExistsIntroduction () () (φ → (∃ x φ)) (
        x φ SubstItself
        eliminateBiconditionalForward

        (value x) x φ ThereExistsIntroductionFromObject
        applySyllogism
))
</jh>

The previous results let us conclude <code>∀ x φ → ∃ x φ</code>.
<jh>
thm (ForAllThereExists () () ((∀ x φ) → (∃ x φ)) (
        x φ Specialization
        φ x ThereExistsIntroduction
        applySyllogism
))
</jh>

== Generalization ==
Here we show that <code>φ → ∀ x φ</code>, provided that <code>x</code> is not free in <code>φ</code>.
<jh>
thm (GeneralizationNotFree () ((HFREE (x is-not-free-in φ))) (φ → (∀ x φ)) (
        HFREE
        φ ImplicationReflexivity
        addForAllToConsequentNotFree
))
</jh>

We also can generalize a theorem, even if the variable is free in it. The proof proceeds by turning <code>φ</code> into <code>⊤ → φ</code>, adding the quantifier to the consequent, and then removing the antecedent.
<jh>
thm (generalize () ((H φ)) (∀ x φ) (
        True

        x (⊤) DistinctNotFree

        H
        (⊤) introduceAntecedent

        addForAllToConsequentNotFree

        applyModusPonens
))
</jh>

== Building for-all across implication ==
Here we differ from [[First-order logic in terms of substitution built on equality]] mainly because our axiom set is a bit different from the axioms used there, not primarily because of any differences between intuitionistic logic and classical logic. In particular, we don't have an axiom for <code>∀ x (φ → ψ) → (∀ x φ → ∀ x ψ)</code> and related theorems, but need to derive them from <code>addForAllToConsequentNotFree</code> and the like. We start with the rule which lets us add <code>∀</code> to both sides of an implication.
<jh>
thm (addForAll () ((H (φ → ψ))) ((∀ x φ) → (∀ x ψ)) (
        x φ BoundForAllNotFree

        x φ Specialization
        H
        applySyllogism

        addForAllToConsequentNotFree
))
</jh>

The builder for the biconditional follows trivially:
<jh>
thm (buildForAll () ((H (φ ↔ ψ))) ((∀ x φ) ↔ (∀ x ψ)) (
        H eliminateBiconditionalReverse x addForAll
        H eliminateBiconditionalForward x addForAll
        introduceBiconditionalFromImplications
))
</jh>

=== For-all across an implication ===
We've just proved rules regarding distributing <code>∀</code> across an implication or biconditional. There are corresponding non-rule theorems. For implication, this is <code>∀ x (φ → ψ) → (∀ x φ → ∀ x ψ)</code>.
<jh>
thm (ForAllImplication () () ((∀ x (φ → ψ)) → ((∀ x φ) → (∀ x ψ))) (
</jh>
The proof is based on <code>∀ x φ ∧ ∀ x (φ → ψ) → ψ</code> (which follows from specialization and propositional logic). From there we'll be adding for-all to the consequent, so we start with <code>x is-not-free-in (∀ x φ ∧ ∀ x (φ → ψ))</code>.
<jh>
        x φ BoundForAllNotFree
        x (φ → ψ) BoundForAllNotFree
        conjunctionNotFree

        x φ Specialization
        x (φ → ψ) Specialization
        conjoin

        φ ψ ModusPonens
        applySyllogism

        addForAllToConsequentNotFree
        export
        applyComm
))
</jh>

== More substitution ==
Now that we have proved builders, we can return to some more substitution results.

=== Builders ===
Here are some builders for which the proof from [[First-order logic in terms of substitution built on equality]] works verbatim.
<jh>
thm (SubstBuilder () () ((∀ x (φ ↔ ψ)) → ((subst s x φ) ↔ (subst s x ψ))) (
        φ ψ BiconditionalReverseElimination
        x addForAll

        x φ ψ s SubstAddition
        applySyllogism

        φ ψ BiconditionalForwardElimination
        x addForAll

        x ψ φ s SubstAddition
        applySyllogism

        introduceBiconditionalFromImplicationsInConsequent
))

thm (addSubst () ((H (φ → ψ))) ((subst s x φ) → (subst s x ψ)) (
        H
        x generalize
        x φ ψ s SubstAddition
        applyModusPonens
))

thm (buildSubst () ((H (φ ↔ ψ))) ((subst s x φ) ↔ (subst s x ψ)) (
        H
        x generalize
        x φ ψ s SubstBuilder
        applyModusPonens
))
</jh>

=== Moving substitution across negation ===
Substitution can be moved in or out of a predicate or operation, provided the predicate or operation has a builder. We start with the case where the predicate is <code>¬</code> and the builder <code>NegationBuilder</code>. Other than changing <code>NegationFunction</code> to <code>NegationBuilder</code>, the proof is as in [[First-order logic in terms of substitution built on equality]], where it is explained in more detail.

We start with the special case in which the variable being substituted is distinct from its replacement.
<jh>
thm (SubstNegationDistinct ((x s)) () ((subst s x (¬ φ)) ↔ (¬ (subst s x φ))) (
        x s φ SubstNotFree
        negateNotFree

        x s φ EqualitySubst

        φ (subst s x φ) NegationBuilder
        applySyllogism

        makeSubstExplicitNotFree
))

thm (SubstNegation ( (y x) (y s) (y φ)) () ((subst s x (¬ φ)) ↔ (¬ (subst s x φ))) (
        s y x (¬ φ) SubstitutionComposition
        swapBiconditional

        (value y) x φ SubstNegationDistinct
        s y buildSubst
        applyBiconditionalTransitivity

        s y (subst (value y) x φ) SubstNegationDistinct
        applyBiconditionalTransitivity

        s y x φ SubstitutionComposition
        addNegation
        applyBiconditionalTransitivity
))
</jh>

=== Moving substitution across implication ===
The proof for other connectives is similar and also matches what we did in [[First-order logic in terms of substitution built on equality]].
<jh>
thm (SubstImplicationDistinct ((s x)) () ((subst s x (φ → ψ)) ↔ ((subst s x φ) → (subst s x ψ))) (
        x s φ SubstNotFree
        x s ψ SubstNotFree
        implicationNotFree

        (value x) s x φ SubstBuilderReplacement
        (value x) s x ψ SubstBuilderReplacement
        buildImplicationInConsequent

        x φ SubstItself
        x ψ SubstItself
        buildImplication
        transformImplicationBiconditionalLeft

        makeSubstExplicitNotFree
))

thm (SubstImplication ( (y x) (y s) (y φ) (y ψ)) () ((subst s x (φ → ψ)) ↔ ((subst s x φ) → (subst s x ψ))) (
        s y x (φ → ψ) SubstitutionComposition
        swapBiconditional

        (value y) x φ ψ SubstImplicationDistinct
        s y buildSubst
        applyBiconditionalTransitivity

        s y (subst (value y) x φ) (subst (value y) x ψ) SubstImplicationDistinct
        applyBiconditionalTransitivity

        s y x φ SubstitutionComposition
        s y x ψ SubstitutionComposition
        buildImplication
        applyBiconditionalTransitivity
))
</jh>

=== Subst across disjunction, conjunction, and biconditional ===
Disjunction and conjunction are not related to implication and negation in as simple a manner as in classical logic, so we just prove the disjunction and conjunction results the same way we proved the implication and negation ones.
<jh>
thm (SubstDisjunctionDistinct ((s x)) () ((subst s x (φ ∨ ψ)) ↔ ((subst s x φ) ∨ (subst s x ψ))) (
        x s φ SubstNotFree
        x s ψ SubstNotFree
        disjunctionNotFree

        (value x) s x φ SubstBuilderReplacement
        (value x) s x ψ SubstBuilderReplacement
        buildDisjunctionInConsequent

        x φ SubstItself
        x ψ SubstItself
        buildDisjunction
        transformImplicationBiconditionalLeft

        makeSubstExplicitNotFree
))

thm (SubstDisjunction ( (y x) (y s) (y φ) (y ψ)) ()
  ((subst s x (φ ∨ ψ)) ↔ ((subst s x φ) ∨ (subst s x ψ))) (
        s y x (φ ∨ ψ) SubstitutionComposition
        swapBiconditional

        (value y) x φ ψ SubstDisjunctionDistinct
        s y buildSubst
        applyBiconditionalTransitivity

        s y (subst (value y) x φ) (subst (value y) x ψ) SubstDisjunctionDistinct
        applyBiconditionalTransitivity

        s y x φ SubstitutionComposition
        s y x ψ SubstitutionComposition
        buildDisjunction
        applyBiconditionalTransitivity
))

thm (SubstConjunctionDistinct ((s x)) () ((subst s x (φ ∧ ψ)) ↔ ((subst s x φ) ∧ (subst s x ψ))) (
        x s φ SubstNotFree
        x s ψ SubstNotFree
        conjunctionNotFree

        (value x) s x φ SubstBuilderReplacement
        (value x) s x ψ SubstBuilderReplacement
        buildConjunctionInConsequent

        x φ SubstItself
        x ψ SubstItself
        buildConjunction
        transformImplicationBiconditionalLeft

        makeSubstExplicitNotFree
))

thm (SubstConjunction ( (y x) (y s) (y φ) (y ψ)) ()
  ((subst s x (φ ∧ ψ)) ↔ ((subst s x φ) ∧ (subst s x ψ))) (
        s y x (φ ∧ ψ) SubstitutionComposition
        swapBiconditional

        (value y) x φ ψ SubstConjunctionDistinct
        s y buildSubst
        applyBiconditionalTransitivity

        s y (subst (value y) x φ) (subst (value y) x ψ) SubstConjunctionDistinct
        applyBiconditionalTransitivity

        s y x φ SubstitutionComposition
        s y x ψ SubstitutionComposition
        buildConjunction
        applyBiconditionalTransitivity
))
</jh>

The biconditional, on the other hand, can be defined in terms of implication and conjunction, as in classical logic. Therefore, it is more convenient to prove the corresponding theorem for the biconditional in terms of the theorems for implication and conjunction.

<jh>
thm (SubstBiconditional () () ((subst s x (φ ↔ ψ)) ↔ ((subst s x φ) ↔ (subst s x ψ))) (
        φ ψ BiconditionalImplication
        s x buildSubst

        s x (φ → ψ) (ψ → φ) SubstConjunction
        applyBiconditionalTransitivity

        s x φ ψ SubstImplication
        s x ψ φ SubstImplication
        buildConjunction
        applyBiconditionalTransitivity

        (subst s x φ) (subst s x ψ) BiconditionalImplication
        swapBiconditional
        applyBiconditionalTransitivity
))
</jh>

== Quantifier commutation ==
Being able to exchange the order of universal quantifiers is proved just as in [[First-order logic in terms of substitution built on equality]].
<jh>
thm (ForAllCommutationImplication () () ((∀ x (∀ y φ)) → (∀ y (∀ x φ))) (

        x (∀ y φ) BoundForAllNotFree
        GeneralizationNotFree

        y φ BoundForAllNotFree
        x addForAllNotFree
        x addForAllNotFree
        GeneralizationNotFree
        applySyllogism

        y φ Specialization
        x addForAll
        x addForAll
        y addForAll
        applySyllogism

        x φ Specialization
        x addForAll
        y addForAll
        applySyllogism
))

thm (ForAllCommutation () () ((∀ x (∀ y φ)) ↔ (∀ y (∀ x φ))) (
        x y φ ForAllCommutationImplication
        y x φ ForAllCommutationImplication
        introduceBiconditionalFromImplications
))
</jh>

== Adding and removing quantifiers ==
The biconditionalized thereorem <code>∀ x φ ↔ φ</code> works just as in [[First-order logic in terms of substitution built on equality]].

<jh>
thm (ForAllAddRemoveNotFree () ((XFREE (x is-not-free-in φ))) ((∀ x φ) ↔ φ) (
        x φ Specialization

        XFREE
        GeneralizationNotFree

        introduceBiconditionalFromImplications
))
</jh>

== Moving is-not-free-in across connectives ==
We've adopted as axioms the ability the move <code>is-not-free-in</code> across most connectives. The one remaining is the biconditional, which follows from the axioms for implication and conjunction.

<jh>
thm (biconditionalNotFree ()
  ((HPHI (x is-not-free-in φ)) (HPSI (x is-not-free-in ψ)))
  (x is-not-free-in (φ ↔ ψ)) (
        HPHI
        HPSI
        implicationNotFree

        HPSI
        HPHI
        implicationNotFree

        conjunctionNotFree

        φ ψ BiconditionalImplication
        x buildNotFree
        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

== Adding there exists to the antecedent ==
We have as an axiom the rule that one can add there exists to the antecedent if the variable of quantification is not free in the consequent. In this section we prove some variations of this rule and consequences of it.

=== Distinct variable version ===
Here's the special case where the variable does not occur in the consequent.
<jh>
thm (addThereExistsToAntecedent ((x ψ))
  ((H (φ → ψ)))
  ((∃ x φ) → ψ) (
        x ψ DistinctNotFree
        H
        addThereExistsToAntecedentNotFree
))
</jh>

=== Non-rule form ===
Here is a non-rule form of adding there-exists to the antecedent.
<jh>
thm (ThereExistsAntecedentIntroductionNotFree ()
  ((HFREE (x is-not-free-in ψ)))
  ((∀ x (φ → ψ)) → ((∃ x φ) → ψ)) (
</jh>
The proof first constructs <code>φ → (∀ x (φ → ψ) → ψ)</code> (from specialization and propositional logic) and then adds there-exists to the antecedent. We start with <code>x is-not-free-in (∀ x (φ → ψ) → ψ)</code>.
<jh>
        x (φ → ψ) BoundForAllNotFree
        HFREE
        implicationNotFree

        x (φ → ψ) Specialization
        applyComm

        addThereExistsToAntecedentNotFree
        applyComm
))
</jh>

=== There exists across a conjunction ===
The proof of <code>∃ x (φ ∧ ψ) → ∃ x φ ∧ ∃ x ψ</code> works as in [[First-order logic in terms of substitution built on equality]] without modification.
<jh>
thm (ThereExistsConjunction () () ((∃ x (φ ∧ ψ)) → ((∃ x φ) ∧ (∃ x ψ))) (
        x φ BoundThereExistsNotFree
        x ψ BoundThereExistsNotFree
        conjunctionNotFree

        φ ψ ConjunctionRightElimination

        φ x ThereExistsIntroduction
        applySyllogism

        φ ψ ConjunctionLeftElimination

        ψ x ThereExistsIntroduction
        applySyllogism

        composeConjunction

        addThereExistsToAntecedentNotFree
))
</jh>

=== Adding there exists to both sides of an implication ===
We prove <code>∀ x (φ → ψ) → (∃ x φ → ∃ x ψ)</code> as in [[First-order logic in terms of substitution built on equality]].
<jh>
thm (ForAllImplicationThereExists () () ((∀ x (φ → ψ)) → ((∃ x φ) → (∃ x ψ))) (
        ψ x ThereExistsIntroduction
        φ addCommonAntecedent
        x addForAll

        x ψ BoundThereExistsNotFree
        φ ThereExistsAntecedentIntroductionNotFree

        applySyllogism
))

thm (addThereExists () ((H (φ → ψ))) ((∃ x φ) → (∃ x ψ)) (
        H
        x generalize
        x φ ψ ForAllImplicationThereExists
        applyModusPonens
))
</jh>

=== There exists commutation ===
Being able to swap the order of two existential quantifiers, <code>∃ x ∃ y φ → ∃ y ∃ x φ</code>, follows from the proof in [[First-order logic in terms of substitution built on equality]] (which, by not being based on the corresponding theorem for <code>∀</code>, works in intuitionistic logic).
<jh>
thm (ThereExistsCommutationImplication () () ((∃ x (∃ y φ)) → (∃ y (∃ x φ))) (
        x φ BoundThereExistsNotFree
        y addThereExistsNotFree

        y (∃ x φ) BoundThereExistsNotFree

        φ x ThereExistsIntroduction

        (∃ x φ) y ThereExistsIntroduction
        applySyllogism

        addThereExistsToAntecedentNotFree

        addThereExistsToAntecedentNotFree
))

thm (ThereExistsCommutation () () ((∃ x (∃ y φ)) ↔ (∃ y (∃ x φ))) (
        x y φ ThereExistsCommutationImplication
        y x φ ThereExistsCommutationImplication
        introduceBiconditionalFromImplications
))
</jh>

=== Adding for-all to the consequent ===
Although the proof of <code>ForAllConsequentNotFree</code> from [[First-order logic in terms of substitution built on equality]] would work here, at least for now we omit it, as we already have <code>addForAllToConsequentNotFree</code>.

=== For all across a biconditional ===
We can distribute for all across a biconditional, and the proof in [[First-order logic in terms of substitution built on equality]] works here without modification.
<jh>
thm (ForAllBiconditionalImplication () () ((∀ x (φ ↔ ψ)) → ((∀ x φ) → (∀ x ψ))) (
        φ ψ BiconditionalReverseElimination
        x addForAll

        x φ ψ ForAllImplication
        applySyllogism
))

thm (ForAllBiconditional () () ((∀ x (φ ↔ ψ)) → ((∀ x φ) ↔ (∀ x ψ))) (
        x φ ψ ForAllBiconditionalImplication

        φ ψ BiconditionalSymmetry
        eliminateBiconditionalReverse
        x addForAll

        x ψ φ ForAllBiconditionalImplication
        applySyllogism

        introduceBiconditionalFromImplicationsInConsequent
))
</jh>

=== Adding there-exists to both sides of a biconditional ===
The counterpart to <code>buildForAll</code> follows from <code>addThereExists</code>. The proof in [[First-order logic in terms of substitution built on equality]] is based on the relationship between <code>∀</code> and <code>∃</code> which holds in classical logic but not in intuitionistic logic.
<jh>
thm (buildThereExists () ((H (φ ↔ ψ))) ((∃ x φ) ↔ (∃ x ψ)) (
        H eliminateBiconditionalReverse x addThereExists
        H eliminateBiconditionalForward x addThereExists
        introduceBiconditionalFromImplications
))
</jh>

=== Change of variable in ∀ ===
The proof in [[First-order logic in terms of substitution built on equality]] holds as-is.

<jh>
thm (ChangeVariableForAllImplicationNotFree ((x y))
  ((HFREEX (x is-not-free-in φy))
   (HFREEY (y is-not-free-in φx))
   (H (((value x) = (value y)) → (φx ↔ φy)))
  )
  ((∀ x φx) → (∀ y φy)) (
        HFREEY
        x addForAllNotFree
        x φx (value y) SpecializationToObject
        addForAllToConsequentNotFree

        HFREEX
        H
        makeSubstExplicitNotFree

        eliminateBiconditionalReverse
        y addForAll
        applySyllogism
))

thm (ChangeVariableForAllNotFree ((x y))
  ((HFREEX (x is-not-free-in φy))
   (HFREEY (y is-not-free-in φx))
   (H (((value x) = (value y)) → (φx ↔ φy)))
  )
  ((∀ x φx) ↔ (∀ y φy)) (
        HFREEX HFREEY H ChangeVariableForAllImplicationNotFree

        HFREEY HFREEX
        H
        (value x) (value y) EqualitySymmetry
        transformAntecedent

        φx φy BiconditionalSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        ChangeVariableForAllImplicationNotFree

        introduceBiconditionalFromImplications
))

thm (ChangeVariableForAll ((y φx) (x φy) (x y))
  ((H (((value x) = (value y)) → (φx ↔ φy))))
  ((∀ x φx) ↔ (∀ y φy)) (
        x φy DistinctNotFree
        y φx DistinctNotFree
        H
        ChangeVariableForAllNotFree
))
</jh>

=== Change of variable in ∃ ===
We prove the similar theorem for <code>∃</code> in a similar way, in which we rewrite <code>φy</code> to <code>[ y / x ] φx</code> and then to <code>∃ x φx</code>.

<jh>
thm (ChangeVariableThereExistsImplicationNotFree ((x y))
  ((HFREEX (x is-not-free-in φy))
   (HFREEY (y is-not-free-in φx))
   (H (((value x) = (value y)) → (φx ↔ φy)))
  )
  ((∃ y φy) → (∃ x φx)) (
</jh>
We start with <code>y is-not-free-in ∃ x φx</code>.
<jh>
        HFREEY
        x addThereExistsNotFree
</jh>
Next is <code>φy → [ y / x ] φx</code>.
<jh>
        HFREEX
        H
        makeSubstExplicitNotFree
        eliminateBiconditionalForward
</jh>
Then we can combine that with <code>[ y / x ] φx → ∃ x φx</code>.
<jh>
        (value y) x φx ThereExistsIntroductionFromObject
        applySyllogism

        addThereExistsToAntecedentNotFree
))
</jh>

Now that we've proved the implication, we just need to biconditionalize it and also would like a variant with distinct variables rather than freeness hypotheses.
<jh>
thm (ChangeVariableThereExistsNotFree ((x y))
  ((HFREEX (x is-not-free-in φy))
   (HFREEY (y is-not-free-in φx))
   (H (((value x) = (value y)) → (φx ↔ φy)))
  )
  ((∃ x φx) ↔ (∃ y φy)) (
        HFREEY HFREEX
        H
        (value x) (value y) EqualitySymmetry
        transformAntecedent

        φx φy BiconditionalSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        ChangeVariableThereExistsImplicationNotFree

        HFREEX HFREEY H ChangeVariableThereExistsImplicationNotFree

        introduceBiconditionalFromImplications
))

thm (ChangeVariableThereExists ((y φx) (x φy) (x y))
  ((H (((value x) = (value y)) → (φx ↔ φy))))
  ((∃ x φx) ↔ (∃ y φy)) (
        x φy DistinctNotFree
        y φx DistinctNotFree
        H
        ChangeVariableThereExistsNotFree
))
</jh>

=== Stating changes of variable in terms of explicit substitutions ===
Another way to express the change variable theorems is with explicit substitution (using <code>subst</code>). The proofs from [[First-order logic with quantifiability]] work without modification.
<jh>
thm (ChangeVariableExplicitThereExists ((y φ) (x y)) () ((∃ x φ) ↔ (∃ y (subst (value y) x φ))) (
        x (value y) φ SubstNotFree
        y φ DistinctNotFree
        x (value y) φ EqualitySubst
        ChangeVariableThereExistsNotFree
))

thm (ChangeVariableExplicitForAll ((y φ) (x y)) () ((∀ x φ) ↔ (∀ y (subst (value y) x φ))) (
        x (value y) φ SubstNotFree
        y φ DistinctNotFree
        x (value y) φ EqualitySubst
        ChangeVariableForAllNotFree
))
</jh>

== Adding and removing there exists ==
Here are a number of results involving removing <code>∃</code>. The proofs in [[First-order logic in terms of substitution built on equality]] apply without modification.
<jh>
thm (ThereExistsAddRemoveNotFree () ((HFREE (x is-not-free-in φ))) ((∃ x φ) ↔ φ) (
        HFREE
        φ ImplicationReflexivity
        addThereExistsToAntecedentNotFree

        φ x ThereExistsIntroduction

        introduceBiconditionalFromImplications
))

thm (NullThereExists ((x φ)) () ((∃ x φ) ↔ φ) (
        x φ DistinctNotFree
        ThereExistsAddRemoveNotFree
))

thm (removeThereExists ((x φ)) ((H (∃ x φ))) φ (
        H
        x φ NullThereExists
        eliminateBiconditionalReverse
        applyModusPonens
))

thm (removeThereExistsInConsequent ((x φ)) ((H (antecedent → (∃ x φ)))) (antecedent → φ) (
        H
        x φ NullThereExists
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

== Relationship between universal and existential quantification ==
In classical first-order logic, there are a number of equivalences involving negation and both kinds of quantifiers. Only some of them hold intuitionistically.

The first one is <code>∃ x ¬ φ → ¬ ∀ x φ</code>. This is a biconditional in classical logic, but this direction holds intuitionistically.
<jh>
thm (NotForAllReverse () () ((∃ x (¬ φ)) → (¬ (∀ x φ))) (
        x φ BoundForAllNotFree
        negateNotFree

        x φ Specialization
        introduceTransposition

        addThereExistsToAntecedentNotFree
))
</jh>

Next is <code>¬ ∃ x φ ↔ ∀ x ¬ φ</code>. The forward direction is much like the previous proof.
<jh>
thm (NotThereExistsForward () () ((¬ (∃ x φ)) → (∀ x (¬ φ))) (
        x φ BoundThereExistsNotFree
        negateNotFree

        φ x ThereExistsIntroduction
        introduceTransposition

        addForAllToConsequentNotFree
))
</jh>

We prove the reverse direction by rewriting <code>¬ φ</code> as <code>φ → ⊥</code> and applying <code>ForAllImplicationThereExists</code>.
<jh>
thm (NotThereExistsReverse () () ((∀ x (¬ φ)) → (¬ (∃ x φ))) (
        φ NegationImplication
        eliminateBiconditionalReverse
        x addForAll

        x φ (⊥) ForAllImplicationThereExists
        applySyllogism
</jh>
Now we have <code>∀ x ¬ φ → (∃ x φ → ∃ x ⊥)</code> and we can remove the second <code>∃</code> because the variable <code>x</code> does not occur in the formula <code>⊥</code>.
<jh>
        import
        removeThereExistsInConsequent
        export

        (∃ x φ) NegationImplication
        eliminateBiconditionalForward
        applySyllogism
))

thm (NotThereExists () () ((¬ (∃ x φ)) ↔ (∀ x (¬ φ))) (
        x φ NotThereExistsForward
        x φ NotThereExistsReverse
        introduceBiconditionalFromImplications
))
</jh>

== Export ==
Having proved everything in [[Interface:Intuitionistic first-order logic]], we export to it.
<jh>
#export (RESULT Interface:Intuitionistic_first-order_logic (PROPOSITIONAL) ())
</jh>

[[Category:Subsystems of classical logic|${PAGENAME}]]
