{{interfaces
| imports = [[Interface:Triangle congruence]]
| exports = [[Interface:Collinearity]]
}}

This is part of a series of modules which prove a variety of geometrical theorems starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

This page is primarily devoted to the proof of one theorem, <code>A ≠ B ∧ between A B C ∧ between A B D → between A C D ∨ between A D C</code>. This is called outer connectivity for betweenness by Narboux<ref>Narboux (2007), page 144</ref> and Givant.<ref>Tarski and Givant (1999), page 186</ref> It was once considered an axiom of Tarski's system, but was proved from the other axioms by Gupta in 1965<ref>Tarski and Givant (1999), page 190</ref><ref>Narboux (2007), citing Gupta, H.N.: Contributions to the axiomatic foundations of geometry. PhD thesis, University of California, Berkley (1965)</ref>

The proof is not simple; Givant calls it "rather involved" and Narboux devotes two and a half pages to an informal proof (and an explanation of part of the formal proof).<ref>Narboux (2007), pages 151-153</ref>

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Collinearity|geometry results so far]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (START Interface:Collinearity (CLASSICAL FIRSTORDER) ())

var (point A B C D E P Q R A′ B′ C′ D′ B″ C″)
var (variable a b b′ c c′ d′ e p q r b″ c″)
</jh>

== Summary ==
[[File:outer connectivity for betweenness 1.svg|thumb|right|construction of C′, D′, B′, and B″]]

Here's an outline of the proof, illustrating which points we construct but leaving most of the detailed line segment congruences for the detailed formal proof.

We first construct <code>C′ and D′</code> extending the line segments <code>A D</code> and <code>A C</code> by a distance of <code>C D</code> in both cases. Eventually, the proof will show that <code>C = C′</code> or <code>D = D′</code>.

Then extend the line segments <code>A C′</code> and <code>A D′</code> to points <code>B′</code> and <code>B″</code> by distances of <code>C B</code> and <code>D B</code>. The result of this construction is that the distance from <code>B</code> is the same to either <code>B′</code> or <code>B″</code> and thus we can conclude that <code>B′ = B″</code>.

[[File:outer connectivity for betweenness 2.svg|thumb|right|construction of E]]
The point <code>E</code> lies at the intersection of <code>C C′</code> and <code>D D′</code>.

At this point we assume <code>C ≠ C′</code> and will deduce from that <code>D = D′</code>.

[[File:outer connectivity for betweenness 3.svg|thumb|right|construction of P, Q, and R]]
Extend <code>C′ C</code> by the distance <code>C D′</code> to a point <code>P</code>. Extend <code>D′ C</code> by the distance <code>C E</code> to a point <code>R</code>. Extend <code>P R</code> by the distance <code>R P</code> to a point <code>Q</code>.

[[File:outer connectivity for betweenness 4.svg|thumb|right|D′ D ≡ P Q and C P ≡ C Q]]
By some congruences we can show first <code>D′ D ≡ P Q</code>, which we'll need at the end of the proof, and <code>C P ≡ C Q</code>, which leads to the next step.

[[File:outer connectivity for betweenness 5.svg|thumb|right|B P ≡ B Q and B′ P ≡ B′ Q]]
We can now show that <code>B</code> and <code>B′</code> are each equidistant from <code>P</code> and <code>Q</code>.

TODO: can we expand on the motivation for this, or how it leads to the next step?

[[File:outer connectivity for betweenness 6.svg|thumb|right|C′ P ≡ C′ Q]]
Similarly, C′ is also equidistant from <code>P</code> and <code>Q</code>.

{{under construction}}
TODO: What is the picture and the brief summary of the last steps (P P ≡ P Q, P = Q, and D = D′)?

== Construction of C′, D′, B′, and B″ ==
[[File:outer connectivity for betweenness 1.svg|thumb|right|construction of C′, D′, B′, and B″]]
We construct <code>c′</code> such that <code>between A D c′ ∧ D c′ ≡ C D</code> and <code>d′</code> such that <code>between A C d′ ∧ C d′ ≡ C D</code>.

Then we construct <code>b′</code> such that <code>between A c′ b′ ∧ c′ b′ ≡ C B</code> and <code>b″</code> such that <code>between A d′ b″ ∧ d′ b″ ≡ D B</code>.

The following lemma embodies these constructions, and a bit of rearrangement of the quantifiers.
<jh>
thm (BetweennessOuterConnectivity-cdbb
  ((A c′ d′ b′ b″) (B c′ d′ b′ b″) (C c′ d′ b′ b″) (D c′ d′ b′ b″)) ()
  ((((A ≠ B) ∧ (between A B C)) ∧ (between A B D)) →
    (∃ c′ (∃ d′ (∃ b′ (∃ b″
      ((((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
      ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
      ((between A (value c′) (value b′)) ∧ ((value c′) (value b′) ≡ C B))) ∧
      ((between A (value d′) (value b″)) ∧ ((value d′) (value b″) ≡ D B))) ∧
      (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))))))) (
        c′ A D C D SegmentConstruction
        d′ A C C D SegmentConstruction
        introduceConjunction

        c′ d′ ((between A D (value c′)) ∧ (D (value c′) ≡ C D))
          ((between A C (value d′)) ∧ (C (value d′) ≡ C D))
          ThereExistsScattering
        eliminateBiconditionalForward

        applyModusPonens
</jh>
So far we have the construction of <code>c′</code> and <code>d′</code>, specifically <code>∃ c′ ∃ d′ ((between A D c′ ∧ D c′ ≡ C D) ∧ (between A C d′ ∧ C d′ ≡ C D))</code>. We now turn to <code>b′</code>.
<jh>
        b′ A (value c′) C B SegmentConstruction
        d′ generalize
        c′ generalize

        introduceConjunction

        c′
          (∃ d′ (((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D))))
          (∀ d′ (∃ b′ ((between A (value c′) (value b′))
            ∧ ((value c′) (value b′) ≡ C B))))
          ThereExistsConjunctionRightCombining
        applyModusPonens

        d′
          (((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D)))
          (∃ b′ ((between A (value c′) (value b′))
            ∧ ((value c′) (value b′) ≡ C B)))
          ThereExistsConjunctionRightCombining
        c′ addThereExists
        applyModusPonens
</jh>
That gives us <code>∃ c′ ∃ d′ ((between A D c′ ∧ D c′ ≡ C D) ∧ (between A C d′ ∧ C d′ ≡ C D) ∧ ∃ b′ (between A c′ b′ ∧ c′ b′ ≡ C B))</code>. The next step is to move <code>∃ b′</code> to the front.
<jh>
        b′
          (((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D)))
          ((between A (value c′) (value b′))
            ∧ ((value c′) (value b′) ≡ C B))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        d′ addThereExists
        c′ addThereExists
        applyModusPonens
</jh>
Now we construct <code>b″</code>, which starts with <code>∃ b″ (between A d′ b″ ∧ d′ b″ ≡ D B)</code> and then moves the quantifiers to the front.
<jh>
        b″ A (value d′) D B SegmentConstruction
        d′ generalize

        introduceConjunction

        c′
          (∃ d′ (∃ b′
            ((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
              ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
              ((between A (value c′) (value b′))
                ∧ ((value c′) (value b′) ≡ C B)))
          ))
          (∀ d′ (∃ b″ ((between A (value d′) (value b″)) ∧ ((value d′) (value b″) ≡ D B))))
          ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applyModusPonens

        d′
          (∃ b′
            ((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
              ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
              ((between A (value c′) (value b′))
                ∧ ((value c′) (value b′) ≡ C B)))
          )
          (∃ b″ ((between A (value d′) (value b″)) ∧ ((value d′) (value b″) ≡ D B)))
          ThereExistsConjunctionRightCombining
        c′ addThereExists
        applyModusPonens

        b′ b″
          ((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
            ((between A (value c′) (value b′))
              ∧ ((value c′) (value b′) ≡ C B)))
          ((between A (value d′) (value b″)) ∧ ((value d′) (value b″) ≡ D B))
          ThereExistsScattering
        eliminateBiconditionalForward
        d′ addThereExists
        c′ addThereExists
        applyModusPonens
</jh>
Now we need to add in <code>A ≠ B ∧ between A B C ∧ between A B D</code>, and move it inside all four quantifiers.
<jh>
        (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)) introduceAntecedent

        (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)) ImplicationReflexivity
        composeConjunction

        c′
          (∃ d′ (∃ b′ (∃ b″
            (((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
            ((between A (value c′) (value b′))
              ∧ ((value c′) (value b′) ≡ C B))) ∧
            ((between A (value d′) (value b″))
              ∧ ((value d′) (value b″) ≡ D B)))
          )))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
        ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applySyllogism

        d′
          (∃ b′ (∃ b″
            (((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
            ((between A (value c′) (value b′))
              ∧ ((value c′) (value b′) ≡ C B))) ∧
            ((between A (value d′) (value b″))
              ∧ ((value d′) (value b″) ≡ D B)))
          ))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
        ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        c′ addThereExists
        applySyllogism

        b′
          (∃ b″
            (((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
            ((between A (value c′) (value b′))
              ∧ ((value c′) (value b′) ≡ C B))) ∧
            ((between A (value d′) (value b″))
              ∧ ((value d′) (value b″) ≡ D B)))
          )
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
        ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        d′ addThereExists
        c′ addThereExists
        applySyllogism

        b″
          (((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
            ((between A (value c′) (value b′))
              ∧ ((value c′) (value b′) ≡ C B))) ∧
            ((between A (value d′) (value b″))
              ∧ ((value d′) (value b″) ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
        ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        b′ addThereExists
        d′ addThereExists
        c′ addThereExists
        applySyllogism
))
</jh>

== B′ is equal to B″ ==
[[File:outer connectivity for betweenness 1.svg|thumb|right|B′ = B″]]
In this section we'll show that <code>B′ = B″</code>. The idea of the proof is simple: to get from <code>B</code> to <code>B′</code> we go through <code>D</code> and <code>C′</code>, and to get from <code>B</code> to <code>B″</code> we go through <code>C</code> and <code>D′</code>. As can be seen from the way we constructed the points, the three segments in the one case are congruent to the three segments in the other (although in reverse order), so the distance from <code>B</code> to either <code>B′</code> or <code>B″</code> is the same. Because <code>A ≠ B</code>, this implies that <code>B′ = B″</code> by the uniqueness of segment construction (applied to <code>A B B′</code> and <code>A B B″</code>).

=== B C′ ≡ B″ C ===
[[File:outer connectivity for betweenness 1.svg|thumb|right|B C′ ≡ B″ C]]
Here we prove <code>B C′ ≡ B″ C</code>, starting with a few lemmas which we'll need.
<jh>
thm (b-d-cprime
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between B D C′)) (
</jh>
First is <code>between A B D</code>.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionLeftElimination
        eliminateLeftConjunctionInConsequent
</jh>
Second is <code>between A D C′</code>
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent


        composeConjunction
</jh>
The result follows from transitivity.
<jh>
        A B D C′ BetweennessInnerTransitivityFlipped
        applySyllogism
))

thm (bdoubleprime-dprime-c
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between B″ D′ C)) (
</jh>
This is another application of transitivity, starting with <code>between B″ D′ A</code>.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        A D′ B″ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
The other thing we need is <code>between D′ C A</code>.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        A C D′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        B″ D′ A C BetweennessInnerTransitivity
        applySyllogism
))

thm (d-cprime-dprime-c
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (D C′ ≡ D′ C)) (
</jh>
Each of the segments <code>D C′</code> and <code>D′ C</code> is congruent to <code>C D</code>, so we just need to apply symmetry and transitivity.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        C D′ C D CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        D C′ C D C D′ CongruenceTransitivity
        applySyllogism

        D C′ C D′ CongruenceRightCommutativity
        eliminateBiconditionalReverse
        applySyllogism
))

thm (b-cprime-bdoubleprime-c
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (B C′ ≡ B″ C)) (
</jh>
We prove this theorem by applying <code>OuterThreeSegment</code> to <code>B D C′</code> and <code>B″ D′ C</code>. The first step is <code>between B D C′</code>.
<jh>
        A D C′ C D′ B′ B B″ b-d-cprime
</jh>
The next is <code>between B″ D′ C</code>.
<jh>
        A D C′ C D′ B′ B B″ bdoubleprime-dprime-c
        composeConjunction
</jh>
The next is <code>B D ≡ B″ D′</code>.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        D′ B″ D B CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        D B D′ B″ CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
The last is <code>D C′ D′ C</code>
<jh>
        A D C′ C D′ B′ B B″ d-cprime-dprime-c
        composeConjunction
</jh>
Three segment gives us <code>B C′ B″ C</code>, the desired result.
<jh>
        B D C′ B″ D′ C OuterThreeSegment
        applySyllogism
))
</jh>

== Under construction ==
{{under construction}}
A ≠ B ∧ between A B C ∧ between A B D →
  ∃ c′ ∃ d′ ∃ b′ ∃ b″ (stuff1)

(stuff1) → ∃ e (stuff2)
    between C e C′ ∧ between D e D′

(stuff2) ∧ C ≠ C′ → ∃ p ∃ q ∃ r (stuff3)

(stuff3) → D = D′

Want (stuff2) → (C ≠ C′ → D = D′)

== Export ==
We now export to [[Interface:Connectivity for betweenness]].
<jh>
#export (RESULTS Interface:Connectivity_for_betweenness (CLASSICAL FIRSTORDER) ())
</jh>

Also, since this page is currently the last in the (in-progress) series on basic geometry, we export to [[Interface:Basic geometry]].
<jh>
export (GEOMETRY Interface:Basic_geometry (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>
* Tarski, Alfred; Givant, Steven (1999), "Tarski's system of geometry", The Bulletin of Symbolic Logic 5 (2): 175–214, doi:10.2307/421089, MR1791303, ISSN 1079-8986

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]