{{interfaces
| imports = [[Interface:Collinearity]]
| exports = [[Interface:Connectivity for betweenness]]
}}

This is part of a series of modules which prove a variety of geometrical theorems starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

This page is devoted to the proof of one theorem, <code>A ≠ B ∧ between A B C ∧ between A B D → between A C D ∨ between A D C</code>.<ref>l5_1 in Narboux</ref> This is called outer connectivity for betweenness by Narboux<ref>Narboux (2007), page 144</ref> and Givant.<ref>Tarski and Givant (1999), page 186</ref> It was once considered an axiom of Tarski's system, but was proved from the other axioms by Gupta in 1965<ref>Tarski and Givant (1999), page 190</ref><ref>Narboux (2007), citing Gupta, H.N.: Contributions to the axiomatic foundations of geometry. PhD thesis, University of California, Berkley (1965)</ref>

The proof is not simple; Givant calls it "rather involved" and Narboux devotes two and a half pages to an informal proof (and an explanation of part of the formal proof).<ref>Narboux (2007), pages 151-153</ref>

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Collinearity|geometry results so far]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (START Interface:Collinearity (CLASSICAL FIRSTORDER) ())

var (point A B C D E P Q R A′ B′ C′ D′ B″ C″)
var (variable a b b′ c c′ d′ e p q r b″ c″)
</jh>

== Summary ==
[[File:outer connectivity for betweenness 1.svg|thumb|right|construction of C′, D′, B′, and B″]]

Here's an outline of the proof, illustrating which points we construct but leaving most of the detailed line segment congruences for the detailed formal proof.

We first construct <code>C′ and D′</code> extending the line segments <code>A D</code> and <code>A C</code> by a distance of <code>C D</code> in both cases. Eventually, the proof will show that <code>C = C′</code> or <code>D = D′</code>.

Then extend the line segments <code>A C′</code> and <code>A D′</code> to points <code>B′</code> and <code>B″</code> by distances of <code>C B</code> and <code>D B</code>. The result of this construction is that the distance from <code>B</code> is the same to either <code>B′</code> or <code>B″</code> and thus we can conclude that <code>B′ = B″</code>.

{{clear}}
[[File:outer connectivity for betweenness 2.svg|thumb|right|construction of E]]
The point <code>E</code> lies at the intersection of <code>C C′</code> and <code>D D′</code>.

At this point we assume <code>C ≠ C′</code> and will deduce from that <code>D = D′</code>.

{{clear}}
[[File:outer connectivity for betweenness 3.svg|thumb|right|construction of P, Q, and R]]
Extend <code>C′ C</code> by the distance <code>C D′</code> to a point <code>P</code>. Extend <code>D′ C</code> by the distance <code>C E</code> to a point <code>R</code>. Extend <code>P R</code> by the distance <code>R P</code> to a point <code>Q</code>.

{{clear}}
[[File:outer connectivity for betweenness 4.svg|thumb|right|D′ D ≡ P Q and C P ≡ C Q]]
By some congruences we can show first <code>D′ D ≡ P Q</code>, which we'll need at the end of the proof, and <code>C P ≡ C Q</code>, which leads to the next step.

{{clear}}
[[File:outer connectivity for betweenness 5.svg|thumb|right|B P ≡ B Q and B′ P ≡ B′ Q]]
[[File:outer connectivity for betweenness 6.svg|thumb|right|C′ P ≡ C′ Q]]
At this point we will apply <code>EquidistantLine</code> five times. In every case we will show that <code>x P ≡ x Q</code> (based on two such existing congruences). For the starting point, we already have <code>C P ≡ C Q</code> and <code>R P ≡ R Q</code>. In turn, we will prove a similar congruence for <code>D′</code>, <code>B</code>, <code>B′</code>, and <code>C′</code>. Those cases easily fit the pictures we have been drawing so far. But we don't stop there: because <code>C′</code>, <code>C</code>, and <code>P</code> are collinear, we can also conclude <code>P P ≡ P Q</code> (this last one doesn't quite as readily lend itself to being illustrated in diagram form, but the first four are illustrated in the adjacent figures).

Of course, <code>P P ≡ P Q</code> implies <code>P = Q</code>, which in turn implies <code>D = D′</code> (via <code>D D′ ≡ P Q</code>).

We have shown that <code>C ≠ C′</code> implies <code>D = D′</code>, or in other words <code>C = C′ ∨ D = D′</code>. The former implies <code>A D C</code> and the latter implies <code>A C D</code>, so we reach the conclusion that <code>between A C D ∨ between A D C</code>.

{{clear}}
== Construction of C′, D′, B′, and B″ ==
[[File:outer connectivity for betweenness 1.svg|thumb|right|construction of C′, D′, B′, and B″]]
We construct <code>c′</code> such that <code>between A D c′ ∧ D c′ ≡ C D</code> and <code>d′</code> such that <code>between A C d′ ∧ C d′ ≡ C D</code>.

Then we construct <code>b′</code> such that <code>between A c′ b′ ∧ c′ b′ ≡ C B</code> and <code>b″</code> such that <code>between A d′ b″ ∧ d′ b″ ≡ D B</code>.

The following lemma embodies these constructions, and a bit of rearrangement of the quantifiers.
<jh>
thm (BetweennessOuterConnectivity-cdbb
  ((A c′ d′ b′ b″) (B c′ d′ b′ b″) (C c′ d′ b′ b″) (D c′ d′ b′ b″)) ()
  ((((A ≠ B) ∧ (between A B C)) ∧ (between A B D)) →
    (∃ c′ (∃ d′ (∃ b′ (∃ b″
      ((((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
      ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
      ((between A (value c′) (value b′)) ∧ ((value c′) (value b′) ≡ C B))) ∧
      ((between A (value d′) (value b″)) ∧ ((value d′) (value b″) ≡ D B))) ∧
      (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))))))) (
        c′ A D C D SegmentConstruction
        d′ A C C D SegmentConstruction
        introduceConjunction

        c′ d′ ((between A D (value c′)) ∧ (D (value c′) ≡ C D))
          ((between A C (value d′)) ∧ (C (value d′) ≡ C D))
          ThereExistsScattering
        eliminateBiconditionalForward

        applyModusPonens
</jh>
So far we have the construction of <code>c′</code> and <code>d′</code>, specifically <code>∃ c′ ∃ d′ ((between A D c′ ∧ D c′ ≡ C D) ∧ (between A C d′ ∧ C d′ ≡ C D))</code>. We now turn to <code>b′</code>.
<jh>
        b′ A (value c′) C B SegmentConstruction
        d′ generalize
        c′ generalize

        combineThereExistsForAll

        d′
          (((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D)))
          (∃ b′ ((between A (value c′) (value b′))
            ∧ ((value c′) (value b′) ≡ C B)))
          ThereExistsConjunctionRightCombining
        c′ addThereExists
        applyModusPonens
</jh>
That gives us <code>∃ c′ ∃ d′ ((between A D c′ ∧ D c′ ≡ C D) ∧ (between A C d′ ∧ C d′ ≡ C D) ∧ ∃ b′ (between A c′ b′ ∧ c′ b′ ≡ C B))</code>. The next step is to move <code>∃ b′</code> to the front.
<jh>
        b′
          (((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D)))
          ((between A (value c′) (value b′))
            ∧ ((value c′) (value b′) ≡ C B))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        d′ addThereExists
        c′ addThereExists
        applyModusPonens
</jh>
Now we construct <code>b″</code>, which starts with <code>∃ b″ (between A d′ b″ ∧ d′ b″ ≡ D B)</code> and then moves the quantifiers to the front.
<jh>
        b″ A (value d′) D B SegmentConstruction
        d′ generalize

        introduceConjunction

        c′
          (∃ d′ (∃ b′
            ((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
              ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
              ((between A (value c′) (value b′))
                ∧ ((value c′) (value b′) ≡ C B)))
          ))
          (∀ d′ (∃ b″ ((between A (value d′) (value b″)) ∧ ((value d′) (value b″) ≡ D B))))
          ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applyModusPonens

        d′
          (∃ b′
            ((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
              ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
              ((between A (value c′) (value b′))
                ∧ ((value c′) (value b′) ≡ C B)))
          )
          (∃ b″ ((between A (value d′) (value b″)) ∧ ((value d′) (value b″) ≡ D B)))
          ThereExistsConjunctionRightCombining
        c′ addThereExists
        applyModusPonens

        b′ b″
          ((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
            ((between A (value c′) (value b′))
              ∧ ((value c′) (value b′) ≡ C B)))
          ((between A (value d′) (value b″)) ∧ ((value d′) (value b″) ≡ D B))
          ThereExistsScattering
        eliminateBiconditionalForward
        d′ addThereExists
        c′ addThereExists
        applyModusPonens
</jh>
Now we need to add in <code>A ≠ B ∧ between A B C ∧ between A B D</code>, and move it inside all four quantifiers.
<jh>
        (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)) introduceAntecedent

        (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)) ImplicationReflexivity
        composeConjunction

        c′
          (∃ d′ (∃ b′ (∃ b″
            (((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
            ((between A (value c′) (value b′))
              ∧ ((value c′) (value b′) ≡ C B))) ∧
            ((between A (value d′) (value b″))
              ∧ ((value d′) (value b″) ≡ D B)))
          )))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
        ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applySyllogism

        d′
          (∃ b′ (∃ b″
            (((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
            ((between A (value c′) (value b′))
              ∧ ((value c′) (value b′) ≡ C B))) ∧
            ((between A (value d′) (value b″))
              ∧ ((value d′) (value b″) ≡ D B)))
          ))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
        ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        c′ addThereExists
        applySyllogism

        b′
          (∃ b″
            (((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
            ((between A (value c′) (value b′))
              ∧ ((value c′) (value b′) ≡ C B))) ∧
            ((between A (value d′) (value b″))
              ∧ ((value d′) (value b″) ≡ D B)))
          )
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
        ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        d′ addThereExists
        c′ addThereExists
        applySyllogism

        b″
          (((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
            ((between A (value c′) (value b′))
              ∧ ((value c′) (value b′) ≡ C B))) ∧
            ((between A (value d′) (value b″))
              ∧ ((value d′) (value b″) ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
        ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        b′ addThereExists
        d′ addThereExists
        c′ addThereExists
        applySyllogism
))
</jh>

== B′ is equal to B″ ==
[[File:outer connectivity for betweenness 1.svg|thumb|right|B′ = B″]]
In this section we'll show that <code>B′ = B″</code>. The idea of the proof is simple: to get from <code>B</code> to <code>B′</code> we go through <code>D</code> and <code>C′</code>, and to get from <code>B</code> to <code>B″</code> we go through <code>C</code> and <code>D′</code>. As can be seen from the way we constructed the points, the three segments in the one case are congruent to the three segments in the other (although in reverse order), so the distance from <code>B</code> to either <code>B′</code> or <code>B″</code> is the same. Because <code>A ≠ B</code>, this implies that <code>B′ = B″</code> by the uniqueness of segment construction (applied to <code>A B B′</code> and <code>A B B″</code>).

=== B C′ ≡ B″ C ===
[[File:outer connectivity for betweenness 1.svg|thumb|right|B C′ ≡ B″ C]]
Here we prove <code>B C′ ≡ B″ C</code>, starting with a few lemmas which we'll need.
<jh>
thm (b-d-cprime
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between B D C′)) (
</jh>
First is <code>between A B D</code>.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
</jh>
Second is <code>between A D C′</code>
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent


        composeConjunction
</jh>
The result follows from transitivity.
<jh>
        A B D C′ BetweennessInnerTransitivityFlipped
        applySyllogism
))

thm (bdoubleprime-dprime-c
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between B″ D′ C)) (
</jh>
This is another application of transitivity, starting with <code>between B″ D′ A</code>.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        A D′ B″ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
The other thing we need is <code>between D′ C A</code>.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        A C D′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        B″ D′ A C BetweennessInnerTransitivity
        applySyllogism
))

thm (d-cprime-dprime-c
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (D C′ ≡ D′ C)) (
</jh>
Each of the segments <code>D C′</code> and <code>D′ C</code> is congruent to <code>C D</code>, so we just need to apply symmetry and transitivity.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        C D′ C D CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        D C′ C D C D′ CongruenceTransitivity
        applySyllogism

        D C′ C D′ CongruenceRightCommutativity
        eliminateBiconditionalReverse
        applySyllogism
))

thm (b-cprime-bdoubleprime-c
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (B C′ ≡ B″ C)) (
</jh>
We prove this theorem by applying <code>OuterThreeSegment</code> to <code>B D C′</code> and <code>B″ D′ C</code>. The first step is <code>between B D C′</code>.
<jh>
        A D C′ C D′ B′ B B″ b-d-cprime
</jh>
The next is <code>between B″ D′ C</code>.
<jh>
        A D C′ C D′ B′ B B″ bdoubleprime-dprime-c
        composeConjunction
</jh>
The next is <code>B D ≡ B″ D′</code>.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        D′ B″ D B CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        D B D′ B″ CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
The last is <code>D C′ D′ C</code>
<jh>
        A D C′ C D′ B′ B B″ d-cprime-dprime-c
        composeConjunction
</jh>
Three segment gives us <code>B C′ B″ C</code>, the desired result.
<jh>
        B D C′ B″ D′ C OuterThreeSegment
        applySyllogism
))
</jh>

=== B B′ ≡ B″ B ===
[[File:outer connectivity for betweenness 1.svg|thumb|right|B B′ ≡ B″ B]]
Here we extend the congruence from the previous section one more point. This is also an application of <code>OuterThreeSegment</code>, and we again break out some of the pieces into lemmas.
<jh>
thm (a-b-cprime
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between A B C′)) (
</jh>
This is an application of transitivity to <code>between A B D</code>
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
</jh>
and <code>between A D C′</code>.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction

        A B D C′ BetweennessMiddleTransitivityFlipped
        applySyllogism
))

thm (b-cprime-bprime
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between B C′ B′)) (
</jh>
Here we apply transitivity to <code>between A B C′</code>.
<jh>
        A D C′ C D′ B′ B B″ a-b-cprime
</jh>
and <code>between A C′ B′</code>.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction

        A B C′ B′ BetweennessInnerTransitivityFlipped
        applySyllogism
))

thm (a-c-bdoubleprime
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between A C B″)) (
</jh>
Here we apply transitivity to <code>between A C D′</code>
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
and <code>between A D′ B″</code>
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction

        A C D′ B″ BetweennessMiddleTransitivityFlipped
        applySyllogism
))

thm (bdoubleprime-c-b
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between B″ C B)) (
</jh>
Here we apply transitivity to <code>A B C</code>
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
and the previous lemma (<code>between A C B″</code>)
<jh>
        A D C′ C D′ B′ B B″ a-c-bdoubleprime
        composeConjunction
</jh>
to produce <code>B C B″</code>. Then we just need to switch the order of the endpoints.
<jh>
        A B C B″ BetweennessInnerTransitivityFlipped
        applySyllogism

        B C B″ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
))

thm (b-bprime-bdoubleprime-b
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (B B′ ≡ B″ B)) (
</jh>
First we need <code>between B C′ B′</code>.
<jh>
        A D C′ C D′ B′ B B″ b-cprime-bprime
</jh>
Next we need <code>between B″ C B</code>.
<jh>
        A D C′ C D′ B′ B B″ bdoubleprime-c-b
        composeConjunction
</jh>
<code>B C′ ≡ B″ C</code>:
<jh>
        A D C′ C D′ B′ B B″ b-cprime-bdoubleprime-c
        composeConjunction
</jh>
<code>C′ B′ ≡ C B</code>:
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction

        B C′ B′ B″ C B OuterThreeSegment
        applySyllogism
))
</jh>

=== B″ = B′ ===
In this section we apply <code>SegmentConstructionUniqueness</code> to prove that <code>B′</code> and <code>B″</code> are in fact the same point. We start with some more betweenness transitivity lemmas.
<jh>
thm (a-b-dprime () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between A B D′)) (
</jh>
<code>between A B C</code>:
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

</jh>
<code>between A C D′</code>:
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction

        A B C D′ BetweennessMiddleTransitivityFlipped
        applySyllogism
))

thm (bdoubleprime-bprime () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (B″ = B′)) (
</jh>
We'll prove <code>B′ = B″</code> (and flip the order later). We first need <code>A ≠ B</code>.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
Next is <code>between A B B′</code>, which follows from <code>between A B C′</code> and <code>between A C′ B′</code> by betweenness transitivity.
<jh>
        A D C′ C D′ B′ B B″ a-b-cprime

        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        composeConjunction

        A B C′ B′ BetweennessMiddleTransitivityFlipped
        applySyllogism

        composeConjunction
</jh>
Next is <code>between B B′ ≡ B″ B</code>.
<jh>
        A D C′ C D′ B′ B B″ b-bprime-bdoubleprime-b
        composeConjunction
</jh>
Next is <code>between A B B″</code>, which follows from <code>between A B D′</code> and <code>between A D′ B″</code> by betweenness transitivity.
<jh>
        A D C′ C D′ B′ B B″ a-b-dprime

        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        composeConjunction

        A B D′ B″ BetweennessMiddleTransitivityFlipped
        applySyllogism

        composeConjunction
</jh>
Finally we need <code>B B″ ≡ B″ B</code>.
<jh>
        B B″ CongruenceABBA

        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          introduceAntecedent
        composeConjunction
</jh>
Applying segment construction uniqueness, and then flipping the order of the equality, we are done.
<jh>
        A B B′ B″ B B″ SegmentConstructionUniqueness
        applySyllogism

        B′ B″ EqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

== Construction of E ==
[[File:outer connectivity for betweenness 2.svg|thumb|right|C′ D′ ≡ C D, construction of E, E C ≡ E C′, and E D ≡ E D′]]
In this section we construct the point <code>E</code> and also prove a number of congruences. First (even before we construct E), we can apply outer five segment to the line segments <code>B C D′</code> and <code>B′ C′ D</code> with points <code>C′</code> and <code>C</code> to give us <code>C′ D′ ≡ C D</code>. Then we construct <code>E</code> as the intersection of <code>C C′</code> and <code>D D′</code> (the axiom of Pasch ensures its existence).

The congruences <code>E C ≡ E C′</code> and <code>E D ≡ E D′</code> may remind us of the familiar theorem that the diagonals of a rhombus bisect each other, but of course to say it that way would get ahead of ourselves. We can readily prove each of those two congruences, however, from a simple invocation of inner five segment.

=== C′ D′ ≡ C D ===
[[File:outer connectivity for betweenness 1a.svg|thumb|right|C′ D′ ≡ C D]]
We just said that this follows from inner five segment, but that's a slight oversimplification. That's true for the <code>B ≠ C</code> case (which we'll prove first), but there's a separate <code>B = C</code> case. We'll start with the <code>B ≠ C</code> case, and before the case itself we'll prove a few lemmas which represent the various antecedents of <code>OuterFiveSegment</code>.
<jh>
thm (b-c-dprime () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between B C D′)) (
</jh>
We prove this via betweenness transitivity from <code>between B C B″</code>
<jh>
        A D C′ C D′ B′ B B″ bdoubleprime-c-b

        B″ C B BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
and <code>between C D′ B″</code>.
<jh>
        A D C′ C D′ B′ B B″ bdoubleprime-dprime-c

        B″ D′ C BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        B C B″ D′ BetweennessInnerTransitivity
        applySyllogism
))

thm (bprime-cprime-d () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between B′ C′ D)) (
</jh>
This follows by betweenness transitivity from <code>B′ C′ B</code>
<jh>
        A D C′ C D′ B′ B B″ b-cprime-bprime

        B C′ B′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
and <code>C′ D B</code>
<jh>
        A D C′ C D′ B′ B B″ b-d-cprime

        B D C′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        B′ C′ B D BetweennessInnerTransitivity
        applySyllogism
))

</jh>
The next two lemmas just apply a substitution to turn <code>B C′ ≡ B″ C</code>, which we have already proved, into <code>B C′ ≡ B′ C</code>.
<jh>
thm (b-cprime-bprime-c-lemma () ()
  (((B″ = B′) ∧ (B C′ ≡ B″ C)) → (B C′ ≡ B′ C)) (
        B EqualityReflexivity
        C′ EqualityReflexivity
        C EqualityReflexivity
        B B C′ C′ B″ B′ C C CongruenceBuilder
        detach2of2
        detach2of3
        detach1of2

        eliminateBiconditionalReverseInConsequent

        import
))

thm (b-cprime-bprime-c () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (B C′ ≡ B′ C)) (
        A D C′ C D′ B′ B B″ bdoubleprime-bprime
        A D C′ C D′ B′ B B″ b-cprime-bdoubleprime-c
        composeConjunction

        B″ B′ B C′ C b-cprime-bprime-c-lemma
        applySyllogism
))

thm (cprime-dprime-c-d-case-bnotc () ()
  (((B ≠ C) ∧
    ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))) →
  (C′ D′ ≡ C D)) (
</jh>
For outer five segment, we first need <code>B ≠ C</code>.
<jh>
        (B ≠ C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionRightElimination
</jh>
Next is <code>between B C D′</code>.
<jh>
        (B ≠ C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionLeftElimination

        A D C′ C D′ B′ B B″ b-c-dprime
        applySyllogism

        composeConjunction
</jh>
Next is <code>between B′ C′ D</code>.
<jh>
        (B ≠ C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionLeftElimination

        A D C′ C D′ B′ B B″ bprime-cprime-d
        applySyllogism

        composeConjunction
</jh>
Next is <code>B C ≡ B′ C′</code>.
<jh>
        (B ≠ C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        C′ B′ C B CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        C B C′ B′ CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Next is <code>C D′ ≡ C′ D</code>.
<jh>
        (B ≠ C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        (B ≠ C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        D C′ C D CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        C D D C′ CongruenceRightCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        C D′ C D C′ D CongruenceTransitivity
        applySyllogism

        composeConjunction
</jh>
Next is <code>B C′ ≡ B′ C</code>.
<jh>
        (B ≠ C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionLeftElimination

        A D C′ C D′ B′ B B″ b-cprime-bprime-c
        applySyllogism

        composeConjunction
</jh>
Last is <code>C C′ ≡ C′ C</code>.
<jh>
        C C′ CongruenceABBA

        ((B ≠ C) ∧
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))))
          introduceAntecedent

        composeConjunction
</jh>
Applying outer five segment gives us <code>D′ C′ ≡ D C</code>. We flip the order of the points to turn that into <code>C′ D′ ≡ C D</code>.
<jh>
        B C D′ B′ C′ D C′ C OuterFiveSegment
        applySyllogism

        D′ C′ D C CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

We now turn to the <code>B = C</code> case. We first note that in this case <code>C′ B′ ≡ C B</code> implies <code>B′ = C′</code>
<jh>
thm (bprime-cprime () ()
  (((B = C) ∧
    ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))) →
  (B′ = C′)) (
        (B = C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionRightElimination

        (B = C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        C′ B′ C B CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        C B C′ B′ CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        B C B′ C′ CongruenceIdentityFromEquality
        import
        applySyllogism
))

thm (cprime-dprime-c-d-case-bc-1 () ()
  ((((B″ = B′) ∧ (B′ = C′)) ∧ (D′ B″ ≡ D B)) → (C′ D′ ≡ B D)) (
        B″ B′ C′ EqualityTransitivity

        D′ EqualityReflexivity
        D EqualityReflexivity
        B EqualityReflexivity
        D′ D′ B″ C′ D D B B CongruenceBuilder
        detach2of2
        detach2of2
        detach1of2

        eliminateBiconditionalReverseInConsequent
</jh>
The top thing on the proof stack is now <code>B″ = C′ → (D′ B″ ≡ D B → D′ C′ ≡ D B</code>. We just need to combine it with the other thing on the proof stack, import, and adjust the consequent.
<jh>
        applySyllogism

        import

        D′ C′ D B CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism
))

thm (cprime-dprime-c-d-case-bc-2 () ()
  (((((B″ = B′) ∧ (B′ = C′)) ∧ (D′ B″ ≡ D B)) ∧ (B = C))
    → (C′ D′ ≡ C D)) (
        (((B″ = B′) ∧ (B′ = C′)) ∧ (D′ B″ ≡ D B)) (B = C)
          ConjunctionRightElimination
        B″ B′ C′ D′ D B cprime-dprime-c-d-case-bc-1
        applySyllogism

        (((B″ = B′) ∧ (B′ = C′)) ∧ (D′ B″ ≡ D B)) (B = C)
          ConjunctionLeftElimination
        C′ EqualityReflexivity
        D′ EqualityReflexivity
        D EqualityReflexivity
        C′ C′ D′ D′ B C D D CongruenceBuilder
        detach2of2
        detach2of3
        detach1of2
        applySyllogism

        eliminateBiconditionalReverseInConsequent

        composeConjunction

        (C′ D′ ≡ B D) (C′ D′ ≡ C D) ModusPonens
        applySyllogism
))

thm (cprime-dprime-c-d-case-bc () ()
  (((B = C) ∧
    ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))) →
  (C′ D′ ≡ C D)) (
</jh>
We've proved all the interesting parts. We just need to pick out the various antecedents for <code>cprime-dprime-c-d-case-bc-2</code>. <code>B″ = B′</code>:
<jh>
        (B = C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionLeftElimination
        A D C′ C D′ B′ B B″ bdoubleprime-bprime
        applySyllogism
</jh>
<code>B′ = C′</code>
<jh>
        B C A D C′ D′ B′ B″ bprime-cprime
        composeConjunction
</jh>
<code>D′ B″ ≡ D B</code>
<jh>
        (B = C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
        composeConjunction
</jh>
<code>B = C</code>:
<jh>
        (B = C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionRightElimination
        composeConjunction

        B″ B′ C′ D′ D B C cprime-dprime-c-d-case-bc-2
        applySyllogism
))
</jh>

Finishing the proof of <code>C′ D′ ≡ C D</code> just involves assembling the two cases.

<jh>
thm (cprime-dprime-c-d () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (C′ D′ ≡ C D)) (
        B C A D C′ D′ B′ B″ cprime-dprime-c-d-case-bc
        export

        B C A D C′ D′ B′ B″ cprime-dprime-c-d-case-bnotc
        export

        eliminateCases
))
</jh>

=== Construction of E ===
We're now ready to construct the point <code>E</code>. We already have the betweenness relationships we need for the axiom of Pasch, <code>between D′ C A</code> and <code>between C′ D A</code>. Applying <code>Pasch</code>, we get <code>C E C′</code> and <code>D E D′</code>.
<jh>
thm (e-exists-1
  ((e A) (e D) (e C′) (e C) (e D′) (e B′) (e B) (e B″)) ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (∃ e ((between C (value e) C′) ∧ (between D (value e) D′)))) (
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        A C D′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        A D C′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        D′ C A C′ D e Pasch
        applySyllogism
))
</jh>

Here's a variant of the previous theorem with the antecedent repeated inside the quantifier.
<jh>
thm (e-exists
  ((e A) (e D) (e C′) (e C) (e D′) (e B′) (e B) (e B″)) ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (∃ e
    (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
      ((between A C D′) ∧ (C D′ ≡ C D))) ∧
      ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
      ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
      (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
      ((between C (value e) C′) ∧ (between D (value e) D′))))) (
        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ImplicationReflexivity

        A D C′ C D′ B′ B B″ e e-exists-1

        composeConjunction

        e
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ((between C (value e) C′) ∧ (between D (value e) D′))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward

        applySyllogism
))
</jh>

=== E C ≡ E C′ ===
[[File:outer connectivity for betweenness 2.svg|thumb|right|E C ≡ E C′ and E D ≡ E D′]]
Here we apply inner five segment to prove <code>E C ≡ E C′</code>. We are applying inner five segment to the line segments <code>D E D′</code> and <code>D E D′</code> and points <code>C</code> and <code>C′</code>.
<jh>
thm (e-c-e-cprime () ()
  ((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) →
  (E C ≡ E C′)) (
</jh>
First we need <code>between D E D′</code>, which is one of our antecedents.
<jh>
        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ((between C E C′) ∧ (between D E D′))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
</jh>
Secondly we need a second copy of <code>between D E D′</code>.
<jh>
        (between D E D′) ConjunctionIdempotence
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Thirdly we need <code>D D′ ≡ D D′</code>, which is an identity.
<jh>
        D D′ CongruenceReflexivity
        (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′)))
          introduceAntecedent
        composeConjunction
</jh>
Fourth we need <code>E D′ ≡ E D′</code>, which is an identity.
<jh>
        E D′ CongruenceReflexivity
        (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′)))
          introduceAntecedent
        composeConjunction
</jh>
Next we need <code>D C ≡ D C′</code>, which is one of our antecedents (slightly rearranged).
<jh>
        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ((between C E C′) ∧ (between D E D′))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        D C′ C D CongruenceRightCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        D C′ D C CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Finally we need <code>D′ C ≡ D′ C′</code>, which follows from the antecedent <code>C D′ ≡ C D</code> and <code>C′ D′ ≡ C D</code>, which we proved previously.
<jh>
        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ((between C E C′) ∧ (between D E D′))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ((between C E C′) ∧ (between D E D′))
          ConjunctionRightElimination
        A D C′ C D′ B′ B B″ cprime-dprime-c-d
        applySyllogism

        C′ D′ C D CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        C D′ C D C′ D′ CongruenceTransitivity
        applySyllogism

        C D′ C′ D′ CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Applying inner five segment we get <code>E C ≡ E C′</code>
<jh>
        D E D′ D E D′ C C′ InnerFiveSegment
        applySyllogism
))
</jh>

=== E D ≡ E D′ ===
The proof that <code>E D ≡ E D′</code> is exactly analogous, but applies inner five segment to the line segments <code>C E C′</code> and <code>C E C′</code> and points <code>D</code> and <code>D′</code>.
<jh>
thm (e-d-e-dprime () ()
  ((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) →
  (E D ≡ E D′)) (
</jh>
First we need <code>between C E C′</code>, which is one of our antecedents.
<jh>
        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ((between C E C′) ∧ (between D E D′))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
</jh>
Secondly we need a second copy of <code>between C E C′</code>.
<jh>
        (between C E C′) ConjunctionIdempotence
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Thirdly we need <code>C C′ ≡ C C′</code>, which is an identity.
<jh>
        C C′ CongruenceReflexivity
        (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′)))
          introduceAntecedent
        composeConjunction
</jh>
Fourth we need <code>E C′ ≡ E C′</code>, which is an identity.
<jh>
        E C′ CongruenceReflexivity
        (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′)))
          introduceAntecedent
        composeConjunction
</jh>
Next we need <code>C D ≡ C D′</code>, which is one of our antecedents (slightly rearranged).
<jh>
        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ((between C E C′) ∧ (between D E D′))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        C D′ C D CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Finally we need <code>C′ D ≡ C′ D′</code>, which follows from the antecedent <code>D C′ ≡ C D</code> and <code>C′ D′ ≡ C D</code>, which we proved previously.
<jh>
        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ((between C E C′) ∧ (between D E D′))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ((between C E C′) ∧ (between D E D′))
          ConjunctionRightElimination
        A D C′ C D′ B′ B B″ cprime-dprime-c-d
        applySyllogism

        C′ D′ C D CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        D C′ C D C′ D′ CongruenceTransitivity
        applySyllogism

        D C′ C′ D′ CongruenceLeftCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Applying inner five segment we get <code>E D ≡ E D′</code>
<jh>
        C E C′ C E C′ D D′ InnerFiveSegment
        applySyllogism
))
</jh>

== Construction of P, Q, and R ==
[[File:outer connectivity for betweenness 3.svg|thumb|right|construction of P, Q, and R]]
Extend <code>C′ C</code> by the distance <code>C D′</code> to a point <code>P</code>. Extend <code>D′ C</code> by the distance <code>C E</code> to a point <code>R</code>. Extend <code>P R</code> by the distance <code>R P</code> to a point <code>Q</code>.

In other words, we are adding <code>(between C′ C P ∧ C P ≡ C D′) ∧ (between D′ C R ∧ C R ≡ C E) ∧ (between P R Q ∧ R Q ≡ R P)</code>
<jh>
thm (p-q-r-exist
  ((p q r A) (p q r D) (p q r C′) (p q r C) (p q r D′) (p q r B′) (p q r B) (p q r B″) (p q r E)) ()
  ((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) →
  (∃ r (∃ p (∃ q (
    (((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C (value p)) ∧ (C (value p) ≡ C D′))) ∧
    ((between D′ C (value r)) ∧ (C (value r) ≡ C E))) ∧
    ((between (value p) (value r) (value q)) ∧ ((value r) (value q) ≡ (value r) (value p)))
  ))))) (
        (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′)))
          ImplicationReflexivity
</jh>
We're ready to construct <code>p</code>.
<jh>
        p C′ C C D′ SegmentConstruction
        introduceRightConjunctToConsequent

        p
          (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
            ((between C E C′) ∧ (between D E D′)))
          ((between C′ C (value p)) ∧ (C (value p) ≡ C D′))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        applySyllogism

</jh>
The construction of <code>r</code> is similar.
<jh>
        r D′ C C E SegmentConstruction
        introduceRightConjunctToConsequent

        # TODO: this can be simplified via ThereExistsScattering, right?
        r
          (∃ p 
            ((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
            ((between C E C′) ∧ (between D E D′))) ∧
            ((between C′ C (value p)) ∧ (C (value p) ≡ C D′))))
          ((between D′ C (value r)) ∧ (C (value r) ≡ C E))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        applySyllogism

        p
          ((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
            ((between C E C′) ∧ (between D E D′))) ∧
            ((between C′ C (value p)) ∧ (C (value p) ≡ C D′)))
          ((between D′ C (value r)) ∧ (C (value r) ≡ C E))
          ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        r addThereExists
        applySyllogism
</jh>
The construction of <code>q</code> is only slightly different (with the most obvious difference in the logic being that it depends on <code>p</code> and <code>r</code>).
<jh>
        q (value p) (value r) (value r) (value p) SegmentConstruction
        p generalize
        r generalize
        introduceRightConjunctToConsequent

        r
          (∃ p (((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
            ((between C E C′) ∧ (between D E D′))) ∧
            ((between C′ C (value p)) ∧ (C (value p) ≡ C D′))) ∧
            ((between D′ C (value r)) ∧ (C (value r) ≡ C E))))
          (∀ p (∃ q ((between (value p) (value r) (value q)) ∧ ((value r) (value q) ≡ (value r) (value p)))))
          ThereExistsConjunctionRightCombining
        applySyllogism

        p
          (((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
            ((between C E C′) ∧ (between D E D′))) ∧
            ((between C′ C (value p)) ∧ (C (value p) ≡ C D′))) ∧
            ((between D′ C (value r)) ∧ (C (value r) ≡ C E)))
          (∃ q ((between (value p) (value r) (value q)) ∧ ((value r) (value q) ≡ (value r) (value p))))
          ThereExistsConjunctionRightCombining
        r addThereExists
        applySyllogism

        q
          (((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
            ((between C E C′) ∧ (between D E D′))) ∧
            ((between C′ C (value p)) ∧ (C (value p) ≡ C D′))) ∧
            ((between D′ C (value r)) ∧ (C (value r) ≡ C E)))
          ((between (value p) (value r) (value q)) ∧ ((value r) (value q) ≡ (value r) (value p)))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        p addThereExists
        r addThereExists
        applySyllogism
))
</jh>

=== C ≠ D′ ===
Our goal is to prove <code>C = C′ ∨ D = D′</code>. We do this by adding <code>C ≠ C′</code> to our antecedent and then showing it implies <code>D = D′</code>. The first step is to show that <code>C ≠ D′</code>. This is a straightforward consequence of <code>C ≠ C′</code> and the congruence of <code>C D′</code> and <code>C′ D′</code>, but it will take a few lemmas to do all the needed arranging.
<jh>
thm (dprime-cprime () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C = D′)) →
  (D′ = C′)) (
</jh>
First we need <code>C = D′</code>.
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C = D′)
          ConjunctionLeftElimination
</jh>
Secondly we need <code>C D′ ≡ D′ C′</code> which we derive from <code>C D′ ≡ C D</code> (an antecedent), <code>C′ D′ ≡ C D</code> (previously proved), and a bit of rearrangement.
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C = D′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C = D′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        A D C′ C D′ B′ B B″ cprime-dprime-c-d
        applySyllogism

        C′ D′ C D CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        C D′ C D C′ D′ CongruenceTransitivity
        applySyllogism

        C D′ C′ D′ CongruenceRightCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Now we can show <code>D′ = C′</code>.
<jh>
        C D′ D′ C′ CongruenceIdentityFromEquality
        import
        applySyllogism
))

thm (c-cprime () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C = D′)) →
  (C = C′)) (
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C = D′)
          ConjunctionLeftElimination

        A D C′ C D′ B′ B B″ E P R Q dprime-cprime

        composeConjunction

        C D′ C′ EqualityTransitivity
        applySyllogism
))

thm (c-dprime () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′)) →
  (C ≠ D′)) (
        A D C′ C D′ B′ B B″ E P R Q c-cprime
        export

        (C = D′) (C = C′) Transposition
        eliminateBiconditionalReverse
        applySyllogism

        import
))
</jh>

=== R P ≡ E D′ ===
The proof is by outer five segment on <code>D′ C R</code> and <code>P C E</code> and points <code>P</code> and <code>D′</code>. We pretty much have everything we need to apply outer five segment, although <code>between P C E</code> is complicated enough to break out into its own lemma. This lemma follows from <code>between P C C′</code> and <code>between C E C′</code>.

<jh>
thm (p-c-e () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′)) →
  (between P C E)) (
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        C′ C P BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction

        P C C′ E BetweennessInnerTransitivity
        applySyllogism
))

thm (r-p-e-dprime () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′)) →
  (R P ≡ E D′)) (
</jh>
First we need <code>D′ ≠ C</code>. We proved it in the previous section.
<jh>
        A D C′ C D′ B′ B B″ E P R Q c-dprime

        C D′ EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next is <code>between D′ C R</code>, from the construction of <code>R</code>.
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
Next is <code>between P C E</code>.
<jh>
        A D C′ C D′ B′ B B″ E P R Q p-c-e
        composeConjunction
</jh>
Next is <code>D′ C ≡ P C</code>, from the construction of <code>P</code>.
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        C P C D′ CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        P C D′ C CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Next is <code>C R ≡ C E</code>, from the construction of <code>R</code>.
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Next is <code>D′ P ≡ P D′</code>, which holds trivially.
<jh>
        D′ P CongruenceABBA
        introduceRightConjunctToConsequent
</jh>
Next is <code>C P ≡ C D′</code>, from the construction of <code>P</code>.
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
We can then conclude <code>R P ≡ E D′</code>.
<jh>
        D′ C R P C E P D′ OuterFiveSegment
        applySyllogism
))
</jh>

=== R Q ≡ E D ===
This is an easy consequence of <code>R P ≡ E D′</code>.
<jh>
thm (r-q-e-d () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′)) →
  (R Q ≡ E D)) (
</jh>
We start with <code>R Q ≡ R P</code> (from the construction of <code>Q</code>).
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
Next is <code>R P ≡ E D′</code> (from the previous section).
<jh>
        A D C′ C D′ B′ B B″ E P R Q r-p-e-dprime
        composeConjunction

        R Q R P E D′ CongruenceTransitivity
        applySyllogism
</jh>
Finally is <code>E D′ ≡ E D</code> (which we proved a few sections back).
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        A D C′ C D′ B′ B B″ E e-d-e-dprime
        applySyllogism

        E D E D′ CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        R Q E D′ E D CongruenceTransitivity
        applySyllogism
))
</jh>

== D′ D ≡ P Q ==
[[File:outer connectivity for betweenness 4.svg|thumb|right|D′ D ≡ P Q and C P ≡ C Q]]
The congruences from the previous section, <code>R P ≡ E D′</code> and <code>R Q ≡ E D</code>, lead to <code>D′ D ≡ P Q</code>, which is a congruence we'll need later on. The proof is by outer three segment on <code>D′ E D</code> and <code>P R Q</code>.
<jh>
thm (dprime-d-p-q () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′)) →
  (D′ D ≡ P Q)) (
</jh>
First is <code>between D′ E D</code>
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        D E D′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next is <code>between P R Q</code>
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
Next is <code>D′ E ≡ P R</code>.
<jh>
        A D C′ C D′ B′ B B″ E P R Q r-p-e-dprime

        R P E D′ CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        E D′ R P CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Last is <code>E D ≡ R Q</code>.
<jh>
        A D C′ C D′ B′ B B″ E P R Q r-q-e-d

        R Q E D CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        D′ E D P R Q OuterThreeSegment
        applySyllogism
))
</jh>

== C Q ≡ C D ==
[[File:outer connectivity for betweenness 4.svg|thumb|right|D′ D ≡ P Q and C P ≡ C Q]]
To prove <code>C Q ≡ C D</code>, there are two cases, based on whether <code>D′ = E</code> or not.

=== <code>D′ = E</code> case ===
We start with the case in which <code>D′ = E</code>.

First is <code>D′ = D</code>, which follows via <code>E = D</code> from <code>E D ≡ E D′</code>.
<jh>
thm (c-q-c-d-case-dprime-e-e-d () ()
  (
    ((D′ = E) ∧
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′))) →
  (E = D)) (
        (D′ = E)
          (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P))) ∧
          (C ≠ C′))
          ConjunctionRightElimination

        (D′ = E)
          (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P))) ∧
          (C ≠ C′))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        A D C′ C D′ B′ B B″ E e-d-e-dprime
        applySyllogism

        E D E D′ CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        E D′ E D CongruenceLeftCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        D′ E E D CongruenceIdentityFromEquality
        import

        applySyllogism
))

thm (c-q-c-d-case-dprime-e-dprime-d () ()
  (
    ((D′ = E) ∧
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′))) →
  (D′ = D)) (
        (D′ = E)
          (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P))) ∧
          (C ≠ C′))
          ConjunctionRightElimination

        D′ E A D C′ C B′ B B″ P R Q c-q-c-d-case-dprime-e-e-d
        composeConjunction

        D′ E D EqualityTransitivity
        applySyllogism
))
</jh>

It might seem that having proved <code>D′ = D</code> we are done with this case (since after all, <code>D′ = D</code> is the long-term goal of this proof). Although we could, of course, proceed this way, it would entail carrying along the two cases to almost the end of the proof. So we instead will take a few more steps to prove <code>C Q ≡ C D</code>. The next one is <code>P = Q</code>.

<jh>
thm (c-q-c-d-case-dprime-e-p-q () ()
  (
    ((D′ = E) ∧
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′))) →
  (P = Q)) (
        D′ E A D C′ C B′ B B″ P R Q c-q-c-d-case-dprime-e-dprime-d

        (D′ = E)
          (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P))) ∧
          (C ≠ C′))
          ConjunctionLeftElimination
        A D C′ C D′ B′ B B″ E P R Q dprime-d-p-q
        applySyllogism

        composeConjunction

        D′ D P Q CongruenceIdentityFromEquality
        import

        applySyllogism
))
</jh>

Now that we have <code>P = Q</code>, we just need to apply transitivity and a substitution to <code>C P ≡ C D′</code> and <code>C D′ ≡ C D</code> to get <code>C Q = C D</code>.
<jh>
thm (c-q-c-d-case-dprime-e () ()
  (
    ((D′ = E) ∧
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′))) →
  (C Q ≡ C D)) (
        D′ E A D C′ C B′ B B″ P R Q c-q-c-d-case-dprime-e-p-q
</jh>
Now we need <code>C P ≡ C D</code>.
<jh>
        (D′ = E)
          (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P))) ∧
          (C ≠ C′))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        (D′ = E)
          (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P))) ∧
          (C ≠ C′))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction

        C P C D′ C D CongruenceTransitivity
        applySyllogism

        composeConjunction
</jh>
<code>P = Q → (C P ≡ C D ↔ C Q ≡ C D)</code>
<jh>
        C EqualityReflexivity
        C EqualityReflexivity
        D EqualityReflexivity
        C C P Q C C D D CongruenceBuilder
        detach2of2
        detach2of2
        detach1of2
</jh>
A bit of rearranging and we are done.
<jh>
        eliminateBiconditionalReverseInConsequent
        import
        applySyllogism
))
</jh>

=== <code>D′ ≠ E</code> case ===
The more interesting case is <code>D′ ≠ E</code>. It follows from outer five segment on line segments <code>D′ E D</code> and <code>P R Q</code> and points <code>C</code> and <code>C</code>.
<jh>
thm (c-q-c-d-case-dprime-not-e () ()
  (
    ((D′ ≠ E) ∧
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′))) →
  (C Q ≡ C D)) (
</jh>
First we need <code>D′ ≠ E</code>.
<jh>
        (D′ ≠ E)
          (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P))) ∧
          (C ≠ C′))
          ConjunctionRightElimination
</jh>
Next we need <code>between D′ E D</code>.
<jh>
        (D′ ≠ E)
          (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P))) ∧
          (C ≠ C′))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        D E D′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Next is <code>between P R Q</code>.
<jh>
        (D′ ≠ E)
          (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P))) ∧
          (C ≠ C′))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
Next is <code>D′ E ≡ P R</code>, which we proved a few sections back.
<jh>
        (D′ ≠ E)
          (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P))) ∧
          (C ≠ C′))
          ConjunctionLeftElimination

        A D C′ C D′ B′ B B″ E P R Q r-p-e-dprime
        applySyllogism

        R P E D′ CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        E D′ R P CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Next is <code>E D ≡ R Q</code>, which we proved a few sections back.
<jh>
        (D′ ≠ E)
          (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P))) ∧
          (C ≠ C′))
          ConjunctionLeftElimination

        A D C′ C D′ B′ B B″ E P R Q r-q-e-d
        applySyllogism

        R Q E D CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Here is <code>D′ C ≡ P C</code>, from the construction of <code>P</code>.
<jh>
        (D′ ≠ E)
          (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P))) ∧
          (C ≠ C′))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        C P C D′ CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        C D′ C P CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Finally we need <code>E C ≡ R C</code>, which comes from the construction of <code>R</code>.
<jh>
        (D′ ≠ E)
          (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P))) ∧
          (C ≠ C′))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        C R C E CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        C E C R CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
From outer five segment we can conclude <code>D C ≡ Q C</code>.
<jh>
        D′ E D P R Q C C OuterFiveSegment
        applySyllogism

        D C Q C CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        Q C D C CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

=== Combining the two cases ===
<jh>
thm (c-q-c-d () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′)) →
  (C Q ≡ C D)) (
        D′ E A D C′ C B′ B B″ P R Q c-q-c-d-case-dprime-e
        export

        D′ E A D C′ C B′ B B″ P R Q c-q-c-d-case-dprime-not-e
        export

        eliminateCases
))
</jh>

=== A Corollary: C P ≡ C Q ===
That the previous result implies <code>C P ≡ C Q</code> is apparent from looking at the single ticked line segments in the diagram. The proof is just some congruence transitivity.
<jh>
thm (c-p-c-q () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′)) →
  (C P ≡ C Q)) (
        A D C′ C D′ B′ B B″ E P R Q c-q-c-d

        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        C D′ C D CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        C Q C D C D′ CongruenceTransitivity
        applySyllogism

        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        C P C D′ CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        C Q C D′ C P CongruenceTransitivity
        applySyllogism

        C Q C P CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

== The line containing C, R, D′, B, B′, C′, and P ==
[[File:outer connectivity for betweenness 5.svg|thumb|right|D′ P ≡ D′ Q, B P ≡ B Q, and likewise for B′ and C′]]
We've set up the dominos, and in this section we push them over. For a domino (point) <code>x</code> to "fall" means that we prove <code>x P ≡ x Q</code> (via <code>EquidistantLine</code>). So we need three collinear points, the first two of which are not equal, and the first two of which already have their congruences with <code>P</code> and <code>Q</code> proven. That gives us the third congruence, and then this domino is ready to push on one of the following ones.

=== D′ ===
We start with <code>R</code>, <code>C</code>, and <code>D′</code>.

The first part is <code>R ≠ C</code>. We will show that <code>R = C</code> implies <code>C = C′</code>, so a transposition gives us what we want.
<jh>
thm (c-e-lemma () ()
  (((C R ≡ C E) ∧ (R = C)) → (C = E)) (
        C R C E CongruenceLeftCommutativity
        eliminateBiconditionalReverse

        R C C E CongruenceIdentityFromEquality
        applyComm
        applySyllogism

        import
))

thm (c-e () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (R = C)) →
  (C = E)) (
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (R = C)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (R = C)
          ConjunctionLeftElimination

        composeConjunction

        C R E c-e-lemma

        applySyllogism
))

thm (e-cprime () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (R = C)) →
  (E = C′)) (
        A D C′ C D′ B′ B B″ E P R Q c-e

        C E EqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism

        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (R = C)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        A D C′ C D′ B′ B B″ E e-c-e-cprime
        applySyllogism

        composeConjunction

        E C E C′ CongruenceIdentityFromEquality
        import

        applySyllogism
))

thm (r-c-implies-c-cprime () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (R = C)) →
  (C = C′)) (
        A D C′ C D′ B′ B B″ E P R Q c-e
        A D C′ C D′ B′ B B″ E P R Q e-cprime
        composeConjunction

        C E C′ EqualityTransitivity
        applySyllogism
))

thm (r-not-c () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′)) →
  (R ≠ C)) (
        A D C′ C D′ B′ B B″ E P R Q r-c-implies-c-cprime
        export

        (R = C) (C = C′) Transposition
        eliminateBiconditionalReverse
        applySyllogism

        import
))
</jh>

Now we are ready to prove <code>D′ P ≡ D′ Q</code>.
<jh>
thm (dprime-p-dprime-q () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′)) →
  (D′ P ≡ D′ Q)) (
</jh>
First we need <code>R ≠ C</code>.
<jh>
        A D C′ C D′ B′ B B″ E P R Q r-not-c
</jh>
Next is <code>collinear R C D′</code>.
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        D′ C R BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        R C D′ BetweennessCollinearity
        applySyllogism

        composeConjunction
</jh>
Next is <code>R P ≡ R Q</code>.
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        R Q R P CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Finally is <code>C P ≡ C Q</code>, which lets us apply <code>EquidistantLine</code>.
<jh>
        A D C′ C D′ B′ B B″ E P R Q c-p-c-q

        composeConjunction

        R C D′ P Q EquidistantLine
        applySyllogism
))
</jh>

=== B′ ===
The next point is <code>B′</code>, which follows from the results for <code>C</code> and <code>D′</code>. We break out one substitution into a lemma, but other than that we have everything we need.

<jh>
thm (c-dprime-bprime () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′)) →
  (between C D′ B′)) (
</jh>
First we put on the proof stack two things: <code>B″ D′ C</code> and <code>B″ = B′</code>.
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        A D C′ C D′ B′ B B″ bdoubleprime-dprime-c
        applySyllogism

        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        A D C′ C D′ B′ B B″ bdoubleprime-bprime
        applySyllogism
</jh>
Next comes our substitution: <code>B″ = B′ → (between B″ D′ C ↔ between B′ D′ C)</code>.
<jh>
        D′ EqualityReflexivity
        C EqualityReflexivity
        B″ B′ D′ D′ C C BetweennessBuilder
        detach2of2
        detach2of2
</jh>
We detach that twice to get <code>between B′ D′ C</code>.
<jh>
        eliminateBiconditionalReverseInConsequent
        applySyllogism

        applyModusPonensInConsequent
</jh>
We swap the endpoints, as the swapped version will be more convenient later.
<jh>
        B′ D′ C BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
))

thm (bprime-p-bprime-q () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′)) →
  (B′ P ≡ B′ Q)) (
</jh>
The first part is <code>C ≠ D′</code>.
<jh>
        A D C′ C D′ B′ B B″ E P R Q c-dprime
</jh>
Next is <code>collinear C D′ B′</code>
<jh>
        A D C′ C D′ B′ B B″ E P R Q c-dprime-bprime
        C D′ B′ BetweennessCollinearity
        applySyllogism

        composeConjunction
</jh>
Next is <code>C P ≡ C Q</code>
<jh>
        A D C′ C D′ B′ B B″ E P R Q c-p-c-q

        composeConjunction
</jh>
Last is <code>D′ P ≡ D′ Q</code>
<jh>
        A D C′ C D′ B′ B B″ E P R Q dprime-p-dprime-q

        composeConjunction

        C D′ B′ P Q EquidistantLine
        applySyllogism
))
</jh>

=== B ===
The next point is <code>B</code>, which also follows from the results for <code>C</code> and <code>D′</code>. We have everything we need here with even less work than in the previous section.

<jh>
thm (b-p-b-q () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′)) →
  (B P ≡ B Q)) (
</jh>
The first part is <code>C ≠ D′</code>.
<jh>
        A D C′ C D′ B′ B B″ E P R Q c-dprime
</jh>
Next is <code>collinear C D′ B</code>
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        A D C′ C D′ B′ B B″ b-c-dprime
        applySyllogism

        B C D′ BetweennessCollinearity
        applySyllogism

        B C D′ CollinearityRotation
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Next is <code>C P ≡ C Q</code>
<jh>
        A D C′ C D′ B′ B B″ E P R Q c-p-c-q

        composeConjunction
</jh>
Last is <code>D′ P ≡ D′ Q</code>
<jh>
        A D C′ C D′ B′ B B″ E P R Q dprime-p-dprime-q

        composeConjunction

        C D′ B P Q EquidistantLine
        applySyllogism
))
</jh>

=== C′ ===
The next point is <code>C′</code>, which follows from the results for <code>B</code> and <code>B′</code>. 

Before we get to the main proof of this, we prove a few lemmas. The first one we need is <code>between B′ C B</code>. As we already have 
<code>between B″ C B</code>, this is just a substitution.

<jh>
thm (bprime-c-b
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between B′ C B)) (
        A D C′ C D′ B′ B B″ bdoubleprime-c-b

        A D C′ C D′ B′ B B″ bdoubleprime-bprime

        C EqualityReflexivity
        B EqualityReflexivity
        B″ B′ C C B B BetweennessBuilder
        detach2of2
        detach2of2

        eliminateBiconditionalReverseInConsequent

        applySyllogism

        applyModusPonensInConsequent
))
</jh>

The next lemma is <code>B ≠ B′</code>. As usual, this will be via the contrapositive.

<jh>
thm (b-bprime-c-cprime () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (B = B′)) →
  (C = C′)) (
</jh>
First we prove <code>C = B</code>, by means of <code>B = B′ ∧ between B C B′ → B = C</code>.
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (B = B′)
          ConjunctionLeftElimination

        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (B = B′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        A D C′ C D′ B′ B B″ bprime-c-b
        applySyllogism

        B′ C B BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        B B′ C IndivisibilityFromEquality
        applySyllogism

        B C EqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Then we prove <code>B = C′</code>, by means of <code>B = B′ ∧ between B C′ B′ → B = C′</code>.
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (B = B′)
          ConjunctionLeftElimination

        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (B = B′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        A D C′ C D′ B′ B B″ b-cprime-bprime
        applySyllogism

        composeConjunction

        B B′ C′ IndivisibilityFromEquality
        applySyllogism
</jh>
Now we combine <code>C = B</code> and <code>B = C′</code> to produce <code>C = C′</code>.
<jh>
        composeConjunction

        C B C′ EqualityTransitivity
        applySyllogism
))

thm (b-bprime () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′)) →
  (B ≠ B′)) (
        A D C′ C D′ B′ B B″ E P R Q b-bprime-c-cprime
        export

        (B = B′) (C = C′) Transposition
        eliminateBiconditionalReverse
        applySyllogism

        import
))

thm (cprime-p-cprime-q () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′)) →
  (C′ P ≡ C′ Q)) (
</jh>
First is <code>B ≠ B′</code>.
<jh>
        A D C′ C D′ B′ B B″ E P R Q b-bprime
</jh>
Next is <code>collinear B B′ C′</code>.
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        A D C′ C D′ B′ B B″ b-cprime-bprime
        applySyllogism

        B C′ B′ BetweennessCollinearity
        applySyllogism

        B C′ B′ Collinearity23
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Next is <code>B P ≡ B Q</code>
<jh>
        A D C′ C D′ B′ B B″ E P R Q b-p-b-q

        composeConjunction
</jh>
Last is <code>B′ P ≡ B′ Q</code>
<jh>
        A D C′ C D′ B′ B B″ E P R Q bprime-p-bprime-q

        composeConjunction

        B B′ C′ P Q EquidistantLine
        applySyllogism
))
</jh>

=== P ===
The next point is <code>P</code>, which follows from the results for <code>C′</code> and <code>C</code>. It would be harder to draw a diagram for this one (if the diagram were to show the congruences as well as just <code>P</code>, <code>C</code>, and <code>C′</code>), but the proof is much the same as the ones we've done so far.

<jh>
thm (p-p-p-q () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′)) →
  (P P ≡ P Q)) (
</jh>
First is <code>C′ ≠ C</code>.
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionLeftElimination

        C C′ EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next is <code>collinear C′ C P</code>.
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E))) ∧
          ((between P R Q) ∧ (R Q ≡ R P)))
          (C ≠ C′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        C′ C P BetweennessCollinearity
        applySyllogism

        composeConjunction
</jh>
Next is <code>C′ P ≡ C′ Q</code>
<jh>
        A D C′ C D′ B′ B B″ E P R Q cprime-p-cprime-q

        composeConjunction
</jh>
Last is <code>C P ≡ C Q</code>
<jh>
        A D C′ C D′ B′ B B″ E P R Q c-p-c-q

        composeConjunction

        C′ C P P Q EquidistantLine
        applySyllogism
))
</jh>

== Assembling the result ==
Having proved <code>P P ≡ P Q</code>, we are most of the way done.

=== P = Q ===
<jh>
thm (p-q () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′)) →
  (P = Q)) (
        A D C′ C D′ B′ B B″ E P R Q p-p-p-q
        P P Q CongruenceIdentityLeft
        applySyllogism
))
</jh>

=== D = D′ ===
Here's a variant of <code>CongruenceIdentityFromEquality</code>. Because we (almost?) always want the imported one, the plan is to phase out the exported version in favor of the imported one.
<jh>
var (point x y z w)
thm (CongruenceIdentityFromEqualityImported () () (((x = y) ∧ (x y ≡ z w)) → (z = w)) (
        x y z w CongruenceIdentityFromEquality
        import
))
</jh>

And <code>D = D′</code> follows from <code>P = Q</code> and <code>P Q ≡ D D′</code>.
<jh>
thm (d-dprime () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C ≠ C′)) →
  (D = D′)) (
        A D C′ C D′ B′ B B″ E P R Q p-q

        A D C′ C D′ B′ B B″ E P R Q dprime-d-p-q

        D′ D P Q CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        P Q D′ D CongruenceIdentityFromEqualityImported
        applySyllogism

        D′ D EqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

=== between A C D ∨ between A D C ===
In this section we prove that the long list of antecedents we have been working with implies <code>between A C D ∨ between A D C</code>. There are a few steps.
<jh>
thm (c-cprime-or-d-dprime () ()
  (
    ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) →
    ((C = C′) ∨ (D = D′))) (
        A D C′ C D′ B′ B B″ E P R Q d-dprime
        export

        (C = C′) (D = D′) DisjunctionImplication
        eliminateBiconditionalForward
        applySyllogism
))

thm (a-d-c () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (C = C′)) →
    (between A D C)) (
        (((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E)))
          ((between P R Q) ∧ (R Q ≡ R P))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
The substitution is <code>C = C′ → (between A D C ↔ between A D C′)</code>, which we then apply to prove the desired result.
<jh>
        A EqualityReflexivity
        D EqualityReflexivity
        A A D D C C′ BetweennessBuilder
        detach2of3
        detach1of2

        eliminateBiconditionalForwardInConsequent
        applyComm

        applySyllogism
        import
))

thm (a-c-d () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) ∧
    (D = D′)) →
    (between A C D)) (
        (((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          ((between C′ C P) ∧ (C P ≡ C D′))) ∧
          ((between D′ C R) ∧ (C R ≡ C E)))
          ((between P R Q) ∧ (R Q ≡ R P))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        
eliminateRightConjunctInConsequent
</jh>
The substitution is <code>D = D′ → (between A C D ↔ between A C D′)</code>, which we then apply to prove the desired result.
<jh>
        A EqualityReflexivity
        C EqualityReflexivity
        A A C C D D′ BetweennessBuilder
        detach2of3
        detach1of2

        eliminateBiconditionalForwardInConsequent
        applyComm

        applySyllogism
        import
))

thm (a-c-d-or-a-d-c () ()
  (
    ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C P) ∧ (C P ≡ C D′))) ∧
    ((between D′ C R) ∧ (C R ≡ C E))) ∧
    ((between P R Q) ∧ (R Q ≡ R P))) →
    ((between A C D) ∨ (between A D C))) (
        A D C′ C D′ B′ B B″ E P R Q c-cprime-or-d-dprime

        A D C′ C D′ B′ B B″ E P R Q a-d-c
        (between A D C) (between A C D) DisjunctionLeftIntroduction
        applySyllogism
        export

        A D C′ C D′ B′ B B″ E P R Q a-c-d
        (between A C D) (between A D C) DisjunctionRightIntroduction
        applySyllogism
        export

        composeConjunction

        (C = C′)
          ((between A C D) ∨ (between A D C))
          (D = D′)
          DisjunctionComposition
        eliminateBiconditionalReverse
        applySyllogism

        applyModusPonensInConsequent
))
</jh>

=== Betweenness outer connectivity ===
We now are prepared to take the various lemmas which represent the construction of the various points, tie them together (basically just syllogisms, with suitable handling of ∃), and then remove the quantifiers once they are no longer needed.
<jh>
thm (BetweennessOuterConnectivity
  ( (A c′ d′ b′ b″ e r p q)
   (B c′ d′ b′ b″ e r p q)
   (C c′ d′ b′ b″ e r p q)
   (D c′ d′ b′ b″ e r p q))
  ()
  ((((A ≠ B) ∧ (between A B C)) ∧ (between A B D)) → ((between A C D) ∨ (between A D C)))
  (
        A B C D c′ d′ b′ b″ BetweennessOuterConnectivity-cdbb

        A D (value c′) C (value d′) (value b′) B (value b″) e e-exists
        b″ addThereExists
        b′ addThereExists
        d′ addThereExists
        c′ addThereExists
        applySyllogism

        A D (value c′) C (value d′) (value b′) B (value b″) (value e) r p q p-q-r-exist
        e addThereExists
        b″ addThereExists
        b′ addThereExists
        d′ addThereExists
        c′ addThereExists
        applySyllogism

        A D (value c′) C (value d′) (value b′) B (value b″) (value e) (value p) (value r) (value q) a-c-d-or-a-d-c
        q addThereExists
        p addThereExists
        r addThereExists
        e addThereExists
        b″ addThereExists
        b′ addThereExists
        d′ addThereExists
        c′ addThereExists
        applySyllogism

        removeThereExistsInConsequent
        removeThereExistsInConsequent
        removeThereExistsInConsequent
        removeThereExistsInConsequent
        removeThereExistsInConsequent
        removeThereExistsInConsequent
        removeThereExistsInConsequent
        removeThereExistsInConsequent
))
</jh>

== Export ==
We now export to [[Interface:Connectivity for betweenness]].
<jh>
export (RESULTS Interface:Connectivity_for_betweenness (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>
* Tarski, Alfred; Givant, Steven (1999), "Tarski's system of geometry", The Bulletin of Symbolic Logic 5 (2): 175–214, doi:10.2307/421089, MR1791303, ISSN 1079-8986

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]