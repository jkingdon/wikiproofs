{{header
 | title    = Principia Mathematica
 | subtitle = propositional logic
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = The purpose of this page is to prove the statements of [[Interface:Classical propositional calculus]] from the [[Interface:Principia Mathematica propositional logic|Principia Mahematica]]<ref>{{sc|A. Whitehead, B. Russell}}, Principia Mathematica, ''Cambridge University Press'', 1910.</ref> axioms for propositional logic.

[[Image:Zeichen 123.svg|50px]] Still under construction
}}
{{interfaces
| imports = [[Interface:Principia Mathematica propositional logic|Principia Mathematica propositional logic]]
| exports = [[Image:Zeichen 123.svg|35px]] None yet
}}

<jh>
import (PRINCIPIA Interface:Principia_Mathematica_propositional_logic () ())
</jh>
We define some variables for well-formed formulas:
<jh>
var (wff p q r s)
</jh>
Principia Mathematica does not define the [[w:nullary#Nullary|nullary]] [[w:logical connective|connectives]] "the true", <math>\top</math>, and "the false", <math>\bot</math>, so we define them here:
<jh>
def ((⊤) (p ∨ (¬ p)))
def ((⊥) (p ∧ (¬ p)))
</jh>
We shall now begin to derive the statements. Whitehead and Russell use a decimal numbering system of the form <math>*r</math>, where <math>r</math> is a rational number with a small number of digits after the decimal point. Unless we give theorems our own name, we shall adopt their system for easier reference. Where we do use our own names, we sometimes give the decimal reference in a JHilbert comment.

== Immediate consequences from the axioms ==

The [[w:modus ponens|modus ponens]] rule is an axiom of Principia Mathematica, so we don't need to prove it. The ''Perm'' axiom immediately gives rise to the [[w:logical disjunction|disjunctive]] commutativity rule:
<jh>
thm (swapDisjunction () ((H (p ∨ q))) (q ∨ p) (
        H
        p q Perm
        applyModusPonens
))
</jh>
Since Principia Mathematica defines implication, <math>p\rightarrow q</math>, as <math>(\neg p)\vee q</math>, the ''Add'' axiom yields the introduction of an antecedent (Whitehead and Russell call it "Simplification").
<jh>
thm (AntecedentIntroduction () () (p → (q → p)) ( # *2.02
        p (¬ q) Add
))
</jh>
It will be convenient to have this theorem as helper rule:
<jh>
thm (introduceAntecedent () ((H p)) (q → p) (
        H
        p q AntecedentIntroduction
        applyModusPonens
))
</jh>
Again due to the way implication is defined, ''Perm'' gives us our first transposition rule:
<jh>
thm (*2.03 () () ((p → (¬ q)) → (q → (¬ p))) (
        (¬ p) (¬ q) Perm
))

thm (transposeWithNegatedConsequent () ((H (p → (¬ q)))) (q → (¬ p)) (
        H
        p q *2.03
        applyModusPonens
))
</jh>
Next, we prove a precursor to the commutative law of Conjunction, which will be very convenient until we get Peano's transportation principle. We call this theorem ''Comm'' in accordance with Whitehead and Russell.
<jh>
thm (Comm () () ((p → (q → r)) → (q → (p → r))) ( # *2.04
        (¬ p) (¬ q) r Assoc
))

thm (applyComm () ((H (p → (q → r)))) (q → (p → r)) (
        H
        p q r Comm
        applyModusPonens
))
</jh>
This theorem enables us to prove ''Syllogism'' from the ''Sum'' axiom:
<jh>
thm (*2.05 () () ((q → r) → ((p → q) → (p → r))) (
        q r (¬ p) Sum
))

thm (Syllogism () () ((p → q) → ((q → r) → (p → r))) ( # *2.06
        q r p *2.05
        (q → r) (p → q) (p → r) Comm
        applyModusPonens
))

thm (applySyllogism () ((H1 (p → q)) (H2 (q → r))) (p → r) (
        H2
        H1
        p q r Syllogism
        applyModusPonens
        applyModusPonens
))
</jh>
The syllogism yields the "identity" ''Id'', <math>p\rightarrow p</math>, and, by ''Perm'', [[w:tertium non datur|tertium non datur]], which is, by our definition, just <math>\top</math>:
<jh>
thm (Id () () (p → p) ( # *2.08
        p p Add
        p Taut
        applySyllogism
))

thm (TertiumNonDatur () () (p ∨ (¬ p)) ( # *2.11
        p Id
        swapDisjunction        
))

thm (True () () (⊤) (
        p TertiumNonDatur
))
</jh>
Actually, for Whitehead and Russell use the permutation of our ''TertiumNonDatur'' as theirs.

With the ''TertiumNonDatur'', we can tackle double negation:
<jh>
thm (*2.12 () () (p → (¬ (¬ p))) (
        (¬ p) TertiumNonDatur
))

thm (*2.13 () () (p ∨ (¬ (¬ (¬ p)))) (
        p TertiumNonDatur
        (¬ p) *2.12
        (¬ p) (¬ (¬ (¬ p))) p Sum
        applyModusPonens
        applyModusPonens
))

thm (*2.14 () () ((¬ (¬ p)) → p) (
        p *2.13
        swapDisjunction
))

thm (eliminateDoubleNegation () ((H (¬ (¬ p)))) p (
        H
        p *2.14
        applyModusPonens
))
</jh>
Combined with double negation, the transposition law <math>*2.03</math> we already have yields the remaining three:
<jh>
thm (*2.15 () () (((¬ p) → q) → ((¬ q) → p)) (
        q *2.12
        q (¬ (¬ q)) (¬ p) *2.05
        applyModusPonens
</jh>
We now have <math>((\neg p)\rightarrow q)\rightarrow((\neg p)\rightarrow(\neg(\neg q)))</math>. We transpose the consequent using our transposition law <math>*2.03</math>
<jh>
        (¬ p) (¬ q) *2.03
        applySyllogism
</jh>
to get <math>((\neg p)\rightarrow q)\rightarrow((\neg q)\rightarrow(\neg(\neg p)))</math>. All that remains to do now is to eliminate the double negation.
<jh>
        p *2.14
        (¬ (¬ p)) p (¬ q) *2.05
        applyModusPonens
        applySyllogism
))

thm (transposeWithNegatedAntecedent () ((H ((¬ p) → q))) ((¬ q) → p) (
        H
        p q *2.15
        applyModusPonens
))
</jh>
The proofs of the next two theorems work similar but are actually easier due to a more favourable distribution of negations:
<jh>
thm (*2.16 () () ((p → q) → ((¬ q) → (¬ p))) (
        q *2.12
        q (¬ (¬ q)) p *2.05
        applyModusPonens
        p (¬ q) *2.03
        applySyllogism
))

thm (introduceTransposition () ((H (p → q))) ((¬ q) → (¬ p)) (
        H
        p q *2.16
        applyModusPonens
))

thm (*2.17 () () (((¬ q) → (¬ p)) → (p → q)) (
        (¬ q) p *2.03
        q *2.14
        (¬ (¬ q)) q p *2.05
        applyModusPonens
        applySyllogism
))

thm (eliminateTransposition () ((H ((¬ q) → (¬ p)))) (p → q) (
        H
        q p *2.17
        applyModusPonens
))
</jh>
Next, we prove the disjunction introduction laws. Introduction from the left is just the ''Add'' axiom of principia, and a permutation yields the introduction from the right.
<jh>
thm (DisjuctionIntroductionLeft () () (p → (q ∨ p)) (
        p q Add
))

thm (introduceLeftDisjunction () ((H p)) (q ∨ p) (
        H
        p q DisjuctionIntroductionLeft
        applyModusPonens
))

thm (DisjuctionIntroductionRight () () (p → (p ∨ q)) ( # *2.2
        p q DisjuctionIntroductionLeft
        q p Perm
        applySyllogism
))

thm (introduceRightDisjunction () ((H p)) (p ∨ q) (
        H
        p q DisjuctionIntroductionRight
        applyModusPonens
))
</jh>
Next, we prove the modus ponens law with ''Assoc'':
<jh>
thm (*2.25 () () (p ∨ ((p ∨ q) → q)) (
        (p ∨ q) Id
        (¬ (p ∨ q)) p q Assoc
        applyModusPonens
))

thm (ModusPonens () () (p → ((p → q) → q)) ( # *2.27
        (¬ p) q *2.25
))
</jh>
We now "repair" the extra twist in the ''Assoc'' axiom to get the actual associativity rules for disjunction:
<jh>
thm (*2.3 () () ((p ∨ (q ∨ r)) → (p ∨ (r ∨ q))) (
        q r Perm
        (q ∨ r) (r ∨ q) p Sum
        applyModusPonens
))

thm (*2.31 () () ((p ∨ (q ∨ r)) → ((p ∨ q) ∨ r)) (
        p q r *2.3
        p r q Assoc
        applySyllogism
        r (p ∨ q) Perm
        applySyllogism
))

thm (groupDisjunctionLeft () ((H (p ∨ (q ∨ r)))) ((p ∨ q) ∨ r) (
        H
        p q r *2.31
        applyModusPonens
))

thm (*2.32 () () (((p ∨ q) ∨ r) → (p ∨ (q ∨ r))) (
        (p ∨ q) r Perm
        r p q Assoc
        applySyllogism
        p r q *2.3
        applySyllogism
))

thm (groupDisjunctionRight () ((H ((p ∨ q) ∨ r))) (p ∨ (q ∨ r)) (
        H
        p q r *2.32
        applyModusPonens
))
</jh>
Now we prove three helpful theorems regarding expression building with disjunctions, that is, they are companions to the ''Sum'' axiom. All these proofs proceed in two steps, using a syllogism to alter the consequent of ''Sum''.
<jh>
thm (*2.36 () () ((q → r) → ((p ∨ q) → (r ∨ p))) (
</jh>
As first step, we simply take the ''Sum'' axiom,
<jh>
        q r p Sum
</jh>
and prove <math>((p\vee q)\rightarrow(p\vee r))\rightarrow((p\vee q)\rightarrow(r\vee p))</math> as second step,
<jh>
        p r Perm
        (p ∨ r) (r ∨ p) (p ∨ q) *2.05
        applyModusPonens
</jh>
so that the result follows via a syllogism:
<jh>
        applySyllogism
))

thm (*2.37 () () ((q → r) → ((q ∨ p) → (p ∨ r))) (
</jh>
As first step, we take the ''Sum'' axiom with transposed consequent, that is <math>(q\rightarrow r)\rightarrow((\neg(p\vee r))\rightarrow(\neg(p\vee q)))</math>,
<jh>
        q r p Sum
        (p ∨ q) (p ∨ r) *2.16
        applySyllogism
</jh>
As second step, we prove <math>((\neg(p\vee r))\rightarrow(\neg(p\vee q)))\rightarrow((\neg(p\vee r))\rightarrow(\neg(q\vee p)))</math>
<jh>
        q p Perm
        introduceTransposition
        (¬ (p ∨ q)) (¬ (q ∨ p)) (¬ (p ∨ r)) *2.05
        applyModusPonens
</jh>
Combining these two steps, the result follows by transposing the consequent back.
<jh>
        applySyllogism
        (p ∨ r) (q ∨ p) *2.17
        applySyllogism
))
</jh>
Finally, <math>*2.38</math> follows directly from <math>*2.37</math> in the same way.
<jh>
thm (*2.38 () () ((q → r) → ((q ∨ p) → (r ∨ p))) (
        q r p *2.37
        p r Perm
        (p ∨ r) (r ∨ p) (q ∨ p) *2.05
        applyModusPonens
        applySyllogism
))
</jh>
The next theorem yields a double negation of the left hand side of a disjunction. This is a useful helper theorem.
<jh>
thm (*2.53 () () ((p ∨ q) → ((¬ p) → q)) (
        p *2.12
        p (¬ (¬ p)) q *2.38
        applyModusPonens
))
</jh>

== Conjunction ==

In this section we prove statements involving conjunction <math>p\wedge q</math>. Recall that conjunction is defined by <math>\neg((\neg p)\vee(\neg q))</math>. Our first theorem is the rule that two true statements can be combined to a conjunction.
<jh>
thm (combineStatements () ((H1 p) (H2 q)) (p ∧ q) ( # *3.03
        H2
        H1
        ((¬ p) ∨ (¬ q)) TertiumNonDatur
</jh>
The trick is now to write <math>(\neg p)\vee(\neg q)\vee\ldots</math> as <math>p\rightarrow(q\rightarrow\ldots)</math>:
<jh>
        groupDisjunctionRight
        applyModusPonens
        applyModusPonens
))
</jh>
We can prove the commutative law for conjunction from ''Perm'' using transpositions:
<jh>
thm (*3.22 () () ((p ∧ q) → (q ∧ p)) (
        (q ∧ p) Id
        eliminateTransposition
        (¬ q) (¬ p) Perm
        applySyllogism
        introduceTransposition
))

thm (swapConjunction () ((H (p ∧ q))) (q ∧ p) (
        H
        p q *3.22
        applyModusPonens
))
</jh>
Next, we prove the negation of <math>\bot</math>:
<jh>
thm (*3.24 () () (¬ (p ∧ (¬ p))) (
        (¬ p) TertiumNonDatur
        ((¬ p) ∨ (¬ (¬ p))) *2.12
        applyModusPonens
))

thm (NotFalse () () (¬ (⊥)) (
        p *3.24
))
</jh>
Next, we prove the conjunction elimination theorems.
<jh>
thm (ConjunctionEliminationRight () () ((p ∧ q) → p) ( # *3.26
        p q AntecedentIntroduction
        groupDisjunctionLeft
</jh>
This gives us <math>((\neg p)\vee(\neg q))\vee p</math>. All we need now is a double negation of the left bracket.
<jh>
        ((¬ p) ∨ (¬ q)) p *2.53
        applyModusPonens
))

thm (eliminateRightConjunction () ((H (p ∧ q))) p (
        H
        p q ConjunctionEliminationRight
        applyModusPonens
))

thm (ConjunctionEliminationLeft () () ((p ∧ q) → q) ( # *3.27
        p q *3.22
        q p ConjunctionEliminationRight
        applySyllogism
))

thm (eliminateLeftConjunction () ((H (p ∧ q))) q (
        H
        p q ConjunctionEliminationLeft
        applyModusPonens
))
</jh>

== Biconditional ==

In Principia, the biconditional <math>p\leftrightarrow q</math> is defined simply as <math>(p\rightarrow q)\wedge(q\rightarrow p)</math>, so our combination and elimination theorems for conjunction immediately yield the corresponding introduction and elimination rules for the biconditional.
<jh>
thm (introduceBiconditional () ((H1 (p → q)) (H2 (q → p))) (p ↔ q) (
        H1 H2 combineStatements
))

thm (eliminateBiconditionalLeft () ((H (p ↔ q))) (p → q) (
        H eliminateRightConjunction
))

thm (eliminateBiconditionalRight () ((H (p ↔ q))) (q → p) (
        H eliminateLeftConjunction
))
</jh>
Some more easy theorems:
<jh>
thm (DoubleNegation () () (p ↔ (¬ (¬ p))) ( # *4.13
        p *2.12
        p *2.14
        introduceBiconditional
))

thm (BiconditionalReflexivity () () (p ↔ p) ( # *4.2
        p Id
        p Id
        introduceBiconditional
))

thm (BiconditionalSymmetry () () ((p ↔ q) → (q ↔ p)) ( # *4.21
        (p → q) (q → p) *3.22
))

thm (swapBiconditional () ((H (p ↔ q))) (q ↔ p) (
        H
        p q BiconditionalSymmetry
        applyModusPonens
))

thm (buildNegation () ((H (p ↔ q))) ((¬ p) ↔ (¬ q)) (
        H eliminateBiconditionalRight
        introduceTransposition
        H eliminateBiconditionalLeft
        introduceTransposition
        combineStatements
))
</jh>
Since the definition of conjunction in Principia is based on [[w:De Morgan's laws|De Morgan's laws]], the laws themselves are not hard to prove.
<jh>
thm (ConjunctionNegation () () ((¬ (p ∧ q)) ↔ ((¬ p) ∨ (¬ q))) ( # *4.51
        ((¬ p) ∨ (¬ q)) DoubleNegation
        swapBiconditional
))
</jh>

:''This page is still incomplete''

== References ==

<references />

[[Category:Classical propositional logic]]