{{header
 | title    = Principia Mathematica
 | subtitle = propositional logic
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = The purpose of this page is to prove the statements of [[Interface:Classical propositional calculus]] from the [[Interface:Principia Mathematica propositional logic|Principia Mahematica]]<ref>{{sc|A. Whitehead, B. Russell}}, Principia Mathematica, ''Cambridge University Press'', 1910.</ref> axioms for propositional logic.

[[Image:Zeichen 123.svg|50px]] Still under construction
}}
{{interfaces
| imports = [[Interface:Principia Mathematica propositional logic|Principia Mathematica propositional logic]]
| exports = [[Image:Zeichen 123.svg|35px]] None yet
}}

<jh>
import (PRINCIPIA Interface:Principia_Mathematica_propositional_logic () ())
</jh>
We define some variables for well-formed formulas:
<jh>
var (wff p q r s)
</jh>
Principia Mathematica does not define the [[w:nullary#Nullary|nullary]] [[w:logical connective|connectives]] "the true", <math>\top</math>, and "the false", <math>\bot</math>, so we define them here:
<jh>
def ((⊤) (p ∨ (¬ p)))
def ((⊥) (p ∧ (¬ p)))
</jh>
We shall now begin to derive the statements. Whitehead and Russell use a decimal numbering system of the form <math>*r</math>, where <math>r</math> is a rational number with a small number of digits after the decimal point. Unless we give theorems our own name, we shall adopt their system for easier reference. Where we do use our own names, we sometimes give the decimal reference in a JHilbert comment.

== Immediate consequences from the axioms ==

The [[w:modus ponens|modus ponens]] rule is an axiom of Principia Mathematica, so we don't need to prove it. The ''Perm'' axiom immediately gives rise to the [[w:logical disjunction|disjunctive]] commutativity rule:
<jh>
thm (swapDisjunction () ((H (p ∨ q))) (q ∨ p) (
        H
        p q Perm
        applyModusPonens
))
</jh>
Since Principia Mathematica defines implication, <math>p\rightarrow q</math>, as <math>(\neg p)\vee q</math>, the ''Add'' axiom yields the introduction of an antecedent (Whitehead and Russell call it "Simplification").
<jh>
thm (AntecedentIntroduction () () (p → (q → p)) ( # *2.02
        p (¬ q) Add
))
</jh>
It will be convenient to have this theorem as helper rule:
<jh>
thm (introduceAntecedent () ((H p)) (q → p) (
        H
        p q AntecedentIntroduction
        applyModusPonens
))
</jh>
Again due to the way implication is defined, ''Perm'' gives us our first transposition rule:
<jh>
thm (*2.03 () () ((p → (¬ q)) → (q → (¬ p))) (
        (¬ p) (¬ q) Perm
))

thm (transposeWithNegatedConsequent () ((H (p → (¬ q)))) (q → (¬ p)) (
        H
        p q *2.03
        applyModusPonens
))
</jh>
Next, we prove a precursor to the commutative law of Conjunction, which will be very convenient until we get Peano's transportation principle. We call this theorem ''Comm'' in accordance with Whitehead and Russell.
<jh>
thm (Comm () () ((p → (q → r)) → (q → (p → r))) ( # *2.04
        (¬ p) (¬ q) r Assoc
))

thm (applyComm () ((H (p → (q → r)))) (q → (p → r)) (
        H
        p q r Comm
        applyModusPonens
))
</jh>
This theorem enables us to prove ''Syllogism'' from the ''Sum'' axiom:
<jh>
thm (*2.05 () () ((q → r) → ((p → q) → (p → r))) (
        q r (¬ p) Sum
))

thm (Syllogism () () ((p → q) → ((q → r) → (p → r))) ( # *2.06
        q r p *2.05
        (q → r) (p → q) (p → r) Comm
        applyModusPonens
))

thm (applySyllogism () ((H1 (p → q)) (H2 (q → r))) (p → r) (
        H2
        H1
        p q r Syllogism
        applyModusPonens
        applyModusPonens
))
</jh>
The syllogism yields the "identity" ''Id'', <math>p\rightarrow p</math>, and, by ''Perm'', [[w:tertium non datur|tertium non datur]], which is, by our definition, just <math>\top</math>:
<jh>
thm (Id () () (p → p) ( # *2.08
        p p Add
        p Taut
        applySyllogism
))

thm (TertiumNonDatur () () (p ∨ (¬ p)) ( # *2.11
        p Id
        swapDisjunction        
))

thm (True () () (⊤) (
        p TertiumNonDatur
))
</jh>
Actually, for Whitehead and Russell use the permutation of our ''TertiumNonDatur'' as theirs.

With the ''TertiumNonDatur'', we can tackle double negation:
<jh>
thm (*2.12 () () (p → (¬ (¬ p))) (
        (¬ p) TertiumNonDatur
))

thm (*2.13 () () (p ∨ (¬ (¬ (¬ p)))) (
        p TertiumNonDatur
        (¬ p) *2.12
        (¬ p) (¬ (¬ (¬ p))) p Sum
        applyModusPonens
        applyModusPonens
))

thm (*2.14 () () ((¬ (¬ p)) → p) (
        p *2.13
        swapDisjunction
))

thm (eliminateDoubleNegation () ((H (¬ (¬ p)))) p (
        H
        p *2.14
        applyModusPonens
))
</jh>
Combined with double negation, the transposition law <math>*2.03</math> we already have yields the remaining three:
<jh>
thm (*2.15 () () (((¬ p) → q) → ((¬ q) → p)) (
        q *2.12
        q (¬ (¬ q)) (¬ p) *2.05
        applyModusPonens
</jh>
We now have <math>((\neg p)\rightarrow q)\rightarrow((\neg p)\rightarrow(\neg(\neg q)))</math>. We transpose the consequent using our transposition law <math>*2.03</math>
<jh>
        (¬ p) (¬ q) *2.03
        applySyllogism
</jh>
to get <math>((\neg p)\rightarrow q)\rightarrow((\neg q)\rightarrow(\neg(\neg p)))</math>. All that remains to do now is to eliminate the double negation.
<jh>
        p *2.14
        (¬ (¬ p)) p (¬ q) *2.05
        applyModusPonens
        applySyllogism
))

thm (transposeWithNegatedAntecedent () ((H ((¬ p) → q))) ((¬ q) → p) (
        H
        p q *2.15
        applyModusPonens
))
</jh>
The proofs of the next two theorems work similar but are actually easier due to a more favourable distribution of negations:
<jh>
thm (*2.16 () () ((p → q) → ((¬ q) → (¬ p))) (
        q *2.12
        q (¬ (¬ q)) p *2.05
        applyModusPonens
        p (¬ q) *2.03
        applySyllogism
))

thm (introduceTransposition () ((H (p → q))) ((¬ q) → (¬ p)) (
        H
        p q *2.16
        applyModusPonens
))

thm (*2.17 () () (((¬ q) → (¬ p)) → (p → q)) (
        (¬ q) p *2.03
        q *2.14
        (¬ (¬ q)) q p *2.05
        applyModusPonens
        applySyllogism
))

thm (eliminateTransposition () ((H ((¬ q) → (¬ p)))) (p → q) (
        H
        q p *2.17
        applyModusPonens
))
</jh>
Next, we prove the disjunction introduction laws. Introduction from the left is just the ''Add'' axiom of principia, and a permutation yields the introduction from the right.
<jh>
thm (DisjuctionIntroductionLeft () () (p → (q ∨ p)) (
        p q Add
))

thm (introduceLeftDisjunction () ((H p)) (q ∨ p) (
        H
        p q DisjuctionIntroductionLeft
        applyModusPonens
))

thm (DisjuctionIntroductionRight () () (p → (p ∨ q)) ( # *2.2
        p q DisjuctionIntroductionLeft
        q p Perm
        applySyllogism
))

thm (introduceRightDisjunction () ((H p)) (p ∨ q) (
        H
        p q DisjuctionIntroductionRight
        applyModusPonens
))
</jh>
Next, we prove the modus ponens law with ''Assoc'':
<jh>
thm (*2.25 () () (p ∨ ((p ∨ q) → q)) (
        (p ∨ q) Id
        (¬ (p ∨ q)) p q Assoc
        applyModusPonens
))

thm (ModusPonens () () (p → ((p → q) → q)) ( # *2.27
        (¬ p) q *2.25
))
</jh>
We now "repair" the extra twist in the ''Assoc'' axiom to get the actual associativity rules for disjunction:
<jh>
thm (*2.3 () () ((p ∨ (q ∨ r)) → (p ∨ (r ∨ q))) (
        q r Perm
        (q ∨ r) (r ∨ q) p Sum
        applyModusPonens
))

thm (*2.31 () () ((p ∨ (q ∨ r)) → ((p ∨ q) ∨ r)) (
        p q r *2.3
        p r q Assoc
        applySyllogism
        r (p ∨ q) Perm
        applySyllogism
))

thm (groupDisjunctionLeft () ((H (p ∨ (q ∨ r)))) ((p ∨ q) ∨ r) (
        H
        p q r *2.31
        applyModusPonens
))

thm (*2.32 () () (((p ∨ q) ∨ r) → (p ∨ (q ∨ r))) (
        (p ∨ q) r Perm
        r p q Assoc
        applySyllogism
        p r q *2.3
        applySyllogism
))

thm (groupDisjunctionRight () ((H ((p ∨ q) ∨ r))) (p ∨ (q ∨ r)) (
        H
        p q r *2.32
        applyModusPonens
))
</jh>
Now we prove three helpful theorems regarding expression building with disjunctions, that is, they are companions to the ''Sum'' axiom. All these proofs proceed in two steps, using a syllogism to alter the consequent of ''Sum''.
<jh>
thm (*2.36 () () ((q → r) → ((p ∨ q) → (r ∨ p))) (
</jh>
As first step, we simply take the ''Sum'' axiom,
<jh>
        q r p Sum
</jh>
and prove <math>((p\vee q)\rightarrow(p\vee r))\rightarrow((p\vee q)\rightarrow(r\vee p))</math> as second step,
<jh>
        p r Perm
        (p ∨ r) (r ∨ p) (p ∨ q) *2.05
        applyModusPonens
</jh>
so that the result follows via a syllogism:
<jh>
        applySyllogism
))

thm (*2.37 () () ((q → r) → ((q ∨ p) → (p ∨ r))) (
</jh>
As first step, we take the ''Sum'' axiom with transposed consequent, that is <math>(q\rightarrow r)\rightarrow((\neg(p\vee r))\rightarrow(\neg(p\vee q)))</math>,
<jh>
        q r p Sum
        (p ∨ q) (p ∨ r) *2.16
        applySyllogism
</jh>
As second step, we prove <math>((\neg(p\vee r))\rightarrow(\neg(p\vee q)))\rightarrow((\neg(p\vee r))\rightarrow(\neg(q\vee p)))</math>
<jh>
        q p Perm
        introduceTransposition
        (¬ (p ∨ q)) (¬ (q ∨ p)) (¬ (p ∨ r)) *2.05
        applyModusPonens
</jh>
Combining these two steps, the result follows by transposing the consequent back.
<jh>
        applySyllogism
        (p ∨ r) (q ∨ p) *2.17
        applySyllogism
))
</jh>
Finally, <math>*2.38</math> follows directly from <math>*2.37</math> in the same way.
<jh>
thm (*2.38 () () ((q → r) → ((q ∨ p) → (r ∨ p))) (
        q r p *2.37
        p r Perm
        (p ∨ r) (r ∨ p) (q ∨ p) *2.05
        applyModusPonens
        applySyllogism
))
</jh>
Our next goal will be to prove the ''if'' part of the implication distribution theorem, <math>(p\rightarrow(q\rightarrow r))\leftrightarrow((p\rightarrow q)\rightarrow(p\rightarrow r))</math>. Given that implication is defined from disjunction and negation in Principia, it would seem more natural to use [[w:de Morgan's law|de Morgan's law]] for disjunction negation for that. However, we don't have that yet, and in fact, implication distribution is instrumental to prove the "principle of the factor" ''Fact'' below, which in turn is required for de Morgan's law. So what we shall do instead is to install equivalences such as <math>p\leftrightarrow(\neg(\neg p))</math>, <math>p\leftrightarrow p\vee p</math> and <math>p\vee q\leftrightarrow q\vee p</math> in more or less deep subexpression in a long chain of theorems until we finally arrive at the desired result. <jh>
thm (*2.53 () () ((p ∨ q) → ((¬ p) → q)) (
</jh>
That is, we make <math>(p\vee q)\rightarrow((\neg(\neg p))\vee q)</math> from <math>p\rightarrow(\neg(\neg q))</math>.
<jh>
        p *2.12
        p (¬ (¬ p)) q *2.38
        applyModusPonens
))

thm (*2.6 () () (((¬ p) → q) → ((p → q) → q)) (
        (¬ p) q q *2.38
</jh>
This gives us already the result, except that the last <math>q</math> has been duplicated, <math>q\vee q</math>. We remove the duplicate using the ''Taut'' axiom.
<jh>
        q Taut
        (q ∨ q) q (¬ ((¬ p) ∨ q)) Sum
        applyModusPonens
        applySyllogism
))

thm (*2.62 () () ((p ∨ q) → ((p → q) → q)) (
        p q *2.53
        p q *2.6
        applySyllogism
))

thm (*2.621 () () ((p → q) → ((p ∨ q) → q)) (
        p q *2.62
        applyComm
))

thm (*2.73 () () ((p → q) → (((p ∨ q) ∨ r) → (q ∨ r))) (
        p q *2.621
        (p ∨ q) q r *2.38
        applySyllogism
))

thm (*2.74 () () ((q → p) → (((p ∨ q) ∨ r) → (p ∨ r))) (
</jh>
This is the same as <math>*2.73</math> except for a permutation in the second antecedent. Since this permutation is nested four levels deep, some work is required. We begin with <math>*2.73</math>,
<jh>
        q p r *2.73
</jh>
and prove the permutation <math>((p\vee q)\vee r)\rightarrow((q\vee p)\vee r)</math>:
<jh>
        p q r *2.32
        p q r Assoc
        applySyllogism
        q p r *2.31
        applySyllogism
</jh>
We can now install this permutation as an antecedent through a transposition. Then the theorem follows through a syllogism.
<jh>
        introduceTransposition
        (¬ ((q ∨ p) ∨ r)) (¬ ((p ∨ q) ∨ r)) (p ∨ r) *2.38
        applyModusPonens
        applySyllogism
))

thm (*2.75 () () ((p ∨ q) → ((p ∨ (q → r)) → (p ∨ r))) (
</jh>
This is <math>*2.74</math>, with <math>q</math> replaced with <math>\neg q</math>, plus some of the usual transformations.
<jh>
        p q Perm
        q p *2.53
        applySyllogism
</jh>
This gives us <math>(p\vee q)\rightarrow((\neg q)\rightarrow p)</math>, which we can connect with <math>*2.74</math>,
<jh>
        (¬ q) p r *2.74
        applySyllogism
</jh>
so we get <math>(p\vee q)\rightarrow(((p\vee(\neg q))\vee r)\rightarrow(p\vee r))</math>. The rest of the proof is now to effect the disjunctive associativity law in the second antecedent.
<jh>
        p (¬ q) r *2.31
        introduceTransposition
        (¬ ((p ∨ (¬ q)) ∨ r)) (¬ (p ∨ ((¬ q) ∨ r))) (p ∨ r) *2.38
        applyModusPonens
        applySyllogism
))

thm (*2.76 () () ((p ∨ (q → r)) → ((p ∨ q) → (p ∨ r))) (
        p q r *2.75
        applyComm
))

thm (*2.77 () () ((p → (q → r)) → ((p → q) → (p → r))) (
        (¬ p) q r *2.76
))

thm (distributeAntecedent () ((H (p → (q → r)))) ((p → q) → (p → r)) (
        H
        p q r *2.77
        applyModusPonens
))
</jh>
Theorem <math>*2.77</math> is now precisely the ''if'' part of the implicational distribution law.

Finally, we prove a "syllogism in the consequent law", that is, <math>(p\rightarrow(q\rightarrow r))\rightarrow((p\rightarrow(r\rightarrow s))\rightarrow(p\rightarrow(q\rightarrow s)))</math>, which is useful for syllogisms depending on a common hypothesis. We first show a modus ponens law for disjunctions.
<jh>
thm (*2.8 () () ((q ∨ r) → ((r → s) → (q ∨ s))) (
        q r Perm
        r q *2.53
        applySyllogism
</jh>
This gives us <math>(q\vee r)\rightarrow((\neg r)\rightarrow q)</math>. The theorem follows now by a summation:
<jh>
        (¬ r) q s *2.38
        applySyllogism
))
</jh>
Next, we prove a three terms summation law:
<jh>
thm (*2.81 () () ((q → (r → s)) → ((p ∨ q) → ((p ∨ r) → (p ∨ s)))) (
        q (r → s) p Sum
</jh>
This gives us <math>(q\rightarrow(r\rightarrow s))\rightarrow((p\vee q)\rightarrow(p\vee(r\rightarrow s)))</math>, so we only need to distribute the <math>p</math> over <math>r\rightarrow s</math>:
<jh>
        p r s *2.76
        (p ∨ q) introduceAntecedent
        distributeAntecedent
        applySyllogism
))
</jh>
Combining <math>*2.8</math> and <math>*2.81</math>, we get
<jh>
thm (*2.82 () () ((p ∨ (q ∨ r)) → ((p ∨ (r → s)) → (p ∨ (q ∨ s)))) (
        q r s *2.8
        (q ∨ r) (r → s) (q ∨ s) p *2.81
        applyModusPonens
))
</jh>
from which we can immediately derive our new syllogism law:
<jh>
thm (*2.83 () () ((p → (q → r)) → ((p → (r → s)) → (p → (q → s)))) (
        (¬ p) (¬ q) r s *2.82
))

thm (applySyllogismInConsequent () ((H1 (p → (q → r))) (H2 (p → (r → s)))) (p → (q → s)) (
        H2
        H1
        p q r s *2.83
        applyModusPonens
        applyModusPonens
))
</jh>

== Conjunction ==

In this section we prove statements involving conjunction <math>p\wedge q</math>. Recall that conjunction is defined by <math>\neg((\neg p)\vee(\neg q))</math>. Our first theorem is the rule that two true statements can be combined to a conjunction.
<jh>
thm (combineStatements () ((H1 p) (H2 q)) (p ∧ q) ( # *3.03
        H2
        H1
        ((¬ p) ∨ (¬ q)) TertiumNonDatur
</jh>
The trick is now to write <math>(\neg p)\vee(\neg q)\vee\ldots</math> as <math>p\rightarrow(q\rightarrow\ldots)</math>:
<jh>
        groupDisjunctionRight
        applyModusPonens
        applyModusPonens
))
</jh>
We can prove the commutative law for conjunction from ''Perm'' using transpositions:
<jh>
thm (*3.22 () () ((p ∧ q) → (q ∧ p)) (
        (q ∧ p) Id
        eliminateTransposition
        (¬ q) (¬ p) Perm
        applySyllogism
        introduceTransposition
))

thm (swapConjunction () ((H (p ∧ q))) (q ∧ p) (
        H
        p q *3.22
        applyModusPonens
))
</jh>
Next, we prove the negation of <math>\bot</math>:
<jh>
thm (*3.24 () () (¬ (p ∧ (¬ p))) (
        (¬ p) TertiumNonDatur
        ((¬ p) ∨ (¬ (¬ p))) *2.12
        applyModusPonens
))

thm (NotFalse () () (¬ (⊥)) (
        p *3.24
))
</jh>
Next, we prove the conjunction elimination theorems.
<jh>
thm (ConjunctionEliminationRight () () ((p ∧ q) → p) ( # *3.26
        p q AntecedentIntroduction
        groupDisjunctionLeft
</jh>
This gives us <math>((\neg p)\vee(\neg q))\vee p</math>. All we need now is a double negation of the left bracket.
<jh>
        ((¬ p) ∨ (¬ q)) p *2.53
        applyModusPonens
))

thm (eliminateRightConjunction () ((H (p ∧ q))) p (
        H
        p q ConjunctionEliminationRight
        applyModusPonens
))

thm (ConjunctionEliminationLeft () () ((p ∧ q) → q) ( # *3.27
        p q *3.22
        q p ConjunctionEliminationRight
        applySyllogism
))

thm (eliminateLeftConjunction () ((H (p ∧ q))) q (
        H
        p q ConjunctionEliminationLeft
        applyModusPonens
))
</jh>
We now prove Peano's import and export principles. We begin with exportation:
<jh>
thm (*3.3 () () (((p ∧ q) → r) → (p → (q → r))) (
</jh>
To shift the bracket right, we combine transposition and the ''Comm'' axiom to get <math>((p\wedge q)\rightarrow r)\rightarrow(p\rightarrow((\neg r)\rightarrow(\neg q)))</math>:
<jh>
        ((¬ p) ∨ (¬ q)) r *2.15
        (¬ r) p (¬ q) Comm
        applySyllogism
</jh>
What remains to do now is to install a transposition of <math>r</math> with <math>q</math>:
<jh>
        r q *2.17
        p introduceAntecedent distributeAntecedent
        applySyllogism
))

thm (export () ((H ((p ∧ q) → r))) (p → (q → r)) (
        H
        p q r *3.3
        applyModusPonens
))
</jh>
Importation is simpler as the conjunction is in the consequent this time:
<jh>
thm (*3.31 () () ((p → (q → r)) → ((p ∧ q) → r)) (
        (¬ p) (¬ q) r *2.31
        ((¬ p) ∨ (¬ q)) r *2.53
        applySyllogism
))

thm (import () ((H (p → (q → r)))) ((p ∧ q) → r) (
        H
        p q r *3.31
        applyModusPonens
))
</jh>

== Biconditional ==

In Principia, the biconditional <math>p\leftrightarrow q</math> is defined simply as <math>(p\rightarrow q)\wedge(q\rightarrow p)</math>, so our combination and elimination theorems for conjunction immediately yield the corresponding introduction and elimination rules for the biconditional.
<jh>
thm (introduceBiconditional () ((H1 (p → q)) (H2 (q → p))) (p ↔ q) (
        H1 H2 combineStatements
))

thm (eliminateBiconditionalLeft () ((H (p ↔ q))) (p → q) (
        H eliminateRightConjunction
))

thm (eliminateBiconditionalRight () ((H (p ↔ q))) (q → p) (
        H eliminateLeftConjunction
))
</jh>
Some more easy theorems:
<jh>
thm (DoubleNegation () () (p ↔ (¬ (¬ p))) ( # *4.13
        p *2.12
        p *2.14
        introduceBiconditional
))

thm (BiconditionalReflexivity () () (p ↔ p) ( # *4.2
        p Id
        p Id
        introduceBiconditional
))

thm (BiconditionalSymmetry () () ((p ↔ q) → (q ↔ p)) ( # *4.21
        (p → q) (q → p) *3.22
))

thm (swapBiconditional () ((H (p ↔ q))) (q ↔ p) (
        H
        p q BiconditionalSymmetry
        applyModusPonens
))

thm (buildNegation () ((H (p ↔ q))) ((¬ p) ↔ (¬ q)) (
        H eliminateBiconditionalRight
        introduceTransposition
        H eliminateBiconditionalLeft
        introduceTransposition
        combineStatements
))
</jh>
Since the definition of conjunction in Principia is based on [[w:De Morgan's laws|De Morgan's laws]], the laws themselves are not hard to prove.
<jh>
thm (ConjunctionNegation () () ((¬ (p ∧ q)) ↔ ((¬ p) ∨ (¬ q))) ( # *4.51
        ((¬ p) ∨ (¬ q)) DoubleNegation
        swapBiconditional
))
</jh>

:''This page is still incomplete''

== References ==

<references />

[[Category:Classical propositional logic]]