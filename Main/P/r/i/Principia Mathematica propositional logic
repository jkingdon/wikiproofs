{{header
 | title    = Principia Mathematica
 | subtitle = propositional logic
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = The purpose of this page is to prove the statements of [[Interface:Classical propositional calculus]] from the [[Interface:Principia Mathematica propositional logic|Principia Mathematica]]<ref>{{sc|A. Whitehead, B. Russell}}, Principia Mathematica, ''Cambridge University Press'', 1910.</ref> axioms for propositional logic.
}}
{{interfaces
| imports = [[Interface:Principia Mathematica propositional logic]]
| exports = [[Interface:Classical propositional calculus]]
}}

<jh>
import (PRINCIPIA Interface:Principia_Mathematica_propositional_logic () ())
</jh>
We define some variables for well-formed formulas:
<jh>
var (wff p q r s)
</jh>
Principia Mathematica does not define the [[w:nullary#Nullary|nullary]] [[w:logical connective|connectives]] "the true", <math>\top</math>, and "the false", <math>\bot</math>, so we define them here:
<jh>
def ((⊤) (p ∨ (¬ p)))
def ((⊥) (p ∧ (¬ p)))
</jh>
We shall now begin to derive the statements. Whitehead and Russell use a decimal numbering system of the form <math>*r</math>, where <math>r</math> is a rational number with a small number of digits after the decimal point. Unless we give theorems our own name, we shall adopt their system for easier reference. Where we do use our own names, we sometimes give the decimal reference in a JHilbert comment.

== Disjunction and implication ==

=== First steps ===

The [[w:modus ponens|modus ponens]] rule is an axiom of Principia Mathematica, so we don't need to prove it. The ''Perm'' axiom immediately gives rise to the [[w:logical disjunction|disjunctive]] commutativity rule:
<jh>
thm (swapDisjunction () ((H (p ∨ q))) (q ∨ p) (
        H
        p q Perm
        applyModusPonens
))
</jh>
Since Principia Mathematica defines implication, <math>p\rightarrow q</math>, as <math>(\neg p)\vee q</math>, the ''Add'' axiom yields the introduction of an antecedent (Whitehead and Russell call it "Simplification").
<jh>
thm (AntecedentIntroduction () () (p → (q → p)) ( # *2.02
        p (¬ q) Add
))
</jh>
It will be convenient to have this theorem as helper rule:
<jh>
thm (introduceAntecedent () ((H p)) (q → p) (
        H
        p q AntecedentIntroduction
        applyModusPonens
))
</jh>
Again due to the way implication is defined, ''Perm'' gives us our first transposition rule:
<jh>
thm (*2.03 () () ((p → (¬ q)) → (q → (¬ p))) (
        (¬ p) (¬ q) Perm
))

thm (transposeWithNegatedConsequent () ((H (p → (¬ q)))) (q → (¬ p)) (
        H
        p q *2.03
        applyModusPonens
))
</jh>
Next, we prove a precursor to the commutative law of Conjunction, which will be very convenient until we get Peano's transportation principle. We call this theorem ''Comm'' in accordance with Whitehead and Russell.
<jh>
thm (Comm () () ((p → (q → r)) → (q → (p → r))) ( # *2.04
        (¬ p) (¬ q) r Assoc
))

thm (applyComm () ((H (p → (q → r)))) (q → (p → r)) (
        H
        p q r Comm
        applyModusPonens
))
</jh>
This theorem enables us to prove ''Syllogism'' from the ''Sum'' axiom:
<jh>
thm (*2.05 () () ((q → r) → ((p → q) → (p → r))) (
        q r (¬ p) Sum
))

thm (Syllogism () () ((p → q) → ((q → r) → (p → r))) ( # *2.06
        q r p *2.05
        (q → r) (p → q) (p → r) Comm
        applyModusPonens
))

thm (applySyllogism () ((H1 (p → q)) (H2 (q → r))) (p → r) (
        H2
        H1
        p q r Syllogism
        applyModusPonens
        applyModusPonens
))
</jh>
The syllogism yields the "identity" ''Id'', <math>p\rightarrow p</math>, and, by ''Perm'', [[w:tertium non datur|tertium non datur]], which is, by our definition, just <math>\top</math>:
<jh>
thm (Id () () (p → p) ( # *2.08
        p p Add
        p Taut
        applySyllogism
))
# Another name for the same theorem:
thm (ImplicationReflexivity () () (p → p) (
        p Id
))

thm (TertiumNonDatur () () (p ∨ (¬ p)) ( # *2.11
        p Id
        swapDisjunction        
))

thm (True () () (⊤) (
        p TertiumNonDatur
))
</jh>
Actually, for Whitehead and Russell use the permutation of our ''TertiumNonDatur'' as theirs.

With the ''TertiumNonDatur'', we can tackle double negation:
<jh>
thm (*2.12 () () (p → (¬ (¬ p))) (
        (¬ p) TertiumNonDatur
))

thm (*2.13 () () (p ∨ (¬ (¬ (¬ p)))) (
        p TertiumNonDatur
        (¬ p) *2.12
        (¬ p) (¬ (¬ (¬ p))) p Sum
        applyModusPonens
        applyModusPonens
))

thm (*2.14 () () ((¬ (¬ p)) → p) (
        p *2.13
        swapDisjunction
))

thm (introduceDoubleNegation () ((H p)) (¬ (¬ p)) (
        H
        p *2.12
        applyModusPonens
))

thm (eliminateDoubleNegation () ((H (¬ (¬ p)))) p (
        H
        p *2.14
        applyModusPonens
))
</jh>

=== Transposition ===
Combined with double negation, the transposition law <math>*2.03</math> we already have yields the remaining three:
<jh>
thm (*2.15 () () (((¬ p) → q) → ((¬ q) → p)) (
        q *2.12
        q (¬ (¬ q)) (¬ p) *2.05
        applyModusPonens
</jh>
We now have <math>((\neg p)\rightarrow q)\rightarrow((\neg p)\rightarrow(\neg(\neg q)))</math>. We transpose the consequent using our transposition law <math>*2.03</math>
<jh>
        (¬ p) (¬ q) *2.03
        applySyllogism
</jh>
to get <math>((\neg p)\rightarrow q)\rightarrow((\neg q)\rightarrow(\neg(\neg p)))</math>. All that remains to do now is to eliminate the double negation.
<jh>
        p *2.14
        (¬ (¬ p)) p (¬ q) *2.05
        applyModusPonens
        applySyllogism
))

thm (transposeWithNegatedAntecedent () ((H ((¬ p) → q))) ((¬ q) → p) (
        H
        p q *2.15
        applyModusPonens
))
</jh>
The proofs of the next two theorems work similar but are actually easier due to a more favourable distribution of negations:
<jh>
thm (*2.16 () () ((p → q) → ((¬ q) → (¬ p))) (
        q *2.12
        q (¬ (¬ q)) p *2.05
        applyModusPonens
        p (¬ q) *2.03
        applySyllogism
))

thm (introduceTransposition () ((H (p → q))) ((¬ q) → (¬ p)) (
        H
        p q *2.16
        applyModusPonens
))

thm (*2.17 () () (((¬ q) → (¬ p)) → (p → q)) (
        (¬ q) p *2.03
        q *2.14
        (¬ (¬ q)) q p *2.05
        applyModusPonens
        applySyllogism
))

thm (eliminateTransposition () ((H ((¬ q) → (¬ p)))) (p → q) (
        H
        q p *2.17
        applyModusPonens
))
</jh>

=== Disjunction introduction ===
Next, we prove the disjunction introduction laws. Introduction from the left is just the ''Add'' axiom of principia, and a permutation yields the introduction from the right.
<jh>
thm (DisjunctionLeftIntroduction () () (p → (q ∨ p)) (
        p q Add
))

thm (introduceLeftDisjunction () ((H p)) (q ∨ p) (
        H
        p q DisjunctionLeftIntroduction
        applyModusPonens
))

thm (DisjunctionRightIntroduction () () (p → (p ∨ q)) ( # *2.2
        p q DisjunctionLeftIntroduction
        q p Perm
        applySyllogism
))

thm (introduceRightDisjunction () ((H p)) (p ∨ q) (
        H
        p q DisjunctionRightIntroduction
        applyModusPonens
))
</jh>

=== Modus ponens law ===
Next, we prove a version of the modus ponens law with ''Assoc'':
<jh>
thm (*2.25 () () (p ∨ ((p ∨ q) → q)) (
        (p ∨ q) Id
        (¬ (p ∨ q)) p q Assoc
        applyModusPonens
))

thm (*2.27 () () (p → ((p → q) → q)) (
        (¬ p) q *2.25
))
</jh>

=== Disjunction associativity ===
We now "repair" the extra twist in the ''Assoc'' axiom to get the actual associativity rules for disjunction:
<jh>
thm (*2.3 () () ((p ∨ (q ∨ r)) → (p ∨ (r ∨ q))) (
        q r Perm
        (q ∨ r) (r ∨ q) p Sum
        applyModusPonens
))

thm (*2.31 () () ((p ∨ (q ∨ r)) → ((p ∨ q) ∨ r)) (
        p q r *2.3
        p r q Assoc
        applySyllogism
        r (p ∨ q) Perm
        applySyllogism
))

thm (groupDisjunctionLeft () ((H (p ∨ (q ∨ r)))) ((p ∨ q) ∨ r) (
        H
        p q r *2.31
        applyModusPonens
))

thm (*2.32 () () (((p ∨ q) ∨ r) → (p ∨ (q ∨ r))) (
        (p ∨ q) r Perm
        r p q Assoc
        applySyllogism
        p r q *2.3
        applySyllogism
))

thm (groupDisjunctionRight () ((H ((p ∨ q) ∨ r))) (p ∨ (q ∨ r)) (
        H
        p q r *2.32
        applyModusPonens
))
</jh>

=== Expression building with disjunctions ===
Now we prove three helpful theorems regarding expression building with disjunctions, that is, they are companions to the ''Sum'' axiom. All these proofs proceed in two steps, using a syllogism to alter the consequent of ''Sum''.
<jh>
thm (*2.36 () () ((q → r) → ((p ∨ q) → (r ∨ p))) (
</jh>
As first step, we simply take the ''Sum'' axiom,
<jh>
        q r p Sum
</jh>
and prove <math>((p\vee q)\rightarrow(p\vee r))\rightarrow((p\vee q)\rightarrow(r\vee p))</math> as second step,
<jh>
        p r Perm
        (p ∨ r) (r ∨ p) (p ∨ q) *2.05
        applyModusPonens
</jh>
so that the result follows via a syllogism:
<jh>
        applySyllogism
))

thm (*2.37 () () ((q → r) → ((q ∨ p) → (p ∨ r))) (
</jh>
As first step, we take the ''Sum'' axiom with transposed consequent, that is <math>(q\rightarrow r)\rightarrow((\neg(p\vee r))\rightarrow(\neg(p\vee q)))</math>,
<jh>
        q r p Sum
        (p ∨ q) (p ∨ r) *2.16
        applySyllogism
</jh>
As second step, we prove <math>((\neg(p\vee r))\rightarrow(\neg(p\vee q)))\rightarrow((\neg(p\vee r))\rightarrow(\neg(q\vee p)))</math>
<jh>
        q p Perm
        introduceTransposition
        (¬ (p ∨ q)) (¬ (q ∨ p)) (¬ (p ∨ r)) *2.05
        applyModusPonens
</jh>
Combining these two steps, the result follows by transposing the consequent back.
<jh>
        applySyllogism
        (p ∨ r) (q ∨ p) *2.17
        applySyllogism
))
</jh>
Finally, <math>*2.38</math> follows directly from <math>*2.37</math> in the same way.
<jh>
thm (*2.38 () () ((q → r) → ((q ∨ p) → (r ∨ p))) (
        q r p *2.37
        p r Perm
        (p ∨ r) (r ∨ p) (q ∨ p) *2.05
        applyModusPonens
        applySyllogism
))
</jh>

=== Implication distribution theorem (if part) ===
Our next goal will be to prove the ''if'' part of the implication distribution theorem, <math>(p\rightarrow(q\rightarrow r))\leftrightarrow((p\rightarrow q)\rightarrow(p\rightarrow r))</math>. Given that implication is defined from disjunction and negation in Principia, it would seem more natural to use [[w:de Morgan's law|de Morgan's law]] for disjunction negation for that. However, we don't have that yet, and in fact, implication distribution is instrumental to prove the "principle of the factor" ''Fact'' below, which in turn is required for de Morgan's law. So what we shall do instead is to install equivalences such as <math>p\leftrightarrow(\neg(\neg p))</math>, <math>p\leftrightarrow p\vee p</math> and <math>p\vee q\leftrightarrow q\vee p</math> in more or less deep subexpression in a long chain of theorems until we finally arrive at the desired result. <jh>
thm (*2.53 () () ((p ∨ q) → ((¬ p) → q)) (
</jh>
That is, we make <math>(p\vee q)\rightarrow((\neg(\neg p))\vee q)</math> from <math>p\rightarrow(\neg(\neg q))</math>.
<jh>
        p *2.12
        p (¬ (¬ p)) q *2.38
        applyModusPonens
))

thm (*2.6 () () (((¬ p) → q) → ((p → q) → q)) (
        (¬ p) q q *2.38
</jh>
This gives us already the result, except that the last <math>q</math> has been duplicated, <math>q\vee q</math>. We remove the duplicate using the ''Taut'' axiom.
<jh>
        q Taut
        (q ∨ q) q (¬ ((¬ p) ∨ q)) Sum
        applyModusPonens
        applySyllogism
))

thm (*2.62 () () ((p ∨ q) → ((p → q) → q)) (
        p q *2.53
        p q *2.6
        applySyllogism
))

thm (*2.621 () () ((p → q) → ((p ∨ q) → q)) (
        p q *2.62
        applyComm
))

thm (*2.73 () () ((p → q) → (((p ∨ q) ∨ r) → (q ∨ r))) (
        p q *2.621
        (p ∨ q) q r *2.38
        applySyllogism
))

thm (*2.74 () () ((q → p) → (((p ∨ q) ∨ r) → (p ∨ r))) (
</jh>
This is the same as <math>*2.73</math> except for a permutation in the second antecedent. Since this permutation is nested four levels deep, some work is required. We begin with <math>*2.73</math>,
<jh>
        q p r *2.73
</jh>
and prove the permutation <math>((p\vee q)\vee r)\rightarrow((q\vee p)\vee r)</math>:
<jh>
        p q r *2.32
        p q r Assoc
        applySyllogism
        q p r *2.31
        applySyllogism
</jh>
We can now install this permutation as an antecedent through a transposition. Then the theorem follows through a syllogism.
<jh>
        introduceTransposition
        (¬ ((q ∨ p) ∨ r)) (¬ ((p ∨ q) ∨ r)) (p ∨ r) *2.38
        applyModusPonens
        applySyllogism
))

thm (*2.75 () () ((p ∨ q) → ((p ∨ (q → r)) → (p ∨ r))) (
</jh>
This is <math>*2.74</math>, with <math>q</math> replaced with <math>\neg q</math>, plus some of the usual transformations.
<jh>
        p q Perm
        q p *2.53
        applySyllogism
</jh>
This gives us <math>(p\vee q)\rightarrow((\neg q)\rightarrow p)</math>, which we can connect with <math>*2.74</math>,
<jh>
        (¬ q) p r *2.74
        applySyllogism
</jh>
so we get <math>(p\vee q)\rightarrow(((p\vee(\neg q))\vee r)\rightarrow(p\vee r))</math>. The rest of the proof is now to effect the disjunctive associativity law in the second antecedent.
<jh>
        p (¬ q) r *2.31
        introduceTransposition
        (¬ ((p ∨ (¬ q)) ∨ r)) (¬ (p ∨ ((¬ q) ∨ r))) (p ∨ r) *2.38
        applyModusPonens
        applySyllogism
))

thm (*2.76 () () ((p ∨ (q → r)) → ((p ∨ q) → (p ∨ r))) (
        p q r *2.75
        applyComm
))

thm (*2.77 () () ((p → (q → r)) → ((p → q) → (p → r))) (
        (¬ p) q r *2.76
))

thm (distributeAntecedent () ((H (p → (q → r)))) ((p → q) → (p → r)) (
        H
        p q r *2.77
        applyModusPonens
))
</jh>
Theorem <math>*2.77</math> is now precisely the ''if'' part of the implicational distribution law.

=== Syllogism in the consequent ===
We prove a "syllogism in the consequent law", that is, <math>(p\rightarrow(q\rightarrow r))\rightarrow((p\rightarrow(r\rightarrow s))\rightarrow(p\rightarrow(q\rightarrow s)))</math>, which is useful for syllogisms depending on a common hypothesis. We first show a modus ponens law for disjunctions.
<jh>
thm (*2.8 () () ((q ∨ r) → ((r → s) → (q ∨ s))) (
        q r Perm
        r q *2.53
        applySyllogism
</jh>
This gives us <math>(q\vee r)\rightarrow((\neg r)\rightarrow q)</math>. The theorem follows now by a summation:
<jh>
        (¬ r) q s *2.38
        applySyllogism
))
</jh>
Next, we prove a three terms summation law:
<jh>
thm (*2.81 () () ((q → (r → s)) → ((p ∨ q) → ((p ∨ r) → (p ∨ s)))) (
        q (r → s) p Sum
</jh>
This gives us <math>(q\rightarrow(r\rightarrow s))\rightarrow((p\vee q)\rightarrow(p\vee(r\rightarrow s)))</math>, so we only need to distribute the <math>p</math> over <math>r\rightarrow s</math>:
<jh>
        p r s *2.76
        (p ∨ q) introduceAntecedent
        distributeAntecedent
        applySyllogism
))
</jh>
Combining <math>*2.8</math> and <math>*2.81</math>, we get
<jh>
thm (*2.82 () () ((p ∨ (q ∨ r)) → ((p ∨ (r → s)) → (p ∨ (q ∨ s)))) (
        q r s *2.8
        (q ∨ r) (r → s) (q ∨ s) p *2.81
        applyModusPonens
))
</jh>
from which we can immediately derive our new syllogism law:
<jh>
thm (SyllogismInConsequent () () ((p → (q → r)) → ((p → (r → s)) → (p → (q → s)))) ( # *2.83
        (¬ p) (¬ q) r s *2.82
))

thm (applySyllogismInConsequent () ((H1 (p → (q → r))) (H2 (p → (r → s)))) (p → (q → s)) (
        H2
        H1
        p q r s SyllogismInConsequent
        applyModusPonens
        applyModusPonens
))
</jh>

=== Implication distribution theorem (only-if part) ===
Next we prove the ''only if'' part of the implicational distribution law (the ''if'' part of which we proved in *2.77). We start with a simple consequence of *2.53 and the converse of *2.53:

<jh>
thm (*2.55 () () ((¬ p) → ((p ∨ q) → q)) (
        p q *2.53
        applyComm
))

thm (*2.54 () () (((¬ p) → q) → (p ∨ q)) (
        p *2.14
        (¬ (¬ p)) p q *2.38
        applyModusPonens
))
</jh>

The meat of our desired result is <code>((p ∨ q) → (p ∨ r)) → (p ∨ (q → r))</code> (*2.85). It differs only by being partly expressed in terms of disjunction instead of implication.  Each of the following thm's is just an intermediate step in proving *2.85:

<jh>
thm (*2.85-1 () () (((p ∨ q) → r) → (q → r)) (
        q p Add
        q (p ∨ q) r Syllogism
        applyModusPonens
))

thm (*2.85-unnamed1 () () ((¬ p) → (((p ∨ q) → (p ∨ r)) → ((p ∨ q) → r))) (
        p r *2.55
        (p ∨ r) r (p ∨ q) *2.05
        applySyllogism
))

thm (*2.85-2 () () ((¬ p) → (((p ∨ q) → (p ∨ r)) → (q → r))) (
        p q r *2.85-unnamed1

        p q r *2.85-1
        (¬ p) introduceAntecedent

        applySyllogismInConsequent
))

thm (*2.85-unnamed2 () () (((p ∨ q) → (p ∨ r)) → ((¬ p) → (q → r))) (
        p q r *2.85-2
        applyComm
))

thm (*2.85 () () (((p ∨ q) → (p ∨ r)) → (p ∨ (q → r))) (
        p q r *2.85-unnamed2
        p (q → r) *2.54
        applySyllogism
))
</jh>

From this follows the ''only if'' part of the implicational distribution law:
<jh>
thm (*2.86 () () (((p → q) → (p → r)) → (p → (q → r))) (
        (¬ p) q r *2.85
))

thm (collectAntecedent () ((H ((p → q) → (p → r)))) (p → (q → r)) (
        H
        p q r *2.86
        applyModusPonens
))
</jh>

== Conjunction ==

In this section we prove statements involving conjunction <math>p\wedge q</math>. Recall that conjunction is defined by <math>\neg((\neg p)\vee(\neg q))</math>. Our first theorem is the combination of two statements to a conjunction.
<jh>
thm (*3.2 () () (p → (q → (p ∧ q))) (
        ((¬ p) ∨ (¬ q)) TertiumNonDatur
</jh>
The trick is now to write <math>(\neg p)\vee(\neg q)\vee\ldots</math> as <math>p\rightarrow(q\rightarrow\ldots)</math>:
<jh>
        groupDisjunctionRight
))

thm (introduceConjunction () ((H1 p) (H2 q)) (p ∧ q) ( # *3.03
        H2
        H1
        p q *3.2
        applyModusPonens
        applyModusPonens
))
</jh>
We can prove the commutative law for conjunction from ''Perm'' using transpositions:
<jh>
thm (*3.22 () () ((p ∧ q) → (q ∧ p)) (
        (q ∧ p) Id
        eliminateTransposition
        (¬ q) (¬ p) Perm
        applySyllogism
        introduceTransposition
))

thm (swapConjunction () ((H (p ∧ q))) (q ∧ p) (
        H
        p q *3.22
        applyModusPonens
))
</jh>
Next, we prove the negation of <math>\bot</math>:
<jh>
thm (*3.24 () () (¬ (p ∧ (¬ p))) (
        (¬ p) TertiumNonDatur
        ((¬ p) ∨ (¬ (¬ p))) *2.12
        applyModusPonens
))

thm (NotFalse () () (¬ (⊥)) (
        p *3.24
))
</jh>

=== Conjunction introduction ===
We provide an additional name for *3.2 and a commuted version.

<jh>
thm (ConjunctionRightIntroduction () () (p → (q → (p ∧ q))) (
        p q *3.2
))

thm (ConjunctionLeftIntroduction () () (p → (q → (q ∧ p))) (
        q p ConjunctionRightIntroduction
        applyComm
))
</jh>

=== Conjunction elimination ===
Next, we prove the conjunction elimination theorems.
<jh>
thm (ConjunctionRightElimination () () ((p ∧ q) → p) ( # *3.26
        p q AntecedentIntroduction
        groupDisjunctionLeft
</jh>
This gives us <math>((\neg p)\vee(\neg q))\vee p</math>. All we need now is a double negation of the left bracket.
<jh>
        ((¬ p) ∨ (¬ q)) p *2.53
        applyModusPonens
))

thm (eliminateRightConjunction () ((H (p ∧ q))) p (
        H
        p q ConjunctionRightElimination
        applyModusPonens
))

thm (ConjunctionLeftElimination () () ((p ∧ q) → q) ( # *3.27
        p q *3.22
        q p ConjunctionRightElimination
        applySyllogism
))

thm (eliminateLeftConjunction () ((H (p ∧ q))) q (
        H
        p q ConjunctionLeftElimination
        applyModusPonens
))
</jh>

=== Import and export ===
We now prove Peano's import and export principles. We begin with exportation:
<jh>
thm (Exportation () () (((p ∧ q) → r) → (p → (q → r))) ( # *3.3
</jh>
To shift the bracket right, we combine transposition and the ''Comm'' axiom to get <math>((p\wedge q)\rightarrow r)\rightarrow(p\rightarrow((\neg r)\rightarrow(\neg q)))</math>:
<jh>
        ((¬ p) ∨ (¬ q)) r *2.15
        (¬ r) p (¬ q) Comm
        applySyllogism
</jh>
What remains to do now is to install a transposition of <math>r</math> with <math>q</math>:
<jh>
        r q *2.17
        p introduceAntecedent distributeAntecedent
        applySyllogism
))

thm (export () ((H ((p ∧ q) → r))) (p → (q → r)) (
        H
        p q r Exportation
        applyModusPonens
))
</jh>
Importation is simpler as the conjunction is in the consequent this time:
<jh>
thm (Importation () () ((p → (q → r)) → ((p ∧ q) → r)) ( # *3.31
        (¬ p) (¬ q) r *2.31
        ((¬ p) ∨ (¬ q)) r *2.53
        applySyllogism
))

thm (import () ((H (p → (q → r)))) ((p ∧ q) → r) (
        H
        p q r Importation
        applyModusPonens
))
</jh>
We can use importation to prove syllogisms in conjunction form:
<jh>
thm (ImplicationTransitivity () () (((p → q) ∧ (q → r)) → (p → r)) ( # *3.33
        p q r Syllogism
        import
))

thm (*3.34 () () (((q → r) ∧ (p → q)) → (p → r)) (
       q r p *2.05
       import
))
</jh>

Import and export also give us another transposition theorem, *3.37 (which we prove in several steps):
<jh>
thm (*3.37-1 () () ((p → (q → r)) → (p → ((¬ r) → (¬ q)))) (
        q r *2.16
        (q → r) ((¬ r) → (¬ q)) p *2.05
        applyModusPonens
))

thm (*3.37 () () (((p ∧ q) → r) → ((p ∧ (¬ r)) → (¬ q))) (
        p q r Exportation
        p q r *3.37-1
        applySyllogism

        p (¬ r) (¬ q) Importation
        applySyllogism
))
</jh>

=== Composition ===
Next, we prove ''Comp'', the principle of composition,
<jh>
thm (Comp () () (((p → q) ∧ (p → r)) → (p → (q ∧ r))) ( # *3.43
        q r *3.2
        q (r → (q ∧ r)) p *2.05
        applyModusPonens
        p r (q ∧ r) *2.77
        applySyllogism
        import
))

thm (composeConjunction () ((H1 (p → q)) (H2 (p → r))) (p → (q ∧ r)) (
        H1 H2 introduceConjunction
        p q r Comp
        applyModusPonens
))
</jh>

=== Disjunction composition ===
Conjunction composition has an analogue for disjunction (*3.44), which we prove in several steps:

<jh>
thm (*3.44-1 () () ((((¬ q) → r) ∧ (r → p)) → ((q → p) → p)) (
        (¬ q) r p ImplicationTransitivity
        q p *2.6
        applySyllogism
))

thm (*3.44-2 () () (((¬ q) → r) → (((q → p) ∧ (r → p)) → p)) (
        q r p *3.44-1
        export

        (r → p) (q → p) p Comm
        applySyllogism

        (q → p) (r → p) p Importation
        applySyllogism
))

thm (*3.44 () () (((q → p) ∧ (r → p)) → ((q ∨ r) → p)) (
        q r p *3.44-2

        applyComm

        q r *2.53
        (q ∨ r) ((¬ q) → r) p Syllogism
        applyModusPonens

        applySyllogism
))

thm (composeDisjunction () ((HQP (q → p)) (HRP (r → p)))
  ((q ∨ r) → p) (
        HQP HRP introduceConjunction
        q p r *3.44
        applyModusPonens
))
</jh>

=== Principle of the factor ===
Finally, we prove Peano's principle of the factor, called ''Fact'' by Whitehead and Russell. It complements the ''Sum'' axiom and its companion theorems. Two consequences are partial builder theorems for conjunction and disjunction.
<jh>
thm (Fact () () ((p → q) → ((p ∧ r) → (q ∧ r))) ( # *3.45
        p q (¬ r) Syllogism
        (q → (¬ r)) (p → (¬ r)) *2.16
        applySyllogism
))

thm (ConjunctionMultiplication () () (((p → r) ∧ (q → s)) → ((p ∧ q) → (r ∧ s))) ( # *3.47
</jh>
We prove this theorem in two steps. First we use the left hand side of the antecedent to deduce <math>((p\rightarrow r)\wedge(q\rightarrow s))\rightarrow((p\wedge q)\rightarrow(q\wedge r))</math>:
<jh>
        (p → r) (q → s) ConjunctionRightElimination
        p r q Fact
        applySyllogism
        r q *3.22
        (p ∧ q) introduceAntecedent distributeAntecedent
        applySyllogism
</jh>
Now we do the same with the right hand side of the antecedent to get <math>((p\rightarrow r)\wedge(q\rightarrow s))\rightarrow((q\wedge r)\rightarrow(r\wedge s))</math>. The theorem then follows from a syllogism in the consequent.
<jh>
        (p → r) (q → s) ConjunctionLeftElimination
        q s r Fact
        applySyllogism
        s r *3.22
        (q ∧ r) introduceAntecedent distributeAntecedent
        applySyllogism
        applySyllogismInConsequent
))

thm (conjoin () ((H1 (p → r)) (H2 (q → s))) ((p ∧ q) → (r ∧ s)) (
        H1 H2 introduceConjunction
        p r q s ConjunctionMultiplication
        applyModusPonens
))

thm (DisjunctionSummation () () (((p → r) ∧ (q → s)) → ((p ∨ q) → (r ∨ s))) ( # *3.48
</jh>
This theorem follows exactly as <math>ConjunctionMultiplication</math>, except that we use the ''Sum'' type theorem <math>*2.37</math> instead of ''Fact'' and <math>*3.22</math>.
<jh>
        (p → r) (q → s) ConjunctionRightElimination
        p r q *2.37
        applySyllogism
        (p → r) (q → s) ConjunctionLeftElimination
        q s r *2.37
        applySyllogism
        applySyllogismInConsequent
))

thm (disjoin () ((H1 (p → r)) (H2 (q → s))) ((p ∨ q) → (r ∨ s)) (
        H1 H2 introduceConjunction
        p r q s DisjunctionSummation
        applyModusPonens
))
</jh>

== Biconditional ==

In Principia, the biconditional <math>p\leftrightarrow q</math> is defined simply as <math>(p\rightarrow q)\wedge(q\rightarrow p)</math>, so our combination and elimination theorems for conjunction immediately yield the corresponding introduction and elimination rules for the biconditional.
<jh>
thm (introduceBiconditional () ((H1 (p → q)) (H2 (q → p))) (p ↔ q) (
        H1 H2 introduceConjunction
))

thm (eliminateBiconditionalLeft () ((H (p ↔ q))) (p → q) (
        H eliminateRightConjunction
))

thm (eliminateBiconditionalRight () ((H (p ↔ q))) (q → p) (
        H eliminateLeftConjunction
))
</jh>

=== Negation ===
In order to prove the negation function theorem <math>(p\leftrightarrow q)\leftrightarrow((\neg p)\leftrightarrow(\neg q))</math>, we combine the two transposition laws <math>*2.16</math> and <math>*2.17</math>:
<jh>
thm (NegationFunction () () ((p ↔ q) ↔ ((¬ p) ↔ (¬ q))) ( # *4.11
        p q *2.16
        q p *2.16
        conjoin
</jh>
This gives us <math>(p\leftrightarrow q)\rightarrow((\neg q)\leftrightarrow(\neg p))</math>, the right hand side of which must be permuted:
<jh>
        ((¬ q) → (¬ p)) ((¬ p) → (¬ q)) *3.22
        applySyllogism
</jh>
Now the same again for <math>*2.17</math>:
<jh>
        p q *2.17
        q p *2.17
        conjoin
        (q → p) (p → q) *3.22
        applySyllogism
        introduceBiconditional
))

thm (addNegation () ((H (p ↔ q))) ((¬ p) ↔ (¬ q)) (
        H
        p q NegationFunction
        eliminateBiconditionalLeft
        applyModusPonens
))
</jh>

=== Biconditionalized transposition laws ===
We proved various transposition laws for the conditional earlier. Now we provide some for the biconditional, starting with (p ↔ (¬ q)) ↔ (q ↔ (¬ p)).  The proof is a straightforward application of the conditional transposition laws, but has to prove each direction of the biconditionals.
<jh>
thm (*4.12-forward () () ((p ↔ (¬ q)) → (q → (¬ p))) (
        (p → (¬ q)) ((¬ q) → p) ConjunctionRightElimination
        p q *2.03 applySyllogism
))

thm (*4.12-reverse () () ((p ↔ (¬ q)) → ((¬ p) → q)) (
        (p → (¬ q)) ((¬ q) → p) ConjunctionLeftElimination
        q p *2.15 applySyllogism
))

thm (*4.12 () () ((p ↔ (¬ q)) ↔ (q ↔ (¬ p))) (
        p q *4.12-forward
        p q *4.12-reverse
        composeConjunction

        q p *4.12-forward
        q p *4.12-reverse
        composeConjunction

        introduceBiconditional
))
</jh>

=== Double negation ===
<jh>
thm (DoubleNegation () () (p ↔ (¬ (¬ p))) ( # *4.13
        p *2.12
        p *2.14
        introduceBiconditional
))
</jh>

=== Some more deduction tools ===
The next two theorems, *4.14 and *4.15, enable making some deductions involving biconditionals and conjunctions. They are similar to *3.37 but extend it.

The idea behind the proof of converse-of-*3.37 is quite simple: *3.37 becomes its own converse (modulo some double negation) when substituted with some negated terms.  The rest of the proof is just getting rid of the double negation.
<jh>
thm (converse-of-*3.37 () () (((p ∧ (¬ r)) → (¬ q)) → ((p ∧ q) → r)) (
        p (¬ r) (¬ q) *3.37
        # (((p ∧ (¬ r)) → (¬ q)) → ((p ∧ (¬ (¬ q))) → (¬ (¬ r))))

        p (¬ (¬ q)) (¬ (¬ r)) Exportation
        # ((p ∧ (¬ (¬ q))) → (¬ (¬ r)))) → (p → ((¬ (¬ q)) → (¬ (¬ r))))

        (¬ q) (¬ r) *2.17
        r q *2.17
        applySyllogism
        # ((¬ (¬ q)) → (¬ (¬ r))) → (q → r)

        ((¬ (¬ q)) → (¬ (¬ r))) (q → r) p *2.05
        applyModusPonens
        # (p → ((¬ (¬ q)) → (¬ (¬ r)))) → (p → (q → r))

        applySyllogism

        p q r Importation
        applySyllogism

        applySyllogism
))

thm (*4.14 () () (((p ∧ q) → r) ↔ ((p ∧ (¬ r)) → (¬ q))) (
        p q r *3.37
        p r q converse-of-*3.37
        introduceBiconditional
))
</jh>

The next theorem, <code>(((p ∧ q) → (¬ r)) ↔ ((q ∧ r) → (¬ p)))</code>, is similar.  Until we have built up more of the biconditional machinery, it will be easier to prove each implication separately.  The proof is a straightforward substitution together with a commutation of the initial p ∧ q. As with the previous proof, most of the length of the proof consists of building up formulas to handle things like removing deeply nested double negation, a process which will get (somewhat) easier later.

<jh>
thm (*4.15-1 () () (((p ∧ q) → r) → ((q ∧ p) → r)) (
        q p *3.22
        (q ∧ p) (p ∧ q) r Syllogism
        applyModusPonens
))

thm (*4.15-2 () () (((p ∧ q) → (¬ r)) → ((q ∧ (¬ (¬ r))) → (¬ p))) (
        p q (¬ r) *4.15-1
        q p (¬ r) *4.14 eliminateBiconditionalLeft
        applySyllogism
))

thm (*4.15-forward () () (((p ∧ q) → (¬ r)) → ((q ∧ r) → (¬ p))) (
        p q r *4.15-2

        q (¬ (¬ r)) (¬ p) Exportation applySyllogism

        r *2.12
        r (¬ (¬ r)) (¬ p) Syllogism
        applyModusPonens

        ((¬ (¬ r)) → (¬ p)) (r → (¬ p)) q *2.05
        applyModusPonens

        applySyllogism

        q r (¬ p) Importation applySyllogism
))

thm (*4.15-2-reverse () () (((q ∧ (¬ (¬ r))) → (¬ p)) → ((p ∧ q) → (¬ r))) (
        q p (¬ r) *4.14 eliminateBiconditionalRight
        q p (¬ r) *4.15-1
        applySyllogism
))

thm (*4.15-reverse () () (((q ∧ r) → (¬ p)) → ((p ∧ q) → (¬ r))) (
        q r (¬ p) Exportation

        r *2.14
        (¬ (¬ r)) r (¬ p) Syllogism
        applyModusPonens

        (r → (¬ p)) ((¬ (¬ r)) → (¬ p)) q *2.05
        applyModusPonens

        applySyllogism

        q (¬ (¬ r)) (¬ p) Importation applySyllogism

        q r p *4.15-2-reverse
        applySyllogism
))

thm (*4.15 () () (((p ∧ q) → (¬ r)) ↔ ((q ∧ r) → (¬ p))) (
        p q r *4.15-forward
        q r p *4.15-reverse
        introduceBiconditional
))
</jh>

=== Reflexive, symmetric, and transitive ===

The biconditional has these three properties (which correspond to those defining an [[w:equivalence relation|equivalence relation]]).

<jh>
thm (BiconditionalReflexivity () () (p ↔ p) ( # *4.2
        p Id
        p Id
        introduceBiconditional
))

thm (BiconditionalSymmetry () () ((p ↔ q) → (q ↔ p)) (
        (p → q) (q → p) *3.22
))

thm (*4.21 () () ((p ↔ q) ↔ (q ↔ p)) (
        p q BiconditionalSymmetry
        q p BiconditionalSymmetry
        introduceBiconditional
))

thm (swapBiconditional () ((H (p ↔ q))) (q ↔ p) (
        H
        p q BiconditionalSymmetry
        applyModusPonens
))
</jh>
The proof of biconditional transitivity is somewhat more complicated. The antecedent contains essentially four disjunctions factors. Each of them has to be picked out and applied:
<jh>
thm (BiconditionalTransitivity () () (((p ↔ q) ∧ (q ↔ r)) → (p ↔ r)) ( # *4.22
</jh>
First factor:
<jh>
        (p ↔ q) (q ↔ r) ConjunctionRightElimination
        (p → q) (q → p) ConjunctionRightElimination
        applySyllogism
</jh>
Third factor:
<jh>
        (p ↔ q) (q ↔ r) ConjunctionLeftElimination
        (q → r) (r → q) ConjunctionRightElimination
        applySyllogism
        applySyllogismInConsequent
</jh>
Fourth factor:
<jh>
        (p ↔ q) (q ↔ r) ConjunctionLeftElimination
        (q → r) (r → q) ConjunctionLeftElimination
        applySyllogism
</jh>
Second factor:
<jh>
        (p ↔ q) (q ↔ r) ConjunctionRightElimination
        (p → q) (q → p) ConjunctionLeftElimination
        applySyllogism
        applySyllogismInConsequent
        composeConjunction
))

thm (applyBiconditionalTransitivity () ((H1 (p ↔ q)) (H2 (q ↔ r))) (p ↔ r) (
        H1 H2 introduceConjunction
        p q r BiconditionalTransitivity
        applyModusPonens
))
</jh>

=== Additional biconditional theorems ===
Another easy builder theorem:
<jh>

thm (*4.37 () () ((p ↔ q) → ((p ∨ r) ↔ (q ∨ r))) (
        p q r *2.38
        q p r *2.38
        conjoin
))

thm (buildRightDisjunction () ((H (p ↔ q))) ((p ∨ r) ↔ (q ∨ r)) (
        H
        p q r *4.37
        applyModusPonens
))
</jh>

=== More theorems stated using the biconditional ===
Some more theorems where we have proved implications in both directions, but can now express them using the biconditional:
<jh>
thm (AntecedentDistribution () () ((p → (q → r)) ↔ ((p → q) → (p → r))) ( # *5.41
        p q r *2.77
        p q r *2.86
        introduceBiconditional
))

thm (Transposition () () ((p → q) ↔ ((¬ q) → (¬ p))) ( # *4.1
        p q *2.16
        q p *2.17
        introduceBiconditional
))

thm (TranspositionWithNegatedAntecedent () () (((¬ p) → q) ↔ ((¬ q) → p)) (
        p q *2.15
        q p *2.15
        introduceBiconditional
))

thm (TranspositionWithNegatedConsequent () () ((p → (¬ q)) ↔ (q → (¬ p))) (
        p q *2.03
        q p *2.03
        introduceBiconditional
))

thm (Transportation () () ((p → (q → r)) ↔ ((p ∧ q) → r)) (
        p q r Importation
        p q r Exportation
        introduceBiconditional
))
</jh>

=== Algebraic laws for disjunction and conjunction ===

Some of the theorems of the propositional calculus can be thought of as analagous to those of other [[w:Abstract algebra|algebras]], showing properties such as commutivity and associativity.  Although Whitehead and Russell think this concept was overemphasized in their day,<ref>Whitehead and Russell, p. 120</ref> they do provide theorems which represent algebraic properties.

==== Idempotence ====

Idempotence for disjunction and conjunction are perhaps the most interesting, as they cause the biggest differences between this algebra and many other algebras:<ref>Whitehead and Russell, p. 121</ref>

<jh>
thm (DisjunctionIdempotence () () (p ↔ (p ∨ p)) ( # *4.25
        p p Add
        p Taut
        introduceBiconditional
))
</jh>

To prove conjunction idempotence, we first catch up on a few basic implication theorems we haven't needed until now:

<jh>
thm (*2.4 () () ((p ∨ (p ∨ q)) → (p ∨ q)) (
        p p q *2.31
</jh>
That gives us <code>((p ∨ (p ∨ q) → ((p ∨ p) ∨ q))</code> and we just need to eliminate the extra <code>p ∨ p</code>:
<jh>
        p Taut
        (p ∨ p) p q *2.38
        applyModusPonens

        applySyllogism
))

thm (*2.43 () () ((p → (p → q)) → (p → q)) (
        (¬ p) q *2.4
))

thm (ConjunctionIdempotence () () (p ↔ (p ∧ p)) ( # *4.24
        p p *3.2
        p (p ∧ p) *2.43
        applyModusPonens

        p p ConjunctionRightElimination

        introduceBiconditional
))
</jh>

Idempotence is also expressed in the following rules.

<jh>
thm (cloneAsDisjunction () ((H p)) (p ∨ p) (
        H
        p p Add
        applyModusPonens
))

thm (conflateDisjunction () ((H (p ∨ p))) p (
        H
        p Taut
        applyModusPonens
))

thm (cloneAsConjunction () ((H p)) (p ∧ p) (
        H
        p ConjunctionIdempotence eliminateBiconditionalLeft
        applyModusPonens
))

thm (conflateConjunction () ((H (p ∧ p))) p (
        H
        p ConjunctionIdempotence eliminateBiconditionalRight
        applyModusPonens
))
</jh>

==== Commutativity ====
We already have commutativity of disjunction and conjunction, but just need to express them using the biconditional:
<jh>
thm (DisjunctionCommutativity () () ((p ∨ q) ↔ (q ∨ p)) ( # *4.31
        p q Perm
        q p Perm
        introduceBiconditional
))

thm (ConjunctionCommutativity () () ((p ∧ q) ↔ (q ∧ p)) ( # *4.3
        p q *3.22
        q p *3.22
        introduceBiconditional
))
</jh>

==== Associativity ====

Both disjunction and conjunction are associative:

<jh>
thm (DisjunctionAssociativity () () (((p ∨ q) ∨ r) ↔ (p ∨ (q ∨ r))) ( # *4.33
        p q r *2.32
        p q r *2.31
        introduceBiconditional
))

</jh>
 
The link between *4.15 (which has some implications and negations) and the conjunctions in ConjunctionAssociativity may not be apparent, but follows from the definitions of conjunction and implication.
<jh>
thm (ConjunctionAssociativity () () (((p ∧ q) ∧ r) ↔ (p ∧ (q ∧ r))) ( # *4.32
        p q r *4.15
        addNegation

        (q ∧ r) p ConjunctionCommutativity

        applyBiconditionalTransitivity
))
</jh>

We already provided rules for associating disjunctions; here are the corresponding ones for conjunctions:

<jh>
thm (groupConjunctionRight () ((H ((p ∧ q) ∧ r))) (p ∧ (q ∧ r)) (
        H
        p q r ConjunctionAssociativity
        eliminateBiconditionalLeft
        applyModusPonens
))

thm (groupConjunctionLeft () ((H (p ∧ (q ∧ r)))) ((p ∧ q) ∧ r) (
        H
        p q r ConjunctionAssociativity
        eliminateBiconditionalRight
        applyModusPonens
))
</jh>

=== Substitution and builders ===
If p ↔ q, then we want to be able to substitute p for q in a theorem to get a new theorem.<ref>Whitehead and Russell, page 120</ref>  The mechanism which we are working towards, in [[Interface:Classical propositional calculus]], is provided by <code>addNegation</code>, <code>removeNegation</code>, <code>buildImplication</code>, <code>buildDisjunction</code>, <code>buildConjunction</code>, and <code>buildBiconditional</code>. Those rules do not eliminate the need for a proof to build up the expressions embodying the substitution, but they reduce the process of constructing such a proof to a familiar (if perhaps tedious) pattern. We proved <code>addNegation</code> already, and we're now ready for <code>buildConjunction</code> and <code>buildDisjunction</code>.

==== Conjunction ====
The proof proceeds by expanding <code>(p ↔ q) ∧ (r ↔ s)</code> into four implications, rearranging them (ConjunctionFunction-1, which is just applying assocativity and commutativity in the usual ways), and applying ConjunctionMultiplication to each half.

<jh>
thm (ConjunctionFunction-1 () () (((p ∧ q) ∧ (r ∧ s)) → ((p ∧ r) ∧ (q ∧ s))) (
        p q (r ∧ s) ConjunctionAssociativity
        eliminateRightConjunction # eliminateRightBiconditionalImplication

        p Id
        q r s ConjunctionAssociativity
        eliminateLeftConjunction # eliminateLeftBiconditionalImplication
        conjoin

        applySyllogism

        p Id
        q r ConjunctionCommutativity
        eliminateRightConjunction # eliminateRightBiconditionalImplication
        s Id 
        conjoin
        conjoin

        applySyllogism

        p Id
        r q s ConjunctionAssociativity
        eliminateRightConjunction # eliminateRightBiconditionalImplication
        conjoin

        applySyllogism

        p r (q ∧ s) ConjunctionAssociativity
        eliminateLeftConjunction # eliminateLeftBiconditionalImplication

        applySyllogism
))

thm (ConjunctionFunction () () (((p ↔ q) ∧ (r ↔ s)) → ((p ∧ r) ↔ (q ∧ s))) ( # *4.38
        (p → q) (q → p) (r → s) (s → r) ConjunctionFunction-1
        
        p q r s ConjunctionMultiplication
        q p s r ConjunctionMultiplication
        conjoin

        applySyllogism
))
</jh>

==== Disjunction ====
This is just like the theorem for conjunction, except that we build on the partial builder theorem DisjunctionSummation instead of ConjunctionMultiplication:

<jh>
thm (DisjunctionFunction () () (((p ↔ q) ∧ (r ↔ s)) → ((p ∨ r) ↔ (q ∨ s))) ( # *4.39
        (p → q) (q → p) (r → s) (s → r) ConjunctionFunction-1
        
        p q r s DisjunctionSummation
        q p s r DisjunctionSummation
        conjoin

        applySyllogism
))
</jh>

==== Rules ====
Here are rules corresponding to the implications which have been proved so far:

<jh>
thm (buildConjunction () (
  (H1 (p ↔ q))
  (H2 (r ↔ s)))
  ((p ∧ r) ↔ (q ∧ s)) (
        H1 H2 introduceConjunction
        p q r s ConjunctionFunction
        applyModusPonens
))

thm (buildDisjunction () (
  (H1 (p ↔ q))
  (H2 (r ↔ s)))
  ((p ∨ r) ↔ (q ∨ s)) (
        H1 H2 introduceConjunction
        p q r s DisjunctionFunction
        applyModusPonens
))

thm (removeNegation () ((H ((¬ p) ↔ (¬ q)))) (p ↔ q) (
        H
        p q NegationFunction
        eliminateBiconditionalRight
        applyModusPonens
))
</jh>

==== Implication ====
The builder for implication is a simple consequence of the builder for disjunction together with the equivalence of <code>(¬ p) ↔ (¬ q)</code> and <code>p ↔ q</code>.

<jh>
thm (ImplicationFunction () () (((p ↔ q) ∧ (r ↔ s)) → ((p → r) ↔ (q → s))) (
        p q NegationFunction
        (r ↔ s) BiconditionalReflexivity
        buildConjunction

        eliminateBiconditionalLeft

        (¬ p) (¬ q) r s DisjunctionFunction

        applySyllogism
))

thm (buildImplication () ((HPQ (p ↔ q)) (HRS (r ↔ s))) 
  ((p → r) ↔ (q → s)) (
        HPQ HRS introduceConjunction
        p q r s ImplicationFunction
        applyModusPonens
))
</jh>

==== Biconditional ====
To prove the biconditional builder, we need <code>((p → r) ∧ (r → p)) ↔ ((q → s) ∧ (s → q))</code>.  As this is an equivalence of conjunctions, we'll get it with the conjunction builder.  The equivalences needed to apply the conjunction builder will come from the implication builder (and conjunction commutativity in one of the two directions).

<jh>
thm (BiconditionalFunction () () (((p ↔ q) ∧ (r ↔ s)) → ((p ↔ r) ↔ (q ↔ s))) (
        p q r s ImplicationFunction

        (p ↔ q) (r ↔ s) *3.22
        r s p q ImplicationFunction
        applySyllogism

        composeConjunction

        (p → r) (q → s) (r → p) (s → q) 
        ConjunctionFunction

        applySyllogism
))

thm (buildBiconditional () ((HPQ (p ↔ q)) (HRS (r ↔ s))) ((p ↔ r) ↔ (q ↔ s)) (
        HPQ HRS introduceConjunction
        p q r s BiconditionalFunction
        applyModusPonens
))
</jh>

=== Distributive law ===
We prove two distributive laws.  The first one, <code>((p ∧ (q ∨ r)) ↔ ((p ∧ q) ∨ (p ∧ r))</code>, is analogous to the distributive law in well-known algebras such as the real numbers, i × (j + k) = i × j + i × k (if one thinks of conjunction as being like multiplication and disjunction as being like addition).

<jh>
thm (ConjunctionLeftDistribution-forward () () 
  ((p ∧ (q ∨ r)) → ((p ∧ q) ∨ (p ∧ r))) (
        p q *3.2
        p r *3.2
        composeConjunction

        q (p ∧ q) r (p ∧ r) DisjunctionSummation
        applySyllogism

        import
))

thm (ConjunctionLeftDistribution-reverse () ()
  (((p ∧ q) ∨ (p ∧ r)) → (p ∧ (q ∨ r))) (
        p q ConjunctionRightElimination
        p r ConjunctionRightElimination
        composeDisjunction

        p q ConjunctionLeftElimination
        p r ConjunctionLeftElimination
        disjoin

        composeConjunction
))

thm (ConjunctionLeftDistribution () () ((p ∧ (q ∨ r)) ↔ ((p ∧ q) ∨ (p ∧ r))) ( # *4.4
        p q r ConjunctionLeftDistribution-forward
        p q r ConjunctionLeftDistribution-reverse
        introduceBiconditional
))
</jh>

The second distributive law, <code>(p ∨ (q ∧ r)) ↔ ((p ∨ q) ∧ (p ∨ r))</code>, has no analogue in ordinary algebra.<ref>Whitehead and Russell, p. 124</ref>

<jh>
thm (DisjunctionLeftDistribution-forward () () ((p ∨ (q ∧ r)) → ((p ∨ q) ∧ (p ∨ r))) (
        q r ConjunctionRightElimination
        (q ∧ r) q p Sum applyModusPonens

        q r ConjunctionLeftElimination
        (q ∧ r) r p Sum applyModusPonens

        composeConjunction
))

thm (DisjunctionLeftDistribution-reverse () () (((p ∨ q) ∧ (p ∨ r)) → (p ∨ (q ∧ r))) (
        p q *2.53
        p r *2.53
        conjoin

        (¬ p) q r Comp
        applySyllogism

        p (q ∧ r) *2.54
        applySyllogism
))

thm (DisjunctionLeftDistribution () () ((p ∨ (q ∧ r)) ↔ ((p ∨ q) ∧ (p ∨ r))) ( # *4.41
        p q r DisjunctionLeftDistribution-forward
        p q r DisjunctionLeftDistribution-reverse
        introduceBiconditional
))
</jh>

We also supply commuted versions of both laws and some rules:

<jh>
thm (DisjunctionRightDistribution () () (((p ∧ q) ∨ r) ↔ ((p ∨ r) ∧ (q ∨ r))) (
        (p ∧ q) r DisjunctionCommutativity
        r p q DisjunctionLeftDistribution
        applyBiconditionalTransitivity

        r p DisjunctionCommutativity
        r q DisjunctionCommutativity
        buildConjunction

        applyBiconditionalTransitivity
))

thm (ConjunctionRightDistribution () () (((p ∨ q) ∧ r) ↔ ((p ∧ r) ∨ (q ∧ r))) (
        (p ∨ q) r ConjunctionCommutativity
        r p q ConjunctionLeftDistribution
        applyBiconditionalTransitivity

        r p ConjunctionCommutativity
        r q ConjunctionCommutativity
        buildDisjunction

        applyBiconditionalTransitivity
))

thm (distributeLeftDisjunction () ((H (p ∨ (q ∧ r)))) ((p ∨ q) ∧ (p ∨ r)) (
        H
        p q r DisjunctionLeftDistribution
        eliminateBiconditionalLeft
        applyModusPonens
))

thm (collectLeftDisjunction () ((H ((p ∨ q) ∧ (p ∨ r)))) (p ∨ (q ∧ r)) (
        H
        p q r DisjunctionLeftDistribution
        eliminateBiconditionalRight
        applyModusPonens
))

thm (distributeRightDisjunction () ((H ((p ∧ q) ∨ r))) ((p ∨ r) ∧ (q ∨ r)) (
        H
        p q r DisjunctionRightDistribution
        eliminateBiconditionalLeft
        applyModusPonens
))

thm (collectRightDisjunction () ((H ((p ∨ r) ∧ (q ∨ r)))) ((p ∧ q) ∨ r) (
        H
        p q r DisjunctionRightDistribution
        eliminateBiconditionalRight
        applyModusPonens
))

thm (distributeLeftConjunction () ((H (p ∧ (q ∨ r)))) ((p ∧ q) ∨ (p ∧ r)) (
        H
        p q r ConjunctionLeftDistribution
        eliminateBiconditionalLeft
        applyModusPonens
))

thm (collectLeftConjunction () ((H ((p ∧ q) ∨ (p ∧ r)))) (p ∧ (q ∨ r)) (
        H
        p q r ConjunctionLeftDistribution
        eliminateBiconditionalRight
        applyModusPonens
))

thm (distributeRightConjunction () ((H ((p ∨ q) ∧ r))) ((p ∧ r) ∨ (q ∧ r)) (
        H
        p q r ConjunctionRightDistribution
        eliminateBiconditionalLeft
        applyModusPonens
))

thm (collectRightConjunction () ((H ((p ∧ r) ∨ (q ∧ r)))) ((p ∨ q) ∧ r) (
        H
        p q r ConjunctionRightDistribution
        eliminateBiconditionalRight
        applyModusPonens
))
</jh>

=== De Morgan's laws ===
Since the definition of conjunction in Principia is based on [[w:De Morgan's laws|De Morgan's laws]], the laws themselves are not hard to prove.
<jh>
thm (DeMorganPDP () () ((¬ (p ∨ q)) ↔ ((¬ p) ∧ (¬ q))) ( # *4.56
        p DoubleNegation
        q DoubleNegation
        buildDisjunction
        addNegation
))

thm (DeMorganPDN () () ((¬ (p ∨ (¬ q))) ↔ ((¬ p) ∧ q)) ( # *4.54
        p DoubleNegation
        (¬ q) buildRightDisjunction
        addNegation
))

thm (DeMorganNDP () () ((¬ ((¬ p) ∨ q)) ↔ (p ∧ (¬ q))) ( # *4.52
        (¬ p) BiconditionalReflexivity
        q DoubleNegation
        buildDisjunction
        addNegation
))

thm (DeMorganNDN () () ((¬ ((¬ p) ∨ (¬ q))) ↔ (p ∧ q)) ( # *4.5
        (¬ ((¬ p) ∨ (¬ q))) BiconditionalReflexivity
))

thm (DeMorganPCP () () ((¬ (p ∧ q)) ↔ ((¬ p) ∨ (¬ q))) ( # *4.51
        ((¬ p) ∨ (¬ q)) DoubleNegation
        swapBiconditional
))

thm (DeMorganPCN () () ((¬ (p ∧ (¬ q))) ↔ ((¬ p) ∨ q)) ( # *4.53
        (¬ p) BiconditionalReflexivity
        q DoubleNegation
        buildDisjunction

        ((¬ p) ∨ (¬ (¬ q))) DoubleNegation
        applyBiconditionalTransitivity
        swapBiconditional
))

thm (DeMorganNCP () () ((¬ ((¬ p) ∧ q)) ↔ (p ∨ (¬ q))) ( # *4.55
        p DoubleNegation
        (¬ q) BiconditionalReflexivity
        buildDisjunction

        ((¬ (¬ p)) ∨ (¬ q)) DoubleNegation
        applyBiconditionalTransitivity
        swapBiconditional
))

thm (DeMorganNCN () () ((¬ ((¬ p) ∧ (¬ q))) ↔ (p ∨ q)) ( # *4.57
        p DoubleNegation
        q DoubleNegation
        buildDisjunction

        ((¬ (¬ p)) ∨ (¬ (¬ q))) DoubleNegation
        applyBiconditionalTransitivity
        swapBiconditional
))

thm (distributeNegationPDP () ((H (¬ (p ∨ q)))) ((¬ p) ∧ (¬ q)) (
        H
        p q DeMorganPDP eliminateBiconditionalLeft
        applyModusPonens
))

thm (distributeNegationPDN () ((H (¬ (p ∨ (¬ q))))) ((¬ p) ∧ q) (
        H
        p q DeMorganPDN eliminateBiconditionalLeft
        applyModusPonens
))

thm (distributeNegationNDP () ((H (¬ ((¬ p) ∨ q)))) (p ∧ (¬ q)) (
        H
        p q DeMorganNDP eliminateBiconditionalLeft
        applyModusPonens
))

thm (distributeNegationNDN () ((H (¬ ((¬ p) ∨ (¬ q))))) (p ∧ q) (
        H
        p q DeMorganNDN eliminateBiconditionalLeft
        applyModusPonens
))

thm (distributeNegationPCP () ((H (¬ (p ∧ q)))) ((¬ p) ∨ (¬ q)) (
        H
        p q DeMorganPCP eliminateBiconditionalLeft
        applyModusPonens
))

thm (distributeNegationPCN () ((H (¬ (p ∧ (¬ q))))) ((¬ p) ∨ q) (
        H
        p q DeMorganPCN eliminateBiconditionalLeft
        applyModusPonens
))

thm (distributeNegationNCP () ((H (¬ ((¬ p) ∧ q)))) (p ∨ (¬ q)) (
        H
        p q DeMorganNCP eliminateBiconditionalLeft
        applyModusPonens
))

thm (distributeNegationNCN () ((H (¬ ((¬ p) ∧ (¬ q))))) (p ∨ q) (
        H
        p q DeMorganNCN eliminateBiconditionalLeft
        applyModusPonens
))

thm (collectNegationPDP () ((H (p ∨ q))) (¬ ((¬ p) ∧ (¬ q))) (
        H
        p q DeMorganNCN eliminateBiconditionalRight
        applyModusPonens
))

thm (collectNegationPDN () ((H (p ∨ (¬ q)))) (¬ ((¬ p) ∧ q)) (
        H
        p q DeMorganNCP eliminateBiconditionalRight
        applyModusPonens
))

thm (collectNegationNDP () ((H ((¬ p) ∨ q))) (¬ (p ∧ (¬ q))) (
        H
        p q DeMorganPCN eliminateBiconditionalRight
        applyModusPonens
))

thm (collectNegationNDN () ((H ((¬ p) ∨ (¬ q)))) (¬ (p ∧ q)) (
        H
        p q DeMorganPCP eliminateBiconditionalRight
        applyModusPonens
))

thm (collectNegationPCP () ((H (p ∧ q))) (¬ ((¬ p) ∨ (¬ q))) (
        H
        p q DeMorganNDN eliminateBiconditionalRight
        applyModusPonens
))

thm (collectNegationPCN () ((H (p ∧ (¬ q)))) (¬ ((¬ p) ∨ q)) (
        H
        p q DeMorganNDP eliminateBiconditionalRight
        applyModusPonens
))

thm (collectNegationNCP () ((H ((¬ p) ∧ q))) (¬ (p ∨ (¬ q))) (
        H
        p q DeMorganPDN eliminateBiconditionalRight
        applyModusPonens
))

thm (collectNegationNCN () ((H ((¬ p) ∧ (¬ q)))) (¬ (p ∨ q)) (
        H
        p q DeMorganPDP eliminateBiconditionalRight
        applyModusPonens
))
</jh>

=== Biconditionalized composition ===

We earlier proved composition laws for disjunction and conjunction:
 ((p → r) ∧ (q → r)) → ((p ∨ q) → r))
 ((p → q) ∧ (p → r)) → (p → (q ∧ r))
The converses, while less interesting, are also true, and we prove them now.

<jh>
thm (DisjunctionComposition () () (((p → r) ∧ (q → r)) ↔ ((p ∨ q) → r)) (
        p r q *3.44

        p q DisjunctionRightIntroduction
        p (p ∨ q) r Syllogism
        applyModusPonens

        q p DisjunctionLeftIntroduction
        q (p ∨ q) r Syllogism
        applyModusPonens

        composeConjunction

        introduceBiconditional
))

thm (ConjunctionComposition () () (((p → q) ∧ (p → r)) ↔ (p → (q ∧ r))) (
        p q r Comp

        q r ConjunctionRightElimination
        (q ∧ r) q p *2.05
        applyModusPonens

        q r ConjunctionLeftElimination
        (q ∧ r) r p *2.05
        applyModusPonens

        composeConjunction

        introduceBiconditional
))

thm (extractLeftDisjunction () ((H ((p ∨ q) → r))) (p → r) (
        p q DisjunctionRightIntroduction
        H
        applySyllogism
))

thm (extractRightDisjunction () ((H ((p ∨ q) → r))) (q → r) (
        q p DisjunctionLeftIntroduction
        H
        applySyllogism
))

thm (extractLeftConjunction () ((H (p → (q ∧ r)))) (p → q) (
        H
        q r ConjunctionRightElimination
        applySyllogism
))

thm (extractRightConjunction () ((H (p → (q ∧ r)))) (p → r) (
        H
        q r ConjunctionLeftElimination
        applySyllogism
))

</jh>

=== Weakenings ===
These are just alternate names or slight variations of what we have already.

<jh>
thm (BiconditionalImplicationLeftElimination () () ((p ↔ q) → (q → p)) (
        (p → q) (q → p) ConjunctionLeftElimination
))

thm (BiconditionalImplicationRightElimination () () ((p ↔ q) → (p → q)) (
        (p → q) (q → p) ConjunctionRightElimination
))

thm (BiconditionalDisjunctionLeftElimination () () ((p ↔ q) → (p ∨ (¬ q))) (
        p q BiconditionalImplicationLeftElimination
        (¬ q) p DisjunctionCommutativity eliminateBiconditionalLeft
        applySyllogism
))

thm (BiconditionalDisjunctionRightElimination () () ((p ↔ q) → ((¬ p) ∨ q)) (
        p q BiconditionalImplicationRightElimination
))

thm (eliminateLeftBiconditionalImplication () ((H (p ↔ q))) (q → p) (
        H
        p q BiconditionalImplicationLeftElimination
        applyModusPonens
))

thm (eliminateRightBiconditionalImplication () ((H (p ↔ q))) (p → q) (
        H
        p q BiconditionalImplicationRightElimination
        applyModusPonens
))

thm (eliminateLeftBiconditionalDisjunction () ((H (p ↔ q))) (p ∨ (¬ q)) (
        H
        p q BiconditionalDisjunctionLeftElimination
        applyModusPonens
))

thm (eliminateRightBiconditionalDisjunction () ((H (p ↔ q))) ((¬ p) ∨ q) (
        H
        p q BiconditionalDisjunctionRightElimination
        applyModusPonens
))
</jh>

== Disjunction elimination ==
A disjunction implies the stronger of its two propositions.  That is, <code>((p ∨ q) ∧ (p → q)) → q</code>.

<jh>
thm (DisjunctionLeftElimination () () (((p ∨ q) ∧ (p → q)) → q) (
        p q *2.62 import
))
</jh>

We also provide a commuted version and some rules:

<jh>
thm (DisjunctionRightElimination () () (((p ∨ q) ∧ (q → p)) → p) (
        p q DisjunctionCommutativity
        (q → p) BiconditionalReflexivity
        buildConjunction
        eliminateBiconditionalLeft

        q p DisjunctionLeftElimination

        applySyllogism
))

thm (eliminateLeftDisjunction () ((HDIS (p ∨ q)) (HIMP (p → q))) q (
        HDIS HIMP introduceConjunction
        p q DisjunctionLeftElimination
        applyModusPonens
))

thm (eliminateRightDisjunction () ((HDIS (p ∨ q)) (HIMP (q → p))) p (
        HDIS HIMP introduceConjunction
        p q DisjunctionRightElimination
        applyModusPonens
))
</jh>

== Case Elimination ==
Proofs often show that one of several cases must apply, and then prove the desired proposition for each case. Here we provide one form of this, where there are two cases: <code>p</code> and <code>(¬ p)</code>.

<jh>
# one direction of *4.83; much like *2.61
thm (CaseElimination () () (((p → q) ∧ ((¬ p) → q)) → q) (
        p q *2.6
        applyComm
        import
))

thm (eliminateCases () ((HP (p → q)) (HNOTP ((¬ p) → q))) q (
        HP HNOTP introduceConjunction
        p q CaseElimination
        applyModusPonens
))
</jh>

== Modus ponens and modus tollens ==
Now that we have import, we can derive the version of the ''modus ponens'' law which [[Interface:Classical propositional calculus]] expects:
<jh>
thm (ModusPonens () () ((p ∧ (p → q)) → q) (
        p q *2.27
        import
))
</jh>

''Modus tollens'' is just a combination of ''modus ponens'' and transposition.

<jh>
thm (ModusTollens () () (((¬ q) ∧ (p → q)) → (¬ p)) (
        (¬ q) BiconditionalReflexivity
        p q Transposition
        buildConjunction eliminateBiconditionalLeft

        (¬ q) (¬ p) ModusPonens

        applySyllogism
))

thm (applyModusTollens () ((H1 (¬ q)) (H2 (p → q))) (¬ p) (
        H1

        H2
        introduceTransposition

        applyModusPonens
))
</jh>

== Tautology and contradiction ==
[[Interface:Classical propositional calculus]] gives the name Tautology to <code>(p ∨ (¬ p)) ↔ (⊤)</code> and Contradiction to <code>(p ∧ (¬ p)) ↔ (⊥)</code>.  They are somewhat more subtle than they appear (and in particular are not just trivial consequences of our definitions of ⊤ and ⊥), because the variable which appears in the definition of ⊤ or ⊥ is not the same as the one in the Tautology or Contradiction theorem.  We therefore prove them as consequences of the notion that two true statements are equivalent (*5.1) or that two false statements are equivalent (*5.21).

<jh>
thm (*3.4 () () ((p ∧ q) → (p → q)) (
        p q ConjunctionLeftElimination
        q p AntecedentIntroduction
        applySyllogism
))

thm (*5.1 () () ((p ∧ q) → (p ↔ q)) (
        p q *3.4

        p q *3.22
        q p *3.4
        applySyllogism

        composeConjunction
))

thm (Tautology () () ((p ∨ (¬ p)) ↔ (⊤)) (
        p TertiumNonDatur
        q TertiumNonDatur
        introduceConjunction

        (p ∨ (¬ p)) (q ∨ (¬ q)) *5.1
        applyModusPonens
))

thm (*5.21 () () (((¬ p) ∧ (¬ q)) → (p ↔ q)) (
        (¬ p) (¬ q) *5.1
        p q NegationFunction eliminateBiconditionalRight
        applySyllogism
))

thm (Contradiction () () ((p ∧ (¬ p)) ↔ (⊥)) (
        p *3.24
        q *3.24
        introduceConjunction

        (p ∧ (¬ p)) (q ∧ (¬ q)) *5.21
        applyModusPonens
))
</jh>

Along the same lines is <code>(¬ p) ↔ (p → (⊥))</code>.

<jh>
thm (NegationImplication-forward () () ((¬ p) → (p → (⊥))) (
       p Contradiction eliminateRightBiconditionalImplication
       export
       applyComm
))

thm (NegationImplication-reverse () () ((p → (⊥)) → (¬ p)) (
        p (⊥) Transposition eliminateRightBiconditionalImplication

        NotFalse
        (¬ (⊥)) (¬ p) ModusPonens export
        applyModusPonens

        applySyllogism
))

thm (NegationImplication () () ((¬ p) ↔ (p → (⊥))) (
        p NegationImplication-forward
        p NegationImplication-reverse
        introduceBiconditional
))

thm (convertFromNegationToImplication () ((H (¬ p))) (p → (⊥)) (
        H
        p NegationImplication
        eliminateRightBiconditionalImplication
        applyModusPonens
))

thm (convertToNegationFromImplication () ((H (p → (⊥)))) (¬ p) (
        H
        p NegationImplication
        eliminateLeftBiconditionalImplication
        applyModusPonens
))
</jh>

== Variants of disjunction summation and conjunction multiplication ==
We've already proved the basic DisjunctionSummation and ConjunctionMultiplication theorems.  Here we provide convenience theorems for cases in which one of the implications is simply <code>r → r</code>, and where there might be a commutation in one of the disjunctions or conjunctions.

Two of these are just new names for the Sum axiom and the Fact theorem; the rest could either be proved from those two and commutativity, or as special cases of DisjunctionSummation and ConjunctionMultiplication.

<jh>
thm (DisjunctionSummationLL () () ((p → q) → ((r ∨ p) → (r ∨ q))) (
        p q r Sum
))

thm (DisjunctionSummationLR () () ((p → q) → ((r ∨ p) → (q ∨ r))) (
        p q r DisjunctionSummationLL

        r q DisjunctionCommutativity eliminateBiconditionalLeft
        (p → q) introduceAntecedent

        applySyllogismInConsequent
))

thm (DisjunctionSummationRR () () ((p → q) → ((p ∨ r) → (q ∨ r))) (
        r ImplicationReflexivity

        p q r r DisjunctionSummation
        export
        applyComm

        applyModusPonens
))

thm (DisjunctionSummationRL () () ((p → q) → ((p ∨ r) → (r ∨ q))) (
        p q r DisjunctionSummationRR

        q r DisjunctionCommutativity eliminateBiconditionalLeft
        (p → q) introduceAntecedent

        applySyllogismInConsequent
))

thm (disjoinLL () ((H (p → q))) ((r ∨ p) → (r ∨ q)) (
        H
        p q r DisjunctionSummationLL
        applyModusPonens
))

thm (disjoinLR () ((H (p → q))) ((r ∨ p) → (q ∨ r)) (
        H
        p q r DisjunctionSummationLR
        applyModusPonens
))

thm (disjoinRL () ((H (p → q))) ((p ∨ r) → (r ∨ q)) (
        H
        p q r DisjunctionSummationRL
        applyModusPonens
))

thm (disjoinRR () ((H (p → q))) ((p ∨ r) → (q ∨ r)) (
        H
        p q r DisjunctionSummationRR
        applyModusPonens
))

thm (ConjunctionMultiplicationLL () () ((p → q) → ((r ∧ p) → (r ∧ q))) (
        r ImplicationReflexivity

        r r p q ConjunctionMultiplication
        export

        applyModusPonens
))

thm (ConjunctionMultiplicationLR () () ((p → q) → ((r ∧ p) → (q ∧ r))) (
        p q r ConjunctionMultiplicationLL

        r q ConjunctionCommutativity eliminateBiconditionalLeft
        (p → q) introduceAntecedent

        applySyllogismInConsequent
))

thm (ConjunctionMultiplicationRR () () ((p → q) → ((p ∧ r) → (q ∧ r))) (
        p q r Fact
))

thm (ConjunctionMultiplicationRL () () ((p → q) → ((p ∧ r) → (r ∧ q))) (
        p q r ConjunctionMultiplicationRR

        q r ConjunctionCommutativity eliminateBiconditionalLeft
        (p → q) introduceAntecedent

        applySyllogismInConsequent
))

thm (conjoinLL () ((H (p → q))) ((r ∧ p) → (r ∧ q)) (
        H
        p q r ConjunctionMultiplicationLL
        applyModusPonens
))

thm (conjoinLR () ((H (p → q))) ((r ∧ p) → (q ∧ r)) (
        H
        p q r ConjunctionMultiplicationLR
        applyModusPonens
))

thm (conjoinRL () ((H (p → q))) ((p ∧ r) → (r ∧ q)) (
        H
        p q r ConjunctionMultiplicationRL
        applyModusPonens
))

thm (conjoinRR () ((H (p → q))) ((p ∧ r) → (q ∧ r)) (
        H
        p q r ConjunctionMultiplicationRR
        applyModusPonens
))
</jh>

== Relationships between connectives ==
Here we express implication in terms of disjunction, biconditional in terms of implication, etc.

=== Biconditional and implications ===
These are all straightforward because we define the biconditional as a conjunction of two implications.

<jh>
thm (BiconditionalImplication () () ((p ↔ q) ↔ ((p → q) ∧ (q → p))) (
        (p ↔ q) BiconditionalReflexivity
))

thm (convertFromBiconditionalToImplications () ((H (p ↔ q))) ((p → q) ∧ (q → p)) (
        H
))

thm (convertToBiconditionalFromImplications () ((H ((p → q) ∧ (q → p)))) (p ↔ q) (
        H
))

thm (introduceBiconditionalFromImplications () ((HPQ (p → q)) (HQP (q → p))) (p ↔ q) (
        HPQ HQP introduceConjunction
))
</jh>

=== Biconditional as disjunction of two conjunctions ===
One way of looking at <code>p ↔ q</code> is "both p and q are true, or neither are true", or in symbols, <code>(p ↔ q) ↔ ((p ∧ q) ∨ ((¬ p) ∧ (¬ q)))</code>.  We prove this via a fairly long string of simpler propositions.

<jh>
thm (Abs () () ((p → (¬ p)) → (¬ p)) ( # *2.01
        (¬ p) Taut
))

thm (*4.61 () () ((¬ (p → q)) ↔ (p ∧ (¬ q))) (
        p q DeMorganNDP
))

thm (*4.82-forward () () (((p → q) ∧ (p → (¬ q))) → (¬ p)) (
        q *3.24

        p q (¬ q) ConjunctionComposition
        p (q ∧ (¬ q)) Transposition
        applyBiconditionalTransitivity
        eliminateRightBiconditionalImplication

        applyComm

        applyModusPonens
))

thm (*5.15 () () ((p ↔ q) ∨ (p ↔ (¬ q))) (
        p q *4.61 eliminateRightBiconditionalImplication
        p (¬ q) *5.1
        applySyllogism

        (p → q) (p ↔ (¬ q)) *2.54
        applyModusPonens
</jh>
At this point we have <code>(p → q) ∨ (p ↔ (¬ q))</code>.  We'll come back to that, after we prove <code>(q → p) ∨ (p ↔ (¬ q))</code>:
<jh>
        q p *4.61 eliminateRightBiconditionalImplication
        q (¬ p) *5.1
        applySyllogism

        q p *4.12 eliminateBiconditionalLeft
        applySyllogism

        (q → p) (p ↔ (¬ q)) *2.54
        applyModusPonens
</jh>
Now we have <code>(p → q) ∨ (p ↔ (¬ q))</code> and <code>(q → p) ∨ (p ↔ (¬ q))</code> on the proof stack. It is now enough to join those with a conjunction and apply the distributive law:
<jh>

        introduceConjunction
        collectRightDisjunction
))

thm (*5.16-1 () () (((p ↔ q) ∧ (p → (¬ q))) → (¬ p)) (
        p q BiconditionalImplicationRightElimination
        (p → (¬ q)) conjoinRR
        p q *4.82-forward
        applySyllogism
))

thm (*5.16-2 () () (((p ↔ q) ∧ (p → (¬ q))) → (¬ q)) (
        p q BiconditionalImplicationLeftElimination
        (p → (¬ q)) conjoinRR

        q p (¬ q) ImplicationTransitivity
        applySyllogism

        q Abs
        applySyllogism
))

thm (*5.16-3 () () (((p ↔ q) ∧ (p → (¬ q))) → (¬ ((¬ q) → p))) (
        p q *5.16-2
        p q *5.16-1
        composeConjunction

</jh>
At this point we have <code>(¬ q) ∧ (¬ p)</code>, and we just need to apply DeMorgan's law and introduce double negation to get <code>(¬ ((¬ (¬ q)) ∨ p))</code>.
<jh>
        q p DeMorganPDP eliminateLeftBiconditionalImplication
        applySyllogism

        q DoubleNegation
        p BiconditionalReflexivity
        buildDisjunction
        addNegation
        eliminateRightBiconditionalImplication

        applySyllogism
))

thm (*5.16 () () (¬ ((p ↔ q) ∧ (p ↔ (¬ q)))) (
        p q *5.16-3
        export
</jh>
We're much closer than it may appear (because jhilbert automatically applies definitions), but other than two applications of DeMorgan's law, it is just the definitions of implication and biconditional:
 (p ↔ q) → ((p → (¬ q)) → (¬ ((¬ q) → p)))
 (p ↔ q) → ((¬ (p → (¬ q))) ∨ (¬ ((¬ q) → p)))
<jh>
        (p → (¬ q)) ((¬ q) → p) DeMorganPCP
        eliminateLeftBiconditionalImplication applySyllogism
</jh>
 (p ↔ q) → (¬ ((p → (¬ q)) ∧ ((¬ q) → p)))
 (p ↔ q) → (¬ (p ↔ (¬ q)))
 (¬ (p ↔ q)) ∨ (¬ (p ↔ (¬ q)))
<jh>
        collectNegationNDN
))

thm (*5.17-1 () () ((p ∨ q) ↔ ((¬ q) → p)) (
        p q DisjunctionCommutativity

        q DoubleNegation
        p BiconditionalReflexivity
        buildDisjunction

        applyBiconditionalTransitivity
))

thm (*5.17-2 () () ((¬ (p ∧ q)) ↔ (p → (¬ q))) (
        p q DeMorganPCP
))

thm (*5.17 () () (((p ∨ q) ∧ (¬ (p ∧ q))) ↔ (p ↔ (¬ q))) (
        p q *5.17-1
        p q *5.17-2
        buildConjunction

        (¬ q) p *4.21

        applyBiconditionalTransitivity
))

thm (*5.18 () () ((p ↔ q) ↔ (¬ (p ↔ (¬ q)))) (
        p q *5.15
        p q *5.16
        introduceConjunction

        (p ↔ q) (p ↔ (¬ q)) *5.17
        eliminateRightBiconditionalImplication applyModusPonens
))

thm (*5.22 () () ((¬ (p ↔ q)) ↔ ((p ∧ (¬ q)) ∨ (q ∧ (¬ p)))) (
        (p → q) (q → p) DeMorganPCP
</jh>
At this point we have (applying the definition of implication) <code>(¬ ((¬ p) ∨ q)) ∨ (¬ ((¬ q) ∨ p))</code> and we need (applying the definition of conjunction) <code>(¬ ((¬ p) ∨ (¬ (¬ q)))) ∨ (¬ ((¬ q) ∨ (¬ (¬ p))))</code>. So we just need to fix the double negation.
<jh>

        (¬ p) BiconditionalReflexivity
        q DoubleNegation
        buildDisjunction
        addNegation

        (¬ q) BiconditionalReflexivity
        p DoubleNegation
        buildDisjunction
        addNegation

        buildDisjunction

        applyBiconditionalTransitivity
))

thm (BiconditionalDisjunction () () ((p ↔ q) ↔ ((p ∧ q) ∨ ((¬ p) ∧ (¬ q)))) ( # *5.23
        p q *5.18
        p (¬ q) *5.22
        applyBiconditionalTransitivity
</jh>
We now have <code>(p ↔ q) ↔ ((p ∧ (¬ (¬ q))) ∨ ((¬ q) ∧ (¬ p)))</code>, so we just need to fix the double negation and commute the second conjunction.
<jh>
        p BiconditionalReflexivity
        q DoubleNegation swapBiconditional
        buildConjunction

        (¬ q) (¬ p) ConjunctionCommutativity

        buildDisjunction

        applyBiconditionalTransitivity
))

thm (convertFromBiconditionalToDisjunction () ((H (p ↔ q))) ((p ∧ q) ∨ ((¬ p) ∧ (¬ q))) (
        H
        p q BiconditionalDisjunction
        eliminateRightBiconditionalImplication
        applyModusPonens
))

thm (convertToBiconditionalFromDisjunction () ((H ((p ∧ q) ∨ ((¬ p) ∧ (¬ q))))) (p ↔ q) (
        H
        p q BiconditionalDisjunction
        eliminateLeftBiconditionalImplication
        applyModusPonens
))
</jh>

=== Biconditional as conjunction of two disjunctions ===
This one follows immediately from our definitions of biconditional and implication, and commutativity.

<jh>
thm (BiconditionalConjunction () () ((p ↔ q) ↔ (((¬ p) ∨ q) ∧ (p ∨ (¬ q)))) (
        ((¬ p) ∨ q) BiconditionalReflexivity
        (¬ q) p DisjunctionCommutativity
        buildConjunction
))

thm (convertFromBiconditionalToConjunction () ((H (p ↔ q))) (((¬ p) ∨ q) ∧ (p ∨ (¬ q))) (
        H
        p q BiconditionalConjunction
        eliminateRightBiconditionalImplication
        applyModusPonens
))

thm (convertToBiconditionalFromConjunction () ((H (((¬ p) ∨ q) ∧ (p ∨ (¬ q))))) (p ↔ q) (
        H
        p q BiconditionalConjunction
        eliminateLeftBiconditionalImplication
        applyModusPonens
))

thm (introduceBiconditionalFromDisjunctions () ((HPQ ((¬ p) ∨ q)) (HQP (p ∨ (¬ q)))) (p ↔ q) (
        HPQ HQP introduceConjunction
        p q BiconditionalConjunction
        eliminateLeftBiconditionalImplication
        applyModusPonens
))
</jh>

=== Implications and disjunctions ===
The relationship between implication and disjunction is just our definition of implication, or an easy consequence thereof.

<jh>
thm (ImplicationDisjunction () () ((p → q) ↔ ((¬ p) ∨ q)) ( # *4.6
        (p → q) BiconditionalReflexivity
))

thm (DisjunctionImplication () () ((p ∨ q) ↔ ((¬ p) → q)) ( # *4.64
        p DoubleNegation
        q BiconditionalReflexivity
        buildDisjunction
))

thm (convertFromImplicationToDisjunction () ((H (p → q))) ((¬ p) ∨ q) (
        H
))

thm (convertToImplicationFromDisjunction () ((H ((¬ p) ∨ q))) (p → q) (
        H
))

thm (convertFromDisjunctionToImplication () ((H (p ∨ q))) ((¬ p) → q) (
        H
        p q DisjunctionImplication
        eliminateRightBiconditionalImplication
        applyModusPonens
))

thm (convertToDisjunctionFromImplication () ((H ((¬ p) → q))) (p ∨ q) (
        H
        p q DisjunctionImplication
        eliminateLeftBiconditionalImplication
        applyModusPonens
))
</jh>

That's it!  We're ready to export our theorems to [[Interface:Classical propositional calculus]]:
<jh>
export (CLASSICAL Interface:Classical_propositional_calculus () ())
</jh>

== References ==

<references />

[[Category:Classical propositional logic]]