{{header
 | title    = Principia Mathematica
 | subtitle = propositional logic
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = The purpose of this page is to prove the statements of [[Interface:Classical propositional calculus]] from the [[Interface:Principia Mathematica propositional logic|Principia Mathematica]]<ref>{{sc|A. Whitehead, B. Russell}}, Principia Mathematica, ''Cambridge University Press'', 1910.</ref> axioms for propositional logic.

[[Image:Zeichen 123.svg|50px]] This page is not yet done.  To help finish it, edit the page (you can see if your edits are verifying by previewing them), or go to [[Help:Contents]] if you haven't yet figured out how to edit and write proofs.
}}
{{interfaces
| imports = [[Interface:Principia Mathematica propositional logic|Principia Mathematica propositional logic]]
| exports = [[Image:Zeichen 123.svg|35px]] None yet
}}

<jh>
import (PRINCIPIA Interface:Principia_Mathematica_propositional_logic () ())
</jh>
We define some variables for well-formed formulas:
<jh>
var (wff p q r s)
</jh>
Principia Mathematica does not define the [[w:nullary#Nullary|nullary]] [[w:logical connective|connectives]] "the true", <math>\top</math>, and "the false", <math>\bot</math>, so we define them here:
<jh>
def ((⊤) (p ∨ (¬ p)))
def ((⊥) (p ∧ (¬ p)))
</jh>
We shall now begin to derive the statements. Whitehead and Russell use a decimal numbering system of the form <math>*r</math>, where <math>r</math> is a rational number with a small number of digits after the decimal point. Unless we give theorems our own name, we shall adopt their system for easier reference. Where we do use our own names, we sometimes give the decimal reference in a JHilbert comment.

== Disjunction and implication ==

=== First steps ===

The [[w:modus ponens|modus ponens]] rule is an axiom of Principia Mathematica, so we don't need to prove it. The ''Perm'' axiom immediately gives rise to the [[w:logical disjunction|disjunctive]] commutativity rule:
<jh>
thm (swapDisjunction () ((H (p ∨ q))) (q ∨ p) (
        H
        p q Perm
        applyModusPonens
))
</jh>
Since Principia Mathematica defines implication, <math>p\rightarrow q</math>, as <math>(\neg p)\vee q</math>, the ''Add'' axiom yields the introduction of an antecedent (Whitehead and Russell call it "Simplification").
<jh>
thm (AntecedentIntroduction () () (p → (q → p)) ( # *2.02
        p (¬ q) Add
))
</jh>
It will be convenient to have this theorem as helper rule:
<jh>
thm (introduceAntecedent () ((H p)) (q → p) (
        H
        p q AntecedentIntroduction
        applyModusPonens
))
</jh>
Again due to the way implication is defined, ''Perm'' gives us our first transposition rule:
<jh>
thm (*2.03 () () ((p → (¬ q)) → (q → (¬ p))) (
        (¬ p) (¬ q) Perm
))

thm (transposeWithNegatedConsequent () ((H (p → (¬ q)))) (q → (¬ p)) (
        H
        p q *2.03
        applyModusPonens
))
</jh>
Next, we prove a precursor to the commutative law of Conjunction, which will be very convenient until we get Peano's transportation principle. We call this theorem ''Comm'' in accordance with Whitehead and Russell.
<jh>
thm (Comm () () ((p → (q → r)) → (q → (p → r))) ( # *2.04
        (¬ p) (¬ q) r Assoc
))

thm (applyComm () ((H (p → (q → r)))) (q → (p → r)) (
        H
        p q r Comm
        applyModusPonens
))
</jh>
This theorem enables us to prove ''Syllogism'' from the ''Sum'' axiom:
<jh>
thm (*2.05 () () ((q → r) → ((p → q) → (p → r))) (
        q r (¬ p) Sum
))

thm (Syllogism () () ((p → q) → ((q → r) → (p → r))) ( # *2.06
        q r p *2.05
        (q → r) (p → q) (p → r) Comm
        applyModusPonens
))

thm (applySyllogism () ((H1 (p → q)) (H2 (q → r))) (p → r) (
        H2
        H1
        p q r Syllogism
        applyModusPonens
        applyModusPonens
))
</jh>
The syllogism yields the "identity" ''Id'', <math>p\rightarrow p</math>, and, by ''Perm'', [[w:tertium non datur|tertium non datur]], which is, by our definition, just <math>\top</math>:
<jh>
thm (Id () () (p → p) ( # *2.08
        p p Add
        p Taut
        applySyllogism
))
# Another name for the same theorem:
thm (ImplicationReflexivity () () (p → p) (
        p Id
))

thm (TertiumNonDatur () () (p ∨ (¬ p)) ( # *2.11
        p Id
        swapDisjunction        
))

thm (True () () (⊤) (
        p TertiumNonDatur
))
</jh>
Actually, for Whitehead and Russell use the permutation of our ''TertiumNonDatur'' as theirs.

With the ''TertiumNonDatur'', we can tackle double negation:
<jh>
thm (*2.12 () () (p → (¬ (¬ p))) (
        (¬ p) TertiumNonDatur
))

thm (*2.13 () () (p ∨ (¬ (¬ (¬ p)))) (
        p TertiumNonDatur
        (¬ p) *2.12
        (¬ p) (¬ (¬ (¬ p))) p Sum
        applyModusPonens
        applyModusPonens
))

thm (*2.14 () () ((¬ (¬ p)) → p) (
        p *2.13
        swapDisjunction
))

thm (eliminateDoubleNegation () ((H (¬ (¬ p)))) p (
        H
        p *2.14
        applyModusPonens
))
</jh>

=== Transposition ===
Combined with double negation, the transposition law <math>*2.03</math> we already have yields the remaining three:
<jh>
thm (*2.15 () () (((¬ p) → q) → ((¬ q) → p)) (
        q *2.12
        q (¬ (¬ q)) (¬ p) *2.05
        applyModusPonens
</jh>
We now have <math>((\neg p)\rightarrow q)\rightarrow((\neg p)\rightarrow(\neg(\neg q)))</math>. We transpose the consequent using our transposition law <math>*2.03</math>
<jh>
        (¬ p) (¬ q) *2.03
        applySyllogism
</jh>
to get <math>((\neg p)\rightarrow q)\rightarrow((\neg q)\rightarrow(\neg(\neg p)))</math>. All that remains to do now is to eliminate the double negation.
<jh>
        p *2.14
        (¬ (¬ p)) p (¬ q) *2.05
        applyModusPonens
        applySyllogism
))

thm (transposeWithNegatedAntecedent () ((H ((¬ p) → q))) ((¬ q) → p) (
        H
        p q *2.15
        applyModusPonens
))
</jh>
The proofs of the next two theorems work similar but are actually easier due to a more favourable distribution of negations:
<jh>
thm (*2.16 () () ((p → q) → ((¬ q) → (¬ p))) (
        q *2.12
        q (¬ (¬ q)) p *2.05
        applyModusPonens
        p (¬ q) *2.03
        applySyllogism
))

thm (introduceTransposition () ((H (p → q))) ((¬ q) → (¬ p)) (
        H
        p q *2.16
        applyModusPonens
))

thm (*2.17 () () (((¬ q) → (¬ p)) → (p → q)) (
        (¬ q) p *2.03
        q *2.14
        (¬ (¬ q)) q p *2.05
        applyModusPonens
        applySyllogism
))

thm (eliminateTransposition () ((H ((¬ q) → (¬ p)))) (p → q) (
        H
        q p *2.17
        applyModusPonens
))
</jh>

=== Disjunction introduction ===
Next, we prove the disjunction introduction laws. Introduction from the left is just the ''Add'' axiom of principia, and a permutation yields the introduction from the right.
<jh>
thm (DisjuctionIntroductionLeft () () (p → (q ∨ p)) (
        p q Add
))

thm (introduceLeftDisjunction () ((H p)) (q ∨ p) (
        H
        p q DisjuctionIntroductionLeft
        applyModusPonens
))

thm (DisjuctionIntroductionRight () () (p → (p ∨ q)) ( # *2.2
        p q DisjuctionIntroductionLeft
        q p Perm
        applySyllogism
))

thm (introduceRightDisjunction () ((H p)) (p ∨ q) (
        H
        p q DisjuctionIntroductionRight
        applyModusPonens
))
</jh>

=== Modus ponens law ===
Next, we prove the modus ponens law with ''Assoc'':
<jh>
thm (*2.25 () () (p ∨ ((p ∨ q) → q)) (
        (p ∨ q) Id
        (¬ (p ∨ q)) p q Assoc
        applyModusPonens
))

thm (ModusPonens () () (p → ((p → q) → q)) ( # *2.27
        (¬ p) q *2.25
))
</jh>

=== Disjunction associativity ===
We now "repair" the extra twist in the ''Assoc'' axiom to get the actual associativity rules for disjunction:
<jh>
thm (*2.3 () () ((p ∨ (q ∨ r)) → (p ∨ (r ∨ q))) (
        q r Perm
        (q ∨ r) (r ∨ q) p Sum
        applyModusPonens
))

thm (*2.31 () () ((p ∨ (q ∨ r)) → ((p ∨ q) ∨ r)) (
        p q r *2.3
        p r q Assoc
        applySyllogism
        r (p ∨ q) Perm
        applySyllogism
))

thm (groupDisjunctionLeft () ((H (p ∨ (q ∨ r)))) ((p ∨ q) ∨ r) (
        H
        p q r *2.31
        applyModusPonens
))

thm (*2.32 () () (((p ∨ q) ∨ r) → (p ∨ (q ∨ r))) (
        (p ∨ q) r Perm
        r p q Assoc
        applySyllogism
        p r q *2.3
        applySyllogism
))

thm (groupDisjunctionRight () ((H ((p ∨ q) ∨ r))) (p ∨ (q ∨ r)) (
        H
        p q r *2.32
        applyModusPonens
))
</jh>

=== Expression building with disjunctions ===
Now we prove three helpful theorems regarding expression building with disjunctions, that is, they are companions to the ''Sum'' axiom. All these proofs proceed in two steps, using a syllogism to alter the consequent of ''Sum''.
<jh>
thm (*2.36 () () ((q → r) → ((p ∨ q) → (r ∨ p))) (
</jh>
As first step, we simply take the ''Sum'' axiom,
<jh>
        q r p Sum
</jh>
and prove <math>((p\vee q)\rightarrow(p\vee r))\rightarrow((p\vee q)\rightarrow(r\vee p))</math> as second step,
<jh>
        p r Perm
        (p ∨ r) (r ∨ p) (p ∨ q) *2.05
        applyModusPonens
</jh>
so that the result follows via a syllogism:
<jh>
        applySyllogism
))

thm (*2.37 () () ((q → r) → ((q ∨ p) → (p ∨ r))) (
</jh>
As first step, we take the ''Sum'' axiom with transposed consequent, that is <math>(q\rightarrow r)\rightarrow((\neg(p\vee r))\rightarrow(\neg(p\vee q)))</math>,
<jh>
        q r p Sum
        (p ∨ q) (p ∨ r) *2.16
        applySyllogism
</jh>
As second step, we prove <math>((\neg(p\vee r))\rightarrow(\neg(p\vee q)))\rightarrow((\neg(p\vee r))\rightarrow(\neg(q\vee p)))</math>
<jh>
        q p Perm
        introduceTransposition
        (¬ (p ∨ q)) (¬ (q ∨ p)) (¬ (p ∨ r)) *2.05
        applyModusPonens
</jh>
Combining these two steps, the result follows by transposing the consequent back.
<jh>
        applySyllogism
        (p ∨ r) (q ∨ p) *2.17
        applySyllogism
))
</jh>
Finally, <math>*2.38</math> follows directly from <math>*2.37</math> in the same way.
<jh>
thm (*2.38 () () ((q → r) → ((q ∨ p) → (r ∨ p))) (
        q r p *2.37
        p r Perm
        (p ∨ r) (r ∨ p) (q ∨ p) *2.05
        applyModusPonens
        applySyllogism
))
</jh>

=== Implication distribution theorem (if part) ===
Our next goal will be to prove the ''if'' part of the implication distribution theorem, <math>(p\rightarrow(q\rightarrow r))\leftrightarrow((p\rightarrow q)\rightarrow(p\rightarrow r))</math>. Given that implication is defined from disjunction and negation in Principia, it would seem more natural to use [[w:de Morgan's law|de Morgan's law]] for disjunction negation for that. However, we don't have that yet, and in fact, implication distribution is instrumental to prove the "principle of the factor" ''Fact'' below, which in turn is required for de Morgan's law. So what we shall do instead is to install equivalences such as <math>p\leftrightarrow(\neg(\neg p))</math>, <math>p\leftrightarrow p\vee p</math> and <math>p\vee q\leftrightarrow q\vee p</math> in more or less deep subexpression in a long chain of theorems until we finally arrive at the desired result. <jh>
thm (*2.53 () () ((p ∨ q) → ((¬ p) → q)) (
</jh>
That is, we make <math>(p\vee q)\rightarrow((\neg(\neg p))\vee q)</math> from <math>p\rightarrow(\neg(\neg q))</math>.
<jh>
        p *2.12
        p (¬ (¬ p)) q *2.38
        applyModusPonens
))

thm (*2.6 () () (((¬ p) → q) → ((p → q) → q)) (
        (¬ p) q q *2.38
</jh>
This gives us already the result, except that the last <math>q</math> has been duplicated, <math>q\vee q</math>. We remove the duplicate using the ''Taut'' axiom.
<jh>
        q Taut
        (q ∨ q) q (¬ ((¬ p) ∨ q)) Sum
        applyModusPonens
        applySyllogism
))

thm (*2.62 () () ((p ∨ q) → ((p → q) → q)) (
        p q *2.53
        p q *2.6
        applySyllogism
))

thm (*2.621 () () ((p → q) → ((p ∨ q) → q)) (
        p q *2.62
        applyComm
))

thm (*2.73 () () ((p → q) → (((p ∨ q) ∨ r) → (q ∨ r))) (
        p q *2.621
        (p ∨ q) q r *2.38
        applySyllogism
))

thm (*2.74 () () ((q → p) → (((p ∨ q) ∨ r) → (p ∨ r))) (
</jh>
This is the same as <math>*2.73</math> except for a permutation in the second antecedent. Since this permutation is nested four levels deep, some work is required. We begin with <math>*2.73</math>,
<jh>
        q p r *2.73
</jh>
and prove the permutation <math>((p\vee q)\vee r)\rightarrow((q\vee p)\vee r)</math>:
<jh>
        p q r *2.32
        p q r Assoc
        applySyllogism
        q p r *2.31
        applySyllogism
</jh>
We can now install this permutation as an antecedent through a transposition. Then the theorem follows through a syllogism.
<jh>
        introduceTransposition
        (¬ ((q ∨ p) ∨ r)) (¬ ((p ∨ q) ∨ r)) (p ∨ r) *2.38
        applyModusPonens
        applySyllogism
))

thm (*2.75 () () ((p ∨ q) → ((p ∨ (q → r)) → (p ∨ r))) (
</jh>
This is <math>*2.74</math>, with <math>q</math> replaced with <math>\neg q</math>, plus some of the usual transformations.
<jh>
        p q Perm
        q p *2.53
        applySyllogism
</jh>
This gives us <math>(p\vee q)\rightarrow((\neg q)\rightarrow p)</math>, which we can connect with <math>*2.74</math>,
<jh>
        (¬ q) p r *2.74
        applySyllogism
</jh>
so we get <math>(p\vee q)\rightarrow(((p\vee(\neg q))\vee r)\rightarrow(p\vee r))</math>. The rest of the proof is now to effect the disjunctive associativity law in the second antecedent.
<jh>
        p (¬ q) r *2.31
        introduceTransposition
        (¬ ((p ∨ (¬ q)) ∨ r)) (¬ (p ∨ ((¬ q) ∨ r))) (p ∨ r) *2.38
        applyModusPonens
        applySyllogism
))

thm (*2.76 () () ((p ∨ (q → r)) → ((p ∨ q) → (p ∨ r))) (
        p q r *2.75
        applyComm
))

thm (*2.77 () () ((p → (q → r)) → ((p → q) → (p → r))) (
        (¬ p) q r *2.76
))

thm (distributeAntecedent () ((H (p → (q → r)))) ((p → q) → (p → r)) (
        H
        p q r *2.77
        applyModusPonens
))
</jh>
Theorem <math>*2.77</math> is now precisely the ''if'' part of the implicational distribution law.

=== Syllogism in the consequent ===
We prove a "syllogism in the consequent law", that is, <math>(p\rightarrow(q\rightarrow r))\rightarrow((p\rightarrow(r\rightarrow s))\rightarrow(p\rightarrow(q\rightarrow s)))</math>, which is useful for syllogisms depending on a common hypothesis. We first show a modus ponens law for disjunctions.
<jh>
thm (*2.8 () () ((q ∨ r) → ((r → s) → (q ∨ s))) (
        q r Perm
        r q *2.53
        applySyllogism
</jh>
This gives us <math>(q\vee r)\rightarrow((\neg r)\rightarrow q)</math>. The theorem follows now by a summation:
<jh>
        (¬ r) q s *2.38
        applySyllogism
))
</jh>
Next, we prove a three terms summation law:
<jh>
thm (*2.81 () () ((q → (r → s)) → ((p ∨ q) → ((p ∨ r) → (p ∨ s)))) (
        q (r → s) p Sum
</jh>
This gives us <math>(q\rightarrow(r\rightarrow s))\rightarrow((p\vee q)\rightarrow(p\vee(r\rightarrow s)))</math>, so we only need to distribute the <math>p</math> over <math>r\rightarrow s</math>:
<jh>
        p r s *2.76
        (p ∨ q) introduceAntecedent
        distributeAntecedent
        applySyllogism
))
</jh>
Combining <math>*2.8</math> and <math>*2.81</math>, we get
<jh>
thm (*2.82 () () ((p ∨ (q ∨ r)) → ((p ∨ (r → s)) → (p ∨ (q ∨ s)))) (
        q r s *2.8
        (q ∨ r) (r → s) (q ∨ s) p *2.81
        applyModusPonens
))
</jh>
from which we can immediately derive our new syllogism law:
<jh>
thm (SyllogismInConsequent () () ((p → (q → r)) → ((p → (r → s)) → (p → (q → s)))) ( # *2.83
        (¬ p) (¬ q) r s *2.82
))

thm (applySyllogismInConsequent () ((H1 (p → (q → r))) (H2 (p → (r → s)))) (p → (q → s)) (
        H2
        H1
        p q r s SyllogismInConsequent
        applyModusPonens
        applyModusPonens
))
</jh>

=== Implication distribution theorem (only-if part) ===
Next we prove the ''only if'' part of the implicational distribution law (the ''if'' part of which we proved in *2.77). We start with a simple consequence of *2.53 and the converse of *2.53:

<jh>
thm (*2.55 () () ((¬ p) → ((p ∨ q) → q)) (
        p q *2.53
        applyComm
))

thm (*2.54 () () (((¬ p) → q) → (p ∨ q)) (
        p *2.14
        (¬ (¬ p)) p q *2.38
        applyModusPonens
))
</jh>

The meat of our desired result is <code>((p ∨ q) → (p ∨ r)) → (p ∨ (q → r))</code> (*2.85). It differs only by being partly expressed in terms of disjunction instead of implication.  Each of the following thm's is just an intermediate step in proving *2.85:

<jh>
thm (*2.85-1 () () (((p ∨ q) → r) → (q → r)) (
        q p Add
        q (p ∨ q) r Syllogism
        applyModusPonens
))

thm (*2.85-unnamed1 () () ((¬ p) → (((p ∨ q) → (p ∨ r)) → ((p ∨ q) → r))) (
        p r *2.55
        (p ∨ r) r (p ∨ q) *2.05
        applySyllogism
))

thm (*2.85-2 () () ((¬ p) → (((p ∨ q) → (p ∨ r)) → (q → r))) (
        p q r *2.85-unnamed1

        p q r *2.85-1
        (¬ p) introduceAntecedent

        applySyllogismInConsequent
))

thm (*2.85-unnamed2 () () (((p ∨ q) → (p ∨ r)) → ((¬ p) → (q → r))) (
        p q r *2.85-2
        applyComm
))

thm (*2.85 () () (((p ∨ q) → (p ∨ r)) → (p ∨ (q → r))) (
        p q r *2.85-unnamed2
        p (q → r) *2.54
        applySyllogism
))
</jh>

From this follows the ''only if'' part of the implicational distribution law:
<jh>
thm (*2.86 () () (((p → q) → (p → r)) → (p → (q → r))) (
        (¬ p) q r *2.85
))

thm (collectAntecedent () ((H ((p → q) → (p → r)))) (p → (q → r)) (
        H
        p q r *2.86
        applyModusPonens
))
</jh>

== Conjunction ==

In this section we prove statements involving conjunction <math>p\wedge q</math>. Recall that conjunction is defined by <math>\neg((\neg p)\vee(\neg q))</math>. Our first theorem is the combination of two statements to a conjunction.
<jh>
thm (*3.2 () () (p → (q → (p ∧ q))) (
        ((¬ p) ∨ (¬ q)) TertiumNonDatur
</jh>
The trick is now to write <math>(\neg p)\vee(\neg q)\vee\ldots</math> as <math>p\rightarrow(q\rightarrow\ldots)</math>:
<jh>
        groupDisjunctionRight
))

thm (combineStatements () ((H1 p) (H2 q)) (p ∧ q) ( # *3.03
        H2
        H1
        p q *3.2
        applyModusPonens
        applyModusPonens
))
</jh>
We can prove the commutative law for conjunction from ''Perm'' using transpositions:
<jh>
thm (*3.22 () () ((p ∧ q) → (q ∧ p)) (
        (q ∧ p) Id
        eliminateTransposition
        (¬ q) (¬ p) Perm
        applySyllogism
        introduceTransposition
))

thm (swapConjunction () ((H (p ∧ q))) (q ∧ p) (
        H
        p q *3.22
        applyModusPonens
))
</jh>
Next, we prove the negation of <math>\bot</math>:
<jh>
thm (*3.24 () () (¬ (p ∧ (¬ p))) (
        (¬ p) TertiumNonDatur
        ((¬ p) ∨ (¬ (¬ p))) *2.12
        applyModusPonens
))

thm (NotFalse () () (¬ (⊥)) (
        p *3.24
))
</jh>

=== Conjunction elimination ===
Next, we prove the conjunction elimination theorems.
<jh>
thm (ConjunctionEliminationRight () () ((p ∧ q) → p) ( # *3.26
        p q AntecedentIntroduction
        groupDisjunctionLeft
</jh>
This gives us <math>((\neg p)\vee(\neg q))\vee p</math>. All we need now is a double negation of the left bracket.
<jh>
        ((¬ p) ∨ (¬ q)) p *2.53
        applyModusPonens
))

thm (eliminateRightConjunction () ((H (p ∧ q))) p (
        H
        p q ConjunctionEliminationRight
        applyModusPonens
))

thm (ConjunctionEliminationLeft () () ((p ∧ q) → q) ( # *3.27
        p q *3.22
        q p ConjunctionEliminationRight
        applySyllogism
))

thm (eliminateLeftConjunction () ((H (p ∧ q))) q (
        H
        p q ConjunctionEliminationLeft
        applyModusPonens
))
</jh>

=== Import and export ===
We now prove Peano's import and export principles. We begin with exportation:
<jh>
thm (Exportation () () (((p ∧ q) → r) → (p → (q → r))) ( # *3.3
</jh>
To shift the bracket right, we combine transposition and the ''Comm'' axiom to get <math>((p\wedge q)\rightarrow r)\rightarrow(p\rightarrow((\neg r)\rightarrow(\neg q)))</math>:
<jh>
        ((¬ p) ∨ (¬ q)) r *2.15
        (¬ r) p (¬ q) Comm
        applySyllogism
</jh>
What remains to do now is to install a transposition of <math>r</math> with <math>q</math>:
<jh>
        r q *2.17
        p introduceAntecedent distributeAntecedent
        applySyllogism
))

thm (export () ((H ((p ∧ q) → r))) (p → (q → r)) (
        H
        p q r Exportation
        applyModusPonens
))
</jh>
Importation is simpler as the conjunction is in the consequent this time:
<jh>
thm (Importation () () ((p → (q → r)) → ((p ∧ q) → r)) ( # *3.31
        (¬ p) (¬ q) r *2.31
        ((¬ p) ∨ (¬ q)) r *2.53
        applySyllogism
))

thm (import () ((H (p → (q → r)))) ((p ∧ q) → r) (
        H
        p q r Importation
        applyModusPonens
))
</jh>
We can use importation to prove syllogisms in conjunction form:
<jh>
thm (*3.33 () () (((p → q) ∧ (q → r)) → (p → r)) (
        p q r Syllogism
        import
))

thm (*3.34 () () (((q → r) ∧ (p → q)) → (p → r)) (
       q r p *2.05
       import
))
</jh>

Import and export also give us another transposition theorem, *3.37 (which we prove in several steps):
<jh>
thm (*3.37-1 () () ((p → (q → r)) → (p → ((¬ r) → (¬ q)))) (
        q r *2.16
        (q → r) ((¬ r) → (¬ q)) p *2.05
        applyModusPonens
))

thm (*3.37 () () (((p ∧ q) → r) → ((p ∧ (¬ r)) → (¬ q))) (
        p q r Exportation
        p q r *3.37-1
        applySyllogism

        p (¬ r) (¬ q) Importation
        applySyllogism
))
</jh>

=== Composition ===
Next, we prove ''Comp'', the principle of composition,
<jh>
thm (Comp () () (((p → q) ∧ (p → r)) → (p → (q ∧ r))) (
        q r *3.2
        q (r → (q ∧ r)) p *2.05
        applyModusPonens
        p r (q ∧ r) *2.77
        applySyllogism
        import
))

thm (applyComp () ((H1 (p → q)) (H2 (p → r))) (p → (q ∧ r)) (
        H1 H2 combineStatements
        p q r Comp
        applyModusPonens
))
</jh>

=== Principle of the factor ===
Finally, we prove Peano's principle of the factor, called ''Fact'' by Whitehead and Russell. It complements the ''Sum'' axiom and its companion theorems. Two consequences are partial builder theorems for conjunction and disjunction.
<jh>
thm (Fact () () ((p → q) → ((p ∧ r) → (q ∧ r))) ( # *3.45
        p q (¬ r) Syllogism
        (q → (¬ r)) (p → (¬ r)) *2.16
        applySyllogism
))

thm (*3.47 () () (((p → r) ∧ (q → s)) → ((p ∧ q) → (r ∧ s))) (
</jh>
We prove this theorem in two steps. First we use the left hand side of the antecedent to deduce <math>((p\rightarrow r)\wedge(q\rightarrow s))\rightarrow((p\wedge q)\rightarrow(q\wedge r))</math>:
<jh>
        (p → r) (q → s) ConjunctionEliminationRight
        p r q Fact
        applySyllogism
        r q *3.22
        (p ∧ q) introduceAntecedent distributeAntecedent
        applySyllogism
</jh>
Now we do the same with the right hand side of the antecedent to get <math>((p\rightarrow r)\wedge(q\rightarrow s))\rightarrow((q\wedge r)\rightarrow(r\wedge s))</math>. The theorem then follows from a syllogism in the consequent.
<jh>
        (p → r) (q → s) ConjunctionEliminationLeft
        q s r Fact
        applySyllogism
        s r *3.22
        (q ∧ r) introduceAntecedent distributeAntecedent
        applySyllogism
        applySyllogismInConsequent
))

thm (combineImplicationsAsConjunction () ((H1 (p → r)) (H2 (q → s))) ((p ∧ q) → (r ∧ s)) (
        H1 H2 combineStatements
        p r q s *3.47
        applyModusPonens
))

thm (*3.48 () () (((p → r) ∧ (q → s)) → ((p ∨ q) → (r ∨ s))) (
</jh>
This theorem follows exactly as <math>*3.47</math>, except that we use the ''Sum'' type theorem <math>*2.37</math> instead of ''Fact'' and <math>*3.22</math>.
<jh>
        (p → r) (q → s) ConjunctionEliminationRight
        p r q *2.37
        applySyllogism
        (p → r) (q → s) ConjunctionEliminationLeft
        q s r *2.37
        applySyllogism
        applySyllogismInConsequent
))

thm (combineImplicationsAsDisjunction () ((H1 (p → r)) (H2 (q → s))) ((p ∨ q) → (r ∨ s)) (
        H1 H2 combineStatements
        p r q s *3.48
        applyModusPonens
))
</jh>

== Biconditional ==

In Principia, the biconditional <math>p\leftrightarrow q</math> is defined simply as <math>(p\rightarrow q)\wedge(q\rightarrow p)</math>, so our combination and elimination theorems for conjunction immediately yield the corresponding introduction and elimination rules for the biconditional.
<jh>
thm (introduceBiconditional () ((H1 (p → q)) (H2 (q → p))) (p ↔ q) (
        H1 H2 combineStatements
))

thm (eliminateBiconditionalLeft () ((H (p ↔ q))) (p → q) (
        H eliminateRightConjunction
))

thm (eliminateBiconditionalRight () ((H (p ↔ q))) (q → p) (
        H eliminateLeftConjunction
))
</jh>
In order to prove the negation function theorem <math>(p\leftrightarrow q)\leftrightarrow((\neg p)\leftrightarrow(\neg q))</math>, we combine the two transposition laws <math>*2.16</math> and <math>*2.17</math>:
<jh>
thm (NegationFunction () () ((p ↔ q) ↔ ((¬ p) ↔ (¬ q))) (
        p q *2.16
        q p *2.16
        combineImplicationsAsConjunction
</jh>
This gives us <math>(p\leftrightarrow q)\rightarrow((\neg q)\leftrightarrow(\neg p))</math>, the right hand side of which must be permuted:
<jh>
        ((¬ q) → (¬ p)) ((¬ p) → (¬ q)) *3.22
        applySyllogism
</jh>
Now the same again for <math>*2.17</math>:
<jh>
        p q *2.17
        q p *2.17
        combineImplicationsAsConjunction
        (q → p) (p → q) *3.22
        applySyllogism
        introduceBiconditional
))

thm (buildNegation () ((H (p ↔ q))) ((¬ p) ↔ (¬ q)) (
        H
        p q NegationFunction
        eliminateBiconditionalLeft
        applyModusPonens
))
</jh>
Some more easy theorems:
<jh>
thm (DoubleNegation () () (p ↔ (¬ (¬ p))) ( # *4.13
        p *2.12
        p *2.14
        introduceBiconditional
))
</jh>

The idea behind the proof of converse-of-*3.37 is quite simple: *3.37 becomes its own converse (modulo some double negation) when substituted with some negated terms.  The rest of the proof is just getting rid of the double negation.
<jh>
thm (converse-of-*3.37 () () (((p ∧ (¬ r)) → (¬ q)) → ((p ∧ q) → r)) (
        p (¬ r) (¬ q) *3.37
        # (((p ∧ (¬ r)) → (¬ q)) → ((p ∧ (¬ (¬ q))) → (¬ (¬ r))))

        p (¬ (¬ q)) (¬ (¬ r)) Exportation
        # ((p ∧ (¬ (¬ q))) → (¬ (¬ r)))) → (p → ((¬ (¬ q)) → (¬ (¬ r))))

        (¬ q) (¬ r) *2.17
        r q *2.17
        applySyllogism
        # ((¬ (¬ q)) → (¬ (¬ r))) → (q → r)

        ((¬ (¬ q)) → (¬ (¬ r))) (q → r) p *2.05
        applyModusPonens
        # (p → ((¬ (¬ q)) → (¬ (¬ r)))) → (p → (q → r))

        applySyllogism

        p q r Importation
        applySyllogism

        applySyllogism
))

thm (*4.14 () () (((p ∧ q) → r) ↔ ((p ∧ (¬ r)) → (¬ q))) (
        p q r *3.37
        p r q converse-of-*3.37
        introduceBiconditional
))

# This one is not yet proved:
#thm (*4.15 () () (((p ∧ q) → (¬ r)) ↔ ((q ∧ r) → (¬ p))) (
#))
</jh>

=== Reflexive, symmetric, and transitive ===

The biconditional has these three properties (which correspond to those defining an [[w:equivalence relation|equivalence relation]]).

<jh>
thm (BiconditionalReflexivity () () (p ↔ p) ( # *4.2
        p Id
        p Id
        introduceBiconditional
))

thm (BiconditionalSymmetry () () ((p ↔ q) → (q ↔ p)) ( # *4.21
        (p → q) (q → p) *3.22
))

thm (swapBiconditional () ((H (p ↔ q))) (q ↔ p) (
        H
        p q BiconditionalSymmetry
        applyModusPonens
))
</jh>
The proof of biconditional transitivity is somewhat more complicated. The antecedent contains essentially four disjunctions factors. Each of them has to be picked out and applied:
<jh>
thm (BiconditionalTransitivity () () (((p ↔ q) ∧ (q ↔ r)) → (p ↔ r)) ( # *4.22
</jh>
First factor:
<jh>
        (p ↔ q) (q ↔ r) ConjunctionEliminationRight
        (p → q) (q → p) ConjunctionEliminationRight
        applySyllogism
</jh>
Third factor:
<jh>
        (p ↔ q) (q ↔ r) ConjunctionEliminationLeft
        (q → r) (r → q) ConjunctionEliminationRight
        applySyllogism
        applySyllogismInConsequent
</jh>
Fourth factor:
<jh>
        (p ↔ q) (q ↔ r) ConjunctionEliminationLeft
        (q → r) (r → q) ConjunctionEliminationLeft
        applySyllogism
</jh>
Second factor:
<jh>
        (p ↔ q) (q ↔ r) ConjunctionEliminationRight
        (p → q) (q → p) ConjunctionEliminationLeft
        applySyllogism
        applySyllogismInConsequent
        applyComp
))

thm (applyBiconditionalTransitivity () ((H1 (p ↔ q)) (H2 (q ↔ r))) (p ↔ r) (
        H1 H2 combineStatements
        p q r BiconditionalTransitivity
        applyModusPonens
))
</jh>

=== Additional biconditional theorems ===
Another easy builder theorem:
<jh>

thm (*4.37 () () ((p ↔ q) → ((p ∨ r) ↔ (q ∨ r))) (
        p q r *2.38
        q p r *2.38
        combineImplicationsAsConjunction
))

thm (buildRightDisjunction () ((H (p ↔ q))) ((p ∨ r) ↔ (q ∨ r)) (
        H
        p q r *4.37
        applyModusPonens
))
</jh>

=== De Morgan's laws ===
Since the definition of conjunction in Principia is based on [[w:De Morgan's laws|De Morgan's laws]], the laws themselves are not hard to prove.
<jh>
thm (ConjunctionNegation () () ((¬ (p ∧ q)) ↔ ((¬ p) ∨ (¬ q))) ( # *4.51
        ((¬ p) ∨ (¬ q)) DoubleNegation
        swapBiconditional
))

thm (*4.54 () () ((¬ (p ∨ (¬ q))) ↔ ((¬ p) ∧ q)) (
        p DoubleNegation
        (¬ q) buildRightDisjunction
        buildNegation
))
</jh>

=== More theorems stated using the biconditional ===
Some more theorems where we have proved implications in both directions, but can now express them using the biconditional:
<jh>
thm (AntecedentDistribution () () ((p → (q → r)) ↔ ((p → q) → (p → r))) (
        p q r *2.77
        p q r *2.86
        introduceBiconditional
))

thm (Transposition () () ((p → q) ↔ ((¬ q) → (¬ p))) (
        p q *2.16
        q p *2.17
        introduceBiconditional
))

thm (TranspositionWithNegatedAntecedent () () (((¬ p) → q) ↔ ((¬ q) → p)) (
        p q *2.15
        q p *2.15
        introduceBiconditional
))

thm (TranspositionWithNegatedConsequent () () ((p → (¬ q)) ↔ (q → (¬ p))) (
        p q *2.03
        q p *2.03
        introduceBiconditional
))

</jh>

=== Algebraic laws for disjunction and conjunction ===

Some of the theorems of the propositional calculus can be thought of as analagous to those of other [[w:Abstract algebra|algebras]], showing properties such as commutivity and associativity.  Although Whitehead and Russell think this concept was overemphasized in their day,<ref>Whitehead and Russell, p. 120</ref> they do provide theorems which represent algebraic properties.

==== Idempotence ====

Idempotence for disjunction and conjunction are perhaps the most interesting, as they cause the biggest differences between this algebra and many other algebras:<ref>Whitehead and Russell, p. 121</ref>

<jh>
thm (DisjunctionIdempotence () () (p ↔ (p ∨ p)) ( # *4.25
        p p Add
        p Taut
        introduceBiconditional
))
</jh>

To prove conjunction idempotence, we first catch up on a few basic implication theorems we haven't needed until now:

<jh>
thm (*2.4 () () ((p ∨ (p ∨ q)) → (p ∨ q)) (
        p p q *2.31
</jh>
That gives us <code>((p ∨ (p ∨ q) → ((p ∨ p) ∨ q))</code> and we just need to eliminate the extra <code>p ∨ p</code>:
<jh>
        p Taut
        (p ∨ p) p q *2.38
        applyModusPonens

        applySyllogism
))

thm (*2.43 () () ((p → (p → q)) → (p → q)) (
        (¬ p) q *2.4
))

thm (ConjunctionIdempotence () () (p ↔ (p ∧ p)) ( # *4.24
        p p *3.2
        p (p ∧ p) *2.43
        applyModusPonens

        p p ConjunctionEliminationRight

        introduceBiconditional
))
</jh>

==== Associativity ====

Both disjunction and conjunction are associative:

<jh>
thm (DisjunctionAssociativity () () (((p ∨ q) ∨ r) ↔ (p ∨ (q ∨ r))) ( # 4.33
        p q r *2.32
        p q r *2.31
        introduceBiconditional
))

# proof of ConjunctionAssociativity to be added later
</jh>

=== Substitution and builders ===
If p ↔ q, then we want to be able to substitute p for q in a theorem to get a new theorem.<ref>Whitehead and Russell, page 120</ref>  The mechanism which we are working towards, in [[Interface:Classical propositional calculus]], is provided by <code>addNegation</code>, <code>removeNegation</code>, <code>buildImplication</code>, <code>buildDisjunction</code>, <code>buildConjunction</code>, and <code>buildBiconditional</code>. Those rules do not eliminate the need for a proof to build up the expressions embodying the substitution, but they reduce the process of constructing such a proof to a familiar (if perhaps tedious) pattern. It will take some time to prove all of these.

:''This page is still incomplete''
:''Once it is done, the following export can be uncommented:''
<jh>
#export (CLASSICAL Interface:Classical_propositional_calculus () ())
</jh>

== References ==

<references />

[[Category:Classical propositional logic]]