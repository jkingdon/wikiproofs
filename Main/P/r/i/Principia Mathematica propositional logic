{{header
 | title    = Principia Mathematica
 | subtitle = propositional logic
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = The purpose of this page is to prove the statements of [[Interface:Classical propositional calculus]] from the [[Interface:Principia Mathematica propositional logic|Principia Mahematica]]<ref>{{sc|A. Whitehead, B. Russell}}, Principia Mathematica, ''Cambridge University Press'', 1910.</ref> axioms for propositional logic.

[[Image:Zeichen 123.svg|50px]] Still under construction
}}
{{interfaces
| imports = [[Interface:Principia Mathematica propositional logic|Principia Mathematica propositional logic]]
| exports = [[Image:Zeichen 123.svg|35px]] None yet
}}

<jh>
import (PRINCIPIA Interface:Principia_Mathematica_propositional_logic () ())
</jh>
We define some variables for well-formed formulas:
<jh>
var (wff p q r s)
</jh>
Principia Mathematica does not define the [[w:nullary#Nullary|nullary]] [[w:logical connective|connectives]] "the true", <math>\top</math>, and "the false", <math>\bot</math>, so we define them here:
<jh>
def ((⊤) (p ∨ (¬ p)))
def ((⊥) (p ∧ (¬ p)))
</jh>
We shall now begin to derive the statements. Whitehead and Russell use a decimal numbering system of the form <math>*r</math>, where <math>r</math> is a rational number with a small number of digits after the decimal point. Unless we give theorems our own name, we shall adopt their system for easier reference. Where we do use our own names, we sometimes give the decimal reference in a JHilbert comment.

== Immediate consequences from the axioms ==

The [[w:modus ponens|modus ponens]] rule is an axiom of Principia Mathematica, so we don't need to prove it. The ''Perm'' axiom immediately gives rise to the [[w:logical disjunction|disjunctive]] commutativity rule:
<jh>
thm (swapDisjunction () ((H (p ∨ q))) (q ∨ p) (
        H
        p q Perm
        applyModusPonens
))
</jh>
Since Principia Mathematica defines implication, <math>p\rightarrow q</math>, as <math>(\neg p)\vee q</math>, the ''Add'' axiom yields the introduction of an antecedent (Whitehead and Russell call it "Simplification").
<jh>
thm (AntecedentIntroduction () () (p → (q → p)) ( # *2.02
        p (¬ q) Add
))
</jh>
It will be convenient to have this theorem as helper rule:
<jh>
thm (introduceAntecedent () ((H p)) (q → p) (
        H
        p q AntecedentIntroduction
        applyModusPonens
))
</jh>
Again due to the way implication is defined, ''Perm'' gives us our first transposition rule:
<jh>
thm (*2.03 () () ((p → (¬ q)) → (q → (¬ p))) (
        (¬ p) (¬ q) Perm
))

thm (transposeWithNegatedConsequent () ((H (p → (¬ q)))) (q → (¬ p)) (
        H
        p q *2.03
        applyModusPonens
))
</jh>
Next, we prove a precursor to the commutative law of Conjunction, which will be very convenient until we get Peano's transportation principle. We call this theorem ''Comm'' in accordance with Whitehead and Russell.
<jh>
thm (Comm () () ((p → (q → r)) → (q → (p → r))) ( # *2.04
        (¬ p) (¬ q) r Assoc
))

thm (applyComm () ((H (p → (q → r)))) (q → (p → r)) (
        H
        p q r Comm
        applyModusPonens
))
</jh>
This theorem enables us to prove ''Syllogism'' from the ''Sum'' axiom:
<jh>
thm (*2.05 () () ((q → r) → ((p → q) → (p → r))) (
        q r (¬ p) Sum
))

thm (Syllogism () () ((p → q) → ((q → r) → (p → r))) ( # *2.06
        q r p *2.05
        (q → r) (p → q) (p → r) Comm
        applyModusPonens
))

thm (applySyllogism () ((H1 (p → q)) (H2 (q → r))) (p → r) (
        H2
        H1
        p q r Syllogism
        applyModusPonens
        applyModusPonens
))
</jh>
The syllogism yields the "identity" ''Id'', <math>p\rightarrow p</math>, and, by ''Perm'', [[w:tertium non datur|tertium non datur]], which is, by our definition, just <math>\top</math>:
<jh>
thm (Id () () (p → p) ( # *2.08
        p p Add
        p Taut
        applySyllogism
))

thm (TertiumNonDatur () () (p ∨ (¬ p)) ( # *2.11
        p Id
        swapDisjunction        
))

thm (True () () (⊤) (
        p TertiumNonDatur
))
</jh>
Actually, for Whitehead and Russell use the permutation of our ''TertiumNonDatur'' as theirs.

With the ''TertiumNonDatur'', we can tackle double negation:
<jh>
thm (*2.12 () () (p → (¬ (¬ p))) (
        (¬ p) TertiumNonDatur
))

thm (*2.13 () () (p ∨ (¬ (¬ (¬ p)))) (
        p TertiumNonDatur
        (¬ p) *2.12
        (¬ p) (¬ (¬ (¬ p))) p Sum
        applyModusPonens
        applyModusPonens
))

thm (*2.14 () () ((¬ (¬ p)) → p) (
        p *2.13
        swapDisjunction
))

thm (eliminateDoubleNegation () ((H (¬ (¬ p)))) p (
        H
        p *2.14
        applyModusPonens
))
</jh>
Combined with double negation, the transposition law <math>*2.03</math> we already have yields the remaining three:
<jh>
thm (*2.15 () () (((¬ p) → q) → ((¬ q) → p)) (
        q *2.12
        q (¬ (¬ q)) (¬ p) *2.05
        applyModusPonens
</jh>
We now have <math>((\neg p)\rightarrow q)\rightarrow((\neg p)\rightarrow(\neg(\neg q)))</math>. We transpose the consequent using our transposition law <math>*2.03</math>
<jh>
        (¬ p) (¬ q) *2.03
        applySyllogism
</jh>
to get <math>((\neg p)\rightarrow q)\rightarrow((\neg q)\rightarrow(\neg(\neg p)))</math>. All that remains to do now is to eliminate the double negation.
<jh>
        p *2.14
        (¬ (¬ p)) p (¬ q) *2.05
        applyModusPonens
        applySyllogism
))

thm (transposeWithNegatedAntecedent () ((H ((¬ p) → q))) ((¬ q) → p) (
        H
        p q *2.15
        applyModusPonens
))
</jh>
The proofs of the next two theorems work similar but are actually easier due to a more favourable distribution of negations:
<jh>
thm (*2.16 () () ((p → q) → ((¬ q) → (¬ p))) (
        q *2.12
        q (¬ (¬ q)) p *2.05
        applyModusPonens
        p (¬ q) *2.03
        applySyllogism
))

thm (introduceTransposition () ((H (p → q))) ((¬ q) → (¬ p)) (
        H
        p q *2.16
        applyModusPonens
))

thm (*2.17 () () (((¬ q) → (¬ p)) → (p → q)) (
        (¬ q) p *2.03
        q *2.14
        (¬ (¬ q)) q p *2.05
        applyModusPonens
        applySyllogism
))

thm (eliminateTransposition () ((H ((¬ q) → (¬ p)))) (p → q) (
        H
        q p *2.17
        applyModusPonens
))
</jh>
Next, we prove the disjunction introduction laws. Introduction from the left is just the ''Add'' axiom of principia, and a permutation yields the introduction from the right.
<jh>
thm (DisjuctionIntroductionLeft () () (p → (q ∨ p)) (
        p q Add
))

thm (introduceLeftDisjunction () ((H p)) (q ∨ p) (
        H
        p q DisjuctionIntroductionLeft
        applyModusPonens
))

thm (DisjuctionIntroductionRight () () (p → (p ∨ q)) ( # *2.2
        p q DisjuctionIntroductionLeft
        q p Perm
        applySyllogism
))

thm (introduceRightDisjunction () ((H p)) (p ∨ q) (
        H
        p q DisjuctionIntroductionRight
        applyModusPonens
))
</jh>
Next, we prove the modus ponens law with ''Assoc'':
<jh>
thm (*2.25 () () (p ∨ ((p ∨ q) → q)) (
        (p ∨ q) Id
        (¬ (p ∨ q)) p q Assoc
        applyModusPonens
))

thm (ModusPonens () () (p → ((p → q) → q)) ( # *2.27
        (¬ p) q *2.25
))
</jh>
We now "repair" the extra twist in the ''Assoc'' axiom to get the actual associativity rules for disjunction:
<jh>
thm (*2.3 () () ((p ∨ (q ∨ r)) → (p ∨ (r ∨ q))) (
        q r Perm
        (q ∨ r) (r ∨ q) p Sum
        applyModusPonens
))

thm (*2.31 () () ((p ∨ (q ∨ r)) → ((p ∨ q) ∨ r)) (
        p q r *2.3
        p r q Assoc
        applySyllogism
        r (p ∨ q) Perm
        applySyllogism
))

thm (groupDisjunctionLeft () ((H (p ∨ (q ∨ r)))) ((p ∨ q) ∨ r) (
        H
        p q r *2.31
        applyModusPonens
))

thm (*2.32 () () (((p ∨ q) ∨ r) → (p ∨ (q ∨ r))) (
        (p ∨ q) r Perm
        r p q Assoc
        applySyllogism
        p r q *2.3
        applySyllogism
))

thm (groupDisjunctionRight () ((H ((p ∨ q) ∨ r))) (p ∨ (q ∨ r)) (
        H
        p q r *2.32
        applyModusPonens
))
</jh>

:''This page is still incomplete''

== References ==

<references />

[[Category:Classical propositional logic]]