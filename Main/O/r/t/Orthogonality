{{interfaces
| imports = [[Interface:Midpoint]]
| exports = [[Interface:Orthogonality]]
}}

This is part of a series of modules which prove a variety of geometrical theorems starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

Here we prove results involving perpendicular lines. This also enables us to prove the existence of the midpoint of a line segment.

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Orthogonality definitions|geometry results so far]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (START Interface:Orthogonality_definitions (CLASSICAL FIRSTORDER) ())

var (formula antecedent)
var (point A B C D E F M P Q R S X Y Z)
var (point A′ B′ C′ D′ E′ M′ P′ Q′ R′ S′ X′ Y′)
var (point C″)
var (variable a a′ b b′ c c′ c″ d d′ e e′ f p p′ q r r′ x x′ y y′ z)
</jh>

== Right angles ==
We've proved a number of the results relating to <code>is-right-angle</code> in [[Orthogonality definitions]]. Here we pick up a few more (particularly ones for which the automatic expansion of definitions in [[Orthogonality definitions]] is inconvenient, and ones which follow from those).

=== Swapping the vertex with one of the legs ===
Another degenerate case is <code>is-right-angle A B C ∧ is-right-angle A C B → B = C</code>.<ref>l8_7 in Narboux</ref>

Let <code>A′</code> be the symmetric point of <code>A</code> through the point <code>C</code>.

First assume <code>B ≠ C</code> (if not, we are done). Then expand <code>is-right-angle A B C</code> by the definition: <code>∃ c′ (B is-midpoint-of C c′ ∧ A C ≡ A c′)</code>. We also flip <code>is-right-angle A C B</code> to <code>is-right-angle B C A</code> and expand it according to the definition: <code>∃ a′ (C is-midpoint-of A a′ ∧ B A ≡ B a′)</code>.
<jh>
thm (RightAngleVertexLeg-cprime
  ((c′ A) (c′ B) (c′ C)) ()
  (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) →
    (∃ c′
      (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
      ((B is-midpoint-of C (value c′)) ∧ (A C ≡ A (value c′))))
  )) (
        (B ≠ C)
          ((is-right-angle A B C) ∧ (is-right-angle A C B))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        A B C c′ RightAngle
        eliminateBiconditionalReverse
        applySyllogism

        repeatAntecedentThereExists
))

thm (RightAngleVertexLeg-aprime
  ((C′ a′) (a′ A) (a′ B) (a′ C)) ()
  (
    (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
      ((B is-midpoint-of C C′) ∧ (A C ≡ A C′))) →
    (∃ a′
      ((((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
      ((B is-midpoint-of C C′) ∧ (A C ≡ A C′))) ∧
      ((C is-midpoint-of A (value a′)) ∧ (B A ≡ B (value a′))))
  )) (
        ((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B)))
          ((B is-midpoint-of C C′) ∧ (A C ≡ A C′))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        A C B RightAngleSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        B C A a′ RightAngle
        eliminateBiconditionalReverse
        applySyllogism

        repeatAntecedentThereExists
))
</jh>

Now we apply <code>RightAngleLeg</code> to get <code>is-right-angle c′ C A</code>.

<jh>
thm (RightAngleVertexLeg-cprime-c-a
  () ()
  (
    ((((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
      ((B is-midpoint-of C C′) ∧ (A C ≡ A C′))) ∧
      ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))) →
    (is-right-angle C′ C A)
  ) (
</jh>
First is <code>is-right-angle B C A</code>.
<jh>
        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        A C B RightAngleSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next is <code>B ≠ C</code>.
<jh>
        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
Finally is <code>collinear C B C′</code>.
<jh>
        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        C B C′ BetweennessCollinearity
        applySyllogism

        composeConjunction

        B C A C′ RightAngleLeg
        applySyllogism
))
</jh>

We can paraphrase the definition of <code>is-right-angle C′ C A</code> as "the symmetric point of <code>A</code> through <code>C</code> is the same distance from <code>C′</code> as <code>A</code> is". By symmetric point uniqueness, said symmetric point is just <code>A′</code>. The following lemma expresses this.
<jh>
#thm (RightAngleVertexLeg-uniqueness-lemma
#  () ()
#  (((is-right-angle C′ C A) ∧ (C is-midpoint-of A A′)) → (C′ A ≡ C′ A′)) (
#        
#))
</jh>
    might want to write that as A C′ ≡ A′ C′
    
  A C ≡ A c′ ∧ A c′ ≡ A′ C′ → A C ≡ A′ C′ (transitivity)

  A C ≡ A′ C (by construction of A′).
  Thus A′ C ≡ A′ C′ by transitivity

  is-right-angle A′ B C
    B is-midpoint-of C C′ ∧ A′ C ≡ A′ C′

  apply RightAngleBetween with everything substituting for itself.
    A B C A′ RightAngleBetween

<jh>
#thm (RightAngleVertexLeg-b-not-c-1 () ()
#  (
#    ((((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
#      ((B is-midpoint-of C C′) ∧ (A C ≡ A C′))) ∧
#      ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))) →
#    (B = C)
#  ) (
#        
#))

#thm (RightAngleVertexLeg-b-not-c
#  ( (c′ A) (c′ B) (c′ C) (c′ a′) (a′ A) (a′ B) (a′ C)) ()
#  (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) →
#    (B = C)) (
#        B C A c′ RightAngleVertexLeg-cprime

#        B C A (value c′) a′ RightAngleVertexLeg-aprime
#        c′ addThereExists
#        applySyllogism

#        B C A (value c′) (value a′) RightAngleVertexLeg-b-not-c-1
#        a′ addThereExists
#        c′ addThereExists
#        applySyllogism

#       removeThereExistsInConsequent
#       removeThereExistsInConsequent
#))

#thm (RightAngleVertexLeg () ()
#  (((is-right-angle A B C) ∧ (is-right-angle A C B)) → (B = C)) (
#        (B = C)
#          ((is-right-angle A B C) ∧ (is-right-angle A C B))
#          AntecedentIntroduction
#
#        B C A RightAngleVertexLeg-b-not-c
#        export
#
#        eliminateCases
#))
</jh>

== Export ==
We now export to [[Interface:Orthogonality]].
<jh>
#export (RESULTS Interface:Orthogonality (CLASSICAL FIRSTORDER) ())
</jh>

Also, since this is currently the last proof module for geometry, we export to [[Interface:Basic geometry]].
<jh>
export (GEOMETRY Interface:Basic_geometry (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>
* Tarski, Alfred; Givant, Steven (1999), "Tarski's system of geometry", The Bulletin of Symbolic Logic 5 (2): 175–214, doi:10.2307/421089, MR1791303, ISSN 1079-8986

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]
