{{interfaces
| imports = [[Interface:Midpoint]]
| exports = [[Interface:Orthogonality]]
}}

This is part of a series of modules which prove a variety of geometrical theorems starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

Here we prove results involving perpendicular lines. This also enables us to prove the existence of the midpoint of a line segment.

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Orthogonality definitions|geometry results so far]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (START Interface:Orthogonality_definitions (CLASSICAL FIRSTORDER) ())

var (formula antecedent)
var (point A B C D E F M P Q R S X Y Z)
var (point A′ B′ C′ D′ E′ M′ P′ Q′ R′ S′ X′ Y′)
var (point C″)
var (variable a a′ b b′ c c′ c″ d d′ e e′ f p p′ q r r′ u u′ v v′ x x′ y y′ z)
</jh>

== Right angles ==
We've proved a number of the results relating to <code>is-right-angle</code> in [[Orthogonality definitions]]. Here we pick up a few more (particularly ones for which the automatic expansion of definitions in [[Orthogonality definitions]] is inconvenient, and ones which follow from those).

=== Proving is-right-angle from an object ===
To prove <code>is-right-angle</code> from <code>RightAngle</code> requires that we come up with a point which satisfies the conditions of <code>RightAngle</code>. Here's a theorem which handles the logic involved in going from that point to an expression containing <code>∃</code>.<ref>not in Narboux, as coq handles this sort of thing</ref>
<jh>
thm (RightAngleObject ( (z A) (z B) (z C) (z Z)) ()
  (((B is-midpoint-of C Z) ∧ (A C ≡ A Z)) →
    (is-right-angle A B C)) (
</jh>
Our substitution is <code>z = Z → (B is-midpoint-of C z ∧ A C ≡ A z ↔ B is-midpoint-of C Z ∧ A C ≡ A Z)</code>.
<jh>
        B EqualityReflexivity
        C EqualityReflexivity
        B B C C (value z) Z MidpointBuilder
        detach2of3
        detach1of2

        C EqualityReflexivity
        A EqualityReflexivity
        A EqualityReflexivity
        A A C C A A (value z) Z CongruenceBuilder
        detach1of4
        detach2of3
        detach1of2

        buildConjunctionInConsequent
</jh>
Now we just turn that into <code>∃</code> and apply <code>RightAngle</code>.
<jh>
        makeSubstExplicit
        eliminateBiconditionalForward

        Z
          z
          ((B is-midpoint-of C (value z)) ∧ (A C ≡ A (value z)))
          ThereExistsIntroductionFromObject
        applySyllogism

        A B C z RightAngle
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

=== Swapping the vertex with one of the legs ===
Another degenerate case is <code>is-right-angle A B C ∧ is-right-angle A C B → B = C</code>.<ref>l8_7 in Narboux</ref>

Let <code>A′</code> be the symmetric point of <code>A</code> through the point <code>C</code>.

First assume <code>B ≠ C</code> (if not, we are done). Then expand <code>is-right-angle A B C</code> by the definition: <code>∃ c′ (B is-midpoint-of C c′ ∧ A C ≡ A c′)</code>. We also flip <code>is-right-angle A C B</code> to <code>is-right-angle B C A</code> and expand it according to the definition: <code>∃ a′ (C is-midpoint-of A a′ ∧ B A ≡ B a′)</code>.
<jh>
thm (RightAngleVertexLeg-cprime
  ((c′ A) (c′ B) (c′ C)) ()
  (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) →
    (∃ c′
      (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
      ((B is-midpoint-of C (value c′)) ∧ (A C ≡ A (value c′))))
  )) (
        (B ≠ C)
          ((is-right-angle A B C) ∧ (is-right-angle A C B))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        A B C c′ RightAngle
        eliminateBiconditionalReverse
        applySyllogism

        repeatAntecedentThereExists
))

thm (RightAngleVertexLeg-aprime
  ((C′ a′) (a′ A) (a′ B) (a′ C)) ()
  (
    (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
      ((B is-midpoint-of C C′) ∧ (A C ≡ A C′))) →
    (∃ a′
      ((((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
      ((B is-midpoint-of C C′) ∧ (A C ≡ A C′))) ∧
      ((C is-midpoint-of A (value a′)) ∧ (B A ≡ B (value a′))))
  )) (
        ((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B)))
          ((B is-midpoint-of C C′) ∧ (A C ≡ A C′))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        A C B RightAngleSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        B C A a′ RightAngle
        eliminateBiconditionalReverse
        applySyllogism

        repeatAntecedentThereExists
))
</jh>

Now we apply <code>RightAngleLeg</code> to get <code>is-right-angle c′ C A</code>.

<jh>
thm (RightAngleVertexLeg-cprime-c-a
  () ()
  (
    ((((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
      ((B is-midpoint-of C C′) ∧ (A C ≡ A C′))) ∧
      ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))) →
    (is-right-angle C′ C A)
  ) (
</jh>
First is <code>is-right-angle B C A</code>.
<jh>
        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        A C B RightAngleSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next is <code>B ≠ C</code>.
<jh>
        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
Finally is <code>collinear C B C′</code>.
<jh>
        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        C B C′ BetweennessCollinearity
        applySyllogism

        composeConjunction

        B C A C′ RightAngleLeg
        applySyllogism
))
</jh>

We can paraphrase the definition of <code>is-right-angle C′ C A</code> as "the symmetric point of <code>A</code> through <code>C</code> is the same distance from <code>C′</code> as <code>A</code> is". By symmetric point uniqueness, said symmetric point is just <code>A′</code>. We express this via the "uniqueness lemma", <code>is-right-angle C′ C A ∧ C is-midpoint-of A A′ → C′ A ≡ C′ A′</code>, which we prove after a few lemmas which reflect parts of its proof.
<jh>
thm (RightAngleVertexLeg-uniqueness-lemma-z-aprime () ()
  ((((C is-midpoint-of A Z) ∧ (C′ A ≡ C′ Z)) ∧ (C is-midpoint-of A A′)) → (Z = A′)) (
        ((C is-midpoint-of A Z) ∧ (C′ A ≡ C′ Z))
          (C is-midpoint-of A A′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        ((C is-midpoint-of A Z) ∧ (C′ A ≡ C′ Z))
          (C is-midpoint-of A A′)
          ConjunctionLeftElimination

        composeConjunction

        C A Z A′ SymmetricPointUniqueness
        applySyllogism
))

thm (RightAngleVertexLeg-uniqueness-lemma-cprime-a-cprime-aprime () ()
  ((((C is-midpoint-of A Z) ∧ (C′ A ≡ C′ Z)) ∧ (C is-midpoint-of A A′)) → (C′ A ≡ C′ A′)) (
        ((C is-midpoint-of A Z) ∧ (C′ A ≡ C′ Z))
          (C is-midpoint-of A A′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        C A Z C′ A′ RightAngleVertexLeg-uniqueness-lemma-z-aprime

        A EqualityReflexivity
        C′ EqualityReflexivity
        C′ EqualityReflexivity
        C′ C′ A A C′ C′ Z A′ CongruenceBuilder
        detach1of4
        detach2of3
        detach1of2
        eliminateBiconditionalReverseInConsequent

        applySyllogism

        applyModusPonensInConsequent
))

thm (RightAngleVertexLeg-uniqueness-lemma
  ( (z C′) (z C) (z A) (z A′)) ()
  (((is-right-angle C′ C A) ∧ (C is-midpoint-of A A′)) → (C′ A ≡ C′ A′)) (
        (is-right-angle C′ C A)
          (C is-midpoint-of A A′)
          ConjunctionRightElimination

        C′ C A z RightAngle
        eliminateBiconditionalReverse
        applySyllogism

        (is-right-angle C′ C A)
          (C is-midpoint-of A A′)
          ConjunctionLeftElimination
        composeConjunction

        moveRightConjunctIntoThereExistsInConsequent
</jh>
The consequent is now <code>∃ z (C is-midpoint-of A z ∧ C′ A ≡ C′ z ∧ C is-midpoint-of A A′)</code>, so we just need to combine with the lemmas we already proved.
<jh>
        C A (value z) C′ A′ RightAngleVertexLeg-uniqueness-lemma-cprime-a-cprime-aprime
        z addThereExists
        applySyllogism

        removeThereExistsInConsequent
))
</jh>

Our next step is <code>A′ C ≡ A′ C′</code>.
<jh>
thm (RightAngleVertexLeg-aprime-c-aprime-cprime () ()
  (
    ((((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
      ((B is-midpoint-of C C′) ∧ (A C ≡ A C′))) ∧
      ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))) →
    (A′ C ≡ A′ C′)
  ) (
</jh>
We start with <code>A′ C ≡ A C</code>, from the construction of <code>A′</code>.
<jh>
        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        swapCongruenceInConsequent
        commuteCongruenceLeftInConsequent
</jh>
Next is <code>A C ≡ A C′</code>
<jh>
        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        applyCongruenceTransitivityInConsequent
</jh>
Next is <code>A C′ ≡ A′ C′</code>, which follows readily from the uniqueness lemma. The uniqueness lemma needs <code>is-right-angle C′ C A</code> and <code>C is-midpoint-of A A′</code>, and it gives us <code>C′ A ≡ C′ A′</code>.
<jh>
        B C A C′ A′ RightAngleVertexLeg-cprime-c-a

        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        composeConjunction

        C′ C A A′ RightAngleVertexLeg-uniqueness-lemma
        applySyllogism
        commuteCongruenceInConsequent

        applyCongruenceTransitivityInConsequent
))
</jh>

Next is <code>is-right-angle A′ B C</code>.
<jh>
thm (RightAngleVertexLeg-aprime-b-c () ()
  (
    ((((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
      ((B is-midpoint-of C C′) ∧ (A C ≡ A C′))) ∧
      ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))) →
    (is-right-angle A′ B C)
  ) (
</jh>
We start with <code>B is-midpoint-of C C′ ∧ A′ C ≡ A′ C′</code>.
<jh>
        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        B C A C′ A′ RightAngleVertexLeg-aprime-c-aprime-cprime

        composeConjunction
</jh>
Applying <code>RightAngleObject</code> we are done.
<jh>
        B C C′ A′ RightAngleObject
        applySyllogism
))
</jh>

<jh>
thm (RightAngleVertexLeg-b-not-c-1 () ()
  (
    ((((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
      ((B is-midpoint-of C C′) ∧ (A C ≡ A C′))) ∧
      ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))) →
    (B = C)
  ) (
</jh>
First we need <code>is-right-angle A B C</code>.
<jh>
        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
Next we need <code>is-right-angle A′ B C</code>.
<jh>
        B C A C′ A′ RightAngleVertexLeg-aprime-b-c
        composeConjunction
</jh>
Finally we need <code>between A C A′</code>
<jh>
        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction
        A B C A′ RightAngleBetween
        applySyllogism
))

thm (RightAngleVertexLeg-b-not-c
  ( (c′ A) (c′ B) (c′ C) (c′ a′) (a′ A) (a′ B) (a′ C)) ()
  (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) →
    (B = C)) (
        B C A c′ RightAngleVertexLeg-cprime

        B C A (value c′) a′ RightAngleVertexLeg-aprime
        c′ addThereExists
        applySyllogism

        B C A (value c′) (value a′) RightAngleVertexLeg-b-not-c-1
        a′ addThereExists
        c′ addThereExists
        applySyllogism

       removeThereExistsInConsequent
       removeThereExistsInConsequent
))

thm (RightAngleVertexLeg () ()
  (((is-right-angle A B C) ∧ (is-right-angle A C B)) → (B = C)) (
        (B = C)
          ((is-right-angle A B C) ∧ (is-right-angle A C B))
          AntecedentIntroduction

        B C A RightAngleVertexLeg-b-not-c
        export

        eliminateCases
))
</jh>

=== A leg which is perpendicular to itself ===
Another degenerate case is <code>is-right-angle A B A → A = B</code>.<ref>l8_8 in Narboux</ref> The proof is that <code>RightAngleVertexLeg</code> gives us <code>is-right-angle A B A ∧ is-right-angle A A B → A = B</code>, but <code>is-right-angle A A B</code> is a theorem, so we are done.
<jh>
thm (RightAngleLegItself () () ((is-right-angle A B A) → (A = B)) (
        B A RightAngleABB

        B A A RightAngleSymmetry
        eliminateBiconditionalReverse
        applyModusPonens

        A B A RightAngleVertexLeg
        detach2of2

        B A EqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

=== Three points which are both perpendicular and collinear ===
If three points are both perpendicular and collinear, then one of the legs must be an empty line segment.<ref>l8_9 in Narboux</ref>
<jh>
thm (RightAngleCollinear () () (((is-right-angle A B C) ∧ (collinear A B C)) → ((A = B) ∨ (C = B))) (
</jh>
The <code>A = B</code> case is trivial.
<jh>
        (A = B)
          ((is-right-angle A B C) ∧ (collinear A B C))
          ConjunctionRightElimination

        (A = B) (C = B) DisjunctionRightIntroduction
        applySyllogism

        export
</jh>
The <code>A ≠ B</code> case is only slightly harder. We apply <code>RightAngleLeg</code> which in this case is <code>is-right-angle A B C ∧ A ≠ B ∧ collinear B A C → is-right-angle C B C</code>.
<jh>
        (A ≠ B)
          ((is-right-angle A B C) ∧ (collinear A B C))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        (A ≠ B)
          ((is-right-angle A B C) ∧ (collinear A B C))
          ConjunctionRightElimination
        composeConjunction

        (A ≠ B)
          ((is-right-angle A B C) ∧ (collinear A B C))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        A B C Collinearity12
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        A B C C RightAngleLeg
        applySyllogism
</jh>
Then <code>C = B</code> immediately follows from <code>is-right-angle C B C</code>.
<jh>
        C B RightAngleLegItself
        applySyllogism

        (C = B) (A = B) DisjunctionLeftIntroduction
        applySyllogism

        export
</jh>
Combining the cases we are done.
<jh>
        eliminateCases
))
</jh>

=== Slight variant of RightAngleABB ===
We'll want this straightforward consequence of <code>RightAngleABB</code> in a moment.

<jh>
thm (RightAngleABBFromEquality () ()
  ((B = C) → (is-right-angle A B C)) (
        A B RightAngleABB

        A EqualityReflexivity
        B EqualityReflexivity
        A A B B B C RightAngleBuilder
        detach2of3
        detach1of2

        detachImplicationBiconditional
))
</jh>

=== A congruence theorem ===
The only reason we rederive this theorem, rather than importing it, is to avoid editing all the interfaces between [[Betweenness of points]] and here.
<jh>
thm (NegatedCongruenceIdentityFromEquality () ()
  (((A ≠ B) ∧ (A B ≡ C D)) → (C ≠ D)) (
        A B C D CongruenceSymmetry
        eliminateBiconditionalReverse
        (A ≠ B) conjoinLL

        C D A B CongruenceIdentityFromEquality
        export
        applyComm

        (C = D) (A = B) Transposition
        eliminateBiconditionalReverse
        applySyllogism

        applyComm
        import
        applySyllogism
))
</jh>

=== An angle congruent to a right angle is a right angle ===
That is, <code>is-right-angle A B C ∧ A B C ≅ A′ B′ C′ → is-right-angle A′ B′ C′</code>.<ref>l8_10 in Narboux</ref>

We start with the <code>B = C</code> case, where we first conclude <code>B′ = C′</code> and so the conclusion follows from <code>RightAngleABB</code>.
<jh>
thm (RightAngleCongruence-b-c () ()
  (((B = C) ∧ ((is-right-angle A B C) ∧ (A B C ≅ A′ B′ C′))) → (is-right-angle A′ B′ C′)) (
        (B = C)
          ((is-right-angle A B C) ∧ (A B C ≅ A′ B′ C′))
          ConjunctionRightElimination

        (B = C)
          ((is-right-angle A B C) ∧ (A B C ≅ A′ B′ C′))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        A B C A′ B′ C′ Congruence23
        applySyllogism

        composeConjunction

        B C B′ C′ CongruenceIdentityFromEquality
        applySyllogism

        B′ C′ A′ RightAngleABBFromEquality
        applySyllogism
))
</jh>

Here's the sketch of the <code>B ≠ C</code> case. Let <code>D</code> be the point we get by expanding the definition of <code>is-right-angle A B C</code> (that is, <code>B is-midpoint-of C D ∧ A C ≡ A D</code>). Let <code>D′</code> be the symmetric point of <code>C′</code> through <code>B′</code>. Now we just need <code>A′ C′ ≡ A′ D′</code>. We apply outer five segment with baselines <code>C B D<code> and <code>C′ B′ D′</code> and points <code>A</code> and <code>A′</code>, which gives us <code>D A ≡ D′ A′</code>. We have <code>A C ≡ A D</code> from the construction of <code>D</code> and <code>A′ C′ ≡ A C</code> from <code>A B C ≅ A′ B′ C′</code>. So by transitivity, we have <code>A′ C′ ≡ A′ D′</code> which is what we needed.

It will be most convenient to start with the construction of <code>D</code> and <code>D′</code>. First we construct <code>D</code> by expanding the definition of <code>is-right-angle</code> and moving terms inside the quantifier.
<jh>
thm (RightAngleCongruence-d ((d A) (d B) (d C) (d A′) (d B′) (d C′)) ()
  (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (A B C ≅ A′ B′ C′))) →
  (∃ d ((B ≠ C) ∧
    (((B is-midpoint-of C (value d)) ∧ (A C ≡ A (value d))) ∧
      (A B C ≅ A′ B′ C′))))) (
        A B C d RightAngle
        eliminateBiconditionalReverse

        (A B C ≅ A′ B′ C′) conjoinRR
        moveRightConjunctIntoThereExistsInConsequent

        (B ≠ C) conjoinLL
        moveLeftConjunctIntoThereExistsInConsequent
))
</jh>

Next we construct <code>D′</code> as the symmetric point of <code>C′</code> through <code>B′</code>.
<jh>
thm (RightAngleCongruence-dprime ((d′ A) (d′ B) (d′ C) (d′ A′) (d′ B′) (d′ C′) (d′ D)) ()
  (((B ≠ C) ∧
    (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
      (A B C ≅ A′ B′ C′))) →
    (∃ d′ (((B ≠ C) ∧
      (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
        (A B C ≅ A′ B′ C′))) ∧
      (B′ is-midpoint-of C′ (value d′)))
    )
  ) (
        d′ B′ C′ SymmetricPoint

        ((B ≠ C) ∧
          (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
            (A B C ≅ A′ B′ C′)))
          introduceAntecedent
        repeatAntecedentThereExists
))
</jh>

Having constructed our points, we can get going, starting with <code>B′ ≠ C′</code>, which follows from <code>B ≠ C</code> and <code>A B C ≅ A′ B′ C′</code>.
<jh>
thm (RightAngleCongruence-bprime-not-cprime () ()
  ((((B ≠ C) ∧
      (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
        (A B C ≅ A′ B′ C′))) ∧
      (B′ is-midpoint-of C′ D′)) →
    (B′ ≠ C′)) (
        ((B ≠ C) ∧
          (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
            (A B C ≅ A′ B′ C′)))
          (B′ is-midpoint-of C′ D′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        ((B ≠ C) ∧
          (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
            (A B C ≅ A′ B′ C′)))
          (B′ is-midpoint-of C′ D′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        A B C A′ B′ C′ Congruence23
        applySyllogism

        composeConjunction

        B C B′ C′ NegatedCongruenceIdentityFromEquality
        applySyllogism
))
</jh>

Next is outer five segment with baselines <code>C B D<code> and <code>C′ B′ D′</code> and points <code>A</code> and <code>A′</code>, to get <code>D A ≡ D′ A′</code>.

<jh>
thm (RightAngleCongruence-d-a-dprime-aprime () ()
  ((((B ≠ C) ∧
      (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
        (A B C ≅ A′ B′ C′))) ∧
      (B′ is-midpoint-of C′ D′)) →
    (D A ≡ D′ A′)) (
</jh>
<code>C ≠ B</code>:
<jh>
        ((B ≠ C) ∧
          (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
            (A B C ≅ A′ B′ C′)))
          (B′ is-midpoint-of C′ D′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        B C EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
<code>between C B D</code>:
<jh>
        ((B ≠ C) ∧
          (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
            (A B C ≅ A′ B′ C′)))
          (B′ is-midpoint-of C′ D′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
<code>between C′ B′ D′</code>:
<jh>
        ((B ≠ C) ∧
          (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
            (A B C ≅ A′ B′ C′)))
          (B′ is-midpoint-of C′ D′)
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
<code>C B ≡ C′ B′</code>:
<jh>
        ((B ≠ C) ∧
          (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
            (A B C ≅ A′ B′ C′)))
          (B′ is-midpoint-of C′ D′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        A B C A′ B′ C′ Congruence23
        applySyllogism
        commuteCongruenceInConsequent

        composeConjunction
</jh>
Next is <code>B D ≡ B′ D′</code>, which follows from <code>B D ≡ B C</code>, <code>B C ≡ B′ C′</code>, and <code>B′ C′ ≡ B′ D′</code>.
<jh>
        ((B ≠ C) ∧
          (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
            (A B C ≅ A′ B′ C′)))
          (B′ is-midpoint-of C′ D′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        swapCongruenceInConsequent
        commuteCongruenceRightInConsequent

        ((B ≠ C) ∧
          (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
            (A B C ≅ A′ B′ C′)))
          (B′ is-midpoint-of C′ D′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        A B C A′ B′ C′ Congruence23
        applySyllogism
        applyCongruenceTransitivityInConsequent

        ((B ≠ C) ∧
          (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
            (A B C ≅ A′ B′ C′)))
          (B′ is-midpoint-of C′ D′)
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
        commuteCongruenceLeftInConsequent
        applyCongruenceTransitivityInConsequent

        composeConjunction
</jh>
<code>C A ≡ C′ A′</code>:
<jh>
        ((B ≠ C) ∧
          (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
            (A B C ≅ A′ B′ C′)))
          (B′ is-midpoint-of C′ D′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        A B C A′ B′ C′ Congruence13
        applySyllogism
        commuteCongruenceInConsequent

        composeConjunction
</jh>
<code>B A ≡ B′ A′</code>:
<jh>
        ((B ≠ C) ∧
          (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
            (A B C ≅ A′ B′ C′)))
          (B′ is-midpoint-of C′ D′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        A B C A′ B′ C′ Congruence12
        applySyllogism
        commuteCongruenceInConsequent

        composeConjunction
</jh>
Applying outer five segment gives us <code>D A ≡ D′ A′</code>.
<jh>
        C B D C′ B′ D′ A A′ OuterFiveSegment
        applySyllogism
))
</jh>

Now we apply transitivity on some line segment congruences which we already have to get <code>A′ C′ ≡ A′ D′</code>.

<jh>
thm (RightAngleCongruence-aprime-cprime-aprime-dprime () ()
  ((((B ≠ C) ∧
      (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
        (A B C ≅ A′ B′ C′))) ∧
      (B′ is-midpoint-of C′ D′)) →
    (A′ C′ ≡ A′ D′)) (
</jh>
First is <code>A′ C′ ≡ A C</code>,
<jh>
        ((B ≠ C) ∧
          (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
            (A B C ≅ A′ B′ C′)))
          (B′ is-midpoint-of C′ D′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        A B C A′ B′ C′ Congruence13
        applySyllogism
        swapCongruenceInConsequent
</jh>
followed by <code>A C ≡ A D</code>,
<jh>
        ((B ≠ C) ∧
          (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
            (A B C ≅ A′ B′ C′)))
          (B′ is-midpoint-of C′ D′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        applyCongruenceTransitivityInConsequent
</jh>
and finally <code>A D ≡ A′ D′</code>.
<jh>
        B C D A A′ B′ C′ D′ RightAngleCongruence-d-a-dprime-aprime
        commuteCongruenceInConsequent
        applyCongruenceTransitivityInConsequent
))
</jh>

That's all the major pieces of <code>is-right-angle A′ B′ C′</code>. We just need to do a bit of assembly.

<jh>
thm (RightAngleCongruence-aprime-bprime-cprime () ()
  ((((B ≠ C) ∧
    (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
      (A B C ≅ A′ B′ C′))) ∧
    (B′ is-midpoint-of C′ D′)) →
  (is-right-angle A′ B′ C′)) (
</jh>
The first piece is <code>B′ is-midpoint-of C′ D′</code>,
<jh>
        ((B ≠ C) ∧
          (((B is-midpoint-of C D) ∧ (A C ≡ A D)) ∧
            (A B C ≅ A′ B′ C′)))
          (B′ is-midpoint-of C′ D′)
          ConjunctionLeftElimination
</jh>
and the second piece is <code>A′ C′ ≡ A′ D′</code>.
<jh>
        B C D A A′ B′ C′ D′ RightAngleCongruence-aprime-cprime-aprime-dprime
        composeConjunction
</jh>
We can now turn those two pieces into <code>is-right-angle A′ B′ C′</code>.
<jh>
        B′ C′ D′ A′ RightAngleObject
        applySyllogism
))

thm (RightAngleCongruence-b-not-c
  ((d d′ A) (d d′ B) (d d′ C) (d d′ A′) (d d′ B′) (d d′ C′)) ()
  (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (A B C ≅ A′ B′ C′))) → (is-right-angle A′ B′ C′)) (
        B C A A′ B′ C′ d RightAngleCongruence-d

        B C (value d) A A′ B′ C′ d′ RightAngleCongruence-dprime
        d addThereExists
        applySyllogism

        B C (value d) A A′ B′ C′ (value d′) RightAngleCongruence-aprime-bprime-cprime
        d′ addThereExists
        d addThereExists
        applySyllogism

        removeThereExistsInConsequent
        removeThereExistsInConsequent
))

thm (RightAngleCongruence () () (((is-right-angle A B C) ∧ (A B C ≅ A′ B′ C′)) → (is-right-angle A′ B′ C′)) (
        B C A A′ B′ C′ RightAngleCongruence-b-c
        export

        B C A A′ B′ C′ RightAngleCongruence-b-not-c
        export

        eliminateCases
))
</jh>

== Perpendicular lines at a point ==
The line <code>A B</code> is perpendicular to the line <code>C D</code> at the point <code>X</code> if that point lies on both lines and if choosing one point from each line plus the vertex <code>X</code> always produces a right angle. In symbols, <code>A B C D ⟂at X</code> is defined as <code>A ≠ B ∧ C ≠ D ∧ collinear X A B ∧ collinear X A D ∧ ∀ u ∀ v (collinear u A B ∧ collinear v C D → is-right-angle u X v)</code>.

<jh>
def ((⟂at A B C D X)
  (((((A ≠ B) ∧ (C ≠ D)) ∧ (collinear X A B)) ∧ (collinear X C D)) ∧
   (∀ u (∀ v (((collinear (value u) A B) ∧ (collinear (value v) C D)) →
     (is-right-angle (value u) X (value v)))))))
</jh>

=== Definition as a theorem ===
As usual, we'll need a theorem form of the definition.
<jh>
thm (PerpendicularAt
  ((u v A) (u v B) (u v C) (u v D) (u v X)   (u′ v′ u v) (u′ v′ A) (u′ v′ B) (u′ v′ C) (u′ v′ D) (u′ v′ X)) ()
  ((A B C D ⟂at X) ↔
    (((((A ≠ B) ∧ (C ≠ D)) ∧ (collinear X A B)) ∧ (collinear X C D)) ∧
     (∀ u (∀ v (((collinear (value u) A B) ∧ (collinear (value v) C D)) →
       (is-right-angle (value u) X (value v))))))) (
</jh>
We start with <code>v = v′ → ((collinear u A B ∧ collinear v C D → is-right-angle u X v) ↔ (collinear u A B ∧ collinear v′ C D → is-right-angle u X v′))</code>.
<jh>
        D EqualityReflexivity
        C EqualityReflexivity
        (value v) (value v′) C C D D CollinearityBuilder
        detach2of3
        detach2of2

        (collinear (value u) A B) buildConjunctionLLInConsequent

        (value u) EqualityReflexivity
        X EqualityReflexivity
        (value u) (value u) X X (value v) (value v′) RightAngleBuilder
        detach2of3
        detach1of2

        buildImplicationInConsequent
</jh>
We turn that into <code>∀ u ∀ v (collinear u A B ∧ collinear v C D → is-right-angle u X v) ↔ ∀ u ∀ v′ (collinear u A B ∧ collinear v′ C D → is-right-angle u X v′)</code>.
<jh>
        ChangeVariableForAll
        u buildForAll
</jh>
Now we pull the same trick for <code>u</code>, starting with <code>u = u′ → (∀ v′ (collinear u A B ∧ collinear v′ C D → is-right-angle u X v′) ↔ ∀ v′ (collinear u′ A B ∧ collinear v′ C D → is-right-angle u′ X v′))</code>.
<jh>
        B EqualityReflexivity
        A EqualityReflexivity
        (value u) (value u′) A A B B CollinearityBuilder
        detach2of3
        detach2of2

        (collinear (value v′) C D) buildConjunctionRRInConsequent

        (value v′) EqualityReflexivity
        X EqualityReflexivity
        (value u) (value u′) X X (value v′) (value v′) RightAngleBuilder
        detach2of3
        detach2of2

        buildImplicationInConsequent

        v′ buildForAllInConsequent

        ChangeVariableForAll

        applyBiconditionalTransitivity
</jh>
That's the hard part; the bit outside the quantifiers needs no extra work.
<jh>
        ((((A ≠ B) ∧ (C ≠ D)) ∧ (collinear X A B)) ∧ (collinear X C D)) buildConjunctionLL
        swapBiconditional
))
</jh>

=== Symmetry ===
Here we prove <code>A B C D ⟂at X ↔ C D A B ⟂at X</code>.<ref>l8_12 in Narboux</ref> The concept is pretty simple: expand the definition and apply symmetry to each piece. The only thing which makes this proof a bit long is the number of pieces.
jh-will-start
thm (PerpendicularAtSymmetry () () ((A B C D ⟂at X) ↔ (C D A B ⟂at X)) (
        ((A ≠ B) ∧ (C ≠ D))
          (collinear X A B)
          (collinear X C D)
          ConjunctionAssociativity

        (A ≠ B) (C ≠ D) ConjunctionSymmetry
        (collinear X A B) (collinear X C D) ConjunctionSymmetry
        buildConjunction
        applyBiconditionalTransitivity

        ((C ≠ D) ∧ (A ≠ B))
          (collinear X C D)
          (collinear X A B)
          ConjunctionAssociativity
        swapBiconditional
        applyBiconditionalTransitivity
))
jh-will-end

== Export ==
We now export to [[Interface:Orthogonality]].
<jh>
#export (RESULTS Interface:Orthogonality (CLASSICAL FIRSTORDER) ())
</jh>

Also, since this is currently the last proof module for geometry, we export to [[Interface:Basic geometry]].
<jh>
export (GEOMETRY Interface:Basic_geometry (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>
* Tarski, Alfred; Givant, Steven (1999), "Tarski's system of geometry", The Bulletin of Symbolic Logic 5 (2): 175–214, doi:10.2307/421089, MR1791303, ISSN 1079-8986

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]
