{{interfaces
| imports = [[Interface:Midpoint]]
| exports = [[Interface:Orthogonality]]
}}

This is part of a series of modules which prove a variety of geometrical theorems starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

Here we prove results involving perpendicular lines. This also enables us to prove the existence of the midpoint of a line segment.

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Orthogonality definitions|geometry results so far]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (START Interface:Orthogonality_definitions (CLASSICAL FIRSTORDER) ())

var (formula antecedent)
var (point A B C D E F M P Q R S X Y Z)
var (point A′ B′ C′ D′ E′ M′ P′ Q′ R′ S′ X′ Y′)
var (point C″)
var (variable a a′ b b′ c c′ c″ d d′ e e′ f p p′ q r r′ x x′ y y′ z)
</jh>

== Right angles ==
We've proved a number of the results relating to <code>is-right-angle</code> in [[Orthogonality definitions]]. Here we pick up a few more (particularly ones for which the automatic expansion of definitions in [[Orthogonality definitions]] is inconvenient, and ones which follow from those).

=== Proving is-right-angle from an object ===
To prove <code>is-right-angle</code> from <code>RightAngle</code> requires that we come up with a point which satisfies the conditions of <code>RightAngle</code>. Here's a theorem which handles the logic involved in going from that point to an expression containing <code>∃</code>.<ref>not in Narboux, as coq handles this sort of thing</ref>
<jh>
thm (RightAngleObject ( (z A) (z B) (z C) (z Z)) ()
  (((B is-midpoint-of C Z) ∧ (A C ≡ A Z)) →
    (is-right-angle A B C)) (
</jh>
Our substitution is <code>z = Z → (B is-midpoint-of C z ∧ A C ≡ A z ↔ B is-midpoint-of C Z ∧ A C ≡ A Z)</code>.
<jh>
        B EqualityReflexivity
        C EqualityReflexivity
        B B C C (value z) Z MidpointBuilder
        detach2of3
        detach1of2

        C EqualityReflexivity
        A EqualityReflexivity
        A EqualityReflexivity
        A A C C A A (value z) Z CongruenceBuilder
        detach1of4
        detach2of3
        detach1of2

        buildConjunctionInConsequent
</jh>
Now we just turn that into <code>∃</code> and apply <code>RightAngle</code>.
<jh>
        makeSubstExplicit
        eliminateBiconditionalForward

        Z
          z
          ((B is-midpoint-of C (value z)) ∧ (A C ≡ A (value z)))
          ThereExistsIntroductionFromObject
        applySyllogism

        A B C z RightAngle
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

=== Swapping the vertex with one of the legs ===
Another degenerate case is <code>is-right-angle A B C ∧ is-right-angle A C B → B = C</code>.<ref>l8_7 in Narboux</ref>

Let <code>A′</code> be the symmetric point of <code>A</code> through the point <code>C</code>.

First assume <code>B ≠ C</code> (if not, we are done). Then expand <code>is-right-angle A B C</code> by the definition: <code>∃ c′ (B is-midpoint-of C c′ ∧ A C ≡ A c′)</code>. We also flip <code>is-right-angle A C B</code> to <code>is-right-angle B C A</code> and expand it according to the definition: <code>∃ a′ (C is-midpoint-of A a′ ∧ B A ≡ B a′)</code>.
<jh>
thm (RightAngleVertexLeg-cprime
  ((c′ A) (c′ B) (c′ C)) ()
  (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) →
    (∃ c′
      (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
      ((B is-midpoint-of C (value c′)) ∧ (A C ≡ A (value c′))))
  )) (
        (B ≠ C)
          ((is-right-angle A B C) ∧ (is-right-angle A C B))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        A B C c′ RightAngle
        eliminateBiconditionalReverse
        applySyllogism

        repeatAntecedentThereExists
))

thm (RightAngleVertexLeg-aprime
  ((C′ a′) (a′ A) (a′ B) (a′ C)) ()
  (
    (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
      ((B is-midpoint-of C C′) ∧ (A C ≡ A C′))) →
    (∃ a′
      ((((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
      ((B is-midpoint-of C C′) ∧ (A C ≡ A C′))) ∧
      ((C is-midpoint-of A (value a′)) ∧ (B A ≡ B (value a′))))
  )) (
        ((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B)))
          ((B is-midpoint-of C C′) ∧ (A C ≡ A C′))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        A C B RightAngleSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        B C A a′ RightAngle
        eliminateBiconditionalReverse
        applySyllogism

        repeatAntecedentThereExists
))
</jh>

Now we apply <code>RightAngleLeg</code> to get <code>is-right-angle c′ C A</code>.

<jh>
thm (RightAngleVertexLeg-cprime-c-a
  () ()
  (
    ((((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
      ((B is-midpoint-of C C′) ∧ (A C ≡ A C′))) ∧
      ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))) →
    (is-right-angle C′ C A)
  ) (
</jh>
First is <code>is-right-angle B C A</code>.
<jh>
        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        A C B RightAngleSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next is <code>B ≠ C</code>.
<jh>
        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
Finally is <code>collinear C B C′</code>.
<jh>
        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        C B C′ BetweennessCollinearity
        applySyllogism

        composeConjunction

        B C A C′ RightAngleLeg
        applySyllogism
))
</jh>

We can paraphrase the definition of <code>is-right-angle C′ C A</code> as "the symmetric point of <code>A</code> through <code>C</code> is the same distance from <code>C′</code> as <code>A</code> is". By symmetric point uniqueness, said symmetric point is just <code>A′</code>. We express this via the "uniqueness lemma", <code>is-right-angle C′ C A ∧ C is-midpoint-of A A′ → C′ A ≡ C′ A′</code>, which we prove after a few lemmas which reflect parts of its proof.
<jh>
thm (RightAngleVertexLeg-uniqueness-lemma-z-aprime () ()
  ((((C is-midpoint-of A Z) ∧ (C′ A ≡ C′ Z)) ∧ (C is-midpoint-of A A′)) → (Z = A′)) (
        ((C is-midpoint-of A Z) ∧ (C′ A ≡ C′ Z))
          (C is-midpoint-of A A′)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        ((C is-midpoint-of A Z) ∧ (C′ A ≡ C′ Z))
          (C is-midpoint-of A A′)
          ConjunctionLeftElimination

        composeConjunction

        C A Z A′ SymmetricPointUniqueness
        applySyllogism
))

thm (RightAngleVertexLeg-uniqueness-lemma-cprime-a-cprime-aprime () ()
  ((((C is-midpoint-of A Z) ∧ (C′ A ≡ C′ Z)) ∧ (C is-midpoint-of A A′)) → (C′ A ≡ C′ A′)) (
        ((C is-midpoint-of A Z) ∧ (C′ A ≡ C′ Z))
          (C is-midpoint-of A A′)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        C A Z C′ A′ RightAngleVertexLeg-uniqueness-lemma-z-aprime

        A EqualityReflexivity
        C′ EqualityReflexivity
        C′ EqualityReflexivity
        C′ C′ A A C′ C′ Z A′ CongruenceBuilder
        detach1of4
        detach2of3
        detach1of2
        eliminateBiconditionalReverseInConsequent

        applySyllogism

        applyModusPonensInConsequent
))

thm (RightAngleVertexLeg-uniqueness-lemma
  ( (z C′) (z C) (z A) (z A′)) ()
  (((is-right-angle C′ C A) ∧ (C is-midpoint-of A A′)) → (C′ A ≡ C′ A′)) (
        (is-right-angle C′ C A)
          (C is-midpoint-of A A′)
          ConjunctionRightElimination

        C′ C A z RightAngle
        eliminateBiconditionalReverse
        applySyllogism

        (is-right-angle C′ C A)
          (C is-midpoint-of A A′)
          ConjunctionLeftElimination
        composeConjunction

        moveRightConjunctIntoThereExistsInConsequent
</jh>
The consequent is now <code>∃ z (C is-midpoint-of A z ∧ C′ A ≡ C′ z ∧ C is-midpoint-of A A′)</code>, so we just need to combine with the lemmas we already proved.
<jh>
        C A (value z) C′ A′ RightAngleVertexLeg-uniqueness-lemma-cprime-a-cprime-aprime
        z addThereExists
        applySyllogism

        removeThereExistsInConsequent
))
</jh>

Our next step is <code>A′ C ≡ A′ C′</code>.
<jh>
thm (RightAngleVertexLeg-aprime-c-aprime-cprime () ()
  (
    ((((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
      ((B is-midpoint-of C C′) ∧ (A C ≡ A C′))) ∧
      ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))) →
    (A′ C ≡ A′ C′)
  ) (
</jh>
We start with <code>A′ C ≡ A C</code>, from the construction of <code>A′</code>.
<jh>
        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        swapCongruenceInConsequent
        commuteCongruenceLeftInConsequent
</jh>
Next is <code>A C ≡ A C′</code>
<jh>
        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        applyCongruenceTransitivityInConsequent
</jh>
Next is <code>A C′ ≡ A′ C′</code>, which follows readily from the uniqueness lemma. The uniqueness lemma needs <code>is-right-angle C′ C A</code> and <code>C is-midpoint-of A A′</code>, and it gives us <code>C′ A ≡ C′ A′</code>.
<jh>
        B C A C′ A′ RightAngleVertexLeg-cprime-c-a

        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        composeConjunction

        C′ C A A′ RightAngleVertexLeg-uniqueness-lemma
        applySyllogism
        commuteCongruenceInConsequent

        applyCongruenceTransitivityInConsequent
))
</jh>

Next is <code>is-right-angle A′ B C</code>.
<jh>
thm (RightAngleVertexLeg-aprime-b-c () ()
  (
    ((((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
      ((B is-midpoint-of C C′) ∧ (A C ≡ A C′))) ∧
      ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))) →
    (is-right-angle A′ B C)
  ) (
</jh>
We start with <code>B is-midpoint-of C C′ ∧ A′ C ≡ A′ C′</code>.
<jh>
        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        B C A C′ A′ RightAngleVertexLeg-aprime-c-aprime-cprime

        composeConjunction
</jh>
Applying <code>RightAngleObject</code> we are done.
<jh>
        B C C′ A′ RightAngleObject
        applySyllogism
))
</jh>

<jh>
thm (RightAngleVertexLeg-b-not-c-1 () ()
  (
    ((((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
      ((B is-midpoint-of C C′) ∧ (A C ≡ A C′))) ∧
      ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))) →
    (B = C)
  ) (
</jh>
First we need <code>is-right-angle A B C</code>.
<jh>
        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
Next we need <code>is-right-angle A′ B C</code>.
<jh>
        B C A C′ A′ RightAngleVertexLeg-aprime-b-c
        composeConjunction
</jh>
Finally we need <code>between A C A′</code>
<jh>
        (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) ∧
            ((B is-midpoint-of C C′) ∧ (A C ≡ A C′)))
          ((C is-midpoint-of A A′) ∧ (B A ≡ B A′))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction
        A B C A′ RightAngleBetween
        applySyllogism
))

thm (RightAngleVertexLeg-b-not-c
  ( (c′ A) (c′ B) (c′ C) (c′ a′) (a′ A) (a′ B) (a′ C)) ()
  (((B ≠ C) ∧ ((is-right-angle A B C) ∧ (is-right-angle A C B))) →
    (B = C)) (
        B C A c′ RightAngleVertexLeg-cprime

        B C A (value c′) a′ RightAngleVertexLeg-aprime
        c′ addThereExists
        applySyllogism

        B C A (value c′) (value a′) RightAngleVertexLeg-b-not-c-1
        a′ addThereExists
        c′ addThereExists
        applySyllogism

       removeThereExistsInConsequent
       removeThereExistsInConsequent
))

thm (RightAngleVertexLeg () ()
  (((is-right-angle A B C) ∧ (is-right-angle A C B)) → (B = C)) (
        (B = C)
          ((is-right-angle A B C) ∧ (is-right-angle A C B))
          AntecedentIntroduction

        B C A RightAngleVertexLeg-b-not-c
        export

        eliminateCases
))
</jh>

=== A leg which is perpendicular to itself ===
Another degenerate case is <code>is-right-angle A B A → A = B</code>.<ref>l8_8 in Narboux</ref> The proof is that <code>RightAngleVertexLeg</code> gives us <code>is-right-angle A B A ∧ is-right-angle A A B → A = B</code>, but <code>is-right-angle A A B</code> is a theorem, so we are done.
<jh>
thm (RightAngleLegItself () () ((is-right-angle A B A) → (A = B)) (
        B A RightAngleABB

        B A A RightAngleSymmetry
        eliminateBiconditionalReverse
        applyModusPonens

        A B A RightAngleVertexLeg
        detach2of2

        B A EqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

== Export ==
We now export to [[Interface:Orthogonality]].
<jh>
#export (RESULTS Interface:Orthogonality (CLASSICAL FIRSTORDER) ())
</jh>

Also, since this is currently the last proof module for geometry, we export to [[Interface:Basic geometry]].
<jh>
export (GEOMETRY Interface:Basic_geometry (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>
* Tarski, Alfred; Givant, Steven (1999), "Tarski's system of geometry", The Bulletin of Symbolic Logic 5 (2): 175–214, doi:10.2307/421089, MR1791303, ISSN 1079-8986

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]
