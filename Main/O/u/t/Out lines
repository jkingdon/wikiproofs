{{interfaces
| imports = [[Interface:Line segment inequality]]
| exports = [[Interface:Out lines]]
}}

This is part of a series of modules which prove a variety of geometrical theorems starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

This page gets its name from ''out lines'', that is a predicate <code>(P is-outside A B)</code> which means that <code>P</code> is on the line <code>A B</code> outside the segment <code>A B</code>. We prove a number of results based on that concept, which in turn lead to a number of theorems involving colinearity.

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Line segment inequality|geometry results so far]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (START Interface:Line_segment_inequality (CLASSICAL FIRSTORDER) ())

var (point A B C D E F P Q R A′ B′ C′ D′ E′ B″ C″)
var (variable c c′ d d′ e e′ f p)
</jh>

== Out lines defined ===
A point <code>P</code> is on the line <code>A B</code> outside the line segment <code>A B</code> if and only if one of those points is between <code>P</code> and the other and <code>P</code> is not equal to either one.<ref>Definition out in Narboux</ref>
<jh>
def ((is-outside P A B) (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A)))))
</jh>

We also state this definition as a theorem.
<jh>
thm (OutBetweenness () () ((P is-outside A B) ↔ (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A)))) (
        (P is-outside A B) BiconditionalReflexivity
))
</jh>

=== Relating out lines to existence of a point beyond the outside point ===
This section (and the next one) have to do with relating <code>P is-outside A B</code> to a point <code>C</code> for which <code>between A P C</code> and <code>between B P C</code>. The first result says that if <code>between A P C</code>, then <code>between B P C</code> is equivalent to <code>P is-outside A B</code>.<ref>l6_2 in Narboux</ref>

We first tackle the <code>between B P C → P is-outside A B</code> case. This is a straightforward application of <code>BetweennessMiddleConnectivity</code>, which in this case says basically that <code>between A P C</code> and <code>between B P C</code> imply <code>between A B P ∨ between B A P</code>.
<jh>
thm (BeyondOutForward () () ((((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C)) ∧ (between B P C)) → (P is-outside A B)) (
</jh>
The first two parts of the <code>P is-outside A B</code> definition are the inequalities <code>A ≠ P</code> and <code>B ≠ P</code> which we just carry over from the antecedent.
<jh>
        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (between B P C)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (between B P C)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
To apply <code>BetweennessMiddleConnectivity</code>, we first need <code>C ≠ P</code>.
<jh>
        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (between B P C)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
Next we need <code>between C P A</code>.
<jh>
        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (between B P C)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        A P C BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
The last thing we will need for <code>BetweennessMiddleConnectivity</code> is <code>between C P B</code>.
<jh>
        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (between B P C)
          ConjunctionLeftElimination

        B P C BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Now we apply connectivity to get <code>between P A B ∨ between P B A</code>, which is the only remaining part of the definition of <code>is-outside</code>.
<jh>
        C P A B BetweennessMiddleConnectivity
        applySyllogism

        composeConjunction
))

</jh>
In the other direction, <code>P is-outside A B</code> tells us that either <code>between P A B</code> or <code>between P B A</code>. In the either case, we can apply transitivity with <code>between A P C</code> to get <code>between B P C</code>.

We'll arrange this proof by first rearranging the disjunction and conjunctions, before we worry about transitivity.
<jh>
thm (BeyondOutReverse-1 () ()
  ((((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C)) ∧ (P is-outside A B)) →
    ((((A ≠ P) ∧ (between A P C)) ∧ (between P A B)) ∨
      (((A ≠ P) ∧ (between A P C)) ∧ (between P B A)))) (
</jh>
First we pick out <code>A ≠ P ∧ between A P C</code>.
<jh>
        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (P is-outside A B)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (P is-outside A B)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Next we take <code>P is-outside A B</code>, unfold the definition, and extract <code>between P A B ∨ between P B A</code>.
<jh>
        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (P is-outside A B)
          ConjunctionLeftElimination

        ((A ≠ P) ∧ (B ≠ P)) ((between P A B) ∨ (between P B A)) ConjunctionLeftElimination
        applySyllogism

        composeConjunction
</jh>
Applying distributivity of conjunction over disjunction finishes the job.
<jh>
        ((A ≠ P) ∧ (between A P C))
          (between P A B)
          (between P B A)
          ConjunctionLeftDistribution
        applySyllogism
))

thm (BeyondOutReverse () () ((((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C)) ∧ (P is-outside A B)) → (between B P C)) (
        A P B C BeyondOutReverse-1
</jh>
Our first transitivity invocation is <code>between B A P ∧ between A P C ∧ A ≠ P → between B P C</code>.
<jh>
        ((A ≠ P) ∧ (between A P C))
          (between P A B)
          ConjunctionLeftElimination

        P A B BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        ((A ≠ P) ∧ (between A P C))
          (between P A B)
          ConjunctionRightElimination
        eliminateLeftConjuctInConsequent

        composeConjunction

        ((A ≠ P) ∧ (between A P C))
          (between P A B)
          ConjunctionRightElimination
        eliminateRightConjuctInConsequent

        composeConjunction

        B A P C BetweennessOuterTransitivityFlipped
        applySyllogism
</jh>
Our second transitivity invocation is <code>between A B P ∧ between A P C → B P C</code>
<jh>
        ((A ≠ P) ∧ (between A P C))
          (between P B A)
          ConjunctionLeftElimination

        P B A BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        ((A ≠ P) ∧ (between A P C))
          (between P B A)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        composeConjunction

        A B P C BetweennessInnerTransitivityFlipped
        applySyllogism
</jh>
Now we combine the two.
<jh>
        composeDisjunction
        applySyllogism
))

thm (BeyondOut () () (((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C)) →
  ((between B P C) ↔ (P is-outside A B))) (
        BeyondOutForward
        export

        BeyondOutReverse
        export

        introduceBiconditionalFromImplicationsInConsequent
))
</jh>

=== The existence of a point beyond the outside point ===
In this section we show that a point is outside a line segment if and only if there exists a point beyond the outside point.  In symbols, <code>P is-outside A B</code> is equivalent to <code>A ≠ P ∧ B ≠ P ∧ ∃ c (C ≠ P ∧ between A P C ∧ between B P C)</code>.

We start with the forward implication. Extend <code>A P</code> to a distinct point <code>c</code> (that is, a point for which <code>P ≠ c ∧ between A P c</code>. We can then apply <code>BeyondOut</code> to show that <code>between B P c</code>.<ref>l6_3_1 in Narboux</ref> Below we present the formal version of this proof, broken down into several lemmas.

<jh>
thm (ExistsBeyondOutForward-bpc () () (((P is-outside A B) ∧ ((C ≠ P) ∧ (between A P C))) → (between B P C)) (
</jh>
At the end of the proof we'll need a copy of <code>P is-outside A B</code>, so we stick it on the proof stack.
<jh>
        (P is-outside A B) ((C ≠ P) ∧ (between A P C)) ConjunctionRightElimination
</jh>
Most of the proof of this lemma consists of an application of  <code>BeyondOut</code>. The first thing we need is <code>A ≠ P</code>.
<jh>
        (P is-outside A B) ((C ≠ P) ∧ (between A P C)) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
Next is <code>B ≠ P</code>
<jh>
        (P is-outside A B) ((C ≠ P) ∧ (between A P C)) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Next is <code>C ≠ P</code>
<jh>
        (P is-outside A B) ((C ≠ P) ∧ (between A P C)) ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
Last is <code>between A P C</code>.
<jh>
        (P is-outside A B) ((C ≠ P) ∧ (between A P C)) ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Applying <code>BeyondOut</code> gives us <code>between B P C ↔ P is-outside A B</code>
<jh>
        A P B C BeyondOut
        applySyllogism
</jh>
Now we detach the <code>P is-outside A B</code> part so we just have <code>between B P C</code>.
<jh>
        eliminateBiconditionalForwardInConsequent
        applyModusPonensInConsequent
))

</jh>
The next lemma is just <code>PointConstructionDifferent</code>, together with some rearrangements via commutativity and symmetry.
<jh>
thm (ExistsBeyondOutForward-c ((c A) (c P)) () (∃ c (((value c) ≠ P) ∧ (between A P (value c)))) (
        c A P PointConstructionDifferent

        (P ≠ (value c)) (between A P (value c)) ConjunctionCommutativity
        eliminateBiconditionalReverse
        c addThereExists
        applyModusPonens

        P (value c) EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        (between A P (value c)) conjoinLL
        c addThereExists
        applyModusPonens
))

thm (ExistsBeyondOutForward-3 ((c A) (c B) (c P)) () ((P is-outside A B) → (∃ c ((((value c) ≠ P) ∧ (between A P (value c))) ∧ (between B P (value c))))) (
        P A B (value c) ExistsBeyondOutForward-bpc
        export
        c addForAllToConsequent
</jh>
We now have <code>P is-outside A B → ∀ c (c ≠ P ∧ between A P c → between B P c)</code>. Combining this with the previous result gives <code>P is-outside A B → ∃ c (c ≠ P ∧ between A P c ∧ (c ≠ P ∧ between A P c → between B P c))</code>.
<jh>
        c P A ExistsBeyondOutForward-c
        introduceLeftConjunctToConsequent

        c
          (((value c) ≠ P) ∧ (between A P (value c)))
          ((((value c) ≠ P) ∧ (between A P (value c))) → (between B P (value c)))
          ThereExistsConjunctionRightCombining
</jh>
To get <code>between B P c</code> is just a matter of modus ponens. The one complication is that we want to keep <code>c ≠ P ∧ between A P c</code> around in addition, so we apply idempotence, associativity, and modus ponens, in that order.
<jh>
        (((value c) ≠ P) ∧ (between A P (value c))) ConjunctionIdempotence
        eliminateBiconditionalReverse
        ((((value c) ≠ P) ∧ (between A P (value c))) → (between B P (value c))) conjoinRR
        c addThereExists
        applySyllogism

        (((value c) ≠ P) ∧ (between A P (value c)))
          (((value c) ≠ P) ∧ (between A P (value c)))
          ((((value c) ≠ P) ∧ (between A P (value c))) → (between B P (value c)))
          ConjunctionAssociativity
        eliminateBiconditionalReverse
        c addThereExists
        applySyllogism

        (((value c) ≠ P) ∧ (between A P (value c)))
          (between B P (value c))
          ModusPonens
        (((value c) ≠ P) ∧ (between A P (value c))) conjoinLL
        c addThereExists
        applySyllogism
))

thm (ExistsBeyondOutForward ((c A) (c B) (c P)) () ((P is-outside A B) → (((A ≠ P) ∧ (B ≠ P)) ∧ (∃ c ((((value c) ≠ P) ∧ (between A P (value c))) ∧ (between B P (value c)))))) (
</jh>
First is <code>P is-outside A B → A ≠ P</code>
<jh>
        (((A ≠ P) ∧ (B ≠ P)) ((between P A B) ∨ (between P B A))) ConjunctionRightElimination
        eliminateRightConjunctInConsequent

</jh>
Next is <code>P is-outside A B → B ≠ P</code>
<jh>
        (((A ≠ P) ∧ (B ≠ P)) ((between P A B) ∨ (between P B A))) ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Next is the remainder.
<jh>
        P A B c ExistsBeyondOutForward-3
        composeConjunction
))

</jh>
We now turn to the reverse direction.<ref>l6_3_2 in Narboux</ref>
<jh>
thm (ExistsBeyondOutReverse ((c A) (c B) (c P)) () ((((A ≠ P) ∧ (B ≠ P)) ∧ (∃ c ((((value c) ≠ P) ∧ (between A P (value c))) ∧ (between B P (value c))))) → (P is-outside A B)) (
</jh>
This proof is basically an application of middle connectivity for betweenness, which in this case is <code>c ≠ P ∧ between c P A ∧ between c P B → between P A B ∨ between P B A</code>. First we need <code>c ≠ P</code>
<jh>
        (((value c) ≠ P) ∧ (between A P (value c)))
          (between B P (value c))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
</jh>
Next is <code>between c P A</code>.
<jh>
        (((value c) ≠ P) ∧ (between A P (value c)))
          (between B P (value c))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        A P (value c) BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next is <code>between c P B</code>.
<jh>
        (((value c) ≠ P) ∧ (between A P (value c)))
          (between B P (value c))
          ConjunctionLeftElimination

        B P (value c) BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
We apply connectivity, remove the quantifier from the consequent, and assemble the result.
<jh>
        (value c) P A B BetweennessMiddleConnectivity
        applySyllogism

        removeThereExistsInConsequent

        ((A ≠ P) ∧ (B ≠ P)) conjoinLL
))

thm (ExistsBeyondOut ((c A) (c B) (c P)) () ((P is-outside A B) ↔ (((A ≠ P) ∧ (B ≠ P)) ∧ (∃ c ((((value c) ≠ P) ∧ (between A P (value c))) ∧ (between B P (value c)))))) (
        P A B c ExistsBeyondOutForward
        A P B c ExistsBeyondOutReverse
        introduceBiconditionalFromImplications
))
</jh>

=== Alternate definition in terms of collinearity ===
A point is outside a line segment if and only if it is collinear with the endpoints of the segment but not between them. That is, <code>P is-outside A B ↔ collinear A P B ∧ ¬ between A P B</code>.

We first tackle the forward direction.<ref>l6_4_1 in Narboux</ref> The first lemma is <code>P ≠ A ∧ P ≠ B ∧ between P A B → ¬ between A P B</code>.
<jh>
thm (OutCollinearityForward-1 () () ((((P ≠ A) ∧ (P ≠ B)) ∧ (between P A B)) → (¬ (between A P B))) (
</jh>
First we pick out and rearrange the parts we need, specifically we prove <code>P ≠ A ∧ P ≠ B ∧ between P A B → between P A B ∧ P ≠ A</code>
<jh>
        ((P ≠ A) ∧ (P ≠ B)) (between P A B) ConjunctionLeftElimination

        ((P ≠ A) ∧ (P ≠ B)) (between P A B) ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
The geometrical content of this proof is <code>between P A B ∧ between A P B → P = A</code>.
<jh>
        P A B BetweennessEquality
</jh>
Applying some propositional logic, we rearrange this to <code>between P A B ∧ P ≠ A → ¬ between A P B</code>
<jh>
        export

        (between A P B) (P = A) Transposition
        eliminateBiconditionalReverse
        applySyllogism

        import
</jh>
Combining this with our first rearrangement, we get the desired result.
<jh>
        applySyllogism
))

The second lemma, <code>P ≠ A ∧ P ≠ B ∧ between P B A → ¬ between A P B</code>, is very similar.
<jh>
thm (OutCollinearityForward-2 () () ((((P ≠ A) ∧ (P ≠ B)) ∧ (between P B A)) → (¬ (between A P B))) (
        (P ≠ A) (P ≠ B) ConjunctionCommutativity
        eliminateBiconditionalReverse
        (between P B A) conjoinRR

        P B A OutCollinearityForward-1
        applySyllogism

        A P B BetweennessSymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

Combining the two previous lemmas we get <code>P is-outside A B → ¬ between A P B</code>.
<jh>
thm (OutCollinearityForward-3 () () ((P is-outside A B) → (¬ (between A P B))) (
        ((P ≠ A) ∧ (P ≠ B)) (between P A B) (between P B A) ConjunctionLeftDistribution

        P A B OutCollinearityForward-1
        P A B OutCollinearityForward-2
        composeDisjunction

        applySyllogism
))
</jh>

Collinearity is straightforward.
<jh>
thm (OutCollinearityForward-collinear () () ((P is-outside A B) → (collinear A P B)) (
        ((P ≠ A) ∧ (P ≠ B)) ((between P A B) ∨ (between P B A)) ConjunctionLeftElimination

        (between P A B) (between P B A) DisjunctionCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        P A B BetweennessSymmetry
        eliminateBiconditionalReverse
        (between P B A) disjoinLL
        applySyllogism

        ((between P B A) ∨ (between B A P)) (between A P B) DisjunctionLeftIntroduction
        applySyllogism
))
</jh>

Combining the last two results gives the forward direction.
<jh>
thm (OutCollinearityForward () () ((P is-outside A B) → ((collinear A P B) ∧ (¬ (between A P B)))) (
        P A B OutCollinearityForward-collinear
        P A B OutCollinearityForward-3
        composeConjunction
))
</jh>

Turning our attention to the reverse direction,<ref>l6_4_2 in Narboux</ref> we have two tasks. The first is to show that <code>P ≠ A</code> and </code>P ≠ B</code>, each of which follows from <code>¬ between A P B</code> (because either equality holding would make <code>between A P B</code> hold trivially).
<jh>
thm (OutCollinearityReverse-1 () () (((collinear A P B) ∧ (¬ (between A P B))) → ((P ≠ A) ∧ (P ≠ B))) (
        (collinear A P B) (¬ (between A P B))
        ConjunctionLeftElimination
</jh>
Next we show <code>P = A → (between P P B ↔ between A P B)</code>, and from it <code>P = A → between A P B</code>.
<jh>
        P B BetweenAAB

        P EqualityReflexivity
        B EqualityReflexivity
        P A P P B B BetweennessBuilder
        detach2of2
        detach2of2

        detachImplicationBiconditional

        introduceTransposition
</jh>
Proving <code>P = B → between A P B</code> is similar (via <code>P = B → (between A P P ↔ between A P B)</code>.
<jh>
        A P BetweenABB

        A EqualityReflexivity
        P EqualityReflexivity
        A A P P P B BetweennessBuilder
        detach2of3
        detach1of2

        detachImplicationBiconditional

        introduceTransposition

        composeConjunction

        applySyllogism
))
</jh>
Our other task is to show <code>between P A B ∨ between P B A</code>.
<jh>
thm (OutCollinearityReverse-2 () () (((collinear A P B) ∧ (¬ (between A P B))) → ((between P A B) ∨ (between P B A))) (
        (collinear A P B) (¬ (between A P B))
        ConjunctionLeftElimination

        (collinear A P B) (¬ (between A P B))
        ConjunctionRightElimination

        (between A P B) (between P B A) (between B A P) DisjunctionAssociativity
        eliminateBiconditionalReverse
        applySyllogism

        (between A P B) ((between P B A) ∨ (between B A P)) DisjunctionImplication
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        applyModusPonensInConsequent
</jh>
That gives us <code>between P B A ∨ between B A P</code>. We just need to rearrange a bit and we are done.
<jh>
        B A P BetweennessSymmetry
        eliminateBiconditionalReverse
        (between P B A) disjoinLL
        applySyllogism

        (between P B A) (between P A B) DisjunctionCommutativity
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

Combining our tasks proves the reverse direction, and combining forward and reverse directions proves the equivalence.
<jh>
thm (OutCollinearityReverse () () (((collinear A P B) ∧ (¬ (between A P B))) → (P is-outside A B)) (
        A P B OutCollinearityReverse-1
        A P B OutCollinearityReverse-2
        composeConjunction
))

thm (OutCollinearity () () ((P is-outside A B) → ((collinear A P B) ∧ (¬ (between A P B)))) (
        P A B OutCollinearityForward
        A P B OutCollinearityReverse
        introduceBiconditionalFromImplications
))
</jh>

== Reflexive, symmetric, and transitive ==
Here we present versions of reflexivity, symmetry, and transitivity. You can think of this as dividing a line (excluding the point <code>P</code> itself) into two equivalence classes: those to the left of <code>P</code> and those to the right (we certainly don't have the machinery to say it quite that way, but that is the rough idea).

=== Reflexivity ===
<jh>
thm (OutReflexivity () () ((P ≠ A) → (P is-outside A A)) (
        (P ≠ A) ConjunctionIdempotence
        eliminateBiconditionalReverse

        P A BetweenABB
        cloneAsDisjunction
        introduceRightConjunctToConsequent
))
</jh>

=== Symmetry ===
<jh>
thm (OutSymmetry () () ((P is-outside A B) ↔ (P is-outside B A)) (
        (P ≠ A) (P ≠ B) ConjunctionSymmetry
        (between P A B) (between P B A) DisjunctionSymmetry
        buildConjunction
))
</jh>

=== Transitivity ===
Expanding the definitions of the antecedent, we start with
  A ≠ P ∧ B ≠ P ∧ (between P A B ∨ between P B A) ∧
  B ≠ P ∧ C ≠ P ∧ (between P B C ∨ between P C B)
Looking at the betweenness part of that, there are four cases (<code>between P A B ∧ between P B C</code> being the first, <code>between P A B ∧ between P C B</code>, being the second, and so on).

The interesting part is a lemma which handles those four cases; there is also a fair bit of rearranging (in the lemma and in the proof of the actual theorem).

<jh>
thm (OutTransitivity () () (((B ≠ P) ∧
  (((between P A B) ∨ (between P B A)) ∧
    ((between P B C) ∨ (between P C B)))) →
  ((between P A C) ∨ (between P C A))) (
</jh>
First we break down the four cases.
<jh>
        (between P A B)
          (between P B A)
          ((between P B C) ∨ (between P C B))
          ConjunctionRightDistribution
        eliminateBiconditionalReverse

        (between P A B) (between P B C) (between P C B) ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        (between P B A) (between P B C) (between P C B) ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        disjoin

        applySyllogism

        (B ≠ P) conjoinLL
</jh>
Now we distribute the <code>B ≠ P</code> into each of the cases.
<jh>
        (B ≠ P)
          (((between P A B) ∧ (between P B C)) ∨ ((between P A B) ∧ (between P C B)))
          (((between P B A) ∧ (between P B C)) ∨ ((between P B A) ∧ (between P C B)))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        applySyllogism

        (B ≠ P)
          ((between P A B) ∧ (between P B C))
          ((between P A B) ∧ (between P C B))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        (B ≠ P)
          ((between P B A) ∧ (between P B C))
          ((between P B A) ∧ (between P C B))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        disjoin
        applySyllogism
</jh>
The first case is <code>B ≠ P ∧ between P A B ∧ between P B C</code>.  In all four cases we are showing that the case in question implies <code>between P A C ∨ between P C A</code>. In the current case, <code>between P A C</code> follows from transitivity.
<jh>
        (B ≠ P)
          ((between P A B) ∧ (between P B C))
          ConjunctionLeftElimination

        P A B C BetweennessMiddleTransitivityFlipped
        applySyllogism

        (between P A C) (between P C A) DisjunctionRightIntroduction
        applySyllogism
</jh>
The second case is <code>B ≠ P ∧ between P A B ∧ between P C B</code>.  Here we apply inner connectivity for betweenness.
<jh>
        (B ≠ P)
          ((between P A B) ∧ (between P C B))
          ConjunctionLeftElimination

        P A B C BetweennessInnerConnectivity
        applySyllogism

        composeDisjunction
</jh>
The third case is <code>B ≠ P ∧ between P B A ∧ between P B C</code>.  Here we apply outer connectivity for betweenness.
<jh>
        B P EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse

        ((between P B A) ∧ (between P B C)) conjoinRR

        P B A C BetweennessOuterConnectivity
        applySyllogism
</jh>
The fourth case is <code>B ≠ P ∧ between P B A ∧ between P C B</code>.  In this one <code>between P C A</code> follows from betweenness transitivity.
<jh>
        (B ≠ P)
          ((between P B A) ∧ (between P C B))
          ConjunctionLeftElimination

        (between P B A) (between P C B) ConjunctionCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        P C B A BetweennessMiddleTransitivityFlipped
        applySyllogism

        (between P C A) (between P A C) DisjunctionLeftIntroduction
        applySyllogism

        composeDisjunction

        composeDisjunction
))

thm (OutTransitivity () () (((P is-outside A B) ∧ (P is-outside B C)) → (P is-outside A C)) (
</jh>
First we pick out <code>A ≠ P</code>.
<jh>
        (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A))))
          (((B ≠ P) ∧ (C ≠ P)) ∧ ((between P B C) ∨ (between P C B))))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
Secondly we pick out <code>C ≠ P</code>.
<jh>
        (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A))))
          (((B ≠ P) ∧ (C ≠ P)) ∧ ((between P B C) ∨ (between P C B))))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
Next we assemble <code>B ≠ P ∧ ((between P A B ∨ between P B A) ∧ (between P B C ∨ between P C B))</code> and apply our lemma to turn this into <code>between P A C ∨ between P C A</code>.
<jh>
        (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A))))
          (((B ≠ P) ∧ (C ≠ P)) ∧ ((between P B C) ∨ (between P C B))))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A))))
          (((B ≠ P) ∧ (C ≠ P)) ∧ ((between P B C) ∨ (between P C B))))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A))))
          (((B ≠ P) ∧ (C ≠ P)) ∧ ((between P B C) ∨ (between P C B))))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction

        composeConjunction

        B P A C OutTransitivity-1
))
</jh>

== Export ==
We now export to [[Interface:Out lines]].
<jh>
#export (RESULTS Interface:Out_lines (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>
* Tarski, Alfred; Givant, Steven (1999), "Tarski's system of geometry", The Bulletin of Symbolic Logic 5 (2): 175–214, doi:10.2307/421089, MR1791303, ISSN 1079-8986

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]
