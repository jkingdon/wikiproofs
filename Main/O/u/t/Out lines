{{interfaces
| imports = [[Interface:Line segment inequality]]
| exports = [[Interface:Out lines]]
}}

This is part of a series of modules which prove a variety of geometrical theorems starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

This page gets its name from ''out lines'', that is a predicate <code>(P is-outside A B)</code> which means that <code>P</code> is on the line <code>A B</code> outside the segment <code>A B</code>. We prove a number of results based on that concept, which in turn lead to a number of theorems involving collinearity.

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Line segment inequality|geometry results so far]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (START Interface:Line_segment_inequality (CLASSICAL FIRSTORDER) ())

var (point A B C D E F P Q R X Y A′ B′ C′ D′ E′ B″ C″)
var (variable c c′ d d′ e e′ f p)
</jh>

== Out lines defined ==
A point <code>P</code> is on the line <code>A B</code> outside the line segment <code>A B</code> if and only if one of those points is between <code>P</code> and the other and <code>P</code> is not equal to either one.<ref>Definition out in Narboux</ref>
<jh>
def ((is-outside P A B) (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A))))
</jh>

We also state this definition as a theorem.
<jh>
thm (OutBetweenness () () ((P is-outside A B) ↔ (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A)))) (
        (P is-outside A B) BiconditionalReflexivity
))
</jh>

=== Relating out lines to existence of a point beyond the outside point ===
This section (and the next one) have to do with relating <code>P is-outside A B</code> to a point <code>C</code> for which <code>between A P C</code> and <code>between B P C</code>. The first result says that if <code>between A P C</code>, then <code>between B P C</code> is equivalent to <code>P is-outside A B</code>.<ref>l6_2 in Narboux</ref>

We first tackle the <code>between B P C → P is-outside A B</code> case. This is a straightforward application of <code>BetweennessMiddleConnectivity</code>, which in this case says basically that <code>between A P C</code> and <code>between B P C</code> imply <code>between A B P ∨ between B A P</code>.
<jh>
thm (BeyondOutForward () () ((((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C)) ∧ (between B P C)) → (P is-outside A B)) (
</jh>
The first two parts of the <code>P is-outside A B</code> definition are the inequalities <code>A ≠ P</code> and <code>B ≠ P</code> which we just carry over from the antecedent.
<jh>
        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (between B P C)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (between B P C)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
To apply <code>BetweennessMiddleConnectivity</code>, we first need <code>C ≠ P</code>.
<jh>
        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (between B P C)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
Next we need <code>between C P A</code>.
<jh>
        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (between B P C)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        A P C BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
The last thing we will need for <code>BetweennessMiddleConnectivity</code> is <code>between C P B</code>.
<jh>
        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (between B P C)
          ConjunctionLeftElimination

        B P C BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Now we apply connectivity to get <code>between P A B ∨ between P B A</code>, which is the only remaining part of the definition of <code>is-outside</code>.
<jh>
        C P A B BetweennessMiddleConnectivity
        applySyllogism

        composeConjunction
))

</jh>
In the other direction, <code>P is-outside A B</code> tells us that either <code>between P A B</code> or <code>between P B A</code>. In the either case, we can apply transitivity with <code>between A P C</code> to get <code>between B P C</code>.

We'll arrange this proof by first rearranging the disjunction and conjunctions, before we worry about transitivity.
<jh>
thm (BeyondOutReverse-1 () ()
  ((((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C)) ∧ (P is-outside A B)) →
    ((((A ≠ P) ∧ (between A P C)) ∧ (between P A B)) ∨
      (((A ≠ P) ∧ (between A P C)) ∧ (between P B A)))) (
</jh>
First we pick out <code>A ≠ P ∧ between A P C</code>.
<jh>
        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (P is-outside A B)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (P is-outside A B)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Next we take <code>P is-outside A B</code>, unfold the definition, and extract <code>between P A B ∨ between P B A</code>.
<jh>
        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (P is-outside A B)
          ConjunctionLeftElimination

        ((A ≠ P) ∧ (B ≠ P))
          ((between P A B) ∨ (between P B A))
          ConjunctionLeftElimination
        applySyllogism

        composeConjunction
</jh>
Applying distributivity of conjunction over disjunction finishes the job.
<jh>
        ((A ≠ P) ∧ (between A P C))
          (between P A B)
          (between P B A)
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        applySyllogism
))

thm (BeyondOutReverse () () ((((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C)) ∧ (P is-outside A B)) → (between B P C)) (
        A P B C BeyondOutReverse-1
</jh>
Our first transitivity invocation is <code>between B A P ∧ between A P C ∧ A ≠ P → between B P C</code>.
<jh>
        ((A ≠ P) ∧ (between A P C))
          (between P A B)
          ConjunctionLeftElimination

        P A B BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        ((A ≠ P) ∧ (between A P C))
          (between P A B)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        composeConjunction

        ((A ≠ P) ∧ (between A P C))
          (between P A B)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        composeConjunction

        B A P C BetweennessOuterTransitivityFlipped
        applySyllogism
</jh>
Our second transitivity invocation is <code>between A B P ∧ between A P C → B P C</code>
<jh>
        ((A ≠ P) ∧ (between A P C))
          (between P B A)
          ConjunctionLeftElimination

        P B A BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        ((A ≠ P) ∧ (between A P C))
          (between P B A)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        composeConjunction

        A B P C BetweennessInnerTransitivityFlipped
        applySyllogism
</jh>
Now we combine the two.
<jh>
        composeDisjunction
        applySyllogism
))

thm (BeyondOut () () (((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C)) →
  ((between B P C) ↔ (P is-outside A B))) (
        A P B C BeyondOutForward
        export

        A P B C BeyondOutReverse
        export

        introduceBiconditionalFromImplicationsInConsequent
))
</jh>

=== The existence of a point beyond the outside point ===
In this section we show that a point is outside a line segment if and only if there exists a point beyond the outside point.  In symbols, <code>P is-outside A B</code> is equivalent to <code>A ≠ P ∧ B ≠ P ∧ ∃ c (C ≠ P ∧ between A P C ∧ between B P C)</code>.

We start with the forward implication. Extend <code>A P</code> to a distinct point <code>c</code> (that is, a point for which <code>P ≠ c ∧ between A P c</code>. We can then apply <code>BeyondOut</code> to show that <code>between B P c</code>.<ref>l6_3_1 in Narboux</ref> Below we present the formal version of this proof, broken down into several lemmas.

<jh>
thm (ExistsBeyondOutForward-bpc () ()
  (((P is-outside A B) ∧ ((C ≠ P) ∧ (between A P C))) →
    (between B P C)) (
</jh>
At the end of the proof we'll need a copy of <code>P is-outside A B</code>, so we stick it on the proof stack.
<jh>
        (P is-outside A B) ((C ≠ P) ∧ (between A P C)) ConjunctionRightElimination
</jh>
Most of the proof of this lemma consists of an application of  <code>BeyondOut</code>. The first thing we need is <code>A ≠ P</code>.
<jh>
        (P is-outside A B) ((C ≠ P) ∧ (between A P C)) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
Next is <code>B ≠ P</code>
<jh>
        (P is-outside A B) ((C ≠ P) ∧ (between A P C)) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Next is <code>C ≠ P</code>
<jh>
        (P is-outside A B) ((C ≠ P) ∧ (between A P C)) ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
Last is <code>between A P C</code>.
<jh>
        (P is-outside A B) ((C ≠ P) ∧ (between A P C)) ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Applying <code>BeyondOut</code> gives us <code>between B P C ↔ P is-outside A B</code>
<jh>
        A P B C BeyondOut
        applySyllogism
</jh>
Now we detach the <code>P is-outside A B</code> part so we just have <code>between B P C</code>.
<jh>
        eliminateBiconditionalForwardInConsequent
        applyModusPonensInConsequent
))

</jh>
The next lemma is just <code>PointConstructionDifferent</code>, together with some rearrangements via commutativity and symmetry.
<jh>
thm (ExistsBeyondOutForward-c ((c A) (c P)) () (∃ c (((value c) ≠ P) ∧ (between A P (value c)))) (
        c A P PointConstructionDifferent

        (between A P (value c)) (P ≠ (value c)) ConjunctionCommutativity
        eliminateBiconditionalReverse
        c addThereExists
        applyModusPonens

        P (value c) EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        (between A P (value c)) conjoinRR
        c addThereExists
        applyModusPonens
))

thm (ExistsBeyondOutForward-3 ((c A) (c B) (c P)) () ((P is-outside A B) → (∃ c ((((value c) ≠ P) ∧ (between A P (value c))) ∧ (between B P (value c))))) (
        P A B (value c) ExistsBeyondOutForward-bpc
        export
        c addForAllToConsequent
</jh>
We now have <code>P is-outside A B → ∀ c (c ≠ P ∧ between A P c → between B P c)</code>. Combining this with the previous result gives <code>P is-outside A B → ∃ c (c ≠ P ∧ between A P c ∧ (c ≠ P ∧ between A P c → between B P c))</code>.
<jh>
        c P A ExistsBeyondOutForward-c
        introduceLeftConjunctToConsequent

        c
          (((value c) ≠ P) ∧ (between A P (value c)))
          ((((value c) ≠ P) ∧ (between A P (value c))) → (between B P (value c)))
          ThereExistsConjunctionRightCombining
        applySyllogism
</jh>
To get <code>between B P c</code> is just a matter of modus ponens. The one complication is that we want to keep <code>c ≠ P ∧ between A P c</code> around in addition, so we apply idempotence, associativity, and modus ponens, in that order.
<jh>
        (((value c) ≠ P) ∧ (between A P (value c))) ConjunctionIdempotence
        eliminateBiconditionalReverse
        ((((value c) ≠ P) ∧ (between A P (value c))) → (between B P (value c))) conjoinRR
        c addThereExists
        applySyllogism

        (((value c) ≠ P) ∧ (between A P (value c)))
          (((value c) ≠ P) ∧ (between A P (value c)))
          ((((value c) ≠ P) ∧ (between A P (value c))) → (between B P (value c)))
          ConjunctionAssociativity
        eliminateBiconditionalReverse
        c addThereExists
        applySyllogism

        (((value c) ≠ P) ∧ (between A P (value c)))
          (between B P (value c))
          ModusPonens
        (((value c) ≠ P) ∧ (between A P (value c))) conjoinLL
        c addThereExists
        applySyllogism
))

thm (ExistsBeyondOutForward ((c A) (c B) (c P)) ()
  ((P is-outside A B) → (((A ≠ P) ∧ (B ≠ P)) ∧
    (∃ c ((((value c) ≠ P) ∧
      (between A P (value c))) ∧ (between B P (value c)))))) (
</jh>
First is <code>P is-outside A B → A ≠ P</code>
<jh>
        ((A ≠ P) ∧ (B ≠ P)) ((between P A B) ∨ (between P B A)) ConjunctionRightElimination
        eliminateRightConjunctInConsequent

</jh>
Next is <code>P is-outside A B → B ≠ P</code>
<jh>
        ((A ≠ P) ∧ (B ≠ P)) ((between P A B) ∨ (between P B A)) ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Next is the remainder.
<jh>
        P A B c ExistsBeyondOutForward-3
        composeConjunction
))

</jh>
We now turn to the reverse direction.<ref>l6_3_2 in Narboux</ref>
<jh>
thm (ExistsBeyondOutReverse ((c A) (c B) (c P)) ()
  ((((A ≠ P) ∧ (B ≠ P)) ∧
    (∃ c ((((value c) ≠ P) ∧
      (between A P (value c))) ∧ (between B P (value c))))) →
   (P is-outside A B)) (
</jh>
This proof is basically an application of middle connectivity for betweenness, which in this case is <code>c ≠ P ∧ between c P A ∧ between c P B → between P A B ∨ between P B A</code>. First we need <code>c ≠ P</code>
<jh>
        (((value c) ≠ P) ∧ (between A P (value c)))
          (between B P (value c))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
</jh>
Next is <code>between c P A</code>.
<jh>
        (((value c) ≠ P) ∧ (between A P (value c)))
          (between B P (value c))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        A P (value c) BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Next is <code>between c P B</code>.
<jh>
        (((value c) ≠ P) ∧ (between A P (value c)))
          (between B P (value c))
          ConjunctionLeftElimination

        B P (value c) BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
We apply connectivity, remove the quantifier from the consequent, and assemble the result.
<jh>
        (value c) P A B BetweennessMiddleConnectivity
        applySyllogism

        c addThereExists
        removeThereExistsInConsequent

        ((A ≠ P) ∧ (B ≠ P)) conjoinLL
))

thm (ExistsBeyondOut ((c A) (c B) (c P)) () ((P is-outside A B) ↔ (((A ≠ P) ∧ (B ≠ P)) ∧ (∃ c ((((value c) ≠ P) ∧ (between A P (value c))) ∧ (between B P (value c)))))) (
        P A B c ExistsBeyondOutForward
        A P B c ExistsBeyondOutReverse
        introduceBiconditionalFromImplications
))
</jh>

=== Alternate definition in terms of collinearity ===
A point is outside a line segment if and only if it is collinear with the endpoints of the segment but not between them. That is, <code>P is-outside A B ↔ collinear A P B ∧ ¬ between A P B</code>.

We first tackle the forward direction.<ref>l6_4_1 in Narboux</ref> The first lemma is <code>P ≠ A ∧ P ≠ B ∧ between P A B → ¬ between A P B</code>.
<jh>
thm (OutCollinearityForward-1 () () ((((A ≠ P) ∧ (B ≠ P)) ∧ (between P A B)) → (¬ (between A P B))) (
</jh>
First we pick out and rearrange the parts we need, specifically we prove <code>P ≠ A ∧ P ≠ B ∧ between P A B → between P A B ∧ P ≠ A</code>
<jh>
        ((A ≠ P) ∧ (B ≠ P)) (between P A B) ConjunctionLeftElimination

        ((A ≠ P) ∧ (B ≠ P)) (between P A B) ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
The geometrical content of this proof is <code>between P A B ∧ between A P B → A = P</code>.
<jh>
        P A B BetweennessEquality

        P A EqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Applying some propositional logic, we rearrange this to <code>between P A B ∧ A ≠ P → ¬ between A P B</code>
<jh>
        export

        (between A P B) (A = P) Transposition
        eliminateBiconditionalReverse
        applySyllogism

        import
</jh>
Combining this with our first rearrangement, we get the desired result.
<jh>
        applySyllogism
))
</jh>

The second lemma, <code>A ≠ P ∧ B ≠ P ∧ between P B A → ¬ between A P B</code>, is very similar.
<jh>
thm (OutCollinearityForward-2 () () ((((A ≠ P) ∧ (B ≠ P)) ∧ (between P B A)) → (¬ (between A P B))) (
        (A ≠ P) (B ≠ P) ConjunctionCommutativity
        eliminateBiconditionalReverse
        (between P B A) conjoinRR

        B P A OutCollinearityForward-1
        applySyllogism

        B P A BetweennessSymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

Combining the two previous lemmas we get <code>P is-outside A B → ¬ between A P B</code>.
<jh>
thm (OutCollinearityForward-3 () () ((P is-outside A B) → (¬ (between A P B))) (
        ((A ≠ P) ∧ (B ≠ P)) (between P A B) (between P B A) ConjunctionLeftDistribution
        eliminateBiconditionalReverse

        A P B OutCollinearityForward-1
        A P B OutCollinearityForward-2
        composeDisjunction

        applySyllogism
))
</jh>

Collinearity is straightforward.
<jh>
thm (OutCollinearityForward-collinear () () ((P is-outside A B) → (collinear A P B)) (
        ((A ≠ P) ∧ (B ≠ P)) ((between P A B) ∨ (between P B A)) ConjunctionLeftElimination

        (between P A B) (between P B A) DisjunctionCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        P A B BetweennessSymmetry
        eliminateBiconditionalReverse
        (between P B A) disjoinLL
        applySyllogism

        ((between P B A) ∨ (between B A P)) (between A P B) DisjunctionLeftIntroduction
        applySyllogism

        (between A P B) (between P B A) (between B A P) DisjunctionAssociativity
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

Combining the last two results gives the forward direction.
<jh>
thm (OutCollinearityForward () () ((P is-outside A B) → ((collinear A P B) ∧ (¬ (between A P B)))) (
        P A B OutCollinearityForward-collinear
        P A B OutCollinearityForward-3
        composeConjunction
))
</jh>

Turning our attention to the reverse direction,<ref>l6_4_2 in Narboux</ref> we have two tasks. The first is to show that <code>P ≠ A</code> and </code>P ≠ B</code>, each of which follows from <code>¬ between A P B</code> (because either equality holding would make <code>between A P B</code> hold trivially).
<jh>
thm (OutCollinearityReverse-1 () () (((collinear A P B) ∧ (¬ (between A P B))) → ((A ≠ P) ∧ (B ≠ P))) (
        (collinear A P B) (¬ (between A P B))
        ConjunctionLeftElimination
</jh>
Next we show <code>A = P → (between A P B ↔ between P P B)</code>, and from it <code>A = P → between A P B</code>.
<jh>
        P B BetweenAAB

        P EqualityReflexivity
        B EqualityReflexivity
        A P P P B B BetweennessBuilder
        detach2of2
        detach2of2

        detachImplicationBiconditionalRight

        introduceTransposition
</jh>
Proving <code>B = P → between A P B</code> is similar (via <code>B = P → (between A P B ↔ between A P P)</code>.
<jh>
        A P BetweenABB

        A EqualityReflexivity
        P EqualityReflexivity
        A A P P B P BetweennessBuilder
        detach2of3
        detach1of2

        detachImplicationBiconditionalRight

        introduceTransposition

        composeConjunction

        applySyllogism
))
</jh>
Our other task is to show <code>between P A B ∨ between P B A</code>.
<jh>
thm (OutCollinearityReverse-2 () ()
  (((collinear A P B) ∧ (¬ (between A P B))) →
    ((between P A B) ∨ (between P B A))) (
</jh>
First we show <code>collinear A P B ∧ ¬ between A P B → between P B A ∨ between P A B</code>
<jh>
        (between A P B) (between P B A) (between B A P) DisjunctionAssociativity
        eliminateBiconditionalReverse

        (between A P B) ((between P B A) ∨ (between B A P)) DisjunctionImplication
        eliminateBiconditionalReverse
        applySyllogism

        import
</jh>
That gives us <code>between P B A ∨ between B A P</code>. We just need to rearrange a bit and we are done.
<jh>
        B A P BetweennessSymmetry
        eliminateBiconditionalReverse
        (between P B A) disjoinLL
        applySyllogism

        (between P B A) (between P A B) DisjunctionCommutativity
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

Combining our tasks proves the reverse direction, and combining forward and reverse directions proves the equivalence.
<jh>
thm (OutCollinearityReverse () () (((collinear A P B) ∧ (¬ (between A P B))) → (P is-outside A B)) (
        A P B OutCollinearityReverse-1
        A P B OutCollinearityReverse-2
        composeConjunction
))

thm (OutCollinearity () () ((P is-outside A B) ↔ ((collinear A P B) ∧ (¬ (between A P B)))) (
        P A B OutCollinearityForward
        A P B OutCollinearityReverse
        introduceBiconditionalFromImplications
))
</jh>

== Reflexive, symmetric, and transitive ==
Here we present versions of reflexivity, symmetry, and transitivity. You can think of this as dividing a line (excluding the point <code>P</code> itself) into two equivalence classes: those to the left of <code>P</code> and those to the right (we certainly don't have the machinery to say it quite that way, but that is the rough idea).

=== Reflexivity ===
<jh>
thm (OutReflexivity () () ((A ≠ P) → (P is-outside A A)) (
        (A ≠ P) ConjunctionIdempotence
        eliminateBiconditionalReverse

        P A BetweenABB
        cloneAsDisjunction
        introduceRightConjunctToConsequent
))
</jh>

=== Symmetry ===
<jh>
thm (OutSymmetry () () ((P is-outside A B) ↔ (P is-outside B A)) (
        (A ≠ P) (B ≠ P) ConjunctionCommutativity
        (between P A B) (between P B A) DisjunctionCommutativity
        buildConjunction
))
</jh>

=== Transitivity ===
Expanding the definitions of the antecedent, we start with
  A ≠ P ∧ B ≠ P ∧ (between P A B ∨ between P B A) ∧
  B ≠ P ∧ C ≠ P ∧ (between P B C ∨ between P C B)
Looking at the betweenness part of that, there are four cases (<code>between P A B ∧ between P B C</code> being the first, <code>between P A B ∧ between P C B</code>, being the second, and so on).

The interesting part is a lemma which handles those four cases; there is also a fair bit of rearranging (in the lemma and in the proof of the actual theorem).

<jh>
thm (OutTransitivity-1 () () (((B ≠ P) ∧
  (((between P A B) ∨ (between P B A)) ∧
    ((between P B C) ∨ (between P C B)))) →
  ((between P A C) ∨ (between P C A))) (
</jh>
First we break down the four cases.
<jh>
        (between P A B)
          (between P B A)
          ((between P B C) ∨ (between P C B))
          ConjunctionRightDistribution
        eliminateBiconditionalReverse

        (between P A B) (between P B C) (between P C B) ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        (between P B A) (between P B C) (between P C B) ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        disjoin

        applySyllogism

        (B ≠ P) conjoinLL
</jh>
Now we distribute the <code>B ≠ P</code> into each of the cases.
<jh>
        (B ≠ P)
          (((between P A B) ∧ (between P B C)) ∨ ((between P A B) ∧ (between P C B)))
          (((between P B A) ∧ (between P B C)) ∨ ((between P B A) ∧ (between P C B)))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        applySyllogism

        (B ≠ P)
          ((between P A B) ∧ (between P B C))
          ((between P A B) ∧ (between P C B))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        (B ≠ P)
          ((between P B A) ∧ (between P B C))
          ((between P B A) ∧ (between P C B))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        disjoin
        applySyllogism
</jh>
The first case is <code>B ≠ P ∧ between P A B ∧ between P B C</code>.  In all four cases we are showing that the case in question implies <code>between P A C ∨ between P C A</code>. In the current case, <code>between P A C</code> follows from transitivity.
<jh>
        (B ≠ P)
          ((between P A B) ∧ (between P B C))
          ConjunctionLeftElimination

        P A B C BetweennessMiddleTransitivityFlipped
        applySyllogism

        (between P A C) (between P C A) DisjunctionRightIntroduction
        applySyllogism
</jh>
The second case is <code>B ≠ P ∧ between P A B ∧ between P C B</code>.  Here we apply inner connectivity for betweenness.
<jh>
        (B ≠ P)
          ((between P A B) ∧ (between P C B))
          ConjunctionLeftElimination

        P A B C BetweennessInnerConnectivity
        applySyllogism

        composeDisjunction
</jh>
The third case is <code>B ≠ P ∧ between P B A ∧ between P B C</code>.  Here we apply outer connectivity for betweenness.
<jh>
        B P EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse

        ((between P B A) ∧ (between P B C)) conjoinRR

        (P ≠ B) (between P B A) (between P B C) ConjunctionAssociativity
        eliminateBiconditionalForward
        applySyllogism

        P B A C BetweennessOuterConnectivity
        applySyllogism
</jh>
The fourth case is <code>B ≠ P ∧ between P B A ∧ between P C B</code>.  In this one <code>between P C A</code> follows from betweenness transitivity.
<jh>
        (B ≠ P)
          ((between P B A) ∧ (between P C B))
          ConjunctionLeftElimination

        (between P B A) (between P C B) ConjunctionCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        P C B A BetweennessMiddleTransitivityFlipped
        applySyllogism

        (between P C A) (between P A C) DisjunctionLeftIntroduction
        applySyllogism

        composeDisjunction

        composeDisjunction

        applySyllogism
))

thm (OutTransitivity () () (((P is-outside A B) ∧ (P is-outside B C)) → (P is-outside A C)) (
</jh>
First we pick out <code>A ≠ P</code>.
<jh>
        (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A)))
          (((B ≠ P) ∧ (C ≠ P)) ∧ ((between P B C) ∨ (between P C B)))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
Secondly we pick out <code>C ≠ P</code>.
<jh>
        (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A)))
          (((B ≠ P) ∧ (C ≠ P)) ∧ ((between P B C) ∨ (between P C B)))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Next we assemble <code>B ≠ P ∧ ((between P A B ∨ between P B A) ∧ (between P B C ∨ between P C B))</code> and apply our lemma to turn this into <code>between P A C ∨ between P C A</code>.
<jh>
        (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A)))
          (((B ≠ P) ∧ (C ≠ P)) ∧ ((between P B C) ∨ (between P C B)))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A)))
          (((B ≠ P) ∧ (C ≠ P)) ∧ ((between P B C) ∨ (between P C B)))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A)))
          (((B ≠ P) ∧ (C ≠ P)) ∧ ((between P B C) ∨ (between P C B)))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction

        composeConjunction

        B P A C OutTransitivity-1

        applySyllogism

        composeConjunction
))
</jh>

== Line segment construction ==
From a given point, in the direction of a second given point, we construct a segment congruent to a given line segment. This is similar to <code>InnerSegmentConstruction</code> but is expressed in terms of <code>is-outside</code>.

=== Existence ===
In this section we prove the existence of such a point. That is, <code>R ≠ A ∧ B ≠ C → ∃ e (A is-outside e R ∧ A e ≡ B C)</code>.

The proof consists of applying <code>InnerSegmentConstruction</code>, rearranging, and applying the definition of <code>is-outside</code>. The following lemma expresses most of the rearrangements.<ref>l6_11_existence in Narboux</ref>
<jh>
thm (OutSegmentConstructionLemma () ()
  ((((R ≠ A) ∧ (B ≠ C)) ∧
    (((between A R E) ∨ (between A E R)) ∧
      (A E ≡ B C))) →
  ((A is-outside E R) ∧ (A E ≡ B C))) (
</jh>
To apply the definition of <code>A is-outside E R</code>, first we need <code>E ≠ A</code>. This follows from <code>B ≠ C</code> and <code>A E ≡ B C</code>, and the first step is picking out those two formulas.
<jh>
        ((R ≠ A) ∧ (B ≠ C))
          (((between A R E) ∨ (between A E R)) ∧
            (A E ≡ B C))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        ((R ≠ A) ∧ (B ≠ C))
          (((between A R E) ∨ (between A E R)) ∧
            (A E ≡ B C))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
The next step in getting to <code>E ≠ A</code> is to show that <code>B ≠ C ∧ A E ≡ B C → A ≠ E</code>.
<jh>
        A E B C CongruenceIdentityFromEquality
        export
        applyComm

        (A = E) (B = C) Transposition
        eliminateBiconditionalReverse
        applySyllogism

        applyComm
        import
</jh>
Combining that with the previous result and flipping the two sides of the not-equals sign gives us <code>E ≠ A</code>.
<jh>
        applySyllogism

        A E EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next we need <code>R ≠ A</code>.
<jh>
        ((R ≠ A) ∧ (B ≠ C))
          (((between A R E) ∨ (between A E R)) ∧
            (A E ≡ B C))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
Then we need <code>between A E R ∨ between A R E</code>
<jh>
        ((R ≠ A) ∧ (B ≠ C))
          (((between A R E) ∨ (between A E R)) ∧
            (A E ≡ B C))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        (between A R E) (between A E R)
        DisjunctionCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
That's all for <code>A is-outside E R</code>. So the only remaining step is <code>A E ≡ B C</code>
<jh>
        ((R ≠ A) ∧ (B ≠ C))
          (((between A R E) ∨ (between A E R)) ∧
            (A E ≡ B C))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
))

thm (OutSegmentConstruction ((e R) (e A) (e B) (e C)) ()
  (((R ≠ A) ∧ (B ≠ C)) →
    (∃ e ((A is-outside (value e) R) ∧ (A (value e) ≡ B C)))) (
        ((R ≠ A) ∧ (B ≠ C)) ImplicationReflexivity
        e A R B C InnerSegmentConstruction
        introduceRightConjunctToConsequent

        e
          ((R ≠ A) ∧ (B ≠ C))
          (((between A R (value e)) ∨ (between A (value e) R)) ∧
            (A (value e) ≡ B C))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        applySyllogism

        R A B C (value e) OutSegmentConstructionLemma
        e addThereExists
        applySyllogism
))
</jh>

=== Uniqueness ===
The point that we construct this way is also unique. In symbols, <code>R ≠ A ∧ B ≠ C ∧ A is-outside X R ∧ A X ≡ B C ∧ A is-outside Y R ∧ A Y ≡ B C → X = Y</code>.

The proof of uniqueness is more involved than the existence proof. Start by expanding the definitions of <code>is-outside</code> (and removing the redundant copies of <code>R ≠ A</code>) so we now have
  R ≠ A ∧ B ≠ C ∧
  X ≠ A ∧ (between A X R ∨ between A R X) ∧
  A X ≡ B C ∧
  Y ≠ A ∧ (between A Y R ∨ between A R Y) ∧
  A Y ≡ B C

By congruence transitivity, we derive <code>A X ≡ A Y</code>. Then we look at the betweenness relationships. Specifically we want to conclude <code>between A X Y ∨ between A Y X</code>. There are four cases: <code>between A X R ∧ between A Y R → between A X Y ∨ between A Y X</code> by inner connectivity, <code>between A X R ∧ between A R Y → between A X Y</code> by transitivity, <code>between A R X ∧ between A Y R → between A Y X</code> by transitivity, and <code>A ≠ R ∧ between A R X ∧ between A R Y → between A X Y ∨ between A Y X</code> by outer connectivity.

Once we have <code>A X ≡ A Y</code> and <code>between A X Y ∨ between A Y X</code>, <code>X = Y</code> follows from <code>BetweennessOneDistanceUniqueness</code> (applied twice, once to each of the betweenness formulas).

Our first lemma just spells out the four cases.
<jh>
thm (OutSegmentConstructionUniqueness-cases () () 
  (((((((R ≠ A) ∧ (B ≠ C)) ∧
    (A is-outside X R)) ∧ (A X ≡ B C)) ∧
    (A is-outside Y R)) ∧ (A Y ≡ B C)) →
  (((((between A X R) ∧ (between A Y R)) ∨
    ((between A X R) ∧ (between A R Y))) ∨
    ((between A R X) ∧ (between A Y R))) ∨
    (((A ≠ R) ∧ (between A R X)) ∧ (between A R Y)))) (
))

thm (OutSegmentConstructionUniqueness-axay () () 
  (((((((R ≠ A) ∧ (B ≠ C)) ∧
    (A is-outside X R)) ∧ (A X ≡ B C)) ∧
    (A is-outside Y R)) ∧ (A Y ≡ B C)) →
  (A X ≡ A Y)) (
))

thm (OutSegmentConstructionUniqueness () () 
  (((((((R ≠ A) ∧ (B ≠ C)) ∧
    (A is-outside X R)) ∧ (A X ≡ B C)) ∧
    (A is-outside Y R)) ∧ (A Y ≡ B C)) →
  (X = Y)) (
))
</jh>

== Line segment construction ==
From a given point, in the direction of a second given point, we construct a segment congruent to a given line segment. This is similar to <code>InnerSegmentConstruction</code> but is expressed in terms of <code>is-outside</code>.

=== Existence ===
In this section we prove the existence of such a point. That is, <code>R ≠ A ∧ B ≠ C → ∃ e (A is-outside e R ∧ A e ≡ B C)</code>.

The proof consists of applying <code>InnerSegmentConstruction</code>, rearranging, and applying the definition of <code>is-outside</code>. The following lemma expresses most of the rearrangements.<ref>l6_11_existence in Narboux</ref>
<jh>
thm (OutSegmentConstructionLemma () ()
  ((((R ≠ A) ∧ (B ≠ C)) ∧
    (((between A R E) ∨ (between A E R)) ∧
      (A E ≡ B C))) →
  ((A is-outside E R) ∧ (A E ≡ B C))) (
</jh>
To apply the definition of <code>A is-outside E R</code>, first we need <code>E ≠ A</code>. This follows from <code>B ≠ C</code> and <code>A E ≡ B C</code>, and the first step is picking out those two formulas.
<jh>
        ((R ≠ A) ∧ (B ≠ C))
          (((between A R E) ∨ (between A E R)) ∧
            (A E ≡ B C))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        ((R ≠ A) ∧ (B ≠ C))
          (((between A R E) ∨ (between A E R)) ∧
            (A E ≡ B C))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
The next step in getting to <code>E ≠ A</code> is to show that <code>B ≠ C ∧ A E ≡ B C → A ≠ E</code>.
<jh>
        A E B C CongruenceIdentityFromEquality
        export
        applyComm

        (A = E) (B = C) Transposition
        eliminateBiconditionalReverse
        applySyllogism

        applyComm
        import
</jh>
Combining that with the previous result and flipping the two sides of the not-equals sign gives us <code>E ≠ A</code>.
<jh>
        applySyllogism

        A E EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next we need <code>R ≠ A</code>.
<jh>
        ((R ≠ A) ∧ (B ≠ C))
          (((between A R E) ∨ (between A E R)) ∧
            (A E ≡ B C))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
Then we need <code>between A E R ∨ between A R E</code>
<jh>
        ((R ≠ A) ∧ (B ≠ C))
          (((between A R E) ∨ (between A E R)) ∧
            (A E ≡ B C))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        (between A R E) (between A E R)
        DisjunctionCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
That's all for <code>A is-outside E R</code>. So the only remaining step is <code>A E ≡ B C</code>
<jh>
        ((R ≠ A) ∧ (B ≠ C))
          (((between A R E) ∨ (between A E R)) ∧
            (A E ≡ B C))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
))

thm (OutSegmentConstruction ((e R) (e A) (e B) (e C)) ()
  (((R ≠ A) ∧ (B ≠ C)) →
    (∃ e ((A is-outside (value e) R) ∧ (A (value e) ≡ B C)))) (
        ((R ≠ A) ∧ (B ≠ C)) ImplicationReflexivity
        e A R B C InnerSegmentConstruction
        introduceRightConjunctToConsequent

        e
          ((R ≠ A) ∧ (B ≠ C))
          (((between A R (value e)) ∨ (between A (value e) R)) ∧
            (A (value e) ≡ B C))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        applySyllogism

        R A B C (value e) OutSegmentConstructionLemma
        e addThereExists
        applySyllogism
))
</jh>

=== Uniqueness ===
The point that we construct this way is also unique. In symbols, <code>R ≠ A ∧ B ≠ C ∧ A is-outside X R ∧ A X ≡ B C ∧ A is-outside Y R ∧ A Y ≡ B C → X = Y</code>.<ref>l6_11_unicity in Narboux</ref>

The proof of uniqueness is more involved than the existence proof. Start by expanding the definitions of <code>is-outside</code> (and removing the redundant copies of <code>R ≠ A</code>) so we now have
  R ≠ A ∧ B ≠ C ∧
  X ≠ A ∧ (between A X R ∨ between A R X) ∧
  A X ≡ B C ∧
  Y ≠ A ∧ (between A Y R ∨ between A R Y) ∧
  A Y ≡ B C

By congruence transitivity, we derive <code>A X ≡ A Y</code>. Then we look at the betweenness relationships. Specifically we want to conclude <code>between A X Y ∨ between A Y X</code>. There are four cases: <code>between A X R ∧ between A Y R → between A X Y ∨ between A Y X</code> by inner connectivity, <code>between A X R ∧ between A R Y → between A X Y</code> by transitivity, <code>between A R X ∧ between A Y R → between A Y X</code> by transitivity, and <code>A ≠ R ∧ between A R X ∧ between A R Y → between A X Y ∨ between A Y X</code> by outer connectivity.

Once we have <code>A X ≡ A Y</code> and <code>between A X Y ∨ between A Y X</code>, <code>X = Y</code> follows from <code>BetweennessOneDistanceUniqueness</code> (applied twice, once to each of the betweenness formulas).

Our first lemma just spells out the four cases.
<jh>
thm (OutSegmentConstructionUniqueness-cases () () 
  (((((((R ≠ A) ∧ (B ≠ C)) ∧
    (A is-outside X R)) ∧ (A X ≡ B C)) ∧
    (A is-outside Y R)) ∧ (A Y ≡ B C)) →
  ((((between A X R) ∧ (between A Y R)) ∨
    ((between A X R) ∧ (between A R Y))) ∨
    (((between A R X) ∧ (between A Y R)) ∨
    (((A ≠ R) ∧ (between A R X)) ∧ (between A R Y))))) (
</jh>
First is <code>A ≠ R</code>.
<jh>
        (((((R ≠ A) ∧ (B ≠ C)) ∧
          (A is-outside X R)) ∧ (A X ≡ B C)) ∧
          (A is-outside Y R))
          (A Y ≡ B C)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        R A EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next is <code>between A X R ∨ between A R X</code>
<jh>
        (((((R ≠ A) ∧ (B ≠ C)) ∧
          (A is-outside X R)) ∧ (A X ≡ B C)) ∧
          (A is-outside Y R))
          (A Y ≡ B C)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
Next is <code>between A Y R ∨ between A R Y</code>
<jh>
        (((((R ≠ A) ∧ (B ≠ C)) ∧
          (A is-outside X R)) ∧ (A X ≡ B C)) ∧
          (A is-outside Y R))
          (A Y ≡ B C)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction

        composeConjunction
</jh>
Now we apply distributivity to expand the four cases.
<jh>
        (between A X R)
          (between A R X)
          ((between A Y R) ∨ (between A R Y))
          ConjunctionRightDistribution
        eliminateBiconditionalReverse

        (between A X R) (between A Y R) (between A R Y) ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        (between A R X) (between A Y R) (between A R Y) ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        disjoin

        applySyllogism

        (A ≠ R) conjoinLL

        applySyllogism
</jh>
Now we distribute the <code>A ≠ R</code> into each of the cases.
<jh>
        (A ≠ R)
          (((between A X R) ∧ (between A Y R)) ∨ ((between A X R) ∧ (between A R Y)))
          (((between A R X) ∧ (between A Y R)) ∨ ((between A R X) ∧ (between A R Y)))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        applySyllogism

        (A ≠ R)
          ((between A X R) ∧ (between A Y R))
          ((between A X R) ∧ (between A R Y))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        (A ≠ R)
          ((between A R X) ∧ (between A Y R))
          ((between A R X) ∧ (between A R Y))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        disjoin
        applySyllogism
</jh>
Now we remove <code>A ≠ R</code> from the first three cases, and apply associativity to the fourth.
<jh>
        (A ≠ R) ((between A X R) ∧ (between A Y R)) ConjunctionLeftElimination
        (A ≠ R) ((between A X R) ∧ (between A R Y)) ConjunctionLeftElimination
        disjoin

        (A ≠ R) ((between A R X) ∧ (between A Y R)) ConjunctionLeftElimination

        (A ≠ R) (between A R X) (between A R Y) ConjunctionAssociativity
        eliminateBiconditionalForward

        disjoin
        disjoin
        applySyllogism
))

thm (OutSegmentConstructionUniqueness-axy-ayx () () 
  (((((((R ≠ A) ∧ (B ≠ C)) ∧
    (A is-outside X R)) ∧ (A X ≡ B C)) ∧
    (A is-outside Y R)) ∧ (A Y ≡ B C)) →
  ((between A X Y) ∨ (between A Y X))) (
        R A B C X Y OutSegmentConstructionUniqueness-cases
</jh>
The first of the four cases is <code>between A X R ∧ between A Y R</code>.
<jh>
        A X R Y BetweennessInnerConnectivity
</jh>
The second case is <code>between A X R ∧ between A R Y</code>.
<jh>
        A X R Y BetweennessMiddleTransitivityFlipped
        (between A X Y) (between A Y X) DisjunctionRightIntroduction
        applySyllogism

        composeDisjunction
</jh>
The third case is <code>between A R X ∧ between A Y R</code>.
<jh>
        (between A R X) (between A Y R) ConjunctionCommutativity
        eliminateBiconditionalReverse

        A Y R X BetweennessMiddleTransitivityFlipped
        (between A Y X) (between A X Y) DisjunctionLeftIntroduction
        applySyllogism

        applySyllogism
</jh>
The fourth case is <code>A ≠ R ∧ between A R X ∧ between A R Y</code>.
<jh>
        A R X Y BetweennessOuterConnectivity

        composeDisjunction

        composeDisjunction

        applySyllogism
))

thm (OutSegmentConstructionUniqueness-axay () () 
  (((((((R ≠ A) ∧ (B ≠ C)) ∧
    (A is-outside X R)) ∧ (A X ≡ B C)) ∧
    (A is-outside Y R)) ∧ (A Y ≡ B C)) →
  (A X ≡ A Y)) (
        (((((R ≠ A) ∧ (B ≠ C)) ∧
          (A is-outside X R)) ∧ (A X ≡ B C)) ∧
          (A is-outside Y R))
          (A Y ≡ B C)
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        (((((R ≠ A) ∧ (B ≠ C)) ∧
          (A is-outside X R)) ∧ (A X ≡ B C)) ∧
          (A is-outside Y R))
          (A Y ≡ B C)
          ConjunctionLeftElimination

        A Y B C CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        A X B C A Y CongruenceTransitivity
        applySyllogism
))

thm (OutSegmentConstructionUniqueness () () 
  (((((((R ≠ A) ∧ (B ≠ C)) ∧
    (A is-outside X R)) ∧ (A X ≡ B C)) ∧
    (A is-outside Y R)) ∧ (A Y ≡ B C)) →
  (X = Y)) (
</jh>
We first arrange the results of the two previous lemmas to get <code>(between A X Y ∧ A X ≡ A Y) ∨ (between A Y X ∧ A X ≡ A Y)</code>.
<jh>
        R A B C X Y OutSegmentConstructionUniqueness-axy-ayx
        R A B C X Y OutSegmentConstructionUniqueness-axay
        composeConjunction

        (between A X Y) (between A Y X) (A X ≡ A Y) ConjunctionRightDistribution
        eliminateBiconditionalReverse
        applySyllogism
</jh>
The result for the first half is <code>between A X Y ∧ A X ≡ A Y → X = Y</code>, which follows directly from <code>BetweennessOneDistanceUniqueness</code>.
<jh>
        A X Y BetweennessOneDistanceUniqueness
</jh>
The second half result, <code>between A Y X ∧ A X ≡ A Y → X = Y</code>, is basically the same thing, but we need to rearrange slightly.
<jh>
        A X A Y CongruenceSymmetry
        eliminateBiconditionalReverse
        (between A Y X) conjoinLL

        A Y X BetweennessOneDistanceUniqueness
        applySyllogism

        Y X EqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Now we combine the two halves.
<jh>
        composeDisjunction
        applySyllogism
))
</jh>

== The closer point is between ==
If <code>A</code> and <code>B</code> are on a line with <code>P</code>, both on the same side of <code>P</code>, and <code>A</code> is closer to <code>P</code> than <code>B</code> is, then <code>A</code> is between <code>P</code> and <code>B</code>. That is, <code>P is-outside A B ∧ P A ≤ P B → between P A B</code>.<ref>l6_13_1 is Narboux/ref>

The proof begins by expanding <code>P A ≤ P B</code> to <code>∃ y (between P y B ∧ P A ≡ P y)</code>. From <code>P is-outside A B</code> and <code>P A ≡ P y</code> we can conclude <code>P ≠ y</code>.

want y = A
  (((((((B ≠ P) ∧ (P ≠ y)) ∧
    (P is-outside y B)) ∧ (P y ≡ P y)) ∧
    (P is-outside A B)) ∧ (P A ≡ P y)) →
  (y = A)) (
want P is-outside y B
  P ≠ y ∧ P ≠ B ∧ (between P y B ∨ between P B y)

== Export ==
We now export to [[Interface:Out lines]].
<jh>
#export (RESULTS Interface:Out_lines (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>
* Tarski, Alfred; Givant, Steven (1999), "Tarski's system of geometry", The Bulletin of Symbolic Logic 5 (2): 175–214, doi:10.2307/421089, MR1791303, ISSN 1079-8986

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]
