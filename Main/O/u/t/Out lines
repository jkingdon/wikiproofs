{{interfaces
| imports = [[Interface:Line segment inequality]]
| exports = [[Interface:Out lines]]
}}

This is part of a series of modules which prove a variety of geometrical theorems starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

This page gets its name from ''out lines'', that is a predicate <code>(P is-outside A B)</code> which means that <code>P</code> is on the line <code>A B</code> outside the segment <code>A B</code>. We prove a number of results based on that concept, which in turn lead to a number of theorems involving collinearity.

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Line segment inequality|geometry results so far]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (START Interface:Line_segment_inequality (CLASSICAL FIRSTORDER) ())

var (point A B C D E F P Q R S X Y Z A′ B′ C′ D′ E′ B″ C″)
var (variable a b c c′ d d′ e e′ f p x y z)
</jh>

== Out lines defined ==
A point <code>P</code> is on the line <code>A B</code> outside the line segment <code>A B</code> if and only if one of those points is between <code>P</code> and the other and <code>P</code> is not equal to either one.<ref>Definition out in Narboux</ref>
<jh>
def ((is-outside P A B) (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A))))
</jh>

We also state this definition as a theorem.
<jh>
thm (OutBetweenness () () ((P is-outside A B) ↔ (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A)))) (
        (P is-outside A B) BiconditionalReflexivity
))
</jh>

=== Relating out lines to existence of a point beyond the outside point ===
This section (and the next one) have to do with relating <code>P is-outside A B</code> to a point <code>C</code> for which <code>between A P C</code> and <code>between B P C</code>. The first result says that if <code>between A P C</code>, then <code>between B P C</code> is equivalent to <code>P is-outside A B</code>.<ref>l6_2 in Narboux</ref>

We first tackle the <code>between B P C → P is-outside A B</code> case. This is a straightforward application of <code>BetweennessMiddleConnectivity</code>, which in this case says basically that <code>between A P C</code> and <code>between B P C</code> imply <code>between A B P ∨ between B A P</code>.
<jh>
thm (BeyondOutForward () () ((((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C)) ∧ (between B P C)) → (P is-outside A B)) (
</jh>
The first two parts of the <code>P is-outside A B</code> definition are the inequalities <code>A ≠ P</code> and <code>B ≠ P</code> which we just carry over from the antecedent.
<jh>
        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (between B P C)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (between B P C)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
To apply <code>BetweennessMiddleConnectivity</code>, we first need <code>C ≠ P</code>.
<jh>
        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (between B P C)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
Next we need <code>between C P A</code>.
<jh>
        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (between B P C)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        A P C BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
The last thing we will need for <code>BetweennessMiddleConnectivity</code> is <code>between C P B</code>.
<jh>
        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (between B P C)
          ConjunctionLeftElimination

        B P C BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Now we apply connectivity to get <code>between P A B ∨ between P B A</code>, which is the only remaining part of the definition of <code>is-outside</code>.
<jh>
        C P A B BetweennessMiddleConnectivity
        applySyllogism

        composeConjunction
))

</jh>
In the other direction, <code>P is-outside A B</code> tells us that either <code>between P A B</code> or <code>between P B A</code>. In the either case, we can apply transitivity with <code>between A P C</code> to get <code>between B P C</code>.

We'll arrange this proof by first rearranging the disjunction and conjunctions, before we worry about transitivity.
<jh>
thm (BeyondOutReverse-1 () ()
  ((((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C)) ∧ (P is-outside A B)) →
    ((((A ≠ P) ∧ (between A P C)) ∧ (between P A B)) ∨
      (((A ≠ P) ∧ (between A P C)) ∧ (between P B A)))) (
</jh>
First we pick out <code>A ≠ P ∧ between A P C</code>.
<jh>
        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (P is-outside A B)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (P is-outside A B)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Next we take <code>P is-outside A B</code>, unfold the definition, and extract <code>between P A B ∨ between P B A</code>.
<jh>
        ((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C))
          (P is-outside A B)
          ConjunctionLeftElimination

        ((A ≠ P) ∧ (B ≠ P))
          ((between P A B) ∨ (between P B A))
          ConjunctionLeftElimination
        applySyllogism

        composeConjunction
</jh>
Applying distributivity of conjunction over disjunction finishes the job.
<jh>
        ((A ≠ P) ∧ (between A P C))
          (between P A B)
          (between P B A)
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        applySyllogism
))

thm (BeyondOutReverse () () ((((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C)) ∧ (P is-outside A B)) → (between B P C)) (
        A P B C BeyondOutReverse-1
</jh>
Our first transitivity invocation is <code>between B A P ∧ between A P C ∧ A ≠ P → between B P C</code>.
<jh>
        ((A ≠ P) ∧ (between A P C))
          (between P A B)
          ConjunctionLeftElimination

        P A B BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        ((A ≠ P) ∧ (between A P C))
          (between P A B)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        composeConjunction

        ((A ≠ P) ∧ (between A P C))
          (between P A B)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        composeConjunction

        B A P C BetweennessOuterTransitivityFlipped
        applySyllogism
</jh>
Our second transitivity invocation is <code>between A B P ∧ between A P C → B P C</code>
<jh>
        ((A ≠ P) ∧ (between A P C))
          (between P B A)
          ConjunctionLeftElimination

        P B A BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        ((A ≠ P) ∧ (between A P C))
          (between P B A)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        composeConjunction

        A B P C BetweennessInnerTransitivityFlipped
        applySyllogism
</jh>
Now we combine the two.
<jh>
        composeDisjunction
        applySyllogism
))

thm (BeyondOut () () (((((A ≠ P) ∧ (B ≠ P)) ∧ (C ≠ P)) ∧ (between A P C)) →
  ((between B P C) ↔ (P is-outside A B))) (
        A P B C BeyondOutForward
        export

        A P B C BeyondOutReverse
        export

        introduceBiconditionalFromImplicationsInConsequent
))
</jh>

=== The existence of a point beyond the outside point ===
In this section we show that a point is outside a line segment if and only if there exists a point beyond the outside point.  In symbols, <code>P is-outside A B</code> is equivalent to <code>A ≠ P ∧ B ≠ P ∧ ∃ c (C ≠ P ∧ between A P C ∧ between B P C)</code>.

We start with the forward implication. Extend <code>A P</code> to a distinct point <code>c</code> (that is, a point for which <code>P ≠ c ∧ between A P c</code>. We can then apply <code>BeyondOut</code> to show that <code>between B P c</code>.<ref>l6_3_1 in Narboux</ref> Below we present the formal version of this proof, broken down into several lemmas.

<jh>
thm (ExistsBeyondOutForward-bpc () ()
  (((P is-outside A B) ∧ ((C ≠ P) ∧ (between A P C))) →
    (between B P C)) (
</jh>
At the end of the proof we'll need a copy of <code>P is-outside A B</code>, so we stick it on the proof stack.
<jh>
        (P is-outside A B) ((C ≠ P) ∧ (between A P C)) ConjunctionRightElimination
</jh>
Most of the proof of this lemma consists of an application of  <code>BeyondOut</code>. The first thing we need is <code>A ≠ P</code>.
<jh>
        (P is-outside A B) ((C ≠ P) ∧ (between A P C)) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
Next is <code>B ≠ P</code>
<jh>
        (P is-outside A B) ((C ≠ P) ∧ (between A P C)) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Next is <code>C ≠ P</code>
<jh>
        (P is-outside A B) ((C ≠ P) ∧ (between A P C)) ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
Last is <code>between A P C</code>.
<jh>
        (P is-outside A B) ((C ≠ P) ∧ (between A P C)) ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Applying <code>BeyondOut</code> gives us <code>between B P C ↔ P is-outside A B</code>
<jh>
        A P B C BeyondOut
        applySyllogism
</jh>
Now we detach the <code>P is-outside A B</code> part so we just have <code>between B P C</code>.
<jh>
        eliminateBiconditionalForwardInConsequent
        applyModusPonensInConsequent
))

</jh>
The next lemma is just <code>PointConstructionDifferent</code>, together with some rearrangements via commutativity and symmetry.
<jh>
thm (ExistsBeyondOutForward-c ((c A) (c P)) () (∃ c (((value c) ≠ P) ∧ (between A P (value c)))) (
        c A P PointConstructionDifferent

        (between A P (value c)) (P ≠ (value c)) ConjunctionCommutativity
        eliminateBiconditionalReverse
        c addThereExists
        applyModusPonens

        P (value c) EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        (between A P (value c)) conjoinRR
        c addThereExists
        applyModusPonens
))

thm (ExistsBeyondOutForward-3 ((c A) (c B) (c P)) () ((P is-outside A B) → (∃ c ((((value c) ≠ P) ∧ (between A P (value c))) ∧ (between B P (value c))))) (
        P A B (value c) ExistsBeyondOutForward-bpc
        export
        c addForAllToConsequent
</jh>
We now have <code>P is-outside A B → ∀ c (c ≠ P ∧ between A P c → between B P c)</code>. Combining this with the previous result gives <code>P is-outside A B → ∃ c (c ≠ P ∧ between A P c ∧ (c ≠ P ∧ between A P c → between B P c))</code>.
<jh>
        c P A ExistsBeyondOutForward-c
        introduceLeftConjunctToConsequent

        c
          (((value c) ≠ P) ∧ (between A P (value c)))
          ((((value c) ≠ P) ∧ (between A P (value c))) → (between B P (value c)))
          ThereExistsConjunctionRightCombining
        applySyllogism
</jh>
To get <code>between B P c</code> is just a matter of modus ponens. The one complication is that we want to keep <code>c ≠ P ∧ between A P c</code> around in addition, so we apply idempotence, associativity, and modus ponens, in that order.
<jh>
        (((value c) ≠ P) ∧ (between A P (value c))) ConjunctionIdempotence
        eliminateBiconditionalReverse
        ((((value c) ≠ P) ∧ (between A P (value c))) → (between B P (value c))) conjoinRR
        c addThereExists
        applySyllogism

        (((value c) ≠ P) ∧ (between A P (value c)))
          (((value c) ≠ P) ∧ (between A P (value c)))
          ((((value c) ≠ P) ∧ (between A P (value c))) → (between B P (value c)))
          ConjunctionAssociativity
        eliminateBiconditionalReverse
        c addThereExists
        applySyllogism

        (((value c) ≠ P) ∧ (between A P (value c)))
          (between B P (value c))
          ModusPonens
        (((value c) ≠ P) ∧ (between A P (value c))) conjoinLL
        c addThereExists
        applySyllogism
))

thm (ExistsBeyondOutForward ((c A) (c B) (c P)) ()
  ((P is-outside A B) → (((A ≠ P) ∧ (B ≠ P)) ∧
    (∃ c ((((value c) ≠ P) ∧
      (between A P (value c))) ∧ (between B P (value c)))))) (
</jh>
First is <code>P is-outside A B → A ≠ P</code>
<jh>
        ((A ≠ P) ∧ (B ≠ P)) ((between P A B) ∨ (between P B A)) ConjunctionRightElimination
        eliminateRightConjunctInConsequent

</jh>
Next is <code>P is-outside A B → B ≠ P</code>
<jh>
        ((A ≠ P) ∧ (B ≠ P)) ((between P A B) ∨ (between P B A)) ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Next is the remainder.
<jh>
        P A B c ExistsBeyondOutForward-3
        composeConjunction
))

</jh>
We now turn to the reverse direction.<ref>l6_3_2 in Narboux</ref>
<jh>
thm (ExistsBeyondOutReverse ((c A) (c B) (c P)) ()
  ((((A ≠ P) ∧ (B ≠ P)) ∧
    (∃ c ((((value c) ≠ P) ∧
      (between A P (value c))) ∧ (between B P (value c))))) →
   (P is-outside A B)) (
</jh>
This proof is basically an application of middle connectivity for betweenness, which in this case is <code>c ≠ P ∧ between c P A ∧ between c P B → between P A B ∨ between P B A</code>. First we need <code>c ≠ P</code>
<jh>
        (((value c) ≠ P) ∧ (between A P (value c)))
          (between B P (value c))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
</jh>
Next is <code>between c P A</code>.
<jh>
        (((value c) ≠ P) ∧ (between A P (value c)))
          (between B P (value c))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        A P (value c) BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Next is <code>between c P B</code>.
<jh>
        (((value c) ≠ P) ∧ (between A P (value c)))
          (between B P (value c))
          ConjunctionLeftElimination

        B P (value c) BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
We apply connectivity, remove the quantifier from the consequent, and assemble the result.
<jh>
        (value c) P A B BetweennessMiddleConnectivity
        applySyllogism

        c addThereExists
        removeThereExistsInConsequent

        ((A ≠ P) ∧ (B ≠ P)) conjoinLL
))

thm (ExistsBeyondOut ((c A) (c B) (c P)) () ((P is-outside A B) ↔ (((A ≠ P) ∧ (B ≠ P)) ∧ (∃ c ((((value c) ≠ P) ∧ (between A P (value c))) ∧ (between B P (value c)))))) (
        P A B c ExistsBeyondOutForward
        A P B c ExistsBeyondOutReverse
        introduceBiconditionalFromImplications
))
</jh>

=== Alternate definition in terms of collinearity ===
A point is outside a line segment if and only if it is collinear with the endpoints of the segment but not between them. That is, <code>P is-outside A B ↔ collinear A P B ∧ ¬ between A P B</code>.

We first tackle the forward direction.<ref>l6_4_1 in Narboux</ref> The first lemma is <code>P ≠ A ∧ P ≠ B ∧ between P A B → ¬ between A P B</code>.
<jh>
thm (OutCollinearityForward-1 () () ((((A ≠ P) ∧ (B ≠ P)) ∧ (between P A B)) → (¬ (between A P B))) (
</jh>
First we pick out and rearrange the parts we need, specifically we prove <code>P ≠ A ∧ P ≠ B ∧ between P A B → between P A B ∧ P ≠ A</code>
<jh>
        ((A ≠ P) ∧ (B ≠ P)) (between P A B) ConjunctionLeftElimination

        ((A ≠ P) ∧ (B ≠ P)) (between P A B) ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
The geometrical content of this proof is <code>between P A B ∧ between A P B → A = P</code>.
<jh>
        P A B BetweennessEquality

        P A EqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Applying some propositional logic, we rearrange this to <code>between P A B ∧ A ≠ P → ¬ between A P B</code>
<jh>
        export

        (between A P B) (A = P) Transposition
        eliminateBiconditionalReverse
        applySyllogism

        import
</jh>
Combining this with our first rearrangement, we get the desired result.
<jh>
        applySyllogism
))
</jh>

The second lemma, <code>A ≠ P ∧ B ≠ P ∧ between P B A → ¬ between A P B</code>, is very similar.
<jh>
thm (OutCollinearityForward-2 () () ((((A ≠ P) ∧ (B ≠ P)) ∧ (between P B A)) → (¬ (between A P B))) (
        (A ≠ P) (B ≠ P) ConjunctionCommutativity
        eliminateBiconditionalReverse
        (between P B A) conjoinRR

        B P A OutCollinearityForward-1
        applySyllogism

        B P A BetweennessSymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

Combining the two previous lemmas we get <code>P is-outside A B → ¬ between A P B</code>.
<jh>
thm (OutCollinearityForward-3 () () ((P is-outside A B) → (¬ (between A P B))) (
        ((A ≠ P) ∧ (B ≠ P)) (between P A B) (between P B A) ConjunctionLeftDistribution
        eliminateBiconditionalReverse

        A P B OutCollinearityForward-1
        A P B OutCollinearityForward-2
        composeDisjunction

        applySyllogism
))
</jh>

Collinearity is straightforward.
<jh>
thm (OutCollinearityForward-collinear () () ((P is-outside A B) → (collinear A P B)) (
        ((A ≠ P) ∧ (B ≠ P)) ((between P A B) ∨ (between P B A)) ConjunctionLeftElimination

        (between P A B) (between P B A) DisjunctionCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        P A B BetweennessSymmetry
        eliminateBiconditionalReverse
        (between P B A) disjoinLL
        applySyllogism

        ((between P B A) ∨ (between B A P)) (between A P B) DisjunctionLeftIntroduction
        applySyllogism

        (between A P B) (between P B A) (between B A P) DisjunctionAssociativity
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

Combining the last two results gives the forward direction.
<jh>
thm (OutCollinearityForward () () ((P is-outside A B) → ((collinear A P B) ∧ (¬ (between A P B)))) (
        P A B OutCollinearityForward-collinear
        P A B OutCollinearityForward-3
        composeConjunction
))
</jh>

Turning our attention to the reverse direction,<ref>l6_4_2 in Narboux</ref> we have two tasks. The first is to show that <code>P ≠ A</code> and </code>P ≠ B</code>, each of which follows from <code>¬ between A P B</code> (because either equality holding would make <code>between A P B</code> hold trivially).
<jh>
thm (OutCollinearityReverse-1 () () (((collinear A P B) ∧ (¬ (between A P B))) → ((A ≠ P) ∧ (B ≠ P))) (
        (collinear A P B) (¬ (between A P B))
        ConjunctionLeftElimination
</jh>
Next we show <code>A = P → (between A P B ↔ between P P B)</code>, and from it <code>A = P → between A P B</code>.
<jh>
        P B BetweenAAB

        P EqualityReflexivity
        B EqualityReflexivity
        A P P P B B BetweennessBuilder
        detach2of2
        detach2of2

        detachImplicationBiconditionalRight

        introduceTransposition
</jh>
Proving <code>B = P → between A P B</code> is similar (via <code>B = P → (between A P B ↔ between A P P)</code>.
<jh>
        A P BetweenABB

        A EqualityReflexivity
        P EqualityReflexivity
        A A P P B P BetweennessBuilder
        detach2of3
        detach1of2

        detachImplicationBiconditionalRight

        introduceTransposition

        composeConjunction

        applySyllogism
))
</jh>
Our other task is to show <code>between P A B ∨ between P B A</code>.
<jh>
thm (OutCollinearityReverse-2 () ()
  (((collinear A P B) ∧ (¬ (between A P B))) →
    ((between P A B) ∨ (between P B A))) (
</jh>
First we show <code>collinear A P B ∧ ¬ between A P B → between P B A ∨ between P A B</code>
<jh>
        (between A P B) (between P B A) (between B A P) DisjunctionAssociativity
        eliminateBiconditionalReverse

        (between A P B) ((between P B A) ∨ (between B A P)) DisjunctionImplication
        eliminateBiconditionalReverse
        applySyllogism

        import
</jh>
That gives us <code>between P B A ∨ between B A P</code>. We just need to rearrange a bit and we are done.
<jh>
        B A P BetweennessSymmetry
        eliminateBiconditionalReverse
        (between P B A) disjoinLL
        applySyllogism

        (between P B A) (between P A B) DisjunctionCommutativity
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

Combining our tasks proves the reverse direction, and combining forward and reverse directions proves the equivalence.
<jh>
thm (OutCollinearityReverse () () (((collinear A P B) ∧ (¬ (between A P B))) → (P is-outside A B)) (
        A P B OutCollinearityReverse-1
        A P B OutCollinearityReverse-2
        composeConjunction
))

thm (OutCollinearity () () ((P is-outside A B) ↔ ((collinear A P B) ∧ (¬ (between A P B)))) (
        P A B OutCollinearityForward
        A P B OutCollinearityReverse
        introduceBiconditionalFromImplications
))
</jh>

== Reflexive, symmetric, and transitive ==
Here we present versions of reflexivity, symmetry, and transitivity. You can think of this as dividing a line (excluding the point <code>P</code> itself) into two equivalence classes: those to the left of <code>P</code> and those to the right (we certainly don't have the machinery to say it quite that way, but that is the rough idea).

=== Reflexivity ===
<jh>
thm (OutReflexivity () () ((A ≠ P) → (P is-outside A A)) (
        (A ≠ P) ConjunctionIdempotence
        eliminateBiconditionalReverse

        P A BetweenABB
        cloneAsDisjunction
        introduceRightConjunctToConsequent
))
</jh>

=== Symmetry ===
<jh>
thm (OutSymmetry () () ((P is-outside A B) ↔ (P is-outside B A)) (
        (A ≠ P) (B ≠ P) ConjunctionCommutativity
        (between P A B) (between P B A) DisjunctionCommutativity
        buildConjunction
))
</jh>

=== Transitivity ===
Expanding the definitions of the antecedent, we start with
  A ≠ P ∧ B ≠ P ∧ (between P A B ∨ between P B A) ∧
  B ≠ P ∧ C ≠ P ∧ (between P B C ∨ between P C B)
Looking at the betweenness part of that, there are four cases (<code>between P A B ∧ between P B C</code> being the first, <code>between P A B ∧ between P C B</code>, being the second, and so on).

The interesting part is a lemma which handles those four cases; there is also a fair bit of rearranging (in the lemma and in the proof of the actual theorem).

<jh>
thm (OutTransitivity-1 () () (((B ≠ P) ∧
  (((between P A B) ∨ (between P B A)) ∧
    ((between P B C) ∨ (between P C B)))) →
  ((between P A C) ∨ (between P C A))) (
</jh>
First we break down the four cases.
<jh>
        (between P A B)
          (between P B A)
          ((between P B C) ∨ (between P C B))
          ConjunctionRightDistribution
        eliminateBiconditionalReverse

        (between P A B) (between P B C) (between P C B) ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        (between P B A) (between P B C) (between P C B) ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        disjoin

        applySyllogism

        (B ≠ P) conjoinLL
</jh>
Now we distribute the <code>B ≠ P</code> into each of the cases.
<jh>
        (B ≠ P)
          (((between P A B) ∧ (between P B C)) ∨ ((between P A B) ∧ (between P C B)))
          (((between P B A) ∧ (between P B C)) ∨ ((between P B A) ∧ (between P C B)))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        applySyllogism

        (B ≠ P)
          ((between P A B) ∧ (between P B C))
          ((between P A B) ∧ (between P C B))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        (B ≠ P)
          ((between P B A) ∧ (between P B C))
          ((between P B A) ∧ (between P C B))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        disjoin
        applySyllogism
</jh>
The first case is <code>B ≠ P ∧ between P A B ∧ between P B C</code>.  In all four cases we are showing that the case in question implies <code>between P A C ∨ between P C A</code>. In the current case, <code>between P A C</code> follows from transitivity.
<jh>
        (B ≠ P)
          ((between P A B) ∧ (between P B C))
          ConjunctionLeftElimination

        P A B C BetweennessMiddleTransitivityFlipped
        applySyllogism

        (between P A C) (between P C A) DisjunctionRightIntroduction
        applySyllogism
</jh>
The second case is <code>B ≠ P ∧ between P A B ∧ between P C B</code>.  Here we apply inner connectivity for betweenness.
<jh>
        (B ≠ P)
          ((between P A B) ∧ (between P C B))
          ConjunctionLeftElimination

        P A B C BetweennessInnerConnectivity
        applySyllogism

        composeDisjunction
</jh>
The third case is <code>B ≠ P ∧ between P B A ∧ between P B C</code>.  Here we apply outer connectivity for betweenness.
<jh>
        B P EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse

        ((between P B A) ∧ (between P B C)) conjoinRR

        (P ≠ B) (between P B A) (between P B C) ConjunctionAssociativity
        eliminateBiconditionalForward
        applySyllogism

        P B A C BetweennessOuterConnectivity
        applySyllogism
</jh>
The fourth case is <code>B ≠ P ∧ between P B A ∧ between P C B</code>.  In this one <code>between P C A</code> follows from betweenness transitivity.
<jh>
        (B ≠ P)
          ((between P B A) ∧ (between P C B))
          ConjunctionLeftElimination

        (between P B A) (between P C B) ConjunctionCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        P C B A BetweennessMiddleTransitivityFlipped
        applySyllogism

        (between P C A) (between P A C) DisjunctionLeftIntroduction
        applySyllogism

        composeDisjunction

        composeDisjunction

        applySyllogism
))

thm (OutTransitivity () () (((P is-outside A B) ∧ (P is-outside B C)) → (P is-outside A C)) (
</jh>
First we pick out <code>A ≠ P</code>.
<jh>
        (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A)))
          (((B ≠ P) ∧ (C ≠ P)) ∧ ((between P B C) ∨ (between P C B)))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
Secondly we pick out <code>C ≠ P</code>.
<jh>
        (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A)))
          (((B ≠ P) ∧ (C ≠ P)) ∧ ((between P B C) ∨ (between P C B)))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Next we assemble <code>B ≠ P ∧ ((between P A B ∨ between P B A) ∧ (between P B C ∨ between P C B))</code> and apply our lemma to turn this into <code>between P A C ∨ between P C A</code>.
<jh>
        (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A)))
          (((B ≠ P) ∧ (C ≠ P)) ∧ ((between P B C) ∨ (between P C B)))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A)))
          (((B ≠ P) ∧ (C ≠ P)) ∧ ((between P B C) ∨ (between P C B)))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        (((A ≠ P) ∧ (B ≠ P)) ∧ ((between P A B) ∨ (between P B A)))
          (((B ≠ P) ∧ (C ≠ P)) ∧ ((between P B C) ∨ (between P C B)))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction

        composeConjunction

        B P A C OutTransitivity-1
        applySyllogism

        composeConjunction
))
</jh>

== Line segment construction ==
From a given point, in the direction of a second given point, we construct a segment congruent to a given line segment. This is similar to <code>InnerSegmentConstruction</code> but is expressed in terms of <code>is-outside</code>.

=== Existence ===
In this section we prove the existence of such a point. That is, <code>R ≠ A ∧ B ≠ C → ∃ e (A is-outside e R ∧ A e ≡ B C)</code>.

The proof consists of applying <code>InnerSegmentConstruction</code>, rearranging, and applying the definition of <code>is-outside</code>. The following lemma expresses most of the rearrangements.<ref>l6_11_existence in Narboux</ref>
<jh>
thm (OutSegmentConstructionLemma () ()
  ((((R ≠ A) ∧ (B ≠ C)) ∧
    (((between A R E) ∨ (between A E R)) ∧
      (A E ≡ B C))) →
  ((A is-outside E R) ∧ (A E ≡ B C))) (
</jh>
To apply the definition of <code>A is-outside E R</code>, first we need <code>E ≠ A</code>. This follows from <code>B ≠ C</code> and <code>A E ≡ B C</code>, and the first step is picking out those two formulas.
<jh>
        ((R ≠ A) ∧ (B ≠ C))
          (((between A R E) ∨ (between A E R)) ∧
            (A E ≡ B C))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        ((R ≠ A) ∧ (B ≠ C))
          (((between A R E) ∨ (between A E R)) ∧
            (A E ≡ B C))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
The next step in getting to <code>E ≠ A</code> is to show that <code>B ≠ C ∧ A E ≡ B C → A ≠ E</code>.
<jh>
        A E B C CongruenceIdentityFromEquality
        export
        applyComm

        (A = E) (B = C) Transposition
        eliminateBiconditionalReverse
        applySyllogism

        applyComm
        import
</jh>
Combining that with the previous result and flipping the two sides of the not-equals sign gives us <code>E ≠ A</code>.
<jh>
        applySyllogism

        A E EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next we need <code>R ≠ A</code>.
<jh>
        ((R ≠ A) ∧ (B ≠ C))
          (((between A R E) ∨ (between A E R)) ∧
            (A E ≡ B C))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
Then we need <code>between A E R ∨ between A R E</code>
<jh>
        ((R ≠ A) ∧ (B ≠ C))
          (((between A R E) ∨ (between A E R)) ∧
            (A E ≡ B C))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        (between A R E) (between A E R)
        DisjunctionCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
That's all for <code>A is-outside E R</code>. So the only remaining step is <code>A E ≡ B C</code>
<jh>
        ((R ≠ A) ∧ (B ≠ C))
          (((between A R E) ∨ (between A E R)) ∧
            (A E ≡ B C))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
))

thm (OutSegmentConstruction ((e R) (e A) (e B) (e C)) ()
  (((R ≠ A) ∧ (B ≠ C)) →
    (∃ e ((A is-outside (value e) R) ∧ (A (value e) ≡ B C)))) (
        ((R ≠ A) ∧ (B ≠ C)) ImplicationReflexivity
        e A R B C InnerSegmentConstruction
        introduceRightConjunctToConsequent

        e
          ((R ≠ A) ∧ (B ≠ C))
          (((between A R (value e)) ∨ (between A (value e) R)) ∧
            (A (value e) ≡ B C))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        applySyllogism

        R A B C (value e) OutSegmentConstructionLemma
        e addThereExists
        applySyllogism
))
</jh>

=== Uniqueness ===
The point that we construct this way is also unique. In symbols, <code>R ≠ A ∧ B ≠ C ∧ A is-outside X R ∧ A X ≡ B C ∧ A is-outside Y R ∧ A Y ≡ B C → X = Y</code>.<ref>l6_11_unicity in Narboux</ref>

The proof of uniqueness is more involved than the existence proof. Start by expanding the definitions of <code>is-outside</code> (and removing the redundant copies of <code>R ≠ A</code>) so we now have
  R ≠ A ∧ B ≠ C ∧
  X ≠ A ∧ (between A X R ∨ between A R X) ∧
  A X ≡ B C ∧
  Y ≠ A ∧ (between A Y R ∨ between A R Y) ∧
  A Y ≡ B C

By congruence transitivity, we derive <code>A X ≡ A Y</code>. Then we look at the betweenness relationships. Specifically we want to conclude <code>between A X Y ∨ between A Y X</code>. There are four cases: <code>between A X R ∧ between A Y R → between A X Y ∨ between A Y X</code> by inner connectivity, <code>between A X R ∧ between A R Y → between A X Y</code> by transitivity, <code>between A R X ∧ between A Y R → between A Y X</code> by transitivity, and <code>A ≠ R ∧ between A R X ∧ between A R Y → between A X Y ∨ between A Y X</code> by outer connectivity.

Once we have <code>A X ≡ A Y</code> and <code>between A X Y ∨ between A Y X</code>, <code>X = Y</code> follows from <code>BetweennessOneDistanceUniqueness</code> (applied twice, once to each of the betweenness formulas).

Our first lemma just spells out the four cases.
<jh>
thm (OutSegmentConstructionUniqueness-cases () () 
  (((((((R ≠ A) ∧ (B ≠ C)) ∧
    (A is-outside X R)) ∧ (A X ≡ B C)) ∧
    (A is-outside Y R)) ∧ (A Y ≡ B C)) →
  ((((between A X R) ∧ (between A Y R)) ∨
    ((between A X R) ∧ (between A R Y))) ∨
    (((between A R X) ∧ (between A Y R)) ∨
    (((A ≠ R) ∧ (between A R X)) ∧ (between A R Y))))) (
</jh>
First is <code>A ≠ R</code>.
<jh>
        (((((R ≠ A) ∧ (B ≠ C)) ∧
          (A is-outside X R)) ∧ (A X ≡ B C)) ∧
          (A is-outside Y R))
          (A Y ≡ B C)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        R A EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next is <code>between A X R ∨ between A R X</code>
<jh>
        (((((R ≠ A) ∧ (B ≠ C)) ∧
          (A is-outside X R)) ∧ (A X ≡ B C)) ∧
          (A is-outside Y R))
          (A Y ≡ B C)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
Next is <code>between A Y R ∨ between A R Y</code>
<jh>
        (((((R ≠ A) ∧ (B ≠ C)) ∧
          (A is-outside X R)) ∧ (A X ≡ B C)) ∧
          (A is-outside Y R))
          (A Y ≡ B C)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction

        composeConjunction
</jh>
Now we apply distributivity to expand the four cases.
<jh>
        (between A X R)
          (between A R X)
          ((between A Y R) ∨ (between A R Y))
          ConjunctionRightDistribution
        eliminateBiconditionalReverse

        (between A X R) (between A Y R) (between A R Y) ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        (between A R X) (between A Y R) (between A R Y) ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        disjoin

        applySyllogism

        (A ≠ R) conjoinLL

        applySyllogism
</jh>
Now we distribute the <code>A ≠ R</code> into each of the cases.
<jh>
        (A ≠ R)
          (((between A X R) ∧ (between A Y R)) ∨ ((between A X R) ∧ (between A R Y)))
          (((between A R X) ∧ (between A Y R)) ∨ ((between A R X) ∧ (between A R Y)))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        applySyllogism

        (A ≠ R)
          ((between A X R) ∧ (between A Y R))
          ((between A X R) ∧ (between A R Y))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        (A ≠ R)
          ((between A R X) ∧ (between A Y R))
          ((between A R X) ∧ (between A R Y))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        disjoin
        applySyllogism
</jh>
Now we remove <code>A ≠ R</code> from the first three cases, and apply associativity to the fourth.
<jh>
        (A ≠ R) ((between A X R) ∧ (between A Y R)) ConjunctionLeftElimination
        (A ≠ R) ((between A X R) ∧ (between A R Y)) ConjunctionLeftElimination
        disjoin

        (A ≠ R) ((between A R X) ∧ (between A Y R)) ConjunctionLeftElimination

        (A ≠ R) (between A R X) (between A R Y) ConjunctionAssociativity
        eliminateBiconditionalForward

        disjoin
        disjoin
        applySyllogism
))

thm (OutSegmentConstructionUniqueness-axy-ayx () () 
  (((((((R ≠ A) ∧ (B ≠ C)) ∧
    (A is-outside X R)) ∧ (A X ≡ B C)) ∧
    (A is-outside Y R)) ∧ (A Y ≡ B C)) →
  ((between A X Y) ∨ (between A Y X))) (
        R A B C X Y OutSegmentConstructionUniqueness-cases
</jh>
The first of the four cases is <code>between A X R ∧ between A Y R</code>.
<jh>
        A X R Y BetweennessInnerConnectivity
</jh>
The second case is <code>between A X R ∧ between A R Y</code>.
<jh>
        A X R Y BetweennessMiddleTransitivityFlipped
        (between A X Y) (between A Y X) DisjunctionRightIntroduction
        applySyllogism

        composeDisjunction
</jh>
The third case is <code>between A R X ∧ between A Y R</code>.
<jh>
        (between A R X) (between A Y R) ConjunctionCommutativity
        eliminateBiconditionalReverse

        A Y R X BetweennessMiddleTransitivityFlipped
        (between A Y X) (between A X Y) DisjunctionLeftIntroduction
        applySyllogism

        applySyllogism
</jh>
The fourth case is <code>A ≠ R ∧ between A R X ∧ between A R Y</code>.
<jh>
        A R X Y BetweennessOuterConnectivity

        composeDisjunction

        composeDisjunction

        applySyllogism
))

thm (OutSegmentConstructionUniqueness-axay () () 
  (((((((R ≠ A) ∧ (B ≠ C)) ∧
    (A is-outside X R)) ∧ (A X ≡ B C)) ∧
    (A is-outside Y R)) ∧ (A Y ≡ B C)) →
  (A X ≡ A Y)) (
        (((((R ≠ A) ∧ (B ≠ C)) ∧
          (A is-outside X R)) ∧ (A X ≡ B C)) ∧
          (A is-outside Y R))
          (A Y ≡ B C)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        (((((R ≠ A) ∧ (B ≠ C)) ∧
          (A is-outside X R)) ∧ (A X ≡ B C)) ∧
          (A is-outside Y R))
          (A Y ≡ B C)
          ConjunctionLeftElimination

        A Y B C CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        A X B C A Y CongruenceTransitivity
        applySyllogism
))

thm (OutSegmentConstructionUniqueness () () 
  (((((((R ≠ A) ∧ (B ≠ C)) ∧
    (A is-outside X R)) ∧ (A X ≡ B C)) ∧
    (A is-outside Y R)) ∧ (A Y ≡ B C)) →
  (X = Y)) (
</jh>
We first arrange the results of the two previous lemmas to get <code>(between A X Y ∧ A X ≡ A Y) ∨ (between A Y X ∧ A X ≡ A Y)</code>.
<jh>
        R A B C X Y OutSegmentConstructionUniqueness-axy-ayx
        R A B C X Y OutSegmentConstructionUniqueness-axay
        composeConjunction

        (between A X Y) (between A Y X) (A X ≡ A Y) ConjunctionRightDistribution
        eliminateBiconditionalReverse
        applySyllogism
</jh>
The result for the first half is <code>between A X Y ∧ A X ≡ A Y → X = Y</code>, which follows directly from <code>BetweennessOneDistanceUniqueness</code>.
<jh>
        A X Y BetweennessOneDistanceUniqueness
</jh>
The second half result, <code>between A Y X ∧ A X ≡ A Y → X = Y</code>, is basically the same thing, but we need to rearrange slightly.
<jh>
        A X A Y CongruenceSymmetry
        eliminateBiconditionalReverse
        (between A Y X) conjoinLL

        A Y X BetweennessOneDistanceUniqueness
        applySyllogism

        Y X EqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Now we combine the two halves.
<jh>
        composeDisjunction
        applySyllogism
))
</jh>

== The closer point is between ==
If <code>A</code> and <code>B</code> are on a line with <code>P</code>, both on the same side of <code>P</code>, and <code>A</code> is closer to <code>P</code> than <code>B</code> is, then <code>A</code> is between <code>P</code> and <code>B</code>. That is, <code>P is-outside A B ∧ P A ≤ P B → between P A B</code>.<ref>l6_13_1 in Narboux</ref>

The proof begins by expanding <code>P A ≤ P B</code> to <code>∃ y (between P y B ∧ P A ≡ P y)</code>. From <code>P is-outside A B</code> and <code>P A ≡ P y</code> we can conclude <code>P ≠ y</code>. We will then be applying <code>OutSegmentConstructionUniqueness</code> which in this case expands to:

  B ≠ P ∧ P ≠ y ∧
  P is-outside y B ∧ P y ≡ P y ∧
  P is-outside A B ∧ P A ≡ P y →
  y = A

Each piece of this is something we already have, or readily follows from things we have. Once we have <code>y = A</code> we just substitute it into <code>between P y B</code> and we are done.

The first lemma constructs the point <code>y</code>.
<jh>
thm (LessEqualBetween-y ((y P) (y A) (y B)) ()
  (((P is-outside A B) ∧ (P A ≤ P B)) →
    (∃ y ((P is-outside A B) ∧
      ((between P (value y) B) ∧ (P A ≡ P (value y)))))) (
        P A P B y LessEqualCutoff
        eliminateBiconditionalReverse
        (P is-outside A B) conjoinLL

        y
          (P is-outside A B)
          ((between P (value y) B) ∧ (P A ≡ P (value y)))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

The next lemma is <code>P ≠ y</code>
<jh>
thm (LessEqualBetween-Py () ()
  (((P is-outside A B) ∧ ((between P Y B) ∧ (P A ≡ P Y))) → (P ≠ Y)) (
</jh>
First we pick out <code>P ≠ A</code>.
<jh>
        (P is-outside A B) ((between P Y B) ∧ (P A ≡ P Y)) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        A P EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next is <code>P A ≡ P Y</code>.
<jh>
        (P is-outside A B) ((between P Y B) ∧ (P A ≡ P Y)) ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Next is <code>P = Y ∧ P A ≡ P Y → P = A</code> (from <code>CongruenceIdentityFromEquality</code>), which we then rearrange to give <code>P ≠ A ∧ P A ≡ P Y → P ≠ Y</code>
<jh>
        P A P Y CongruenceSymmetry
        eliminateBiconditionalReverse
        (P = Y) conjoinLL

        P Y P A CongruenceIdentityFromEquality
        applySyllogism

        export
        applyComm

        (P = Y) (P = A) Transposition
        eliminateBiconditionalReverse
        applySyllogism
        
        applyComm
        import
</jh>
Combining that with the previous result finishes the proof.
<jh>
        applySyllogism
))
</jh>

The next lemma is <code>P is-outside Y B</code>.
<jh>
thm (LessEqualBetween-PyB () ()
  (((P is-outside A B) ∧ ((between P Y B) ∧ (P A ≡ P Y))) →
  (P is-outside Y B)) (
</jh>
First we need <code>Y ≠ P</code>.
<jh>
        P A B Y LessEqualBetween-Py

        P Y EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Then we need <code>B ≠ P</code>.
<jh>
        (P is-outside A B) ((between P Y B) ∧ (P A ≡ P Y)) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Finally we need <code>between P Y B ∨ between P B Y</code>.
<jh>
        (P is-outside A B) ((between P Y B) ∧ (P A ≡ P Y)) ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        (between P Y B) (between P B Y) DisjunctionRightIntroduction
        applySyllogism

        composeConjunction
))

</jh>
The next lemma applies <code>OutSegmentConstructionUniqueness</code> to give <code>Y = A</code>.
<jh>
thm (LessEqualBetween-yA () ()
  (((P is-outside A B) ∧ ((between P Y B) ∧ (P A ≡ P Y))) →
  (Y = A)) (
</jh>
First we need <code>B ≠ P</code>.
<jh>
        (P is-outside A B) ((between P Y B) ∧ (P A ≡ P Y)) ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
Next we need <code>P ≠ Y</code>.
<jh>
        P A B Y LessEqualBetween-Py
        composeConjunction
</jh>
Next we need <code>P is-outside Y B</code>.
<jh>
        P A B Y LessEqualBetween-PyB
        composeConjunction
</jh>
Next is <code>P Y ≡ P Y</code>.
<jh>
        P Y CongruenceReflexivity
        introduceRightConjunctToConsequent
</jh>
Next is <code>P is-outside A B</code>.
<jh>
        (P is-outside A B) ((between P Y B) ∧ (P A ≡ P Y)) ConjunctionRightElimination
        composeConjunction
</jh>
Next is <code>P A ≡ P Y</code>.
<jh>
        (P is-outside A B) ((between P Y B) ∧ (P A ≡ P Y)) ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
        composeConjunction
</jh>
Now that we have all the hypotheses, we'll apply <code>OutSegmentConstructionUniqueness</code> to give <code>Y = A</code>.
<jh>
        B P P Y Y A OutSegmentConstructionUniqueness
        applySyllogism
))

</jh>
Now that we have <code>Y = A</code>, we just substitute that into <code>between P Y B</code> to get <code>between P A B</code>.
<jh>
thm (LessEqualBetween-PAB () ()
  (((P is-outside A B) ∧ ((between P Y B) ∧ (P A ≡ P Y))) →
  (between P A B)) (
</jh>
First we get out <code>Y = A</code> and <code>between P Y B</code>.
<jh>
        P A B Y LessEqualBetween-yA

        (P is-outside A B) ((between P Y B) ∧ (P A ≡ P Y)) ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
The substitution is <code>Y = A → (between P Y B ↔ between P A B)</code>.
<jh>
        P EqualityReflexivity
        B EqualityReflexivity
        P P Y A B B BetweennessBuilder
        detach2of2
        detach1of2

        eliminateBiconditionalReverseInConsequent
        import

        applySyllogism
))

thm (LessEqualBetweenForward ( (y P) (y A) (y B)) ()
  (((P is-outside A B) ∧ (P A ≤ P B)) → (between P A B)) (
        P A B y LessEqualBetween-y

        P A B (value y) LessEqualBetween-PAB
        y addThereExists
        applySyllogism

        removeThereExistsInConsequent
))
</jh>

=== The point which is between is closer ===
The converse also holds: <code>P is-outside A B ∧ between P A B → P A ≤ P B</code>.<ref>l6_13_2 in Narboux</ref> To prove <code>P A ≤ P B</code>, we need <code>∃ c (between P c B ∧ P A ≡ P c)</code>, and the point <code>A</code> suffices for the choice of <code>c</code>. In fact, we don't need the hypothesis <code>P is-outside A B</code>, so unlike Narboux we state the theorem without it.
<jh>
thm (LessEqualBetweenReverse ( (c P) (c A) (c B)) ()
  ((between P A B) → (P A ≤ P B)) (
        (between P A B) ImplicationReflexivity

        P A CongruenceReflexivity
        introduceRightConjunctToConsequent
</jh>
Now we apply a substitution <code>c = A → (between P c B ∧ P A ≡ P c ↔ between P A B ∧ P A ≡ P A)</code> to turn <code>between P A B ∧ P A ≡ P A</code> into <code>[ A / c ] (between P c B ∧ P A ≡ P c)</code>.
<jh>
        P EqualityReflexivity
        B EqualityReflexivity
        P P (value c) A B B BetweennessBuilder
        detach2of2
        detach1of2

        A EqualityReflexivity
        P EqualityReflexivity
        P EqualityReflexivity
        P P A A P P (value c) A CongruenceBuilder
        detach1of4
        detach2of3
        detach1of2

        buildConjunctionInConsequent

        makeSubstExplicit
        eliminateBiconditionalForward
        applySyllogism
</jh>
Turning the substitution into ∃ and applying <code>LessEqualCutoff</code> we are done.
<jh>
        A
          c
          ((between P (value c) B) ∧ (P A ≡ P (value c)))
          ThereExistsIntroductionFromObject
        applySyllogism

        P A P B c LessEqualCutoff
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

=== Biconditional ===
Here we combine the previous two results: <code>P is-outside A B → (P A ≤ P B ↔ between P A B)</code>.
<jh>
thm (LessEqualBetween () ()
  ((P is-outside A B) → ((P A ≤ P B) ↔ (between P A B))) (
        P A B LessEqualBetweenForward
        export

        P A B LessEqualBetweenReverse
        (P is-outside A B) introduceAntecedent

        introduceBiconditionalFromImplicationsInConsequent
))
</jh>

== Collinearity ==
In this section we prove a number of results involving collinearity.

=== Outer transitivity ===
Here we prove <code>P ≠ Q ∧ collinear P Q A ∧ collinear P Q B → collinear P A B</code>.<ref>col_transitivity_1 in Narboux</ref> We call it "outer" transitivity although unlike similar-looking results for betweenness, five segment, etc, this does not make it a different theorem than inner transitivity, just a different rearrangement (since the order of points in a collinearity predicate does not matter).

Actually, we first prove it in the slightly rearranged form <code>P ≠ Q ∧ collinear S P Q ∧ collinear X P Q → collinear X P S</code> (in which <code>P</code> and <code>Q</code> are interchanged and the order of the points in the collinearity statements are changed). There is no deep reason for this rearrangement, but it will be slightly more convenient in the next section.

Expanding each <code>collinear</code> in the antecedent by the definition, and then applying associativity, gives us nine cases. In each case we'll be able to prove <code>between X P S</code>, <code>between P X S</code>, <code>between P S X</code>, or a disjunction between two of them. Each case will follow from either betweenness transitivity or betweenness connectivity.

We start with a lemma, and then proceed to the proof.
<jh>
thm (CollinearityCollinearity-1 () ()
  (((between P S X) ∨ (between P X S)) → (collinear X P S)) (
</jh>
We prove <code>collinear X P S</code> via its definition: <code>between X P S ∨ between P S X ∨ between S X P</code>.
<jh>
        P X S BetweennessSymmetry
        eliminateBiconditionalReverse

        (between P S X) disjoinLL

        ((between P S X) ∨ (between S X P))
          (between X P S)
          DisjunctionLeftIntroduction
        applySyllogism

        (between X P S) (between P S X) (between S X P) DisjunctionAssociativity
        eliminateBiconditionalForward
        applySyllogism
))

thm (CollinearityOuterTransitivityRearranged () ()
  ((((P ≠ Q) ∧ (collinear S P Q)) ∧ (collinear X P Q)) →
  (collinear X P S)) (
</jh>
First we associate the two collinearity formulas together.
<jh>
        (P ≠ Q)
          (collinear S P Q)
          (collinear X P Q)
          ConjunctionAssociativity
        eliminateBiconditionalReverse
</jh>
Now we apply distributivity multiple times to separate out the nine cases. Round one: splitting <code>collinear S P Q</code> halfway.
<jh>
        ((between S P Q) ∨ (between P Q S))
          (between Q S P) 
          (collinear X P Q)
          ConjunctionRightDistribution
        eliminateBiconditionalReverse
</jh>
Round two: splitting <code>collinear S P Q</code> the rest of the way.
<jh>
        (between S P Q)
          (between P Q S)
          (collinear X P Q)
          ConjunctionRightDistribution
        eliminateBiconditionalReverse
        ((between Q S P) ∧ (collinear X P Q)) disjoinRR
        applySyllogism
</jh>
Round three: split <code>collinear X P Q</code> halfway.
<jh>
        (between S P Q)
          ((between X P Q) ∨ (between P Q X))
          (between Q X P)
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse

        (between P Q S)
          ((between X P Q) ∨ (between P Q X))
          (between Q X P)
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse

        disjoin

        (between Q S P)
          ((between X P Q) ∨ (between P Q X))
          (between Q X P)
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse

        disjoin
        applySyllogism
</jh>
Round four: split <code>collinear X P Q</code> the rest of the way.
<jh>
        (between S P Q)
          (between X P Q)
          (between P Q X)
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse

        ((between S P Q) ∧ (between Q X P)) disjoinRR

        (between P Q S)
          (between X P Q)
          (between P Q X)
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse

        ((between P Q S) ∧ (between Q X P)) disjoinRR

        disjoin

        (between Q S P)
          (between X P Q)
          (between P Q X)
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse

        ((between Q S P) ∧ (between Q X P)) disjoinRR

        disjoin

        applySyllogism
</jh>
Having split out the nine cases, we combine with <code>P ≠ Q</code> and then distribute <code>P ≠ Q</code> into each of the cases.
<jh>
        (P ≠ Q) conjoinLL
        applySyllogism
</jh>
Round one.
<jh>
        (P ≠ Q)
          (((((between S P Q) ∧ (between X P Q)) ∨
                ((between S P Q) ∧ (between P Q X))) ∨
              ((between S P Q) ∧ (between Q X P))) ∨
            ((((between P Q S) ∧ (between X P Q)) ∨
                ((between P Q S) ∧ (between P Q X))) ∨
              ((between P Q S) ∧ (between Q X P))))
          ((((between Q S P) ∧ (between X P Q)) ∨
              ((between Q S P) ∧ (between P Q X))) ∨
            ((between Q S P) ∧ (between Q X P)))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Round two.
<jh>
        (P ≠ Q)
          ((((between S P Q) ∧ (between X P Q)) ∨
                ((between S P Q) ∧ (between P Q X))) ∨
              ((between S P Q) ∧ (between Q X P)))
          ((((between P Q S) ∧ (between X P Q)) ∨
              ((between P Q S) ∧ (between P Q X))) ∨
            ((between P Q S) ∧ (between Q X P)))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse

        ((P ≠ Q) ∧
          ((((between Q S P) ∧ (between X P Q)) ∨
              ((between Q S P) ∧ (between P Q X))) ∨
            ((between Q S P) ∧ (between Q X P))))
          disjoinRR
        applySyllogism
</jh>
Round three.
<jh>
        (P ≠ Q)
          (((between S P Q) ∧ (between X P Q)) ∨
            ((between S P Q) ∧ (between P Q X)))
          ((between S P Q) ∧ (between Q X P))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse

        (P ≠ Q)
          (((between P Q S) ∧ (between X P Q)) ∨
            ((between P Q S) ∧ (between P Q X)))
          ((between P Q S) ∧ (between Q X P))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse

        disjoin

        (P ≠ Q)
          (((between Q S P) ∧ (between X P Q)) ∨
            ((between Q S P) ∧ (between P Q X)))
          ((between Q S P) ∧ (between Q X P))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse

        disjoin
        applySyllogism
</jh>
Round four.
<jh>
        (P ≠ Q)
          ((between S P Q) ∧ (between X P Q))
          ((between S P Q) ∧ (between P Q X))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        ((P ≠ Q) ∧ ((between S P Q) ∧ (between Q X P))) disjoinRR

        (P ≠ Q)
          ((between P Q S) ∧ (between X P Q))
          ((between P Q S) ∧ (between P Q X))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        ((P ≠ Q) ∧ ((between P Q S) ∧ (between Q X P))) disjoinRR

        disjoin

        (P ≠ Q)
          ((between Q S P) ∧ (between X P Q))
          ((between Q S P) ∧ (between P Q X))
          ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        ((P ≠ Q) ∧ ((between Q S P) ∧ (between Q X P))) disjoinRR

        disjoin
        applySyllogism
</jh>
Sorry breaking out the cases took so long. Anyway, we are ready to tackle them one by one. The first is <code>between S P Q ∧ between X P Q</code> (of course, all of them have <code>P ≠ Q</code> tacked on the front, which we usually will not state explicitly). It follows from the following application of <code>BetweennessMiddleConnectivity</code>: <code>Q ≠ P ∧ between Q P S ∧ between Q P X → between P S X ∨ between P X S</code>
<jh>
        (P ≠ Q)
          ((between S P Q) ∧ (between X P Q))
          ConjunctionRightElimination

        P Q EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism

        (P ≠ Q)
          ((between S P Q) ∧ (between X P Q))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        S P Q BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        (P ≠ Q)
          ((between S P Q) ∧ (between X P Q))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        X P Q BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        Q P S X BetweennessMiddleConnectivity
        applySyllogism
</jh>
To finish the first case we turn <code>between P S X ∨ between P X S</code> into <code>collinear X P S</code>.
<jh>
        P S X CollinearityCollinearity-1
        applySyllogism
</jh>
The second case is <code>between S P Q ∧ between P Q X</code>. This follows from <code>between S P Q ∧ between P Q X ∧ P ≠ Q → between S P X</code>, which is an instance of <code>BetweennessOuterTransitivity</code>.
<jh>
        (P ≠ Q)
          ((between S P Q) ∧ (between P Q X))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        (P ≠ Q)
          ((between S P Q) ∧ (between P Q X))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction

        (P ≠ Q)
          ((between S P Q) ∧ (between P Q X))
          ConjunctionRightElimination

        composeConjunction

        S P Q X BetweennessOuterTransitivity
        applySyllogism
</jh>
Now we need <code>between S P X → collinear X P S</code>.
<jh>
        S P X BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        X P S BetweennessCollinearity
        applySyllogism

        composeDisjunction
</jh>
The third case is <code>between S P Q ∧ between Q X P</code>, which follows from <code>between S P Q ∧ between P X Q → between S P X</code>, which is an instance of <code>BetweennessInnerTransitivity</code>
<jh>
        (P ≠ Q)
          ((between S P Q) ∧ (between Q X P))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        (P ≠ Q)
          ((between S P Q) ∧ (between Q X P))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        Q X P BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        S P Q X BetweennessInnerTransitivity
        applySyllogism
</jh>
To finish this case we need <code>between S P X → collinear X P S</code>.
<jh>
        S P X BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        X P S BetweennessCollinearity
        applySyllogism

        composeDisjunction
</jh>
We now start the second set of cases, those starting with <code>between P Q S</code>. The fourth case is <code>between P Q S ∧ between X P Q</code>, which follows from <code>between X P Q ∧ between P Q S ∧ P ≠ Q → between X P S</code>, which is an instance of <code>BetweennessOuterTransitivity</code>.
<jh>
        (P ≠ Q)
          ((between P Q S) ∧ (between X P Q))
          ConjunctionLeftElimination

        (between P Q S) (between X P Q) ConjunctionCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        (P ≠ Q)
          ((between P Q S) ∧ (between X P Q))
          ConjunctionRightElimination
        composeConjunction

        X P Q S BetweennessOuterTransitivity
        applySyllogism
</jh>
To finish this case we need <code>between X P S → collinear X P S</code>.
<jh>
        X P S BetweennessCollinearity
        applySyllogism
</jh>
The fifth case is <code>between P Q S ∧ between P Q X</code>. This follows from <code>BetweennessOuterConnectivity</code>, which in this case is <code>P ≠ Q ∧ between P Q S ∧ between P Q X → between P S X ∨ between P X S</code>.
<jh>
        (P ≠ Q)
          ((between P Q S) ∧ (between P Q X))
          ConjunctionRightElimination

        (P ≠ Q)
          ((between P Q S) ∧ (between P Q X))
          ConjunctionLeftElimination

        composeConjunction

        (P ≠ Q) (between P Q S) (between P Q X) ConjunctionAssociativity
        eliminateBiconditionalForward
        applySyllogism

        P Q S X BetweennessOuterConnectivity
        applySyllogism
</jh>
To finish this case we turn <code>between P S X ∨ between P X S</code> into <code>collinear X P S</code>.
<jh>
        P S X CollinearityCollinearity-1
        applySyllogism

        composeDisjunction
</jh>
The sixth case is <code>between P Q S ∧ between Q X P</code>. It follows from <code>between P X Q ∧ between P Q S → between P X S</code>, an instance of <code>BetweennessMiddleTransitivityFlipped</code>
<jh>
        (P ≠ Q)
          ((between P Q S) ∧ (between Q X P))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        Q X P BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        (P ≠ Q)
          ((between P Q S) ∧ (between Q X P))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        composeConjunction

        P X Q S BetweennessMiddleTransitivityFlipped
        applySyllogism
</jh>
To finish the case we turn <code>between P X S</code> into <code>collinear X P S</code>.
<jh>
        P X S BetweennessCollinearity
        applySyllogism

        P X S Collinearity12
        eliminateBiconditionalReverse
        applySyllogism

        composeDisjunction

        composeDisjunction
</jh>
We are ready for the last trio of cases, those which start with <code>between Q S P</code>. The seventh case is <code>between Q S P ∧ between X P Q</code>. It follows from <code>between X P Q ∧ between P S Q → between X P S</code>, which is an instance of <code>BetweennessInnerTransitivity</code>.
<jh>
        (P ≠ Q)
          ((between Q S P) ∧ (between X P Q))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        (P ≠ Q)
          ((between Q S P) ∧ (between X P Q))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        Q S P BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        X P Q S BetweennessInnerTransitivity
        applySyllogism
</jh>
To finish the case we turn <code>between X P S</code> into <code>collinear X P S</code>.
<jh>
        X P S BetweennessCollinearity
        applySyllogism
</jh>
The eighth case is <code>between Q S P ∧ between P Q X</code>. It follows by <code>between P S Q ∧ between P Q X → between P S X</code> which is an instance of <code>BetweennessMiddleTransitivityFlipped</code>.
<jh>
        (P ≠ Q)
          ((between Q S P) ∧ (between P Q X))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent

        Q S P BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        (P ≠ Q)
          ((between Q S P) ∧ (between P Q X))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction

        P S Q X BetweennessMiddleTransitivityFlipped
        applySyllogism
</jh>
To finish the case we need to turn <code>between P S X</code> into <code>collinear X P S</code>.
<jh>
        P S X BetweennessCollinearity
        applySyllogism

        X P S CollinearityRotation
        eliminateBiconditionalForward
        applySyllogism

        composeDisjunction
</jh>
The ninth and final case is <code>between Q S P ∧ between Q X P</code>. It follows from <code>between P S Q ∧ between P X Q → between P S X ∨ between P X S</code>, which is an instance of <code>BetweennessInnerConnectivity</code>.
<jh>
        (P ≠ Q)
          ((between Q S P) ∧ (between Q X P))
          ConjunctionLeftElimination

        Q S P BetweennessSymmetry
        Q X P BetweennessSymmetry
        buildConjunction
        eliminateBiconditionalReverse
        applySyllogism

        P S Q X BetweennessInnerConnectivity
        applySyllogism
</jh>
To finish this case, we turn <code>between P S X ∨ between P X S</code> into <code>collinear X P S</code>.
<jh>
        P S X CollinearityCollinearity-1
        applySyllogism

        composeDisjunction

        composeDisjunction
</jh>
To finish the proof, we simply combine the breaking down of the cases with the resolution of each case.
<jh>
        applySyllogism
))
</jh>

Now we return to <code>P ≠ Q ∧ collinear P Q A ∧ collinear P Q B → collinear P A B</code>.
<jh>
thm (CollinearityOuterTransitivity () ()
  ((((P ≠ Q) ∧ (collinear P Q A)) ∧ (collinear P Q B)) →
  (collinear P A B)) (
</jh>
First we need <code>P ≠ Q</code>
<jh>
        ((P ≠ Q) ∧ (collinear P Q A))
          (collinear P Q B)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
</jh>
Second we need <code>collinear A P Q</code>.
<jh>
        ((P ≠ Q) ∧ (collinear P Q A))
          (collinear P Q B)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        A P Q CollinearityRotation
        eliminateBiconditionalForward
        applySyllogism

        composeConjunction
</jh>
Lastly we need <code>collinear B P Q</code>.
<jh>
        ((P ≠ Q) ∧ (collinear P Q A))
          (collinear P Q B)
          ConjunctionLeftElimination

        B P Q CollinearityRotation
        eliminateBiconditionalForward
        applySyllogism

        composeConjunction
</jh>
Applying the previous rearrangement of transitivity gives us <code>collinear B P A</code>, which we then rearrange to <code>collinear P A B</code>.
<jh>
        P Q A B CollinearityOuterTransitivityRearranged
        applySyllogism

        B P A CollinearityRotation
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

=== Being collinear to collinear points ===
Given three collinear distinct points, a fourth point being collinear to two of them is equivalent to being collinear to two others. More precisely, <code>P ≠ Q ∧ S ≠ P ∧ collinear S P Q → (collinear X P Q ↔ collinear X P S)</code>.

The forward direction is <code>P ≠ Q ∧ S ≠ P ∧ collinear S P Q ∧ collinear X P Q → collinear X P S</code>.<ref>l6_16_1 in Narboux</ref> It is almost identical to what we proved in the previous section (we just need to drop the <code>S ≠ P</code>).
<jh>
thm (CollinearityCollinearityForward () ()
  (((((P ≠ Q) ∧ (S ≠ P)) ∧
    (collinear S P Q)) ∧ (collinear X P Q)) →
  (collinear X P S)) (
        (((P ≠ Q) ∧ (S ≠ P)) ∧ (collinear S P Q))
          (collinear X P Q)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        (((P ≠ Q) ∧ (S ≠ P)) ∧ (collinear S P Q))
          (collinear X P Q)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        composeConjunction

        (((P ≠ Q) ∧ (S ≠ P)) ∧ (collinear S P Q))
          (collinear X P Q)
          ConjunctionLeftElimination
        composeConjunction

        P Q S X CollinearityOuterTransitivityRearranged
        applySyllogism
))
</jh>

The reverse direction is <code>P ≠ Q ∧ S ≠ P ∧ collinear S P Q ∧ collinear X P S → collinear X P Q</code>.<ref>l6_16_2 in Narboux</ref> This is essentially the same as the forward direction, as exchanging <code>S</code> and <code>Q</code> doesn't really change the statement. Narboux proves the reverse direction by copy-pasting the proof of the forward direction, interchanging <code>S</code> and <code>Q</code>, but our proof simply performs the right rearrangements to apply the forward direction.
<jh>
thm (CollinearityCollinearityReverse () ()
  (((((P ≠ Q) ∧ (S ≠ P)) ∧
    (collinear S P Q)) ∧ (collinear X P S)) →
  (collinear X P Q)) (
</jh>
We first need <code>P ≠ S</code>.
<jh>
        (((P ≠ Q) ∧ (S ≠ P)) ∧ (collinear S P Q))
          (collinear X P S)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        S P EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next is <code>Q ≠ P</code>.
<jh>
        (((P ≠ Q) ∧ (S ≠ P)) ∧ (collinear S P Q))
          (collinear X P S)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        P Q EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Next is <code>collinear Q P S</code>.
<jh>
        (((P ≠ Q) ∧ (S ≠ P)) ∧ (collinear S P Q))
          (collinear X P S)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        S P Q Collinearity13
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Last is <code>collinear X P S</code>.
<jh>
        (((P ≠ Q) ∧ (S ≠ P)) ∧ (collinear S P Q))
          (collinear X P S)
          ConjunctionLeftElimination

        composeConjunction
</jh>
Applying the forward theorem, with <code>S</code> and <code>Q</code> interchanged, finishes the job.
<jh>
        P S Q X CollinearityCollinearityForward
        applySyllogism
))
</jh>

We combine the two previous results to get <code>P ≠ Q ∧ S ≠ P ∧ collinear S P Q → (collinear X P Q ↔ collinear X P S)</code>
<jh>
thm (CollinearityCollinearity () ()
  ((((P ≠ Q) ∧ (S ≠ P)) ∧ (collinear S P Q)) →
    ((collinear X P Q) ↔ (collinear X P S))) (
        P Q S X CollinearityCollinearityForward
        export

        P Q S X CollinearityCollinearityReverse
        export

        introduceBiconditionalFromImplicationsInConsequent
))
</jh>

=== Inner transitivity ===
Here we prove <code>P ≠ Q ∧ collinear P Q A ∧ collinear P Q B → collinear Q A B</code>.<ref>col_transitivity_2 in Narboux</ref> As we said before, the mathematical meaning of the theorem is not different from the "outer" collinearity transitivity; it is merely a rearrangement.
<jh>
thm (CollinearityInnerTransitivity () ()
  ((((P ≠ Q) ∧ (collinear P Q A)) ∧ (collinear P Q B)) →
  (collinear Q A B)) (
</jh>
We will be applying collinearity outer transitivity. First we need <code>Q ≠ P</code>.
<jh>
        ((P ≠ Q) ∧ (collinear P Q A))
          (collinear P Q B)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        P Q EqualitySymmetry
        addNegation
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Next is <code>collinear Q P A</code>.
<jh>
        ((P ≠ Q) ∧ (collinear P Q A))
          (collinear P Q B)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        P Q A Collinearity12
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Last is <code>collinear Q P B</code>.
<jh>
        ((P ≠ Q) ∧ (collinear P Q A))
          (collinear P Q B)
          ConjunctionLeftElimination

        P Q B Collinearity12
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        Q P A B CollinearityOuterTransitivity
        applySyllogism
))
</jh>

== The intersection of two lines ==
If two distinct, non-degenerate lines intersect, they intersect in a single point. At least for this theorem, we consider a line <code>A B</code> and line <code>C D</code> to be distinct and non-degenerate if <code>¬ collinear A B C ∧ C ≠ D</code>. The statement of the whole theorem is <code>¬ collinear A B C ∧ C ≠ D ∧ collinear A B P ∧ collinear A B Q ∧ collinear C D P ∧ collinear C D Q → P = Q</code>.<ref>l6_21 in Narboux</ref>

The proof consists of multiple applications of collinearity transitivity, together with some cases and a proof by contradiction. It starts with <code>collinear C P Q</code> (by collinearity transitivity).
<jh>
thm (LineIntersection-cpq () ()
  (((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
    (collinear A B P)) ∧ (collinear A B Q)) ∧
    (collinear C D P)) ∧ (collinear C D Q)) →
    (collinear C P Q)) (
</jh>
<code>C ≠ D</code>:
<jh>
        (((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
            (collinear A B P)) ∧ (collinear A B Q)) ∧
            (collinear C D P))
          (collinear C D Q)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
<code>collinear C D P</code>:
<jh>
        (((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
            (collinear A B P)) ∧ (collinear A B Q)) ∧
            (collinear C D P))
          (collinear C D Q)
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
<code>collinear C D Q</code>:
<jh>
        (((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
            (collinear A B P)) ∧ (collinear A B Q)) ∧
            (collinear C D P))
          (collinear C D Q)
          ConjunctionLeftElimination

        composeConjunction

        C D P Q CollinearityOuterTransitivity
        applySyllogism
))
</jh>

Then note that <code>A ≠ B</code> (as a consequence of <code>¬ collinear A B C</code>), and collinearity transitivity gives us <code>collinear A P Q</code> and <code>collinear B P Q</code>.
<jh>
thm (LineIntersection-ab () ()
  (((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
    (collinear A B P)) ∧ (collinear A B Q)) ∧
    (collinear C D P)) ∧ (collinear C D Q)) →
    (A ≠ B)) (
</jh>
We pick out <code>¬ collinear A B C</code>, which we will need shortly.
<jh>
        (((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
            (collinear A B P)) ∧ (collinear A B Q)) ∧
            (collinear C D P))
          (collinear C D Q)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
</jh>
The next step is to note <code>collinear A A C</code> and apply a substitution to turn it into <code>A = B → collinear A B C</code>.
<jh>
        A C CollinearityAAB

        A EqualityReflexivity
        C EqualityReflexivity
        A A A B C C CollinearityBuilder
        detach2of2
        detach1of2

        detachImplicationBiconditional
</jh>
Now we just transpose and combine with <code>¬ collinear A B C</code>.
<jh>
        introduceTransposition
        applySyllogism
))

thm (LineIntersection-abpq () ()
  (((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
    (collinear A B P)) ∧ (collinear A B Q)) ∧
    (collinear C D P)) ∧ (collinear C D Q)) →
    (((A ≠ B) ∧ (collinear A B P)) ∧ (collinear A B Q))) (
</jh>
<code>A ≠ B</code>:
<jh>
        A B C D P Q LineIntersection-ab
</jh>
<code>collinear A B P</code>:
<jh>
        (((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
            (collinear A B P)) ∧ (collinear A B Q)) ∧
            (collinear C D P))
          (collinear C D Q)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
<code>collinear A B Q</code>:
<jh>
        (((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
            (collinear A B P)) ∧ (collinear A B Q)) ∧
            (collinear C D P))
          (collinear C D Q)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
))

thm (LineIntersection-apq () ()
  (((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
    (collinear A B P)) ∧ (collinear A B Q)) ∧
    (collinear C D P)) ∧ (collinear C D Q)) →
    (collinear A P Q)) (
        A B C D P Q LineIntersection-abpq
        A B P Q CollinearityOuterTransitivity
        applySyllogism
))

thm (LineIntersection-bpq () ()
  (((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
    (collinear A B P)) ∧ (collinear A B Q)) ∧
    (collinear C D P)) ∧ (collinear C D Q)) →
    (collinear B P Q)) (
        A B C D P Q LineIntersection-abpq
        A B P Q CollinearityInnerTransitivity
        applySyllogism
))
</jh>

We now assume <code>P ≠ Q</code> and will show <code>collinear A B C</code>, which is a contradiction. The first thing we get from <code>P ≠ Q</code> is <code>collinear A C Q</code> (from <code>collinear A P Q</code> and <code>collinear C P Q</code>).
<jh>
thm (LineIntersection-pqa () ()
  ((((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
    (collinear A B P)) ∧ (collinear A B Q)) ∧
    (collinear C D P)) ∧ (collinear C D Q)) ∧ (P ≠ Q)) →
    (collinear P Q A)) (
        ((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
            (collinear A B P)) ∧ (collinear A B Q)) ∧
            (collinear C D P)) ∧ (collinear C D Q))
          (P ≠ Q)
          ConjunctionRightElimination
        A B C D P Q LineIntersection-apq
        applySyllogism

        A P Q CollinearityRotation
        eliminateBiconditionalReverse
        applySyllogism
))

thm (LineIntersection-pqc () ()
  ((((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
    (collinear A B P)) ∧ (collinear A B Q)) ∧
    (collinear C D P)) ∧ (collinear C D Q)) ∧ (P ≠ Q)) →
    (collinear P Q C)) (
        ((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
            (collinear A B P)) ∧ (collinear A B Q)) ∧
            (collinear C D P)) ∧ (collinear C D Q))
          (P ≠ Q)
          ConjunctionRightElimination
        A B C D P Q LineIntersection-cpq
        applySyllogism

        C P Q CollinearityRotation
        eliminateBiconditionalReverse
        applySyllogism
))

thm (LineIntersection-acq () ()
  ((((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
    (collinear A B P)) ∧ (collinear A B Q)) ∧
    (collinear C D P)) ∧ (collinear C D Q)) ∧ (P ≠ Q)) →
    (collinear A C Q)) (
</jh>
<code>P ≠ Q</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
            (collinear A B P)) ∧ (collinear A B Q)) ∧
            (collinear C D P)) ∧ (collinear C D Q))
          (P ≠ Q)
          ConjunctionLeftElimination
</jh>
<code>collinear P Q A</code>:
<jh>
        A B C D P Q LineIntersection-pqa
        composeConjunction
</jh>
<code>collinear P Q C</code>:
<jh>
        A B C D P Q LineIntersection-pqc
        composeConjunction
</jh>
Transitivity produces <code>collinear Q A C</code>, which we then rearrange to <code>collinear A C Q</code>.
<jh>
        P Q A C CollinearityInnerTransitivity
        applySyllogism

        Q A C CollinearityRotation
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

In a similar way we prove <code>collinear A B Q</code>.

<jh>
thm (LineIntersection-pqb () ()
  ((((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
    (collinear A B P)) ∧ (collinear A B Q)) ∧
    (collinear C D P)) ∧ (collinear C D Q)) ∧ (P ≠ Q)) →
    (collinear P Q B)) (
        ((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
            (collinear A B P)) ∧ (collinear A B Q)) ∧
            (collinear C D P)) ∧ (collinear C D Q))
          (P ≠ Q)
          ConjunctionRightElimination
        A B C D P Q LineIntersection-bpq
        applySyllogism

        B P Q CollinearityRotation
        eliminateBiconditionalReverse
        applySyllogism
))

thm (LineIntersection-abq () ()
  ((((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
    (collinear A B P)) ∧ (collinear A B Q)) ∧
    (collinear C D P)) ∧ (collinear C D Q)) ∧ (P ≠ Q)) →
    (collinear A B Q)) (
</jh>
<code>P ≠ Q</code>:
<jh>
        ((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
            (collinear A B P)) ∧ (collinear A B Q)) ∧
            (collinear C D P)) ∧ (collinear C D Q))
          (P ≠ Q)
          ConjunctionLeftElimination
</jh>
<code>collinear P Q A</code>:
<jh>
        A B C D P Q LineIntersection-pqa
        composeConjunction
</jh>
<code>collinear P Q B</code>:
<jh>
        A B C D P Q LineIntersection-pqb
        composeConjunction
</jh>
Transitivity produces <code>collinear Q A B</code>, which we then rearrange to <code>collinear A B Q</code>.
<jh>
        P Q A B CollinearityInnerTransitivity
        applySyllogism

        Q A B CollinearityRotation
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

Now we consider two cases: <code>Q = A</code> and <code>Q ≠ A</code>.

For the <code>Q = A</code> case, first apply collinearity transitivity to <code>collinear C P Q</code> and <code>collinear B P Q</code> to get <code>collinear C B Q</code>, which turns into our desired contradiction <code>collinear A B C</code> by substituting <code>A</code> for <code>Q</code>.
<jh>
thm (LineIntersection-qa () ()
  (((Q = A) ∧
    (((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
    (collinear A B P)) ∧ (collinear A B Q)) ∧
    (collinear C D P)) ∧ (collinear C D Q)) ∧ (P ≠ Q))) →
    (collinear A B C)) (
</jh>
<code>P ≠ Q</code>:
<jh>
        (Q = A)
          (((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
          (collinear A B P)) ∧ (collinear A B Q)) ∧
          (collinear C D P)) ∧ (collinear C D Q)) ∧ (P ≠ Q))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
</jh>
<code>collinear P Q B</code>:
<jh>
        (Q = A)
          (((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
          (collinear A B P)) ∧ (collinear A B Q)) ∧
          (collinear C D P)) ∧ (collinear C D Q)) ∧ (P ≠ Q))
          ConjunctionLeftElimination
        A B C D P Q LineIntersection-pqb
        applySyllogism

        composeConjunction
</jh>
<code>collinear P Q C</code>:
<jh>
        (Q = A)
          (((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
          (collinear A B P)) ∧ (collinear A B Q)) ∧
          (collinear C D P)) ∧ (collinear C D Q)) ∧ (P ≠ Q))
          ConjunctionLeftElimination
        A B C D P Q LineIntersection-pqc
        applySyllogism

        composeConjunction
</jh>
Applying transitivity yields <code>collinear Q B C</code>, which we then turn into <code>collinear A B C</code> via a subsitution.
<jh>
        P Q B C CollinearityInnerTransitivity
        applySyllogism

        (Q = A)
          (((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
          (collinear A B P)) ∧ (collinear A B Q)) ∧
          (collinear C D P)) ∧ (collinear C D Q)) ∧ (P ≠ Q))
          ConjunctionRightElimination
        composeConjunction

        B EqualityReflexivity
        C EqualityReflexivity
        Q A B B C C CollinearityBuilder
        detach2of2
        detach2of2

        eliminateBiconditionalReverseInConsequent
        applyComm
        import

        applySyllogism
))
</jh>

The <code>Q ≠ A</code> case lets us apply transitivity to <code>collinear A C Q</code> and <code>collinear A B Q</code> to get <code>collinear A B C</code>, which is our desired contradiction.
<jh>
thm (LineIntersection-qnota () ()
  (((Q ≠ A) ∧
    (((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
    (collinear A B P)) ∧ (collinear A B Q)) ∧
    (collinear C D P)) ∧ (collinear C D Q)) ∧ (P ≠ Q))) →
    (collinear A B C)) (
</jh>
<code>Q ≠ A</code>:
<jh>
        (Q ≠ A)
          (((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
          (collinear A B P)) ∧ (collinear A B Q)) ∧
          (collinear C D P)) ∧ (collinear C D Q)) ∧ (P ≠ Q))
          ConjunctionRightElimination
</jh>
<code>collinear Q A B</code>:
<jh>
        (Q ≠ A)
          (((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
          (collinear A B P)) ∧ (collinear A B Q)) ∧
          (collinear C D P)) ∧ (collinear C D Q)) ∧ (P ≠ Q))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        Q A B CollinearityRotation
        eliminateBiconditionalForward
        applySyllogism

        composeConjunction
</jh>
<code>collinear Q A C</code>:
<jh>
        (Q ≠ A)
          (((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
          (collinear A B P)) ∧ (collinear A B Q)) ∧
          (collinear C D P)) ∧ (collinear C D Q)) ∧ (P ≠ Q))
          ConjunctionLeftElimination
        A B C D P Q LineIntersection-acq
        applySyllogism

        Q A C CollinearityRotation
        eliminateBiconditionalForward
        applySyllogism

        composeConjunction

        Q A B C CollinearityInnerTransitivity
        applySyllogism
))
</jh>

Next we combine the cases.
<jh>
thm (LineIntersection-abc () ()
  ((((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
    (collinear A B P)) ∧ (collinear A B Q)) ∧
    (collinear C D P)) ∧ (collinear C D Q)) ∧ (P ≠ Q)) →
    (collinear A B C)) (
        Q A B C D P LineIntersection-qa
        export

        Q A B C D P LineIntersection-qnota
        export

        eliminateCases
))
</jh>

Here we point out the contradiction.
<jh>
thm (LineIntersection-contradiction () ()
  ((((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
    (collinear A B P)) ∧ (collinear A B Q)) ∧
    (collinear C D P)) ∧ (collinear C D Q)) ∧ (P ≠ Q)) →
    (⊥)) (
        A B C D P Q LineIntersection-abc

        ((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
            (collinear A B P)) ∧ (collinear A B Q)) ∧
            (collinear C D P)) ∧ (collinear C D Q))
          (P ≠ Q)
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction

        (collinear A B C) Contradiction
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

Since assuming <code>P ≠ Q</code> produced a contradiction, we can conclude that <code>P = Q</code>.
<jh>
thm (LineIntersection () ()
  (((((((¬ (collinear A B C)) ∧ (C ≠ D)) ∧
    (collinear A B P)) ∧ (collinear A B Q)) ∧
    (collinear C D P)) ∧ (collinear C D Q)) →
    (P = Q)) (
        A B C D P Q LineIntersection-contradiction
        export

        (P ≠ Q) NegationImplication
        eliminateBiconditionalForward
        applySyllogism

        (P = Q) DoubleNegation
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

== The existence of a point not on a given line ==
Given a line, there is a point which is not on that line. Formally, <code>A ≠ B → ∃ c ¬ collinear A B c</code>.<ref>l6_25 in Narboux</ref>

The proof, not surprisingly, is based on <code>LowerDimension</code>, which gives us three non-collinear points x, y, and z. If any one of them is not on the line (that is, <code>¬ collinear A B x</code> or likewise for y or z), we are done. But if they are all collinear with <code>A</code> and <code>B</code>, we can conclude <code>collinear x y z</code> by transitivity, which is a contradiction.

We start by restating <code>LowerDimension</code> in terms of collinearity.
<jh>
thm (LowerDimensionCollinearity ((a b c)) ()
  (∃ a (∃ b (∃ c (¬ (collinear (value a) (value b) (value c)))))) (
        a b c LowerDimension

        (between (value a) (value b) (value c))
          (between (value b) (value c) (value a))
          DeMorganPDP
        eliminateBiconditionalForward
        (¬ (between (value c) (value a) (value b))) conjoinRR
        c addThereExists
        b addThereExists
        a addThereExists
        applyModusPonens

        ((between (value a) (value b) (value c)) ∨
            (between (value b) (value c) (value a)))
          (between (value c) (value a) (value b))
          DeMorganPDP
        eliminateBiconditionalForward
        c addThereExists
        b addThereExists
        a addThereExists
        applyModusPonens
))
</jh>

The next lemma says that if we have a point not collinear with <code>A</code> and <code>B</code>, we are done.
<jh>
thm (PointNotOnLineLemma ((c A) (c B) (c P)) ()
  ((¬ (collinear A B P)) → (∃ c (¬ (collinear A B (value c))))) (
        A EqualityReflexivity
        B EqualityReflexivity
        A A B B (value c) P CollinearityBuilder
        detach2of3
        detach1of2

        addNegationInConsequent

        makeSubstExplicit
        eliminateBiconditionalForward

        P c (¬ (collinear A B (value c))) ThereExistsIntroductionFromObject
        applySyllogism
))
</jh>

We're ready to start working on getting <code>collinear x y z</code> by transitivity. There are two cases: <code>A = X</code> and <code>A ≠ X</code>. The <code>A = X</code> case is the easier one: we first conclude <code>collinear A Y Z</code> and then substitute <code>X</code> for <code>A</code>.
<jh>
thm (PointNotOnLine-ax () ()
  (((A = X) ∧ (((collinear A B X) ∧ ((collinear A B Y) ∧
    (A ≠ B))) ∧ (collinear A B Z))) →
  (collinear X Y Z)) (
</jh>
<code>A ≠ B</code>:
<jh>
        (A = X)
          (((collinear A B X) ∧ ((collinear A B Y) ∧
            (A ≠ B))) ∧ (collinear A B Z))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
<code>collinear A B Y</code>:
<jh>
        (A = X)
          (((collinear A B X) ∧ ((collinear A B Y) ∧
            (A ≠ B))) ∧ (collinear A B Z))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
<code>collinear A B Z</code>:
<jh>
        (A = X)
          (((collinear A B X) ∧ ((collinear A B Y) ∧
            (A ≠ B))) ∧ (collinear A B Z))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Applying transitivity gives <code>collinear A Y Z</code>,
<jh>
        A B Y Z CollinearityOuterTransitivity
        applySyllogism
</jh>
and applying a substitution turns that into <code>collinear X Y Z</code>.
<jh>
        (A = X)
          (((collinear A B X) ∧ ((collinear A B Y) ∧
            (A ≠ B))) ∧ (collinear A B Z))
          ConjunctionRightElimination
        composeConjunction

        Y EqualityReflexivity
        Z EqualityReflexivity
        A X Y Y Z Z CollinearityBuilder
        detach2of2
        detach2of2

        eliminateBiconditionalReverseInConsequent
        applyComm
        import
        applySyllogism
))
</jh>

The <code>A ≠ X</code> case involves first proving <code>collinear A X Y</code> and <code>collinear A X Z</code> (each by transitivity), and applying transitivity again, to get <code>collinear X Y Z</code>.
<jh>
thm (PointNotOnLine-anotx () ()
  (((A ≠ X) ∧ (((collinear A B X) ∧ ((collinear A B Y) ∧
    (A ≠ B))) ∧ (collinear A B Z))) →
  (collinear X Y Z)) (
</jh>
We start with <code>A ≠ X</code>.
<jh>
        (A ≠ X)
          (((collinear A B X) ∧ ((collinear A B Y) ∧
            (A ≠ B))) ∧ (collinear A B Z))
          ConjunctionRightElimination
</jh>
To prove <code>collinear A X Y</code>, we first need <code>A ≠ B</code>:
<jh>
        (A ≠ X)
          (((collinear A B X) ∧ ((collinear A B Y) ∧
            (A ≠ B))) ∧ (collinear A B Z))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
<code>collinear A B X</code>:
<jh>
        (A ≠ X)
          (((collinear A B X) ∧ ((collinear A B Y) ∧
            (A ≠ B))) ∧ (collinear A B Z))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
<code>collinear A B Y</code>:
<jh>
        (A ≠ X)
          (((collinear A B X) ∧ ((collinear A B Y) ∧
            (A ≠ B))) ∧ (collinear A B Z))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
That's all we need for <code>collinear A X Y</code>
<jh>
        A B X Y CollinearityOuterTransitivity
        applySyllogism
        composeConjunction
</jh>
Now we need <code>collinear A X Z</code>, and the first antecedent is <code>A ≠ B</code>.
<jh>
        (A ≠ X)
          (((collinear A B X) ∧ ((collinear A B Y) ∧
            (A ≠ B))) ∧ (collinear A B Z))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent
</jh>
<code>collinear A B X</code>:
<jh>
        (A ≠ X)
          (((collinear A B X) ∧ ((collinear A B Y) ∧
            (A ≠ B))) ∧ (collinear A B Z))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
<code>collinear A B Z</code>:
<jh>
        (A ≠ X)
          (((collinear A B X) ∧ ((collinear A B Y) ∧
            (A ≠ B))) ∧ (collinear A B Z))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
Applying transitivity we get <code>collinear A X Z</code>
<jh>
        A B X Z CollinearityOuterTransitivity
        applySyllogism
        composeConjunction
</jh>
We are now ready to apply transitivity to <code>A ≠ X</code>, <code>collinear A X Y</code>, and <code>collinear A X Z</code> to get <code>collinear X Y Z</code>.
<jh>
        A X Y Z CollinearityInnerTransitivity
        applySyllogism
))
</jh>

We now combine the <code>A = X</code> and <code>A ≠ X</code> cases and rearrange a bit.
<jh>
thm (PointNotOnLine-abz () ()
  ((((collinear A B X) ∧ ((collinear A B Y) ∧
    (A ≠ B))) ∧ (¬ (collinear X Y Z))) →
  (¬ (collinear A B Z))) (
        A X B Y Z PointNotOnLine-ax
        export

        A X B Y Z PointNotOnLine-anotx
        export

        eliminateCases

        export

        (collinear A B Z) (collinear X Y Z) Transposition
        eliminateBiconditionalReverse
        applySyllogism

        import
))
</jh>

The next lemma gets rid of <code>collinear A B X</code> (because the case <code>¬ collinear A B X</code> is taken care of by <code>PointNotOnLineLemma</code>).
<jh>
thm (PointNotOnLine-eliminate-abx ((c A) (c B) (c X) (c Z)) ()
  ((((collinear A B Y) ∧ (A ≠ B)) ∧ (¬ (collinear X Y Z))) →
  (∃ c (¬ (collinear A B (value c))))) (
</jh>
First, the <code>collinear A B X</code> case:
<jh>
        (collinear A B X)
          ((collinear A B Y) ∧ (A ≠ B))
          (¬ (collinear X Y Z))
          ConjunctionAssociativity
        eliminateBiconditionalForward

        A B X Y Z PointNotOnLine-abz
        applySyllogism

        A B Z c PointNotOnLineLemma
        applySyllogism

        export
</jh>
Second, the <code>¬ collinear A B X</code> case:
<jh>
        (¬ (collinear A B X))
          (((collinear A B Y) ∧ (A ≠ B)) ∧ (¬ (collinear X Y Z)))
          ConjunctionRightElimination
        A B X c PointNotOnLineLemma
        applySyllogism

        export
</jh>
Now we just need to combine the cases.
<jh>
        eliminateCases
))
</jh>

In a very similar manner we get rid of <code>collinear A B Y</code>.
<jh>
thm (PointNotOnLine-eliminate-aby ((c A) (c B) (c X) (c Y) (c Z)) ()
  (((A ≠ B) ∧ (¬ (collinear X Y Z))) →
  (∃ c (¬ (collinear A B (value c))))) (
</jh>
First, the <code>collinear A B Y</code> case:
<jh>
        (collinear A B Y)
          (A ≠ B)
          (¬ (collinear X Y Z))
          ConjunctionAssociativity
        eliminateBiconditionalForward

        A B Y X Z c PointNotOnLine-eliminate-abx
        applySyllogism

        export
</jh>
Second, the <code>¬ collinear A B Y</code> case:
<jh>
        (¬ (collinear A B Y))
          ((A ≠ B) ∧ (¬ (collinear X Y Z)))
          ConjunctionRightElimination
        A B Y c PointNotOnLineLemma
        applySyllogism

        export
</jh>
Now we just need to combine the cases.
<jh>
        eliminateCases
))
</jh>

At this point we are very close. The only thing remaining in the antecedent that we need to get rid of is <code>¬ collinear X Y Z</code>. But <code>X</code>, <code>Y</code>, and <code>Z</code> no longer appear anywhere else in the formula. So we can quantify at will, specifically to turn <code>¬ collinear X Y Z</code> into <code>∃ x ∃ y ∃ z ¬ collinear x y z</code>, which we can then detach as it is a theorem.

<jh>
thm (PointNotOnLine ((c A) (c B)  (x y z A) (x y z B) (x y z c)) ()
  ((A ≠ B) → (∃ c (¬ (collinear A B (value c))))) (
</jh>
First we put the theorem on the proof stack.
<jh>
        x y z LowerDimensionCollinearity
</jh>
Now we show we can move the quantifiers to the start: <code>A ≠ B ∧ ∃ x ∃ y ∃ z ¬ collinear x y z → ∃ x ∃ y ∃ z (A ≠ B ∧ ¬ collinear x y z)</code>
<jh>
        x
          (A ≠ B)
          (∃ y (∃ z (¬ (collinear (value x) (value y) (value z)))))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward

        y
          (A ≠ B)
          (∃ z (¬ (collinear (value x) (value y) (value z))))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        x addThereExists
        applySyllogism

        z
          (A ≠ B)
          (¬ (collinear (value x) (value y) (value z)))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        y addThereExists
        x addThereExists
        applySyllogism

</jh>
Now we can introduce the previous theorem and then add the quantifiers.
<jh>
        A B (value x) (value y) (value z) c PointNotOnLine-eliminate-aby
        z addThereExistsToAntecedent
        y addThereExistsToAntecedent
        x addThereExistsToAntecedent

        applySyllogism
</jh>
Detaching the theorem finishes the proof.
<jh>
        detach2of2
))
</jh>

== Intersecting lines and congruences ==
[[File:Theorem t2_8 from Narboux.svg|thumb|right]]
Given two intersecting line segments, where the portions of each segment on the sides of the intersection are congruent, the segments drawn from the endpoints of one line segment to the endpoints of the other are congruent. That is, <code>between A B C ∧ between D B E ∧ A B ≡ D B ∧ B C ≡ B E → A E ≡ C D</code>.<ref>Theorem t2_8 in Narboux</ref>

We consider <code>A = B</code> and <code>A ≠ B</code> cases. The <code>A = B</code> case is easy: <code>A = B</code> implies <code>D = B</code> and substituting into <code>B C ≡ B E</code> gives us <code>A E ≡ C D</code>.

The <code>A ≠ B</code> case follows from outer five segment, using baselines <code>A B C</code> and <code>D B E</code> and points <code>D</code> and <code>A</code>.

Starting on the <code>A = B</code> case, the first step is proving <code>D = B</code>.
<jh>
thm (IntersectionCongruence-db () ()
  (((A = B) ∧ ((((between A B C) ∧ (between D B E)) ∧
    (A B ≡ D B)) ∧ (B C ≡ B E))) →
  (D = B)) (
</jh>
To apply <code>CongruenceIdentityFromEquality</code>, we first need <code>A = B</code>.
<jh>
        (A = B)
          ((((between A B C) ∧ (between D B E)) ∧
            (A B ≡ D B)) ∧ (B C ≡ B E))
          ConjunctionRightElimination
</jh>
Secondly, we need <code>A B ≡ D B</code>.
<jh>
        (A = B)
          ((((between A B C) ∧ (between D B E)) ∧
            (A B ≡ D B)) ∧ (B C ≡ B E))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
That lets us conclude <code>D = B</code>.
<jh>
        A B D B CongruenceIdentityFromEquality
        applySyllogism
))

thm (IntersectionCongruence-ab () ()
  (((A = B) ∧ ((((between A B C) ∧ (between D B E)) ∧
    (A B ≡ D B)) ∧ (B C ≡ B E))) →
  (A E ≡ C D)) (
</jh>
We'll need <code>B C ≡ B E</code> a bit later, so we put it on the proof stack.
<jh>
        (A = B)
          ((((between A B C) ∧ (between D B E)) ∧
            (A B ≡ D B)) ∧ (B C ≡ B E))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent
</jh>
The next step is the substitution. The substitution will be <code>D = B ∧ A = B → (D C ≡ A E ↔ B C ≡ B E)</code>, so we start with <code>D = B ∧ A = B</code>.
<jh>
        A B C D E IntersectionCongruence-db

        (A = B)
          ((((between A B C) ∧ (between D B E)) ∧
            (A B ≡ D B)) ∧ (B C ≡ B E))
          ConjunctionRightElimination

        composeConjunction
</jh>
Here is <code>D = B ∧ A = B → (D C ≡ A E ↔ B C ≡ B E)</code>, as promised.
<jh>
        C EqualityReflexivity
        E EqualityReflexivity
        D B C C A B E E CongruenceBuilder
        detach2of2
        detach2of3

        applySyllogism
</jh>
Pulling <code>B C ≡ B E</code> off the proof stack and combining, we get <code>D C ≡ A E</code>.
<jh>
        eliminateBiconditionalForwardInConsequent
        applyModusPonensInConsequent
</jh>
Now we just rearrange that congruence to <code>A E ≡ C D</code>.
<jh>
        D C A E CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        A E D C CongruenceRightCommutativity
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

Now we are ready for the <code>A ≠ B</code> case, in which we apply outer five segment using baselines <code>A B C</code> and <code>D B E</code> and points <code>D</code> and <code>A</code>.
<jh>
thm (IntersectionCongruence-anotb () ()
  (((A ≠ B) ∧ ((((between A B C) ∧ (between D B E)) ∧
    (A B ≡ D B)) ∧ (B C ≡ B E))) →
  (A E ≡ C D)) (
</jh>
First we need <code>A ≠ B</code>.
<jh>
        (A ≠ B)
          ((((between A B C) ∧ (between D B E)) ∧
            (A B ≡ D B)) ∧ (B C ≡ B E))
          ConjunctionRightElimination
</jh>
We need two betweenness relationships, the first of which is <code>between A B C</code>.
<jh>
        (A ≠ B)
          ((((between A B C) ∧ (between D B E)) ∧
            (A B ≡ D B)) ∧ (B C ≡ B E))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        composeConjunction
</jh>
The other is <code>between D B E</code>.
<jh>
        (A ≠ B)
          ((((between A B C) ∧ (between D B E)) ∧
            (A B ≡ D B)) ∧ (B C ≡ B E))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
There are two congruences for the baseline, <code>A B ≡ D B</code>,
<jh>
        (A ≠ B)
          ((((between A B C) ∧ (between D B E)) ∧
            (A B ≡ D B)) ∧ (B C ≡ B E))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
and <code>B C ≡ B E</code>.
<jh>
        (A ≠ B)
          ((((between A B C) ∧ (between D B E)) ∧
            (A B ≡ D B)) ∧ (B C ≡ B E))
          ConjunctionLeftElimination
        eliminateLeftConjunctInConsequent

        composeConjunction
</jh>
The off-baseline congruences are <code>A D ≡ D A</code>,
<jh>
        A D CongruenceABBA
        introduceRightConjunctToConsequent
</jh>
and <code>B D ≡ B A</code>.
<jh>
        (A ≠ B)
          ((((between A B C) ∧ (between D B E)) ∧
            (A B ≡ D B)) ∧ (B C ≡ B E))
          ConjunctionLeftElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        A B D B CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        D B A B CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Applying five segment gives us <code>C D ≡ E A</code>, which we then rearrange to <code>A E ≡ C D</code>.
<jh>
        A B C D B E D A OuterFiveSegment
        applySyllogism

        C D E A CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        E A C D CongruenceLeftCommutativity
        eliminateBiconditionalReverse
        applySyllogism
))

thm (IntersectionCongruence () ()
  (((((between A B C) ∧ (between D B E)) ∧
    (A B ≡ D B)) ∧ (B C ≡ B E)) →
  (A E ≡ C D)) (
        A B C D E IntersectionCongruence-ab
        export

        A B C D E IntersectionCongruence-anotb
        export

        eliminateCases
))
</jh>

== Export ==
We now export to [[Interface:Out lines]].
<jh>
export (RESULTS Interface:Out_lines (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>
* Tarski, Alfred; Givant, Steven (1999), "Tarski's system of geometry", The Bulletin of Symbolic Logic 5 (2): 175–214, doi:10.2307/421089, MR1791303, ISSN 1079-8986

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]
