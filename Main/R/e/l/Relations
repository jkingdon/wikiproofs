{{header
 | title    = Relations
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = Here we start with [[Interface:Basic operations of general set theory]] and provide ordered pairs, relations, and functions. }}
{{interfaces
| imports = [[Interface:Basic operations of general set theory]]
| exports = none yet
}}

We first import [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|first-order logic]].
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (BASIC Interface:Basic_operations_of_general_set_theory (CLASSICAL FIRSTORDER) ())
</jh>

As usual, capital letters starting from <code>A</code> are set expressions (that is, objects or "classes") and lowercase letters starting with <code>x</code> are set variables.
<jh>
var (object A B C D A0 A1 B0 B1)
var (variable x y z w)
</jh>

== Unordered pairs ==
Logically, these theorems belong with the other unordered pair theorems in [[General set theory]]. However, until JHilbert changes its handling of dummy variables in definitions, it may be easier to handle them here.

=== An unordered pair contains its first member ===
Here we show that <code>A ∈ {A, B}</code>.<ref>[http://us.metamath.org/mpeuni/prid1.html prid1], metamath's set.mm, accessed August 4, 2010.</ref>
<jh>
thm (UnorderedPairLeftMembership () () (A ∈ (unorderedPair A B)) (
        A EqualityReflexivity
        (A = B) introduceRightDisjunction

        A A B UnorderedPair
        eliminateBiconditionalForward

        applyModusPonens
))
</jh>

=== Unordered pair equality can imply equality of members ===
<code>{A, C} = {B, C} → A = B</code>.<ref>[http://us.metamath.org/mpeuni/preqr1.html preqr1], metamath's set.mm, accessed August 4, 2010</ref>

First we prove a lemma, <code>{A, C} = {B, C} → A = B ∨ A = C</code>
<jh>
thm (UnorderedPairFirstMembersEqual-1 () () (((unorderedPair A C) = (unorderedPair B C)) → ((A = B) ∨ (A = C))) (
        A C UnorderedPairLeftMembership

        (unorderedPair A C) (unorderedPair B C) A IsElementBuilderLL

        detachImplicationBiconditional
</jh>
That gives us <code>{A, C} = {B, C} → A ∈ {B, C}</code>.
<jh>
        A B C UnorderedPair
        eliminateBiconditionalReverse
        applySyllogism
))

# ...to be continued
</jh>

== Ordered pair ==
The ordered pair <code>〈A, B〉</code> can be defined in several ways as long as the definition implies the key ordered pair theorem <code>〈A0, B0〉=〈A1, B1〉↔ A0 = A1 ∧ B0 = B1</code>. The most widely adopted definition is <code>〈A, B〉≝ { {A}, {A, B} }</code>, which is the one we use. Because the notation <code>〈A, B〉</code> is not available in JHilbert, we call it <code>(orderedPair A B)</code>.
<jh>
def ((orderedPair A B) (unorderedPair (singleton A) (unorderedPair A B)))
</jh>

=== Ordered pair builder ===
Equals can be substituted for equals in ordered pairs, that is, <code>A0 = A1 ∧ B0 = B1 →〈A0, B0〉=〈A1, B1〉</code>. This forms one direction of the ordered pair theorem (it is the less interesting of the two, as it holds for a wide variety of operations, not just ordered pairs).
<jh>
thm (OrderedPairBuilder () () (((A0 = A1) ∧ (B0 = B1)) → ((orderedPair A0 B0) = (orderedPair A1 B1))) (
        (A0 = A1) (B0 = B1) ConjunctionRightElimination
        A0 A1 SingletonBuilder
        applySyllogism

        A0 A1 B0 B1 UnorderedPairBuilder

        composeConjunction

        (singleton A0) (singleton A1) (unorderedPair A0 B0) (unorderedPair A1 B1) UnorderedPairBuilder
        applySyllogism
))
</jh>

== To be added ==
Either here or in other set theory files: induction, recursion, ordinal successors. some kinds of unions, intersection, set difference, and so on.

[[Category:Other classical set theory]]