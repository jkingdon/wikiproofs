{{header
 | title    = Relations
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = Here we start with [[Interface:Basic operations of Zermelo–Fraenkel set theory]] and provide ordered pairs, relations, and functions. }}
{{interfaces
| imports = [[Interface:Basic operations of Zermelo–Fraenkel set theory]]
| exports = [[Interface:Set theory]]
}}

We first import [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|first-order logic]].
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
</jh>

We also import [[Interface:Basic operations of Zermelo–Fraenkel set theory]], which is the current home of some of the basic results involving singletons, unordered pairs, and the like. 
<jh>
import (BASIC Interface:Basic_operations_of_Zermelo–Fraenkel_set_theory (CLASSICAL FIRSTORDER) ())
</jh>

As usual, capital letters starting from <code>A</code> are set expressions (that is, objects or "classes") and lowercase letters starting with <code>x</code> are set variables.
<jh>
var (object A B C D A0 A1 B0 B1 α β)
var (variable a b x y z w x′ y′ z′)
var (formula φ)
</jh>

== Singletons ==
Logically, these theorems belong with the other singleton theorems in [[First steps in set theory]]. However, until JHilbert changes its handling of dummy variables in definitions, it may be easier to handle them here.

=== A set is an element of its singleton ===
Here we show <code>A ∈ {A}</code>.<ref>[http://us.metamath.org/mpeuni/snid.html snid], metamath's set.mm, accessed August 5, 2010</ref>
<jh>
thm (SingletonMembership () () (A ∈ (singleton A)) (
        A EqualityReflexivity

        A A Singleton
        eliminateBiconditionalForward

        applyModusPonens
))
</jh>

== Unordered pairs ==
Logically, these theorems belong with the other unordered pair theorems in [[First steps in set theory]]. However, until JHilbert changes its handling of dummy variables in definitions, it may be easier to handle them here.

=== An unordered pair contains its first member ===
Here we show that <code>A ∈ {A, B}</code>.<ref>[http://us.metamath.org/mpeuni/prid1.html prid1], metamath's set.mm, accessed August 4, 2010.</ref>
<jh>
thm (UnorderedPairLeftMembership () () (A ∈ (unorderedPair A B)) (
        A EqualityReflexivity
        (A = B) introduceRightDisjunction

        A A B UnorderedPair
        eliminateBiconditionalForward

        applyModusPonens
))
</jh>

A similar result holds, of course, for the second member.<ref>[http://us.metamath.org/mpeuni/prid2.html prid2], metamath's set.mm, accessed February 2, 2011.</ref>

<jh>
thm (UnorderedPairRightMembership () () (B ∈ (unorderedPair A B)) (
        B EqualityReflexivity
        (B = A) introduceLeftDisjunction

        B A B UnorderedPair
        eliminateBiconditionalForward

        applyModusPonens
))
</jh>

=== Unordered pair commutativity ===
Unordered pairs are unordered: <code>{A, B} = {B, A}</code>.
<jh>
thm (UnorderedPairCommutativity ((x A) (x B)) () ((unorderedPair A B) = (unorderedPair B A)) (
        (value x) A B UnorderedPair

        ((value x) = A) ((value x) = B) DisjunctionCommutativity
        applyBiconditionalTransitivity

        (value x) B A UnorderedPair
        swapBiconditional
        applyBiconditionalTransitivity

        x generalize
        x (unorderedPair A B) (unorderedPair B A) ExtensionalityObject

        applyModusPonens
))
</jh>

=== Unordered pair equality can imply equality of members ===
Here we prove <code>{A, C} = {B, C} → A = B</code>.<ref>[http://us.metamath.org/mpeuni/preqr1.html preqr1], metamath's set.mm, accessed August 4, 2010</ref>

First we prove a lemma, <code>{A, C} = {B, C} → A = B ∨ A = C</code>
<jh>
thm (UnorderedPairFirstMembersEqual-1 () () (((unorderedPair A C) = (unorderedPair B C)) → ((A = B) ∨ (A = C))) (
        A C UnorderedPairLeftMembership

        (unorderedPair A C) (unorderedPair B C) A IsElementBuilderLL

        detachImplicationBiconditional
</jh>
That gives us <code>{A, C} = {B, C} → A ∈ {B, C}</code>.
<jh>
        A B C UnorderedPair
        eliminateBiconditionalReverse
        applySyllogism
))

thm (UnorderedPairFirstMembersEqual () () (((unorderedPair A C) = (unorderedPair B C)) → (A = B)) (
</jh>
We apply our lemma once to get <code>{A, C} = {B, C} → A = B ∨ A = C</code>
<jh>
        A C B UnorderedPairFirstMembersEqual-1

</jh>
Applying the lemma a second time, with some commutations, gives us <code>{A, C} = {B, C} → A = B ∨ B = C</code>
<jh>
        (unorderedPair A C) (unorderedPair B C) EqualitySymmetry
        eliminateBiconditionalReverse
        B C A UnorderedPairFirstMembersEqual-1
        applySyllogism

        B A EqualitySymmetry
        transformImplicationDisjunctionLeft
</jh>
We now combine the two results to get <code>{A, C} = {B, C} → (A = B ∨ A = C) ∧ (A = B ∨ B = C)</code>, and apply distributivity to the right hand side to turn it into <code>A = B ∨ (A = C ∧ B = C)</code>.
<jh>
        composeConjunction
        (A = B) (A = C) (B = C) DisjunctionLeftDistribution
        eliminateBiconditionalForward
        applySyllogism
</jh>
We turn <code>A = C ∧ B = C</code> into <code>A = B</code>, and after a bit more rearrangement, we are done.
<jh>
        B C EqualitySymmetry
        eliminateBiconditionalReverse
        (A = C) conjoinLL
        A C B EqualityTransitivity
        applySyllogism

        (A = B) disjoinLL
        applySyllogism

        (A = B) DisjunctionIdempotence
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

Here is a commuted version: <code>{C, A} = {C, B} → A = B</code>.<ref>[http://us.metamath.org/mpeuni/preqr2.html preqr2], metamath's set.mm, accessed August 4, 2010</ref>
<jh>
thm (UnorderedPairSecondMembersEqual () () (((unorderedPair C A) = (unorderedPair C B)) → (A = B)) (
        C A UnorderedPairCommutativity
        C B UnorderedPairCommutativity
        buildEquality
        eliminateBiconditionalReverse

        A C B UnorderedPairFirstMembersEqual
        applySyllogism
))
</jh>

== Separation ==
Logically, these theorems belong with the other separation theorems in [[First steps in set theory]]. However, until JHilbert changes its handling of dummy variables in definitions, it may be easier to handle them here.

Although, in general, we cannot specify a set by a formula ("the set of all x for which φ holds") and expect it to exist, such a definition does specify a set in the case in which the formula φ implies that x is part of some set which is known to exist. There might be a few ways to formalize this notion; the one here is particularly aimed at helping us make a definition of the form <code>{z ∈ A | φ}</code> and then prove a statement about membership in that defined set. In symbols, given <code>φ → z ∈ A</code> we conclude <code>B ∈ {z ∈ A | φ} ↔ [B / z]φ</code>.
<jh>
thm (FormulaBoundLemma ((z A) (z B)) ((H (φ → ((value z) ∈ A))))
  (((B ∈ A) ∧ (subst B z φ)) ↔ (subst B z φ)) (
</jh>
The forward direction is trivial.
<jh>
        (B ∈ A) (subst B z φ) ConjunctionLeftElimination
</jh>
To prove the reverse direction we start by adding a substitution to our hypothesis to get <code>[ B / z ] φ → [ B / z ] z ∈ A</code>.
<jh>
        H
        B z addSubst
</jh>
Now we perform the latter subsitution, starting with <code>z = B → (z ∈ A ↔ B ∈ A)</code>, and then combining with the previous step to get <code>[ B / z ] φ → B ∈ A</code>.
<jh>
        (value z) B A IsElementBuilderRR
        makeSubstExplicit
        eliminateBiconditionalReverse
        applySyllogism
</jh>
We now just need to add <code>[ B / z ] φ</code> and combine the two directions.
<jh>
        (subst B z φ) ImplicationReflexivity
        composeConjunction

        introduceBiconditionalFromImplications
))

thm (FormulaBound ((z A) (z B)) ((H (φ → ((value z) ∈ A))))
  ((B ∈ (separate z A φ)) ↔ (subst B z φ)) (
        B z A φ Separation
        H
        B FormulaBoundLemma
        applyBiconditionalTransitivity
))
</jh>

== Unions ==
Logically, these theorems belong with the other union theorems in [[First steps in set theory]]. However, until JHilbert changes its handling of dummy variables in definitions, it may be easier to handle them here.

The union of two sets is just a special case of the union of a set: <code>A ∪ B</code> is defined to be <code>⋃ {A, B}</code>.
<jh>
def ((∪ A B) (⋃ (unorderedPair A B)))
</jh>

=== A lemma involving substitution ===
Here we prove <code>A ∈ B ↔ ∃ x (A ∈ x ∧ x = B)</code>. This only holds because of the [[Interface:Axiom of quantifiability]]; a treatment of set theory which does not have that axiom (for example, because it allows proper classes) will handle things differently.
<jh>
thm (IsElementThereExists ((x A) (x B)) ()
  ((A ∈ B) ↔ (∃ x ((A ∈ (value x)) ∧ ((value x) = B)))) (
</jh>
We start with the forward direction. First we prove <code>A ∈ B → ∃ x (x = B ∧ A ∈ B)</code>.
<jh>
        (A ∈ B) ImplicationReflexivity
        x B Quantifiability
        introduceLeftConjunctToConsequent

        x ((value x) = B) (A ∈ B) ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applySyllogism
</jh>
Next is the substitution <code>x = B → (A ∈ x ↔ A ∈ B)</code>, which we then rearrange to <code>x = B ∧ A ∈ B → A ∈ x)</code>.
<jh>
        (value x) B A IsElementBuilderLL
        eliminateBiconditionalForwardInConsequent
        import
</jh>
Combining this with <code>x = B</code> we get <code>x = B ∧ A ∈ B → A ∈ x ∧ x = B</code>, and adding in the quantifier we finish the forward direction.
<jh>
        ((value x) = B) (A ∈ B) ConjunctionRightElimination
        composeConjunction

        x addThereExists
        applySyllogism
</jh>
The reverse direction is just a substitution. We start with <code>x = B → (A ∈ x ↔ A ∈ B)</code> and rearrange it to <code>A ∈ x ∧ x = B → A ∈ B</code>.
<jh>
        (value x) B A IsElementBuilderLL
        eliminateBiconditionalReverseInConsequent
        applyComm
        import
</jh>
Adding in the quantifier finishes the reverse direction, and we combine the two directions.
<jh>
        x addThereExists
        removeThereExistsInConsequent

        introduceBiconditionalFromImplications
))
</jh>

=== Membership in a union related to membership in one of the two sets ===
The next theorem, <code>A ∈ B ∪ C ↔ A ∈ B ∨ A ∈ C</code>, is another way of stating what the union of two sets means.<ref>[http://us.metamath.org/mpeuni/elun.html elun] in metamath's set.mm, accessed January 22, 2011</ref>
<jh>
thm (BinaryUnion ( (x A) (x B) (x C)) () ((A ∈ (B ∪ C)) ↔ ((A ∈ B) ∨ (A ∈ C))) (
</jh>
We apply the definition of the union of two sets, and the <code>Union</code> theorem to get <code>A ∈ ⋃ {B, C} ↔ ∃ x (A ∈ x ∧ x ∈ {B, C})</code>
<jh>
        A (unorderedPair B C) x Union
</jh>
Expanding the unordered pair turns that into <code>∃ x (A ∈ x ∧ (x = B ∨ x = C))</code>.
<jh>
        (value x) B C UnorderedPair
        (A ∈ (value x)) buildConjunctionLL
        x buildThereExists
        applyBiconditionalTransitivity
</jh>
Distributivity gives us <code>∃ x ((A ∈ x ∧ x = B) ∨ (A ∈ x ∧ x = C))</code> and splitting the quantifier turns that into <code>∃ x (A ∈ x ∧ x = B) ∨ ∃ x (A ∈ x ∧ x = C)</code>.
<jh>
        (A ∈ (value x)) ((value x) = B) ((value x) = C) ConjunctionLeftDistribution
        x buildThereExists
        applyBiconditionalTransitivity

        x
          ((A ∈ (value x)) ∧ ((value x) = B))
          ((A ∈ (value x)) ∧ ((value x) = C))
          ThereExistsDisjunction
        applyBiconditionalTransitivity
</jh>
Now we can apply the lemma from the previous section to get <code>A ∈ B ∨ A ∈ C</code>.
<jh>
        A B x IsElementThereExists

        A C x IsElementThereExists

        buildDisjunction
        swapBiconditional
        applyBiconditionalTransitivity
))
</jh>

== Subset ==
Logically, these theorems belong with the other subset theorems in [[First steps in set theory]]. However, until JHilbert changes its handling of dummy variables in definitions, it may be easier to handle them here.

=== Singleton and subset ===
Here we prove <code>A ∈ B ↔ { A } ⊆ B</code>.<ref>[http://us.metamath.org/mpeuni/snss.html snss], metamath's set.mm, accessed January 29, 2011</ref>

<jh>
thm (SingletonSubset ( (x A) (x B)) ()
  ((A ∈ B) ↔ ((singleton A) ⊆ B)) (
</jh>
We start from the <code>{ A } ⊆ B</code> side, first expanding it to <code>∀ x (x ∈ { A } → x ∈ B)</code>.
<jh>
        (singleton A) B x Subset
</jh>
Then we transform the <code>x ∈ { A }</code> into <code>x = A</code>
<jh>
        (value x) A Singleton
        ((value x) ∈ B) buildImplicationConsequent
        x buildForAll
        applyBiconditionalTransitivity
</jh>
That gives us <code>∀ x (x = A → x ∈ B)</code>, which is equivalent to <code>A ∈ B</code> via the substitution <code>x = A → (x ∈ B ↔ A ∈ B)</code>.
<jh>
        (value x) A B IsElementBuilderRR
        ImplicitForAll
        applyBiconditionalTransitivity

        swapBiconditional
))
</jh>

=== Subset and membership ===
If one set is a subset of another, then being an element of the subset implies being an element of the containing set. That is, <code>A ⊆ B → (C ∈ A → C ∈ B)</code>. This resembles <code>Subset</code>, but it is not biconditional because it does not make a statement about all potential elements, but just about one particular one.<ref>[http://us.metamath.org/mpeuni/ssel.html ssel], metamath's set.mm, accessed February 1, 2011</ref>
<jh>
thm (SubsetMembership ( (x A) (x B)) ()
  ((A ⊆ B) → ((C ∈ A) → (C ∈ B))) (
</jh>
First we expand <code>A ⊆ B</code> to <code>∀ x (x ∈ A → x ∈ B)</code>.
<jh>
        A B x Subset
</jh>
Then we conjoin <code>x = C</code> to both sides of the implication to get <code>∀ x (x = C ∧ x ∈ A → x = C ∧ x ∈ B)</code>
<jh>
        ((value x) ∈ A) ((value x) ∈ B) ((value x) = C) ConjunctionMultiplicationLL
        x addForAll
        applySyllogism
</jh>
Next we distribute the quantifier across the implication to get <code>∃ x (x = C ∧ x ∈ A) → ∃ x (x = C ∧ x ∈ B)</code>.
<jh>
        x
          (((value x) = C) ∧ ((value x) ∈ A))
          (((value x) = C) ∧ ((value x) ∈ B))
          ForAllImplicationThereExists
        applySyllogism
</jh>
But the two halves of that are equivalent to <code>C ∈ A</code> and <code>C ∈ B</code>, respectively, thanks to <code>MembershipThereExists</code>.
<jh>
        C A x MembershipThereExists
        C B x MembershipThereExists
        buildImplication
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

=== Unordered pair and subset ===
Analogous to the result we already proved which relates a singleton being a subset to the singleton's element being an element, here is a similar result for unordered pairs: <code>A ∈ C ∧ B ∈ C ↔ { A, B } ⊆ C</code>.<ref>[http://us.metamath.org/mpeuni/prss.html prss], metamath's set.mm, accessed February 1, 2011</ref>
<jh>
thm (UnorderedPairSubsetForward ( (x A) (x B) (x C)) ()
  (((A ∈ C) ∧ (B ∈ C)) → ((unorderedPair A B) ⊆ C)) (
</jh>
We begin with <code>A ∈ C → (x = A → x ∈ C)</code> and likewise for <code>B</code>
<jh>
        (value x) A C MembershipBuilderRR
        eliminateBiconditionalForwardInConsequent
        applyComm

        (value x) B C MembershipBuilderRR
        eliminateBiconditionalForwardInConsequent
        applyComm
</jh>
We combine the two implications with conjunctions to get <code>A ∈ C ∧ B ∈ C → ((x = A → x ∈ C) ∧ (x = B → x ∈ C))</code>, but the consequent of that simplifies to <code>x = A ∨ x = B → x ∈ C</code>.
<jh>
        conjoin

        ((value x) = A)
          ((value x) ∈ C)
          ((value x) = B)
          DisjunctionComposition
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Now we transform <code>x = A ∨ x = B</code> into <code>x ∈ { A, B }</code>.
<jh>
        (value x) A B UnorderedPair
        swapBiconditional
        transformImplicationImplicationAntecedent
</jh>
That gives <code>A ∈ C ∧ B ∈ C → (x ∈ { A, B } → x ∈ C)</code>. But the consequent simplifies to just <code>{ A, B } ⊆ C</code>.
<jh>
        x addForAllToConsequent

        (unorderedPair A B) C x Subset
        eliminateBiconditionalForward
        applySyllogism
))

thm (UnorderedPairSubsetReverse ( (x A) (x B) (x C)) ()
  (((unorderedPair A B) ⊆ C) → ((A ∈ C) ∧ (B ∈ C))) (
        A B UnorderedPairLeftMembership
        (unorderedPair A B) C A SubsetMembership
        applyComm
        applyModusPonens

        A B UnorderedPairRightMembership
        (unorderedPair A B) C B SubsetMembership
        applyComm
        applyModusPonens

        composeConjunction
))

thm (UnorderedPairSubset () ()
  (((A ∈ C) ∧ (B ∈ C)) ↔ ((unorderedPair A B) ⊆ C)) (
        A C B UnorderedPairSubsetForward
        A C B UnorderedPairSubsetReverse
        introduceBiconditionalFromImplications
))
</jh>

== Ordered pair ==
The ordered pair <code>〈A, B〉</code> can be defined in several ways as long as the definition implies the key ordered pair theorem <code>〈A0, B0〉=〈A1, B1〉↔ A0 = A1 ∧ B0 = B1</code>. The most widely adopted definition is <code>〈A, B〉≝ { {A}, {A, B} }</code>, which is the one we use. Because the notation <code>〈A, B〉</code> is not available in JHilbert, we call it <code>(orderedPair A B)</code>.
<jh>
def ((orderedPair A B) (unorderedPair (singleton A) (unorderedPair A B)))
</jh>

=== Ordered pair builder ===
Equals can be substituted for equals in ordered pairs, that is, <code>A0 = A1 ∧ B0 = B1 →〈A0, B0〉=〈A1, B1〉</code>. This forms one direction of the ordered pair theorem (it is the less interesting of the two, as it holds for a wide variety of operations, not just ordered pairs).
<jh>
thm (OrderedPairBuilder () () (((A0 = A1) ∧ (B0 = B1)) → ((orderedPair A0 B0) = (orderedPair A1 B1))) (
        (A0 = A1) (B0 = B1) ConjunctionRightElimination
        A0 A1 SingletonBuilder
        applySyllogism

        A0 A1 B0 B1 UnorderedPairBuilder

        composeConjunction

        (singleton A0) (singleton A1) (unorderedPair A0 B0) (unorderedPair A1 B1) UnorderedPairBuilder
        applySyllogism
))
</jh>

We also provide the usual convenience builders.
<jh>
thm (OrderedPairBuilderLL () () ((B0 = B1) → ((orderedPair A B0) = (orderedPair A B1))) (
        A EqualityReflexivity
        A A B0 B1 OrderedPairBuilder
        export
        applyModusPonens
))

thm (OrderedPairBuilderRR () () ((A0 = A1) → ((orderedPair A0 B) = (orderedPair A1 B))) (
        B EqualityReflexivity
        A0 A1 B B OrderedPairBuilder
        export
        applyComm
        applyModusPonens
))
</jh>

=== First half of the ordered pair theorem ===
In this section we prove <code>〈A0, B0〉=〈A1, B1〉→ A0 = A1</code>.

Our first lemma is <code>{A} ∈ 〈A, B〉</code>a simple consequence of our definition of ordered pair.<ref>[http://us.metamath.org/mpeuni/opi1.html opi1], metamath's set.mm, accessed August 5, 2010.</ref>
<jh>
thm (OrderedPairTheoremForwardFirst-1 () () ((singleton A) ∈ (orderedPair A B)) (
        (singleton A) (unorderedPair A B) UnorderedPairLeftMembership
))
</jh>

The next lemma, <code>A ∈ 〈B, C〉 ↔ A = {B} ∨ A = {B, C}</code>, also follows directly from our definition of ordered pair.<ref>[http://us.metamath.org/mpeuni/elop.html elop], metamath's set.mm, accessed August 5, 2010.</ref>
<jh>
thm (OrderedPairTheoremForwardFirst-2 () () ((A ∈ (orderedPair B C)) ↔ ((A = (singleton B)) ∨ (A = (unorderedPair B C)))) (
         A (singleton B) (unorderedPair B C) UnorderedPair
))
</jh>

We're ready for <code>〈A0, B0〉=〈A1, B1〉→ A0 = A1</code>. We rename the variables in an effort to make the proof easier to read: <code>〈A, B〉=〈C, D〉→ A = C</code><ref>[http://us.metamath.org/mpeuni/opth1.html opth1], metamath's set.mm, accessed August 5, 2010.</ref>
<jh>
thm (OrderedPairTheoremForwardFirst () () (((orderedPair A B) = (orderedPair C D)) → (A = C)) (
</jh>
The first step is <code>〈A, B〉=〈C, D〉 → ({C} ∈ 〈A, B〉 ↔ {C} ∈ 〈C, D〉)</code>, from our builder for <code>∈</code>.

But <code>{C} ∈ 〈C, D〉</code> is true unconditionally, so this formula reduces to <code>〈A, B〉=〈C, D〉 → {C} ∈ 〈A, B〉</code>.
<jh>
        C D OrderedPairTheoremForwardFirst-1
        (orderedPair A B) (orderedPair C D) (singleton C) IsElementBuilderLL
        detachImplicationBiconditionalRight
</jh>
We now apply our other lemma to turn <code>{C} ∈ 〈A, B〉</code> into <code>{C} = {A} ∨ {C} = {A, B}</code>.
<jh>
        (singleton C) A B OrderedPairTheoremForwardFirst-2
        eliminateBiconditionalReverse
        applySyllogism
</jh>
We'll show that each half of <code>{C} = {A} ∨ {C} = {A, B}</code> implies <code>A ∈ {C}</code>.  The left half follows from <code>{C} = {A} → (A ∈ {C} ↔ A ∈ {A})</code> once we detach the theorem <code>A ∈ {A}</code>.
<jh>
        A SingletonMembership
        (singleton C) (singleton A) A IsElementBuilderLL
        detachImplicationBiconditionalRight
</jh>
The right half is similar: the builder gives us <code>{C} = {A, B} → (A ∈ {C} ↔ A ∈ {A, B})</code> and we can detach <code>A ∈ {A, B}</code>.
<jh>
        A B UnorderedPairLeftMembership
        (singleton C) (unorderedPair A B) A IsElementBuilderLL
        detachImplicationBiconditionalRight
</jh>
We now compose the two and combine with our earlier result to get <code>〈A, B〉=〈C, D〉 → A ∈ {C}</code>
<jh>
        composeDisjunction
        applySyllogism
</jh>
Transforming <code>A ∈ {C}</code> to <code>A = C</code> finishes the proof.
<jh>
        A C Singleton
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

=== Second half of the ordered pair theorem ===
In this section we prove <code>〈A0, B0〉=〈A1, B1〉→ B0 = B1</code>.

Our first lemma is <code>〈C, D〉=〈C, B〉→ D = B</code>.<ref>Taken from a portion of the proof of [http://us.metamath.org/mpeuni/opth.html opth], metamath's set.mm, accessed August 6, 2010.</ref>
<jh>
thm (OrderedPairTheoremForwardSecond-1 () () (((orderedPair C D) = (orderedPair C B)) → (D = B)) (
</jh>
The definition of ordered pair gives us <code>{{C}, {C, D}} = {{C}, {C, B}}</code> and two applications of <code>UnorderedPairSecondMembersEqual</code> give us <code>D = B</code>.
<jh>
        (singleton C) (unorderedPair C D) (unorderedPair C B) UnorderedPairSecondMembersEqual
        C D B UnorderedPairSecondMembersEqual
        applySyllogism
))
</jh>

The next lemma is most of the work. It is <code>〈A, B〉=〈C, D〉→ (A = C → D = B)</code>.
<jh>
thm (OrderedPairTheoremForwardSecond-2 () () (((orderedPair A B) = (orderedPair C D)) → ((A = C) → (D = B))) (
</jh>
We start with <code>〈A, B〉=〈C, D〉→ (〈A, B〉=〈C, B〉 ↔ 〈C, D〉=〈C, B〉)</code>.
<jh>
        (orderedPair A B) (orderedPair C D) (orderedPair C B) EqualityBuilderRR
</jh>
The ordered pair builder and a bit of rearrangment turns that into <code>〈A, B〉=〈C, D〉→ (A = C → 〈C, D〉=〈C, B〉)</code>.
<jh>
        ((orderedPair A B) = (orderedPair C B)) ((orderedPair C D) = (orderedPair C B)) BiconditionalReverseElimination
        applySyllogism

        A C B OrderedPairBuilderRR
        ((orderedPair C D) = (orderedPair C B)) addCommonConsequent
        applySyllogism
</jh>
Applying the lemma <code>OrderedPairTheoremForwardSecond-1</code> turns this into <code>〈A, B〉=〈C, D〉→ (A = C → D = B)</code>, our desired result.
<jh>
        C D B OrderedPairTheoremForwardSecond-1
        (A = C) addCommonAntecedent
        applySyllogism
))
</jh>

We now combine <code>〈A, B〉=〈C, D〉→ A = C</code> and <code>〈A, B〉=〈C, D〉→ (A = C → D = B)</code> to get <code>〈A, B〉=〈C, D〉→ B = D</code>.
<jh>
thm (OrderedPairTheoremForwardSecond () () (((orderedPair A B) = (orderedPair C D)) → (B = D)) (
        A B C D OrderedPairTheoremForwardFirst
        A B C D OrderedPairTheoremForwardSecond-2
        applyModusPonensInConsequent

        D B EqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

=== Ordered pair theorem ===
We are now ready to combine these results to prove the ordered pair theorem <code>〈A0, B0〉=〈A1, B1〉↔ A0 = A1 ∧ B0 = B1</code>. We prove the forward implication,
<jh>
thm (OrderedPairTheoremForward () () (((orderedPair A0 B0) = (orderedPair A1 B1)) → ((A0 = A1) ∧ (B0 = B1))) (
        A0 B0 A1 B1 OrderedPairTheoremForwardFirst
        A0 B0 A1 B1 OrderedPairTheoremForwardSecond
        composeConjunction
))
</jh>

and the biconditionalized theorem.
<jh>
thm (OrderedPairTheorem () () (((orderedPair A0 B0) = (orderedPair A1 B1)) ↔ ((A0 = A1) ∧ (B0 = B1))) (
        A0 B0 A1 B1 OrderedPairTheoremForward
        A0 A1 B0 B1 OrderedPairBuilder
        introduceBiconditionalFromImplications
))
</jh>

== Relations ==
A relation is a set of ordered pairs. We typically use the letters R, S, T, and U for relations.
<jh>
def ((relation A) (∀ z (((value z) ∈ A) → (∃ x (∃ y ((value z) = (orderedPair (value x) (value y))))))))
var (object R S T U)
</jh>

Here we prove a theorem form of the definition. The distinct variable constraints are needed for soundness (analogous to the distinct variable constraints in, for example, metamath's dfss2<ref>[http://us.metamath.org/mpeuni/dfss2.html dfss2], metamath's set.mm, accessed 1 Oct 2010</ref>).
<jh>
thm (Relation ((x y z A) (x′ y′ z′ x y z A)) ()
  ((relation A) ↔ (∀ z (((value z) ∈ A) → (∃ x (∃ y ((value z) = (orderedPair (value x) (value y)))))))) (
</jh>
To prove this we need to prove that the truth of the formula doesn't depend on the choice of variables for <code>x</code>, <code>y</code>, and <code>z</code>. In other words, <code>∀ z′ (z′ ∈ A → ∃ x′ ∃ y′ z′ = 〈x′, y′〉) ↔ ∀ z (z ∈ A → ∃ x ∃ y z = 〈x, y〉)</code>

We'll first worry about the explicit substitutions and getting them in the right place relative to the quantifiers. We work from the outside in, so the first step is <code>∀ z (z ∈ A → ∃ x ∃ y z = 〈x, y〉) ↔ ∀ z′ [z′ / z] (z ∈ A → ∃ x ∃ y z = 〈x, y〉)</code>
<jh>
        z (((value z) ∈ A) → (∃ x (∃ y ((value z) = (orderedPair (value x) (value y)))))) z′ ChangeVariableExplicitForAll
</jh>
We now move the substitution inside all quantifiers.
<jh>
        (value z′) z ((value z) ∈ A) (∃ x (∃ y ((value z) = (orderedPair (value x) (value y))))) SubstImplication
        z′ buildForAll
        applyBiconditionalTransitivity

        (value z′) z x (∃ y ((value z) = (orderedPair (value x) (value y)))) SubstThereExists
        (subst (value z′) z ((value z) ∈ A)) buildImplicationAntecedent
        z′ buildForAll
        applyBiconditionalTransitivity

        (value z′) z y ((value z) = (orderedPair (value x) (value y))) SubstThereExists
        x buildThereExists
        (subst (value z′) z ((value z) ∈ A)) buildImplicationAntecedent
        z′ buildForAll
        applyBiconditionalTransitivity
</jh>
That gives us <code>∀ z (z ∈ A → ∃ x ∃ y z = 〈x, y〉) ↔ ∀ z′ ([z′ / z] z ∈ A → ∃ x ∃ y [z′ / z] z = 〈x, y〉)</code>. The next step is to add the substitution for <code>x′</code>.
<jh>
        x (∃ y (subst (value z′) z ((value z) = (orderedPair (value x) (value y))))) x′ ChangeVariableExplicitThereExists
        (subst (value z′) z ((value z) ∈ A)) buildImplicationAntecedent
        z′ buildForAll
        applyBiconditionalTransitivity

        (value x′) x y (subst (value z′) z ((value z) = (orderedPair (value x) (value y)))) SubstThereExists
        x′ buildThereExists
        (subst (value z′) z ((value z) ∈ A)) buildImplicationAntecedent
        z′ buildForAll
        applyBiconditionalTransitivity
</jh>
That gives us <code>∀ z (z ∈ A → ∃ x ∃ y z = 〈x, y〉) ↔ ∀ z′ ([z′ / z] z ∈ A → ∃ x′ ∃ y [x′ / x] [z′ / z] z = 〈x, y〉)</code>. The next step is to add the substitution for <code>y′</code>.
<jh>
        y (subst (value x′) x (subst (value z′) z ((value z) = (orderedPair (value x) (value y))))) y′ ChangeVariableExplicitThereExists
        x′ buildThereExists
        (subst (value z′) z ((value z) ∈ A)) buildImplicationAntecedent
        z′ buildForAll
        applyBiconditionalTransitivity
</jh>
Now we perform the substitutions. The first one is <code>[z′ / z] z ∈ A ↔ z′ ∈ A</code>.
<jh>
        (value z) (value z′) A IsElementBuilderRR
        makeSubstExplicit
</jh>
The next is <code>[z′ / z] z = 〈x, y〉 ↔ z′ = 〈x, y〉</code>.
<jh>
        (value z) (value z′) (orderedPair (value x) (value y)) EqualityBuilderRR
        makeSubstExplicit

        (value x′) x buildSubst
</jh>
The next is <code>[x′ / x] z′ = 〈x, y〉 ↔ z′ = 〈x′, y〉</code>.
<jh>
        (value x) (value x′) (value y) OrderedPairBuilderRR
        (value z′) buildEqualityLLInConsequent
        makeSubstExplicit
        applyBiconditionalTransitivity

        (value y′) y buildSubst
</jh>
The next is <code>[y′ / y] z′ = 〈x′, y〉 ↔ z′ = 〈x′, y′〉</code>.
<jh>
        (value y) (value y′) (value x′) OrderedPairBuilderLL
        (value z′) buildEqualityLLInConsequent
        makeSubstExplicit
        applyBiconditionalTransitivity
</jh>
We combine with the <code>z ∈ A</code> substitution.
<jh>
        y′ buildThereExists
        x′ buildThereExists

        buildImplication
        z′ buildForAll
        applyBiconditionalTransitivity
</jh>
We have proved <code>∀ z (z ∈ A → ∃ x ∃ y z = 〈x, y〉) ↔ ∀ z′ (z′ ∈ A → ∃ x′ ∃ y′ z′ = 〈x′, y′〉)</code>. JHilbert will unify the one with the primes with <code>(relation A)</code>, if we just put it on the left hand side.
<jh>
        swapBiconditional
))
</jh>

A relation for two objects holds if and only if the corresponding ordered pair is an element of the relation. A more conventional notation would just write this as <code>A R B</code> rather than <code>relates A R B</code>,<ref>[http://us.metamath.org/mpeuni/wbr.html wbr], metamath's set.mm, accessed September 18, 2010</ref> but JHilbert does not offer that option.
<jh>
def ((relates A R B) ((orderedPair A B) ∈ R))
</jh>

== Cartesian product ==
The Cartesian product of two sets is the set of all ordered pairs consisting of one set from the first given set and one set from the second given set.

To show that it exists, we need to define it terms of a larger set which contains it. The larger set is <code>(power (power A ∪ B))</code> (this choice depends on our definition of ordered pair). Based on this concept, we define <code>A × B</code> to be <code>{z ∈ (power (power (A ∪ B))) | ∃ a ∃ b z = 〈a, b〉∧ a ∈ A ∧ b ∈ B}</code>.
<jh>
def ((× A B) (separate z (power (power (A ∪ B)))
  (∃ a (∃ b ((((value z) = (orderedPair (value a) (value b))) ∧ ((value a) ∈ A)) ∧ ((value b) ∈ B))))))
</jh>

To go from the definition to various theorems which restate what a Cartesian product is, our first lemma is <code>α ∈ A ∧ β ∈ B → 〈α, β〉∈ (power (power (A ∪ B))</code>.
<jh>
#thm (IsElementCartesianProductLemma () ()
#  (((α ∈ A) ∧ (β ∈ B)) → ((orderedPair α β) ∈ (power (power (A ∪ B))))) (
#))
</jh>

== To be added ==
Either here or in other set theory files: induction, recursion, ordinal successors. some kinds of unions, intersection, set difference, and so on.

== Export ==
We export to [[Interface:Set theory]].
<jh>
export (SETS Interface:Set_theory (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>

[[Category:Other classical set theory]]

