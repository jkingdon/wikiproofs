{{interfaces
| imports = [[Interface:Real number axioms]]
| exports = [[Interface:Real numbers]]
}}

The '''[[w:real numbers|real numbers]]''' are defined here by axioms which define addition, multiplication, and the [[w:completeness of the real numbers|completeness]] property. Here we add some elementary consequences of the axioms such as subtraction.

We import the interfaces we build on, which are logic, set theory, and the real number axioms.
<jh>
import (PROPOSITIONAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (PROPOSITIONAL) ())
import (SETS Interface:Set_theory (PROPOSITIONAL FIRSTORDER) ())
import (AXIOMS Interface:Real_number_axioms (PROPOSITIONAL FIRSTORDER SETS) ())

var (object a b c d)
var (variable x)
</jh>

== Addition ==
There are a few theorems which have different names in [[Interface:Real numbers]] than they did in [[Interface:Real number axioms]], but are otherwise unchanged.
<jh>
thm (RealAdditionCommutativity () () (((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) → ((a + b) = (b + a))) (
        a b AdditionCommutativity
))

thm (RealAdditionAssociativity () () ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) → (((a + b) + c) = (a + (b + c)))) (
        a b c AdditionAssociativity
))

thm (RealAdditiveIdentity () () ((a ∈ (ℝ)) → ((a + (0)) = a)) (
        a AdditiveIdentity
))
</jh>

=== Builders ===
We have assumed the basic addition builder as an axiom, so we just want to define some convenience theorems.
<jh>
var (object b0 b1 a0 a1)
thm (AdditionBuilderLL () () ((b0 = b1) → ((a + b0) = (a + b1))) (
        a EqualityReflexivity
        a a b0 b1 AdditionBuilder
        detach1of2
))

thm (AdditionBuilderRR () () ((a0 = a1) → ((a0 + b) = (a1 + b))) (
        b EqualityReflexivity
        a0 a1 b b AdditionBuilder
        detach2of2
))
</jh>

== Additive inverse ==
We define <code>- a</code> to be the unique number <code>x</code> for which <code>a + x = 0</code>.
{{cleanup|deciding whether to stick to this definition or moving this after subtraction is defined and then defining - a to be 0 − a}}
<jh>
def ((- a) (⋃ (separate x (ℝ) ((a + (value x)) = (0)))))
</jh>

That an additive inverse exists is a consequence of the invertibility of addition. We just need to rearrange some things.
<jh>
thm (RealAdditiveInverseExists ((x a)) () ((a ∈ (ℝ)) →
  (∃ x (((value x) ∈ (ℝ)) ∧ ((a + (value x)) = (0))))) (
        ZeroReal
        (0) a x AdditionInvertibility
        detach1of2

        (0) (a + (value x)) EqualitySymmetry
        eliminateBiconditionalReverse
        ((value x) ∈ (ℝ)) conjoinLL
        x addThereExists
        applySyllogism
))
</jh>

=== Addition Cancellation ===
In this section we are going to prove <code>a + c = b + c → a = b</code>.

<jh>
thm (RealAdditionCancellationRightForward-ab () ()
  ((((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) ∧ ((d ∈ (ℝ)) ∧ ((c + d) = (0)))) ∧ ((a + c) = (b + c))) →
  (a = b)) (
</jh>
We start with <code>a + c = b + c</code> and then add <code>d</code> to both sides.
<jh>
        ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) ∧ ((d ∈ (ℝ)) ∧ ((c + d) = (0))))
          ((a + c) = (b + c))
          ConjunctionLeftElimination

        (a + c) (b + c) d AdditionBuilderRR
        applySyllogism
</jh>
The next step is to regroup the additions. This is just a matter of applying associativity twice, but needing to assert that all the terms are real is what makes this part of the proof longer. 
<jh>
        ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) ∧ ((d ∈ (ℝ)) ∧ ((c + d) = (0))))
          ((a + c) = (b + c))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) ∧ ((d ∈ (ℝ)) ∧ ((c + d) = (0))))
          ((a + c) = (b + c))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        composeConjunction

        ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) ∧ ((d ∈ (ℝ)) ∧ ((c + d) = (0))))
          ((a + c) = (b + c))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        composeConjunction

        a c d AdditionAssociativity
        applySyllogism

        ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) ∧ ((d ∈ (ℝ)) ∧ ((c + d) = (0))))
          ((a + c) = (b + c))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) ∧ ((d ∈ (ℝ)) ∧ ((c + d) = (0))))
          ((a + c) = (b + c))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent
        composeConjunction

        ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) ∧ ((d ∈ (ℝ)) ∧ ((c + d) = (0))))
          ((a + c) = (b + c))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateRightConjunctInConsequent
        composeConjunction

        b c d AdditionAssociativity
        applySyllogism

        buildEqualityInConsequent

        eliminateBiconditionalReverseInConsequent
        applyModusPonensInConsequent
</jh>
That gives us <code>a + (c + d) = b + (c + d)</code>. Now we turn each occurrence of <code>c + d</code> into <code>0</code> via the substitution <code>c + d = 0 → (a + (c + d) = b + (c + d) ↔ a + 0 = b + 0)</code>.
<jh>
        ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) ∧ ((d ∈ (ℝ)) ∧ ((c + d) = (0))))
          ((a + c) = (b + c))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent
        eliminateLeftConjunctInConsequent

        (c + d) (0) a AdditionBuilderLL
        (c + d) (0) b AdditionBuilderLL
        buildEqualityInConsequent
        eliminateBiconditionalReverseInConsequent
        applySyllogism

        applyModusPonensInConsequent
</jh>
Now we have <code>a + 0 = b + 0</code> and we just need to turn that into <code>a = b</code>.
<jh>
        ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) ∧ ((d ∈ (ℝ)) ∧ ((c + d) = (0))))
          ((a + c) = (b + c))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent

        a RealAdditiveIdentity
        applySyllogism

        ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) ∧ ((d ∈ (ℝ)) ∧ ((c + d) = (0))))
          ((a + c) = (b + c))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent
        eliminateRightConjunctInConsequent
        eliminateLeftConjunctInConsequent

        b RealAdditiveIdentity
        applySyllogism

        buildEqualityInConsequent
        eliminateBiconditionalReverseInConsequent
        applyModusPonensInConsequent
))

thm (RealAdditionCancellationRightForward ( (x a) (x b) (x c)) ()
  ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) → (((a + c) = (b + c)) → (a = b))) (
</jh>
We start with <code>∃ x (x ∈ ℝ ∧ c + x = 0)</code>
<jh>
        ((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) (c ∈ (ℝ)) ConjunctionLeftElimination
        c x RealAdditiveInverseExists
        applySyllogism
</jh>
Copying the antecedent inside the quantifier we are ready to apply our lemma.
<jh>
        repeatAntecedentThereExists

        a b c (value x) RealAdditionCancellationRightForward-ab
        export
        x addThereExists
        applySyllogism

        removeThereExistsInConsequent
))
</jh>

We've proved the interesting direction of cancellation, but in line with our usual practice of biconditionalizing theorems which can be biconditionalized, we combine it with the addition builder.
<jh>
thm (RealAdditionCancellationRight () ()
  ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) → (((a + c) = (b + c)) ↔ (a = b))) (
        a b c RealAdditionCancellationRightForward

        a b c AdditionBuilderRR
        (((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) introduceAntecedent

        introduceBiconditionalFromImplicationsInConsequent
))
</jh>

=== Closure of additive inverse ===
Here we prove that <code>- a</code> is real if <code>a</code> is real. This involves showing that the additive inverse is unique and doing enough logic to turn that into the proof that <code>- a</code> is real.

The first lemma is <code>a ∈ ℝ ∧ x ∈ ℝ → a + A = 0 ↔ A = x</code> TODO: what about A being real?

<jh>
#thm (RealAdditiveInverseClosed () () ((a ∈ (ℝ)) → ((- a) ∈ (ℝ))) (
#))
</jh>

Here are some theorems about showing that an operation is closed on a base set. They start from the starting point that the result of the operation is unique. That is, <code>∃ x (x ∈ BaseSet ∧ φx ∧ ∀ y (φy → y = x))</code> (where <code>φx</code> and <code>φy</code> represent the same formula, with <code>x</code> and with <code>y</code>, respectively).

We start by showing that <code>A = x → A ∈ baseSet ∧ [ A / y ] φy</code>. This is basically just a matter of substitution into <code>x ∈ baseSet</code> and <code>φx</code>.
<jh>
var (object baseSet xx A)
var (variable y)
var (formula φx φy)

thm (ClosureLemma1Reverse-baseSet () ((HSUB (((value x) = (value y)) → (φx ↔ φy)))) (
  ((((value x) ∈ baseSet) ∧ φx) ∧ (∀ y ((((value y) ∈ baseSet) ∧ φy) → ((value y) = (value x))))) →
  ((A = (value x)) → (A ∈ baseSet))) (
        (((value x) ∈ baseSet) ∧ φx)
          (∀ y ((((value y) ∈ baseSet) ∧ φy) → ((value y) = (value x))))
          ConjunctionRightElimination
        eliminateRightConjunctInConsequent

        A (value x) baseSet MembershipBuilderRR
        eliminateBiconditionalForwardInConsequent
        applyComm

        applySyllogism
))

thm (ClosureLemma1Reverse-phiy ((y φx) (y x))
  ((HSUB (((value x) = (value y)) → (φx ↔ φy)))) (
  ((((value x) ∈ baseSet) ∧ φx) ∧ (∀ y ((((value y) ∈ baseSet) ∧ φy) → ((value y) = (value x))))) →
  ((A = (value x)) → (subst A y φy))) (
</jh>
We first transform <code>φx</code> to <code>[ x / y ] φy</code>.
<jh>
        (((value x) ∈ baseSet) ∧ φx)
          (∀ y ((((value y) ∈ baseSet) ∧ φy) → ((value y) = (value x))))
          ConjunctionRightElimination
        eliminateLeftConjunctInConsequent

        (value y) (value x) EqualitySymmetry
        eliminateBiconditionalReverse
        HSUB
        applySyllogism

        φx φy BiconditionalSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        makeSubstExplicit

        eliminateBiconditionalForward
        applySyllogism
</jh>
Then we can turn the substitution <code>A = x → ([ A / y ] φy ↔ [ x / y ] φy)</code> into <code>A = x → [ A / y ] φy</code>.
<jh>
        A (value x) y φy SubstBuilderReplacement
        eliminateBiconditionalForwardInConsequent
        applyComm

        applySyllogism
))

thm (ClosureLemma1Reverse ((y φx) (y x)) ((HSUB (((value x) = (value y)) → (φx ↔ φy)))) (
  ((((value x) ∈ baseSet) ∧ φx) ∧ (∀ y ((((value y) ∈ baseSet) ∧ φy) → ((value y) = (value x))))) →
  ((A = (value x)) → ((A ∈ baseSet) ∧ (subst A y φy)))) (
        HSUB
        baseSet A ClosureLemma1Reverse-baseSet

        HSUB
        baseSet A ClosureLemma1Reverse-phiy

        composeConjunction

        (A = (value x))
          (A ∈ baseSet)
          (subst A y φy)
          ConjunctionComposition
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

The converse of that is <code>A ∈ baseSet ∧ [ A / y ] φy → A = x</code>. Here we use uniqueness. That is, we take <code>∀ y (y ∈ baseSet ∧ φy → y = x)</code> and specialize <code>y</code> to <code>A</code>.
<jh>
#thm (ClosureLemma1Forward () () (
#  ((((value x) ∈ baseSet) ∧ φx) ∧ (∀ y ((((value y) ∈ baseSet) ∧ φy) → ((value y) = (value x))))) →
#  (((A ∈ baseSet) ∧ (subst A y φy)) → (A = (value x)))) (
#        
#))

#thm (ClosureLemma1 () () (
#  ((((value x) ∈ baseSet) ∧ φx) ∧ (∀ y ((((value y) ∈ baseSet) ∧ φy) → ((value y) = (value x))))) →
#  (((A ∈ baseSet) ∧ (subst A y φy)) ↔ (A = (value x)))) (
#))
</jh>

stmt (Separation ((x A)) ()
  ((C ∈ (separate x A φ)) ↔ ((C ∈ A) ∧ (subst C x φ))))

hyp: ψ → ∃ x (x ∈ BaseSet ∧ φx ∧ (A ∈ BaseSet ∧ [ A / y ] φy ↔ A = x))
  or maybe ψ → ∃ x (x ∈ BaseSet ∧ φx ∧ (∀ y φy → y = x))
concl: ψ → ⋃ { y ∈ BaseSet | φy } ∈ BaseSet
closed form: ∃ x (x ∈ BaseSet ∧ φx ∧ ∀ y (φy → y = x)) → ⋃ { y ∈ BaseSet | φy } ∈ BaseSet

{{cleanup|finishing this proof. Here's an outline of how it might be done}}
one solution would be: ∃ x (x ∈ ℝ ∧ a + x = 0 ∧ { y ∈ ℝ | a + y = 0 } = { x })
  for that need A ∈ { y ∈ ℝ | a + y = 0 } ↔ A ∈ { x }
  for that need A ∈ ℝ ∧ [ A / y ] a + y = 0 ↔ A = x (by Separation and Singleton)
  for that need a + A = 0 ↔ A = x
    the A = x → a + A = 0 direction is just a substitution
    to get a + A = 0 → A = x, 
      a + x = a + A (because both are equal to zero)
      x = A (by cancellation)
Then we get - a = x
  and we're a substitution away, because x ∈ ℝ

def ((- a) (⋃ (separate x (ℝ) ((a + (value x)) = (0)))))

== Subtraction ==
We define <code>b − a</code> to be the unique number <code>x</code> for which <code>a + x = b</code>. Our notation for this is <code>⋃ { x ∈ ℝ | a + x = b }</code>, which works because the union of a singleton is the singleton's element.

<jh>
def ((− b a) (⋃ (separate x (ℝ) ((a + (value x)) = b))))
</jh>

== Multiplication ==
There are a few theorems which have different names in [[Interface:Real numbers]] than they did in [[Interface:Real number axioms]], but are otherwise unchanged.

<jh>
thm (RealMultiplicationClosure () () (((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) → ((a · b) ∈ (ℝ))) (
        a b MultiplicationClosure
))

thm (RealMultiplicationCommutativity () () (((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) → ((a · b) = (b · a))) (
        a b MultiplicationCommutativity
))

thm (RealMultiplicationAssociativity () () ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) → (((a · b) · c) = (a · (b · c)))) (
        a b c MultiplicationAssociativity
))

thm (RealDistributivity () () ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) → ((a · (b + c)) = ((a · b) + (a · c)))) (
        a b c Distributivity
))

thm (RealMultiplicativeIdentity () () ((a ∈ (ℝ)) → ((a · (1)) = a)) (
        a MultiplicativeIdentity
))
</jh>

== Division ==
We define <code>b / a</code> to be the unique number <code>x</code> for which <code>a · x = b</code>. Our notation for this is <code>⋃ { x ∈ ℝ | a · x = b }</code>, which works for non-zero <code>a</code> because the union of a singleton is the singleton's element. If <code>a</code> is zero, the definition can produce anything (in particular, it doesn't need to produce a real number), because we don't expect dividing by zero to yield anything useful.

<jh>
def ((/ b a) (⋃ (separate x (ℝ) ((a · (value x)) = b))))
</jh>

== Constants ==
To export to [[Interface:Real numbers]], we need to define various contants, such as <code>2</code> and <code>1000</code>. Since we have already defined addition and multiplication, we have what we need to define these constants.
<jh>
def ((2) ((1) + (1)))
def ((3) ((2) + (1)))
def ((4) ((3) + (1)))
def ((5) ((4) + (1)))
def ((6) ((5) + (1)))
def ((7) ((6) + (1)))
def ((8) ((7) + (1)))
def ((9) ((8) + (1)))
def ((10) ((9) + (1)))
def ((11) ((10) + (1)))
def ((12) ((11) + (1)))
def ((30) ((3) · (10)))
def ((45) (((4) · (10)) + (5)))
def ((60) ((6) · (10)))
def ((90) ((9) · (10)))
def ((100) ((10) · (10)))
def ((180) ((100) + ((8) · (10))))
def ((360) (((3) · (100)) + (60)))
def ((1000) ((100) · (10)))
def ((1000000) ((1000) · (1000)))
</jh>

All of the above constants are real numbers. Here we prove this for each one.
<jh>
thm (closeAddition () ((HLeft (a ∈ (ℝ))) (HRight (b ∈ (ℝ)))) ((a + b) ∈ (ℝ)) (
        HLeft
        HRight
        introduceConjunction

        a b RealAdditionClosure
        applyModusPonens
))

thm (closeMultiplication () ((HLeft (a ∈ (ℝ))) (HRight (b ∈ (ℝ)))) ((a · b) ∈ (ℝ)) (
        HLeft
        HRight
        introduceConjunction

        a b RealMultiplicationClosure
        applyModusPonens
))

thm (TwoReal () () ((2) ∈ (ℝ)) (
        OneReal
        OneReal
        closeAddition
))

thm (ThreeReal () () ((3) ∈ (ℝ)) (
        TwoReal
        OneReal
        closeAddition
))

thm (FourReal () () ((4) ∈ (ℝ)) (ThreeReal OneReal closeAddition))
thm (FiveReal () () ((5) ∈ (ℝ)) (FourReal OneReal closeAddition))
thm (SixReal () () ((6) ∈ (ℝ)) (FiveReal OneReal closeAddition))
thm (SevenReal () () ((7) ∈ (ℝ)) (SixReal OneReal closeAddition))
thm (EightReal () () ((8) ∈ (ℝ)) (SevenReal OneReal closeAddition))
thm (NineReal () () ((9) ∈ (ℝ)) (EightReal OneReal closeAddition))
thm (TenReal () () ((10) ∈ (ℝ)) (NineReal OneReal closeAddition))
thm (ElevenReal () () ((11) ∈ (ℝ)) (TenReal OneReal closeAddition))
thm (TwelveReal () () ((12) ∈ (ℝ)) (ElevenReal OneReal closeAddition))
thm (ThirtyReal () () ((30) ∈ (ℝ)) (ThreeReal TenReal closeMultiplication))
thm (FortyFiveReal () () ((45) ∈ (ℝ)) (FourReal TenReal closeMultiplication FiveReal closeAddition))
thm (SixtyReal () () ((60) ∈ (ℝ)) (SixReal TenReal closeMultiplication))
thm (NinetyReal () () ((90) ∈ (ℝ)) (NineReal TenReal closeMultiplication))
thm (HundredReal () () ((100) ∈ (ℝ)) (TenReal TenReal closeMultiplication))
thm (HundredEightyReal () () ((180) ∈ (ℝ)) (HundredReal EightReal TenReal closeMultiplication closeAddition))
thm (ThreeHundredSixtyReal () () ((360) ∈ (ℝ)) (
        ThreeReal HundredReal closeMultiplication SixReal TenReal closeMultiplication closeAddition
))
thm (ThousandReal () () ((1000) ∈ (ℝ)) (HundredReal TenReal closeMultiplication))
thm (MillionReal () () ((1000000) ∈ (ℝ)) (ThousandReal ThousandReal closeMultiplication))
</jh>

== Order ==
Our axioms define a total (linear) order, so we just need to define the various convenience theorems and other total order notations.

To get to the starting point ([[Interface:First-order linear order defined via strict inequality]]), we need to prove a few theorems (there are various ways to state that an order is a total order, and the one there is slightly different than the one at [[Interface:Real number axioms]]).

Using [[Interface:First-order linear order defined via strict inequality]] is actually kind of awkward here, as it is a first-order theory and we are built on set theory. But partly just as a proof of concept that such things can be done, we translate between the two worlds rather than just duplicating the linear order proofs in a set theory context. We use the <code>restrict.</code> prefix for things which are restricted to real numbers.

<jh>
def ((universe) (ℝ))
export (UNIVERSE Interface:Universe (PROPOSITIONAL FIRSTORDER SETS) ())
import (RESTRICT Interface:Restricting_all_quantifiers (PROPOSITIONAL FIRSTORDER SETS UNIVERSE) restrict.)

var (restrict.object restrict.x restrict.y restrict.z)
def ((restrict.< restrict.x restrict.y) ((restrict.asSet restrict.x) < (restrict.asSet restrict.y)))
thm (restrict.LessThanAsymmetry () ()
  ((restrict.x restrict.< restrict.y) → (¬ (restrict.y restrict.< restrict.x))) (
        restrict.x restrict.InUniverse
        restrict.y restrict.InUniverse
        introduceConjunction

        (restrict.asSet restrict.x) (restrict.asSet restrict.y) LessThanAsymmetry
        applyModusPonens
))

var (restrict.object restrict.x0 restrict.x1 restrict.y0 restrict.y1)
thm (restrict.LessThanBuilder () ()
  (((restrict.x0 restrict.= restrict.x1) ∧ (restrict.y0 restrict.= restrict.y1)) →
    ((restrict.x0 restrict.< restrict.y0) ↔ (restrict.x1 restrict.< restrict.y1))
  ) (
        (restrict.asSet restrict.x0) (restrict.asSet restrict.x1)
          (restrict.asSet restrict.y0) (restrict.asSet restrict.y1)
          LessThanBuilder
))

thm (restrict.LessThanTransitivity () ()
  (((restrict.x restrict.< restrict.y) ∧ (restrict.y restrict.< restrict.z)) → (restrict.x restrict.< restrict.z)) (
        restrict.x restrict.InUniverse
        restrict.y restrict.InUniverse
        introduceConjunction

        restrict.z restrict.InUniverse
        introduceConjunction

        (restrict.asSet restrict.x) (restrict.asSet restrict.y) (restrict.asSet restrict.z) LessThanTransitivity
        applyModusPonens
))

</jh>

The first substantive order theorem is <code>¬ x < x</code>. The proof is by contradiction: if <code>x < x</code>, then <code>¬ x < x</code> (by LessThanAsymmetry), which is a contradiction.
<jh>
thm (restrict.LessThanIrreflexivity () () (¬ (restrict.x restrict.< restrict.x)) (
        restrict.x restrict.x restrict.LessThanAsymmetry
        deduceNegationFromContradiction
))
</jh>

The other non-trivial theorem is that we need to restate totality a bit.
<jh>
thm (restrict.LessThanTotality () ()
  (((restrict.x restrict.< restrict.y) ∨ (restrict.x restrict.= restrict.y)) ∨
    (restrict.y restrict.< restrict.x)) (
        restrict.x restrict.InUniverse
        restrict.y restrict.InUniverse
        introduceConjunction
        (restrict.asSet restrict.x) (restrict.asSet restrict.y) LessThanTotalityImplication
        applyModusPonens

        convertToDisjunctionFromImplication
        groupDisjunctionLeft
        swap12ofDisjunction3
))


export (ORDER_DEFINED Interface:First-order_linear_order_defined_via_strict_inequality (PROPOSITIONAL RESTRICT) restrict.)

import (ORDER Interface:First-order_linear_order_from_strict_inequality (PROPOSITIONAL RESTRICT ORDER_DEFINED) restrict.)
</jh>

We've defined all the order theorems and notations in the <code>restrict.</code> world; we just need to translate back to the set theory world.
<jh>
def ((> a b) ((restrict.asRestrictedTerm a) restrict.> (restrict.asRestrictedTerm b)))
def ((≤ a b) ((restrict.asRestrictedTerm a) restrict.≤ (restrict.asRestrictedTerm b)))
def ((≥ a b) ((restrict.asRestrictedTerm a) restrict.≥ (restrict.asRestrictedTerm b)))
</jh>

== Square root ==
We define the square root of <code>a</code> as the unique number <code>x</code> for which <code>x · x = a</code>. If there is no such unique number (that is, if <code>a</code> is negative), we need not define it to be a real number or anything else in particular.

<jh>
def ((√ a) (⋃ (separate x (ℝ) (((value x) · (value x)) = a))))
</jh>

== Export ==

<jh>
#export (RESULTS Interface:Real_numbers (PROPOSITIONAL FIRSTORDER SETS) ())
</jh>

== References ==
<references/>

[[Category:Real and complex fields]]