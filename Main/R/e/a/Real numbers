{{interfaces
| imports = [[Interface:Real number axioms]]
| exports = [[Interface:Real numbers]]
}}

The '''[[w:real numbers|real numbers]]''' are defined here by axioms which define addition, multiplication, and the [[w:completeness of the real numbers|completeness]] property. Here we add some elementary consequences of the axioms such as subtraction.

We import the interfaces we build on, which are logic, set theory, and the real number axioms.
<jh>
import (PROPOSITIONAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (PROPOSITIONAL) ())
import (SETS Interface:Set_theory (PROPOSITIONAL FIRSTORDER) ())
import (AXIOMS Interface:Real_number_axioms (PROPOSITIONAL FIRSTORDER SETS) ())

var (object a b c)
var (variable x)
</jh>

== Constants ==
To export to [[Interface:Real numbers]], we need to define various contants, such as <code>2</code> and <code>1000</code>. Since we have already defined addition and multiplication, we have what we need to define these constants.
<jh>
def ((2) ((1) + (1)))
def ((3) ((2) + (1)))
def ((4) ((3) + (1)))
def ((5) ((4) + (1)))
def ((6) ((5) + (1)))
def ((7) ((6) + (1)))
def ((8) ((7) + (1)))
def ((9) ((8) + (1)))
def ((10) ((9) + (1)))
def ((11) ((10) + (1)))
def ((12) ((11) + (1)))
def ((30) ((3) · (10)))
def ((45) (((4) · (10)) + (5)))
def ((60) ((6) · (10)))
def ((90) ((9) · (10)))
def ((100) ((10) · (10)))
def ((180) ((100) + ((8) · (10))))
def ((360) (((3) · (100)) + (60)))
def ((1000) ((100) · (10)))
def ((1000000) ((1000) · (1000)))
</jh>

== Addition ==
There are a few theorems which have different names in [[Interface:Real numbers]] than they did in [[Interface:Real number axioms]], but are otherwise unchanged.
<jh>
thm (RealAdditionCommutativity () () (((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) → ((a + b) = (b + a))) (
        a b AdditionCommutativity
))

thm (RealAdditionAssociativity () () ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) → (((a + b) + c) = (a + (b + c)))) (
        a b c AdditionAssociativity
))
</jh>

== Additive inverse ==
We define <code>- a</code> to be the unique number <code>x</code> for which <code>a + x = 0</code>.
{{cleanup|deciding whether to stick to this definition or moving this after subtraction is defined and then defining - a to be 0 − a}}
<jh>
def ((- a) (⋃ (separate x (ℝ) ((a + (value x)) = (0)))))
</jh>

== Subtraction ==
We define <code>b − a</code> to be the unique number <code>x</code> for which <code>a + x = b</code>. Our notation for this is <code>⋃ { x ∈ ℝ | a + x = b }</code>, which works because the union of a singleton is the singleton's element.

<jh>
def ((− b a) (⋃ (separate x (ℝ) ((a + (value x)) = b))))
</jh>

== Multiplication ==
There are a few theorems which have different names in [[Interface:Real numbers]] than they did in [[Interface:Real number axioms]], but are otherwise unchanged.

<jh>
thm (RealMultiplicationClosure () () (((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) → ((a · b) ∈ (ℝ))) (
        a b MultiplicationClosure
))

thm (RealMultiplicationCommutativity () () (((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) → ((a · b) = (b · a))) (
        a b MultiplicationCommutativity
))

thm (RealMultiplicationAssociativity () () ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) → (((a · b) · c) = (a · (b · c)))) (
        a b c MultiplicationAssociativity
))

thm (RealDistributivity () () ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) → ((a · (b + c)) = ((a · b) + (a · c)))) (
        a b c Distributivity
))
</jh>

== Division ==
We define <code>b / a</code> to be the unique number <code>x</code> for which <code>a · x = b</code>. Our notation for this is <code>⋃ { x ∈ ℝ | a · x = b }</code>, which works for non-zero <code>a</code> because the union of a singleton is the singleton's element. If <code>a</code> is zero, the definition can produce anything (in particular, it doesn't need to produce a real number), because we don't expect dividing by zero to yield anything useful.

<jh>
def ((/ b a) (⋃ (separate x (ℝ) ((a · (value x)) = b))))
</jh>

== Order ==
Our axioms define a total (linear) order, so we just need to define the various convenience theorems and other total order notations.

To get to the starting point ([[Interface:First-order linear order defined via strict inequality]]), we need to prove a few theorems (there are various ways to state that an order is a total order, and the one there is slightly different than the one at [[Interface:Real number axioms]]).

Using [[Interface:First-order linear order defined via strict inequality]] is actually kind of awkward here, as it is a first-order theory and we are built on set theory. But partly just as a proof of concept that such things can be done, we translate between the two worlds rather than just duplicating the linear order proofs in a set theory context. We use the <code>restrict.</code> prefix for things which are restricted to real numbers.

<jh>
def ((universe) (ℝ))
export (UNIVERSE Interface:Universe (PROPOSITIONAL FIRSTORDER SETS) ())
import (RESTRICT Interface:Restricting_all_quantifiers (PROPOSITIONAL FIRSTORDER SETS UNIVERSE) restrict.)

var (restrict.object restrict.x restrict.y restrict.z)
def ((restrict.< restrict.x restrict.y) ((restrict.asSet restrict.x) < (restrict.asSet restrict.y)))
thm (restrict.LessThanAsymmetry () ()
  ((restrict.x restrict.< restrict.y) → (¬ (restrict.y restrict.< restrict.x))) (
        restrict.x restrict.InUniverse
        restrict.y restrict.InUniverse
        introduceConjunction

        (restrict.asSet restrict.x) (restrict.asSet restrict.y) LessThanAsymmetry
        applyModusPonens
))

var (restrict.object restrict.x0 restrict.x1 restrict.y0 restrict.y1)
thm (restrict.LessThanBuilder () ()
  (((restrict.x0 restrict.= restrict.x1) ∧ (restrict.y0 restrict.= restrict.y1)) →
    ((restrict.x0 restrict.< restrict.y0) ↔ (restrict.x1 restrict.< restrict.y1))
  ) (
        (restrict.asSet restrict.x0) (restrict.asSet restrict.x1)
          (restrict.asSet restrict.y0) (restrict.asSet restrict.y1)
          LessThanBuilder
))

thm (restrict.LessThanTransitivity () ()
  (((restrict.x restrict.< restrict.y) ∧ (restrict.y restrict.< restrict.z)) → (restrict.x restrict.< restrict.z)) (
        restrict.x restrict.InUniverse
        restrict.y restrict.InUniverse
        introduceConjunction

        restrict.z restrict.InUniverse
        introduceConjunction

        (restrict.asSet restrict.x) (restrict.asSet restrict.y) (restrict.asSet restrict.z) LessThanTransitivity
        applyModusPonens
))

</jh>

The first substantive order theorem is <code>¬ x &lt; x</code>. The proof is by contradiction: if <code>x &lt; x</code>, then <code>¬ x &lt; x</code> (by LessThanAsymmetry), which is a contradiction.
<jh>
thm (restrict.LessThanIrreflexivity () () (¬ (restrict.x restrict.< restrict.x)) (
        restrict.x restrict.x restrict.LessThanAsymmetry
        deduceNegationFromContradiction
))
</jh>

The other non-trivial theorem is that we need to restate totality a bit.
<jh>
thm (restrict.LessThanTotality () ()
  (((restrict.x restrict.< restrict.y) ∨ (restrict.x restrict.= restrict.y)) ∨
    (restrict.y restrict.< restrict.x)) (
        restrict.x restrict.InUniverse
        restrict.y restrict.InUniverse
        introduceConjunction
        (restrict.asSet restrict.x) (restrict.asSet restrict.y) LessThanTotalityImplication
        applyModusPonens

        convertToDisjunctionFromImplication
        groupDisjunctionLeft
        swap12ofDisjunction3
))


export (ORDER_DEFINED Interface:First-order_linear_order_defined_via_strict_inequality (PROPOSITIONAL RESTRICT) restrict.)

import (ORDER Interface:First-order_linear_order_from_strict_inequality (PROPOSITIONAL RESTRICT ORDER_DEFINED) restrict.)
</jh>

We've defined all the order theorems and notations in the <code>restrict.</code> world; we just need to translate back to the set theory world.
<jh>
def ((> a b) ((restrict.asRestrictedTerm a) restrict.> (restrict.asRestrictedTerm b)))
def ((≤ a b) ((restrict.asRestrictedTerm a) restrict.≤ (restrict.asRestrictedTerm b)))
def ((≥ a b) ((restrict.asRestrictedTerm a) restrict.≥ (restrict.asRestrictedTerm b)))
</jh>

== Square root ==
We define the square root of <code>a</code> as the unique number <code>x</code> for which <code>x · x = a</code>. If there is no such unique number (that is, if <code>a</code> is negative), we need not define it to be a real number or anything else in particular.

<jh>
def ((√ a) (⋃ (separate x (ℝ) (((value x) · (value x)) = a))))
</jh>

== Export ==

<jh>
#export (RESULTS Interface:Real_numbers (PROPOSITIONAL FIRSTORDER SETS) ())
</jh>

== References ==
<references/>

[[Category:Real and complex fields]]
