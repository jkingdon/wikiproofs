== unidirectional builders ==

Part of the reason why I added a section called Unidirectional builders to [[Principia Mathematica propositional logic]] is that some of them seem to be missing from [[Interface:Classical propositional calculus]]. Some are used a lot in the proofs in that module, as late as ConjunctionComposition. If there is a more powerful mechanism which replaces them, I didn't see it. The ones which are particularly used are *2.05, *2.06, and the typical usage could be expressed in the following rules:

 stmt (addCommonAntecedent () ((q → r)) ((p → q) → (p → r))) # rule form of *2.05
 stmt (addCommonConsequent () ((p → q)) ((q → r) → (p → r))) # rule form of *2.06

The contrast between these rules and applySyllogism should make it clear that they are functioning as builders, and calling them Syllogism is actually kind of confusing (at least, it was for me at first). I suppose I'd add *2.05 and *2.06 as CommonAntecedentAddition and CommonConsequentAddition (and get rid of Syllogism by that name, as ImplicationTransitivity is what most people think of as syllogism). Metamath's set.mm calls these rules "Inference adding common antecedents in an implication" (imim2i) and "Inference adding common consequents in an implication, thereby interchanging the original antecedent and consequent" (imim1i), so my proposed names seem plausible.

I also find that my general unidirection builder for implication is in set.mm as imim12i. Based on set.mm it seems like it gets some usage but not as much as imim1i or imim2i. We could always add it later if we miss it. [[User:Kingdon|Kingdon]] 03:42, 14 February 2010 (UTC)

== Things I thought of adding ==

I'm not sure the case for adding any of these is strong, but I thought I'd mention them.

*applyComm from [[Principia Mathematica propositional logic]].  Of course you can import, then apply ConjunctionCommutativity and the implication builder (once), and then export, but that can seem like a lot of work.  The case for this is weakened by the fact that it seems to be used only a handful of times in set.mm (where it is pm2.04) and fewer times than I realized in [[Principia Mathematica propositional logic]]. We can see whether the four-step process mentioned above becomes common before worrying about this.

* Proposition *5.1. Whitehead and Russell put this in a list of theorems used "very frequently". set.mm says about 13 usages (it is pm5.1). Its friend, *5.21, and some variants in set.mm (theorems whose names start with pm5.21) seem to get used a bit more, but I didn't look closely at the variants (probably more like separate theorems than applications of *5.21).

* <code>(⊤ ∧ p) ↔ p</code> and <code>(⊥ ∨ p) ↔ p</code>. I was scribbing on a piece of paper and thought I might have use for these, but I'm not sure I was even handling dummy variables right, or how often it would come up. Sounds quite safe to put this off until there is a more pressing need.

In general, my first instinct is to err on the side of waiting and seeing, especially until we have a bit more experience. [[User:Kingdon|Kingdon]] 04:26, 14 February 2010 (UTC)

== Name of eliminateLeftBiconditionalImplication and friends ==

I have two big gripes with the name: 

* The left/right nomenclature. We currently explain it this way: "The naming convention here is that when we think of p ↔ q as consisting of two implications, we call p → q the left one and q → p the right one." but I think "forward" and "reverse" would probably be clearer. Left and right could just as easily be thought of as the way the arrow is pointing (which would be the opposite meaning from the current one).

* It is way too long for something which is used constantly.  set.mm has a bunch of theorems which are modus ponens for the forward implication, modus ponens for the reverse implication, etc, etc, but I am kind of hoping that if we give eliminateLeftBiconditionalImplication a shorter name, we can avoid the need for lots of theorems of that sort.

Therefore, I'm thinking "forward" and "reverse" to replace eliminateRightBiconditionalImplication and eliminateLeftBiconditionalImplication, respectively. I'm not as worried about extreme conciseness for BiconditionalImplicationRightElimination and BiconditionalImplicationLeftElimination, so something like BiconditionalImplicationForward and BiconditionalImplicationReverse would be OK with me. I know that naming rules after nouns rather than verbs goes against the grain, and I normally try to resist the urge to make everything short, but I'm taking what feels like a slightly extreme measure to try to avoid proliferation of theorems (either for inferences, as mentioned above, or for both directions of a theorem which we also have in the biconditional). [[User:Kingdon|Kingdon]] 04:37, 14 February 2010 (UTC)