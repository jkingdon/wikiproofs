{{header
 | title    = Peano axioms
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = The first-order [[w:Peano axioms|Peano axioms]] are the most widely used formalism for [[w:Arithmetic|arithmetic]] (that is, the natural numbers: zero, one, two, ...). They are stronger than the axioms of [[w:Robinson arithmetic|Robinson arithmetic]] (which are similar but omit the induction axiom) and weaker than systems like [[w:Second-order arithmetic|second-order arithmetic]] or most kinds of set theory (such as [[w:Zermelo–Fraenkel set theory|ZFC]]).
}}
{{modules
| parameters = [[Interface:Classical propositional calculus|Classical propositional calculus]], [[Interface:First-order logic|First-order logic]]
| importedby = None yet.
| exportedby = None yet.
}}

First, we adopt the axioms of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic|first-order logic]] (including equality):

<jh>
param (CLASSICAL Interface:Classical_propositional_calculus () ())
param (FIRSTORDER Interface:First-order_logic (CLASSICAL) ())
</jh>

The kind <code>object</code>, defined in first-order logic, represents a natural number:
<jh>
kindbind (object nat)
var (nat k n m n0 n1 m0 m1)
</jh>

There is a number zero:

<jh>
term (nat (0))
</jh>

There is a successor operation:
<jh>
term (nat (succ nat))
</jh>

Zero is not the successor of any number:
<jh>
stmt (ZeroNotSuccessor () () (¬ ((0) = (succ n))))
</jh>

By making the following axiom a biconditional, we express two ideas. The first is that equals can be substituted for equals (this is often a generic rule of first order logic, but JHilbert requires us to provide it for each term). The second idea, specific to the successor operation, is that each number is the successor of only one number.
<jh>
stmt (Successor () () (((succ m) = (succ n)) ↔ (m = n)))
</jh>

[[w:mathematical induction|Induction]]:
<jh>
var (formula φ)
stmt (Induction () () (((subst (0) n φ) ∧ ((subst k n φ) → (subst (succ k) n φ))) → (∀ n φ)))
</jh>

We also supply the usual axioms for addition and multiplication:

<jh>
term (nat (+ nat nat))
stmt (AdditiveIdentity () () ((n + (0)) = n))
stmt (Addition () () ((n + (succ m)) = (succ (n + m))))

term (nat (· nat nat))
stmt (MultiplicativeZero () () ((n · (0)) = (0)))
stmt (Multiplication () () ((n · (succ m)) = (n + (n · m))))
</jh>

and the principle that equals can be substituted for equals, in the context of addition and multiplication:
<jh>
stmt (AdditionBuilder () () (((n0 = n1) ∧ (m0 = m1)) → ((n0 + m0) = (n1 + m1))))
stmt (MultiplicationBuilder () () (((n0 = n1) ∧ (m0 = m1)) → ((n0 · m0) = (n1 · m1))))
</jh>

[[Category:Elementary number theory|{{PAGENAME}}]]