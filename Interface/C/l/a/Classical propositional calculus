{{header
 | title    = Classical propositional calculus
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = This interface collects all important theorems from [[w:classical propositional calculus|classical propositional calculus]]. It is meant as a user-friendly reservoir for those interfaces and proof modules which merely use propositional logic, without proving anything new within it.

Statements can be added if necessary, but then the exporting modules have to be updated accordingly.
}}
{{modules
| parameters = ''None''
| importedby = None yet
| exportedby = None yet
}}

== Well-formed formulas ==

We first introduce the kind of [[w:well-formed formulas|well-formed formulas]] and a few variables for this kind.
<jh>
kind (wff)
var (wff p q r s)
</jh>

== Logical connectives ==

There are five standard [[w:logical connective|logical connective]]s in the classical propositional calculus, [[w:negation|negation]],
<jh>
term (wff (¬ wff))
</jh>
[[w:material conditional|implication]],
<jh>
term (wff (→ wff wff))
</jh>
[[w:logical disjunction|disjunction]],
<jh>
term (wff (∨ wff wff))
</jh>
[[w:logical conjunction|conjunction]],
<jh>
term (wff (∧ wff wff))
</jh>
and, finally, the [[w:logical biconditional|biconditional]],
<jh>
term (wff (↔ wff wff))
</jh>
In addition, one can also consider the constant formulas (or [[w:nullary#Nullary|nullary]] connectives) "the true",
<jh>
term (wff (⊤))
</jh>
and "the false",
<jh>
term (wff (⊥))
</jh>

== Simple statements ==

Here are the statements which do not require any hypotheses.

=== Constant statements ===

The simplest statements are the "true" and the "not false" statement:
<jh>
stmt (True () () (⊤))
stmt (NotFalse () () (¬ (⊥)))
</jh>

=== Statements about negation ===

Double negation:
<jh>
stmt (DoubleNegation () () (p ↔ (¬ (¬ p))))
</jh>
Negation as a truth function:
<jh>
stmt (NegationFunction () () ((p ↔ q) ↔ ((¬ p) ↔ (¬ q))))
</jh>

=== Statements about implication ===

Chaining [[w:antecedent|antecedent]]s in an implication is equivalent to a conjunction of these antecedents. This is the importation/exportation principle of [[w:Giuseppe Peano|Giuseppe Peano]].
<jh>
stmt (Transportation () () ((p → (q → r)) ↔ ((p ∧ q) → r)))
</jh>
The distributive law of implication.
<jh>
stmt (ImplicationDistribution () () ((p → (q → r)) ↔ ((p → q) → (p → r))))
</jh>
Three [[w:Transposition_(logic)|transposition]] statements:
<jh>
stmt (Transposition () () ((p → q) ↔ ((¬ q) → (¬ p))))
stmt (TranspositionWithNegatedAntecedent () () (((¬ p) → q) ↔ ((¬ q) → p)))
stmt (TranspositionWithNegatedConsequent () () ((p → (¬ q)) ↔ (q → (¬ p))))
</jh>
[[w:Syllogism|Syllogism]]:
<jh>
stmt (Syllogism () () ((p → q) → ((q → r) → (p → r))))
</jh>
[[w:Modus ponens|Modus ponens]] and [[w:modus tollens|modus tollens]]:
<jh>
stmt (ModusPonens () () (p → ((p → q) → q)))
stmt (ModusTollens () () ((¬ q) → ((p → q) → (¬ p))))
</jh>
Introduction of an antecedent. Whitehead and Russell call this "Simplification":
<jh>
stmt (AntecedentIntroduction () () (p → (q → p)))
</jh>
Implication as a truth function:
<jh>
stmt (ImplicationFunction () () (((p ↔ q) ∧ (r ↔ s)) → ((p → r) ↔ (q → s))))
</jh>

=== Statements abount disjunction and conjunction ===

==== Idempotence ====

<jh>
stmt (DisjunctionIdempotence () () (p ↔ (p ∨ p)))
stmt (ConjunctionIdempotence () () (p ↔ (p ∧ p)))
</jh>

==== Associativity ====

<jh>
stmt (DisjunctionAssociativity () () (((p ∨ q) ∨ r) ↔ (p ∨ (q ∨ r))))
stmt (ConjunctionAssociativity () () (((p ∧ q) ∧ r) ↔ (p ∧ (q ∧ r))))
</jh>

==== Commutativity ====

<jh>
stmt (DisjunctionCommutativity () () ((p ∨ q) ↔ (q ∨ p)))
stmt (ConjunctionCommutativity () () ((p ∧ q) ↔ (q ∧ p)))
</jh>

==== Distributive laws ====

<jh>
stmt (DisjunctionLeftDistribution () () ((p ∨ (q ∧ r)) ↔ ((p ∨ q) ∧ (p ∨ r))))
stmt (DisjunctionRightDistribution () () (((p ∧ q) ∨ r) ↔ ((p ∨ r) ∧ (q ∨ r))))
stmt (ConjunctionLeftDistribution () () ((p ∧ (q ∨ r)) ↔ ((p ∧ q) ∨ (p ∧ r))))
stmt (ConjunctionRightDistribution () () (((p ∨ q) ∧ r) ↔ ((p ∧ r) ∨ (q ∧ r))))
</jh>

==== Introduction and elimination laws ====

<jh>
stmt (DisjunctionIntroductionLeft () () (p → (q ∨ p)))
stmt (DisjunctionIntroductionRight () () (p → (p ∨ q)))
stmt (DisjunctionElimination () () ((p ∨ q) → ((p → r) → ((q → r) → r))))
stmt (ConjunctionIntroduction () () (p → ((p → q) → ((p → r) → (q ∧ r)))))
stmt (ConjunctionEliminationLeft () () ((p ∧ q) → q))
stmt (ConjunctionEliminationRight () () ((p ∧ q) → p))
</jh>

==== De Morgan's laws ====

<jh>
stmt (DisjunctionNegation () () ((¬ (p ∨ q)) ↔ ((¬ p) ∧ (¬ q))))
stmt (ConjunctionNegation () () ((¬ (p ∧ q)) ↔ ((¬ p) ∨ (¬ q))))
</jh>

==== Disjunction and conjunction as truth functions ====

<jh>
stmt (DisjunctionFunction () () (((p ↔ q) ∧ (r ↔ s)) → ((p ∨ r) ↔ (q ∨ s))))
stmt (ConjunctionFunction () () (((p ↔ q) ∧ (r ↔ s)) → ((p ∧ r) ↔ (q ∧ s))))
</jh>

=== Statements about the biconditional ===

The biconditional simply creates an [[w:equivalence relation|equivalence relation]] among well-formed formulas:
<jh>
stmt (BiconditionalReflexivity () () (p ↔ p))
stmt (BiconditionalSymmetry () () ((p ↔ q) → (q ↔ p)))
stmt (BiconditionalTransitivity () () (((p ↔ q) ∧ (q ↔ r)) → (p ↔ r)))
</jh>
This equivalence relation creates two [[w:equivalence class|equivalence class]]es, the true and the false formulas:
<jh>
stmt (Tautology () () ((p ∨ (¬ p)) ↔ (⊤)))
stmt (Contradiction () () ((p ∧ (¬ p)) ↔ (⊥)))
</jh>
The left hand side of ''Tautology'' is precisely the [[w:tertium non datur|tertium non datur]] statement ensuring the existence of at most two truth-values:
<jh>
stmt (TertiumNonDatur () () (p ∨ (¬ p)))
</jh>
Biconditional as a truth function:
<jh>
stmt (BiconditionalFunction () () (((p ↔ q) ∧ (r ↔ s)) → ((p ↔ r) ↔ (q ↔ s))))
</jh>

=== Some truth function interdependencies ===

Biconditional as bidirectional implication:
<jh>
stmt (BiconditionalImplication () () ((p ↔ q) ↔ ((p → q) ∧ (q → p))))
</jh>
Biconditional as equivalence:
<jh>
stmt (BiconditionalEquivalence () () ((p ↔ q) ↔ ((p ∧ q) ∨ ((¬ p) ∧ (¬ q)))))
</jh>
Implication as disjunction:
<jh>
stmt (ImplicationDisjunction () () ((p → q) ↔ ((¬ p) ∨ q)))
</jh>
Negation as implication:
<jh>
stmt (NegationImplication () () ((¬ p) ↔ (p → (⊥))))
</jh>

== Rules ==

Each propositional calculus needs at least one rule of detachment (modus ponens appears to be the most common). However, it will be convenient to have certain toolbox of rules implementing often used statements.

=== Negation and implication ===

Double negation elimination:
<jh>
stmt (eliminateDoubleNegation () ((¬ (¬ p))) p)
</jh>
Peano's importation and exportation rules:
<jh>
stmt (import () ((p → (q → r))) ((p ∧ q) → r))
stmt (export () (((p ∧ q) → r)) (p → (q → r)))
</jh>
Distribute and collect antecedents:
<jh>
stmt (distributeAntecedent () ((p → (q → r))) ((p → q) → (p → r)))
stmt (collectAntecedent () (((p → q) → (p → r))) (p → (q → r)))
</jh>
Four transposition rules:
<jh>
stmt (eliminateTransposition () (((¬ q) → (¬ p))) (p → q))
stmt (introduceTransposition () ((p → q)) ((¬ q) → (¬ p)))
stmt (transposeWithNegatedAntecedent () (((¬ p) → q)) ((¬ q) → p))
stmt (transposeWithNegatedConsequent () ((p → (¬ q))) (q → (¬ p)))
</jh>
Syllogism:
<jh>
stmt (applySyllogism () ((p → q) (q → r)) (p → r))
</jh>
Modus ponens and modus tollens:
<jh>
stmt (applyModusPonens () (p (p → q)) q)
stmt (applyModusTollens () ((¬ q) (p → q)) (¬ p))
</jh>

=== Disjunction and conjunction ===

Associative laws:
<jh>
stmt (groupDisjunctionLeft () ((p ∨ (q ∨ r))) ((p ∨ q) ∨ r))
stmt (groupDisjunctionRight () (((p ∨ q) ∨ r)) (p ∨ (q ∨ r)))
stmt (groupConjunctionLeft () ((p ∧ (q ∧ r))) ((p ∧ q) ∧ r))
stmt (groupConjunctionRight () (((p ∧ q) ∧ r)) (p ∧ (q ∧ r)))
</jh>
Commutative laws:
<jh>
stmt (swapDisjunction () ((p ∨ q)) (q ∨ p))
stmt (swapConjunction () ((p ∧ q)) (q ∧ p))
</jh>
Distributive laws:
<jh>
stmt (distributeLeftDisjunction () ((p ∨ (q ∧ r))) ((p ∨ q) ∧ (p ∨ r)))
stmt (collectLeftDisjunction () (((p ∨ q) ∧ (p ∨ r))) (p ∨ (q ∧ r)))
stmt (distributeRightDisjunction () (((p ∧ q) ∨ r)) ((p ∨ r) ∧ (q ∨ r)))
stmt (collectRightDisjunction () (((p ∨ r) ∧ (q ∨ r))) ((p ∧ q) ∨ r))
stmt (distributeLeftConjunction () ((p ∧ (q ∨ r))) ((p ∧ q) ∨ (p ∧ r)))
stmt (collectLeftConjunction () (((p ∧ q) ∨ (p ∧ r))) (p ∧ (q ∨ r)))
stmt (distributeRightConjunction () (((p ∨ q) ∧ r)) ((p ∧ r) ∨ (q ∧ r)))
stmt (collectRightConjunction () (((p ∧ r) ∨ (q ∧ r))) ((p ∨ q) ∧ r))
</jh>
Introduction/elimination rules:
<jh>
stmt (eliminateDisjunction () ((p ∨ q) (p → r) (q → r)) r)
stmt (combineStatements () (p q) (p ∧ q))
stmt (introduceConjunction () (p (p → q) (p → r)) (q ∧ r))
stmt (eliminateRightConjunction () ((p ∧ q)) p)
stmt (eliminateLeftConjunction () ((p ∧ q)) q)
</jh>

=== Biconditional ===

Introduction and elimination:
<jh>
stmt (introduceBiconditional () ((p → q) (q → p)) (p ↔ q))
stmt (eliminateBiconditionalLeft () ((p ↔ q)) (p → q))
stmt (eliminateBiconditionalRight () ((p ↔ q)) (q → p))
</jh>
Symmetry:
<jh>
stmt (swapBiconditional () ((p ↔ q)) (q ↔ p))
</jh>
Transitivity:
<jh>
stmt (combineBiconditionals () ((p ↔ q) (q ↔ r)) (p ↔ r))
</jh>
Expression builders:
<jh>
stmt (buildNegation () ((p ↔ q)) ((¬ p) ↔ (¬ q)))
stmt (buildImplication () ((p ↔ q) (r ↔ s)) ((p → r) ↔ (q → s)))
stmt (buildFromAntecedents () ((p ↔ q)) ((p → r) ↔ (q ↔ r)))
stmt (buildFromConsequents () ((p ↔ q)) ((r → p) ↔ (r → q)))
stmt (buildDisjunction () ((p ↔ q) (r ↔ s)) ((p ∨ r) ↔ (q ∨ s)))
stmt (buildLeftDisjunction () ((p ↔ q)) ((r ∨ p) ↔ (r ∨ q)))
stmt (buildRightDisjunction () ((p ↔ q)) ((p ∨ r) ↔ (q ∨ r)))
stmt (buildConjunction () ((p ↔ q) (r ↔ s)) ((p ∧ r) ↔ (q ∧ s)))
stmt (buildLeftConjunction () ((p ↔ q)) ((r ∧ p) ↔ (r ∧ q)))
stmt (buildRightConjunction () ((p ↔ q)) ((p ∧ r) ↔ (q ∧ r)))
stmt (buildBiconditional () ((p ↔ q) (r ↔ s)) ((p ↔ r) ↔ (q ↔ s)))
stmt (buildLeftBiconditional () ((p ↔ q)) ((r ↔ p) ↔ (r ↔ q)))
</jh>

[[Category:Classical propositional logic|!]]