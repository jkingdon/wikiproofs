{{modules
| parameters = [[Interface:Classical propositional calculus|Classical propositional calculus]], [[Interface:First-order logic with quantifiability|first-order logic]], [[Interface:Set theory|set theory]]
| importedby = none yet
| exportedby = none yet
}}

The complex numbers can be described, on top of set theory, by the axioms in this file. They are "axioms" in the sense that they are sufficient to define the complex (and real) numbers, but are theorems in the sense that it is possible to prove them from the [[Interface:Zermelo–Fraenkel set theory|axioms of set theory]] (by the usual construction of natural numbers, rational numbers as ratios, real numbers as Dedekind cuts, negative numbers, and complex numbers as pairs of real numbers). The form of the axioms in this file closely follows metamath (modulo a few details involving notation and the fact that we exclude proper classes while metamath does not).<ref>[http://us.metamath.org/mpeuni/mmcomplex.html Real and Complex Numbers], last updated on 6-May-2008</ref>

We build on [[Interface:Classical propositional calculus|propositional logic]], [[Interface:First-order logic with quantifiability|first-order logic]], and [[Interface:Set theory|set theory]].

<jh>
param (CLASSICAL Interface:Classical_propositional_calculus () ())
param (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
param (SETS Interface:Set_theory (CLASSICAL FIRSTORDER) ())
</jh>

== Complex numbers ==
There is a set of complex numbers. As a convention, we tend to use <code>z</code> and <code>w</code> to refer to complex numbers, although using these names does not by itself ensure that an <code>object</code> is a complex number rather than a set of numbers or a relation or something else.
<jh>
term (object (ℂ))
var (object z w s)
</jh>

The complex numbers are closed under an addition operation, which is commutative and associative.
<jh>
term (object (+ object object))
stmt (ComplexAdditionClosure () () (((z ∈ (ℂ)) ∧ (w ∈ (ℂ))) → ((z + w) ∈ (ℂ))))
stmt (AdditionCommutativity () () (((z ∈ (ℂ)) ∧ (w ∈ (ℂ))) → ((z + w) = (w + z))))
stmt (AdditionAssociativity () () ((((z ∈ (ℂ)) ∧ (w ∈ (ℂ))) ∧ (s ∈ (ℂ))) → (((z + w) + s) = (z + (w + s)))))
</jh>

The complex numbers are closed under a multiplication operation, which is commutative and associative.
<jh>
term (object (· object object))
stmt (ComplexMultiplicationClosure () () (((z ∈ (ℂ)) ∧ (w ∈ (ℂ))) → ((z · w) ∈ (ℂ))))
stmt (MultiplicationCommutativity () () (((z ∈ (ℂ)) ∧ (w ∈ (ℂ))) → ((z · w) = (w · z))))
stmt (MultiplicationAssociativity () () ((((z ∈ (ℂ)) ∧ (w ∈ (ℂ))) ∧ (s ∈ (ℂ))) → (((z · w) · s) = (z · (w · s)))))
</jh>

Multiplication distributes over addition.
<jh>
stmt (Distributivity () () ((((z ∈ (ℂ)) ∧ (w ∈ (ℂ))) ∧ (s ∈ (ℂ))) → ((z · (w + s)) = ((z · w) + (z · s)))))
</jh>

There is a complex number <code>1</code>, which serves as a multiplicative identity.
<jh>
term (object (1))
stmt (OneComplex () () ((1) ∈ (ℂ)))
stmt (MultiplicativeIdentity () () ((z ∈ (ℂ)) → ((z · (1)) = z)))
</jh>

There is a complex number <code>0</code>, not equal to <code>1</code>, which serves as an additive identity. We don't have an axiom stating that zero is complex simply because it is implied by the other axioms.
<jh>
term (object (0))
stmt (AdditiveIdentity () () ((z ∈ (ℂ)) → ((z + (0)) = z)))
stmt (ZeroOne () () ((0) ≠ (1)))
</jh>

There is a complex number <code>i</code> for the square root of negative one.
<jh>
term (object (i))
stmt (IComplex () () ((i) ∈ (ℂ)))
stmt (ISquared () () ((((i) · (i)) + (1)) = (0)))
</jh>

== Real numbers ==
There is a subset of the complex numbers called the real numbers which are closed under addition and multiplication. We conventionally use <code>a</code>, <code>b</code>, and <code>c</code> to refer to real number objects, and <code>x</code> and <code>y</code> for real variables.
<jh>
term (object (ℝ))
var (object a b c)
var (variable x y)
stmt (RealComplex () () ((ℝ) ⊆ (ℂ)))
stmt (RealAdditionClosure () () (((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) → ((a + b) ∈ (ℝ))))
stmt (RealMultiplicationClosure () () (((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) → ((a · b) ∈ (ℝ))))
</jh>

Any complex number can be written as real and imaginary parts.
<jh>
stmt (ComplexParts ((x y z)) () ((z ∈ (ℂ)) → (∃ x (((value x) ∈ (ℝ)) ∧ (∃ y (((value y) ∈ (ℝ)) ∧ (z = ((value x) + ((i) · (value y))))))))))
</jh>

Any real number has an additive inverse, and a nonzero real number has a multiplicative inverse.
<jh>
stmt (AdditiveInverse ((x a)) () ((a ∈ (ℝ)) → (∃ x (((value x) ∈ (ℝ)) ∧ ((a + (value x)) = (0))))))
stmt (MultiplicativeInverse ((x a)) () (((a ∈ (ℝ)) ∧ (a ≠ (0))) → (∃ x (((value x) ∈ (ℝ)) ∧ ((a · (value x)) = (1))))))
</jh>

YMMD with that asenwr! TX

== References ==
<references/>

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Real and complex fields]]