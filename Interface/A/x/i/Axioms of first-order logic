{{header
 | title    = Axioms of first-order logic
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = Predicate logic builds on [[Interface:Classical propositional calculus|propositional logic]] by adding quantifiers ("for all" and "there exists") and equality. More specifically, the kind of predicate logic we define here is known as first-order logic, which is a common basis for theories such as set theory or arithmetic.

The axioms of first-order logic are usually stated in terms of substitution of one variable or constant for another, [[w:free variable|free variables]] and [[w:bound variable|bound variables]]. JHilbert or metamath do not have the ability to perform this kind of substitution or recognize free variables syntactically, so the version of the axioms here is not based on those concepts. JHilbert does have distinct variable constraints, although whether to use them in this context is somewhat a matter of taste; the metamath archive contains versions of many of these axioms either with distinct variable constraints or with other conditions which also make them correct. The axioms as presented here are adapted from metamath (which in turn got many of the ideas from a 1965 paper by Tarski).<ref>[http://us.metamath.org/mpeuni/mmset.html#pcaxioms Predicate calculus], accessed February 24, 2010</ref>
}}

== Formulas and objects ==
We build on [[Interface:Classical propositional calculus]]:
<jh>
param (CLASSICAL Interface:Classical_propositional_calculus () ())
</jh>

By convention we use φ, ψ, χ, and θ to represent formulas:
<jh>
var (formula φ ψ χ θ)
</jh>

We use the term ''object'' to refer to something which is subject to quantification or equality. From an axiomatic point of view, what is an object is defined implicitly, by axioms such as those of [[w:Zermelo–Fraenkel set theory|ZFC set theory]] or [[w:Peano axioms|Peano arithmetic]].

<jh>
kind (object)
var (object s t u s0 s1 t0 t1)
</jh>

A ''variable'' is something we can quantify over.

<jh>
kind (variable)
var (variable x y z x0 x1 y0 y1)
</jh>

A variable can be used where an object is expected, although it needs to be converted via the following explicit conversion:
<jh>
term (object (value variable))
</jh>

The reverse is not possible.  Examples of objects which are not variables might be <code>s + t</code> for Peano arithmetic, or <code>s ∪ t</code> for set theory.

== Quantification ==
We extend the available formulas with [[w:Universal quantification|universal quantification]]:
<jh>
term (formula (∀ variable formula))

stmt (QuantifiedImplication () () ( (∀ x (φ → ψ)) → ((∀ x φ) → (∀ x ψ)) ) )
stmt (QuantifiedNegation () () ( (¬ (∀ x φ)) → (∀ x (¬ (∀ x φ))) ) )
stmt (QuantifierCommutation () () ( (∀ x (∀ y φ)) → (∀ y (∀ x φ)) ) )
</jh>

[[w:Generalization (logic)|Generalization]]:
<jh>
stmt (Generalization ((x φ)) () (φ → (∀ x φ)))
stmt (generalize () (φ) (∀ x φ))
</jh>

Although a usable theory of predicate logic will generally have at least one more quantifier (∃ for "there exists"), it can be defined in terms of ∀, so we have avoided it in the above axioms and do not need to define it here.

== Equality ==

We introduce equality and provide our first equality axiom, a version of the transitive law for equality:
<jh>
term (formula (= object object))
stmt (AxiomEquality () () ( (s = t) → ( (s = u) → (t = u) ) ) )
</jh>

The next four axioms combine equality and quantification.

The <code>Existence</code> axiom asserts that there is at least one object:
<jh>
stmt (Existence () () (¬ (∀ x (¬ ((value x) = s)))) )
stmt (QuantifierSubstitution () () ((∀ x ((value x) = (value y))) → (∀ y ((value y) = (value x)))) )
stmt (VariableSubstitution () () ( ((value x) = (value y)) → ( (∀ y φ) → (∀ x (((value x) = (value y)) → φ)) ) ) )
</jh>

The <code>QuantifierIntroduction</code> axiom says that if <code>z</code> is not equal to either <code>s</code> or <code>t</code>, then <code>z</code> does not affect the truth of <code>s = t</code>, so it is OK to add <code>∀ z</code> to the start of <code>x = y</code>.
<jh>
stmt (QuantifierIntroduction () () ( 
  (¬ (∀ z ((value z) = s))) 
  → ( (¬ (∀ z ((value z) = t))) 
      → ( (s = t) → (∀ z (s = t)) ) ) )
)
</jh>

There is also the principle of "equals can be substituted for equals". In our system, there is no way to express this generally, and it must be provided separately for each kind of expression which exists in the theory (for example, <code>∈</code> (is an element of), for set theory, or <code>S</code> (successor) or <code>+</code> (addition) for Peano arithmetic). Such a statement for equals itself, <code>(x0 = x1 ∧ y0 = y1) → (x0 = y0 ↔ x1 = y1)</code>, can be proved from the above axioms, so an additional axiom is not needed here.

== References ==
<references/>

== External links ==
*[[w:First-order logic]]

[[Category:Classical first-order logic|{{PAGENAME}}]]