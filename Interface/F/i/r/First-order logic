{{header
 | title    = First-order logic
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = This interface collects important theorems from first-order logic, which builds on [[Interface:Classical propositional calculus|propositional logic]] by adding quantifiers ("for all" and "there exists") and equality. It is meant as a user-friendly reservoir for those interfaces and proof modules which merely use first-order logic, without proving anything new within it.

Statements can be added if necessary, but then the exporting modules have to be updated accordingly.
}}
{{modules
| parameters = [[Interface:Classical propositional calculus]]
| importedby = None yet
| exportedby = None yet
}}
== Formulas, objects, and quantification ==
We build on [[Interface:Classical propositional calculus]]:
<jh>
param (CLASSICAL Interface:Classical_propositional_calculus () ())
</jh>

By convention we use φ, ψ, χ, and θ to represent formulas:
<jh>
var (formula φ ψ χ θ)
</jh>

We use the term ''object'' to refer to something which is subject to quantification or equality. From an axiomatic point of view, what is a valid object is defined implicitly, by axioms such as those of [[w:Zermelo–Fraenkel set theory|ZFC set theory]] or [[w:Peano axioms|Peano arithmetic]].

<jh>
kind (object)
var (object x y z)
</jh>

We extend the available formulas with [[w:Universal quantification|universal quantification]] and [[w:Existential quantification|existential quantification]]:
<jh>
term (formula (∀ object formula))
term (formula (∃ object formula))
</jh>

== Relationship between universal and existential quantification ==

<jh>
stmt (NotForAll () () ((¬ (∀ x φ)) ↔ (∃ x (¬ φ))))
stmt (NotThereExists () () ((¬ (∃ x φ)) ↔ (∀ x (¬ φ))))
</jh>

== Builders ==
As with propositional calculus, we need to build up formulas explicitly, and these rules let us do it.  We provide them for both quantifiers, for implication and the biconditional.
<jh>
stmt (addForAll () ((φ → ψ)) ((∀ x φ) → (∀ x ψ)))
stmt (addThereExists () ((φ → ψ)) ((∃ x φ) → (∃ x ψ)))

stmt (buildForAll () ((φ ↔ ψ)) ((∀ x φ) ↔ (∀ x ψ)))
stmt (buildThereExists () ((φ ↔ ψ)) ((∃ x φ) ↔ (∃ x ψ)))
</jh>

== Order ==
The order of adjacent quantifiers of the same type can be exchanged:
<jh>
stmt (ForAllCommutation () () ((∀ x (∀ y φ)) ↔ (∀ y (∀ x φ))))
stmt (ThereExistsCommutation () () ((∃ x (∃ y φ)) ↔ (∃ y (∃ x φ))))
</jh>

∃ followed by ∀ can be switched:
<jh>
stmt (ThereExistsForAllCommutation () () ((∃ x (∀ y φ)) → (∀ y (∃ x φ))))
</jh>

but the converse is only possible in special cases:
<jh>
stmt (ForAllThereExistsImplicationCommutation ((x y) (ψ x) (φ y)) ()
  ((∃ x (∀ y (φ → ψ))) ↔ (∀ y (∃ x (φ → ψ))))
)
</jh>

== Combining quantified statements ==
Quantifiers of the same variable can sometimes be combined or split:
<jh>
stmt (ForAllConjunction () () ((∀ x (φ ∧ ψ)) ↔ ((∀ x φ) ∧ (∀ x ψ))))
stmt (ThereExistsDisjunction () () ((∃ x (φ ∨ ψ)) ↔ ((∃ x φ) ∨ (∃ x ψ))))
stmt (ThereExistsImplication () () ((∃ x (φ → ψ)) ↔ ((∀ x φ) → (∃ x ψ))))
stmt (ForAllImplication () () ((∀ x (φ → ψ)) → ((∀ x φ) → (∀ x ψ))))
</jh>

We also provide rules for the above theorems:
<jh>
stmt (distributeForAllConjunction () ((∀ x (φ ∧ ψ))) ((∀ x φ) ∧ (∀ x ψ)))
stmt (collectForAllConjunction () ((∀ x φ) (∀ x ψ)) (∀ x (φ ∧ ψ)))

stmt (distributeThereExistsDisjunction () ((∃ x (φ ∨ ψ)))  ((∃ x φ) ∨ (∃ x ψ)))
stmt (collectThereExistsDisjunction () (((∃ x φ) ∨ (∃ x ψ))) (∃ x (φ ∨ ψ)))

stmt (distributeThereExistsImplication () ((∃ x (φ → ψ))) ((∀ x φ) → (∃ x ψ)))
stmt (collectThereExistsImplication () (((∀ x φ) → (∃ x ψ))) (∃ x (φ → ψ)))

stmt (distributeForAllImplication () ((∀ x (φ → ψ))) ((∀ x φ) → (∀ x ψ)))
</jh>

== Generalization and specialization ==
We can remove a universal quantifier:
<jh>
stmt (Specialization () () ((∀ x φ) → φ))
</jh>

The converse is sometimes possible, but only with some restrictions. Either the variable does not occur in the formula, or the formula is unconditionally true:
<jh>
stmt (Generalization ((x φ)) () (φ → (∀ x φ)))
stmt (generalize () (φ) (∀ x φ))
</jh>

== Equality ==
Equality is reflexive, symmetry, and transitive.
<jh>
term (formula (= object object))
stmt (EqualityReflexivity () () (x = x))
stmt (EqualitySymmetry () () ((x = y) ↔ (y = x)))
stmt (EqualityTransitivity () () (((x = y) ∧ (y = z)) → (x = z)))
</jh>

There is also the principle of "equals can be substituted for equals". In our system, there is no way to express this generally, and it must be provided separately for each kind of expression which exists in the theory (for example, ∈ (is an element of), for set theory, or S (successor) or + (addition) for Peano arithmetic).

== What else? ==
This page is not complete.  If you know what should be here, edit the page or suggest it on the talk page.

[[Category:Classical first-order logic|{{PAGENAME}}]]