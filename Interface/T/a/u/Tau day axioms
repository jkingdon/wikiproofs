{{modules
| parameters = [[Interface:Classical propositional calculus|Classical propositional calculus]], [[Interface:First-order logic with quantifiability|first-order logic]]
| importedby = none yet
| exportedby = none yet
}}

This is the starting point for the [[Tau day]] exercises. It defines the basic operations on real numbers: addition, subtraction, square roots, and so on. It also defines the sine and cosine trigonometric functions, and includes theorems for things like arithmetic results which are needed for the tau day exercises.

We build on [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|first-order logic]].

<jh>
param (PROPOSITIONAL Interface:Classical_propositional_calculus () ())
param (FIRSTORDER Interface:First-order_logic_with_quantifiability (PROPOSITIONAL) ())
</jh>

== Real numbers ==
In this file, any variable refers to a real number.
<jh>
kindbind (object real)
var (object x y z t θ α β)
</jh>

There is an addition operation, which is commutative and associative.
<jh>
term (real (+ real real))
stmt (AdditionCommutativity () () ((x + y) = (y + x)))
#stmt (AdditionAssociativity () () ((((z ∈ (ℂ)) ∧ (w ∈ (ℂ))) ∧ (s ∈ (ℂ))) → (((z + w) + s) = (z + (w + s)))))
</jh>

There is a multiplication operation, which is commutative and associative.
<jh>
term (real (· real real))
#stmt (ComplexMultiplicationClosure () () (((z ∈ (ℂ)) ∧ (w ∈ (ℂ))) → ((z · w) ∈ (ℂ))))
#stmt (MultiplicationCommutativity () () (((z ∈ (ℂ)) ∧ (w ∈ (ℂ))) → ((z · w) = (w · z))))
#stmt (MultiplicationAssociativity () () ((((z ∈ (ℂ)) ∧ (w ∈ (ℂ))) ∧ (s ∈ (ℂ))) → (((z · w) · s) = (z · (w · s)))))
</jh>

Multiplication distributes over addition.
<jh>
#stmt (Distributivity () () ((((z ∈ (ℂ)) ∧ (w ∈ (ℂ))) ∧ (s ∈ (ℂ))) → ((z · (w + s)) = ((z · w) + (z · s)))))
</jh>

There is a real number <code>1</code>, which serves as a multiplicative identity.
<jh>
term (real (1))
#stmt (MultiplicativeIdentity () () ((z ∈ (ℂ)) → ((x · (1)) = x)))
</jh>

There is a complex number <code>0</code>, not equal to <code>1</code>, which serves as an additive identity.
<jh>
term (real (0))
#stmt (AdditiveIdentity () () ((z ∈ (ℂ)) → ((z + (0)) = z)))
stmt (ZeroOne () () ((0) ≠ (1)))
</jh>

=== Numerical constants ===

There is not (yet at least) any particularly convenient way of expressing integers short of defining each one, so here are some of the more commonly used ones.
<jh>
def ((2) ((1) + (1)))
def ((3) ((2) + (1)))
def ((4) ((3) + (1)))
def ((5) ((4) + (1)))
def ((6) ((5) + (1)))
def ((7) ((6) + (1)))
def ((8) ((7) + (1)))
def ((9) ((8) + (1)))
def ((10) ((9) + (1)))
def ((11) ((10) + (1)))
def ((12) ((11) + (1)))
</jh>

=== Additive inverse and subtraction ===
Any real number has an additive inverse. Our notation is <code>- a</code> for the additive inverse of <code>a</code>.

<jh>
term (object (- object))
stmt (AdditiveInverse () () ((z + (- z)) = (0)))
</jh>

We can subtract any real number from another. In case your screen doesn't show it clearly, the minus sign is a different character (longer) than the negation sign above.
<jh>
term (object (− object object))
stmt (SubtractionClosed () () (((z ∈ (ℂ)) ∧ (w ∈ (ℂ))) → ((z − w) ∈ (ℂ))))
stmt (Subtraction () () (((z ∈ (ℂ)) ∧ (w ∈ (ℂ))) → ((z − w) = (z + (- w)))))
</jh>

=== Multiplicative inverse and division ===
Every nonzero complex (real?) number has a multiplicative inverse (TODO: what notation does metamath use for this?).

We can divide any real number by any nonzero complex number.
<jh>
term (real (/ real real))
stmt (DivisionClosed () () ((((z ∈ (ℂ)) ∧ (w ∈ (ℂ))) ∧ (w ≠ (0))) →
  ((z / w) ∈ (ℂ))))
stmt (Division () () ((((z ∈ (ℂ)) ∧ (w ∈ (ℂ))) ∧ (w ≠ (0))) →
  ((z / w) = (z · (reciprocal w)))))

stmt (Reciprocal () () ((z ≠ (0)) → ((z · ((1) / z)) = (1))))
</jh>

== Order on the reals ==
We define a [[w:Total order|total order]] on the reals, which is consistent with addition and multiplication.
<jh>
term (formula (< real real))
#stmt (Trichotomy () () (((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) → ((a < b) ↔ (¬ ((a = b) ∨ (b < a))))))
#stmt (Transitivity () () ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) → (((a < b) ∧ (b < c)) → (a < c))))
#stmt (LessThanAddition () () ((((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) ∧ (c ∈ (ℝ))) → ((a < b) → ((c + a) < (c + b)))))
#stmt (LessThanMultiplication () () (((a ∈ (ℝ)) ∧ (b ∈ (ℝ))) → ((((0) < a) ∧ ((0) < b)) → ((0) < (a · b)))))

def ((> a b) (b < a))
def ((≤ a b) ((a < b) ∨ (a = b)))
def ((≥ a b) (b ≤ a))
</jh>

=== Square root ===

We can take the square root of any nonnegative real number.
<jh>
term (real (√ real))
stmt (SquareRoot () () ((x ≥ (0)) → (((√ x) · (√ x)) = x)))
</jh>

== Trigonometry ==

[[w:Trigonometry|Trigonometry]] concerns the sine function (and others which can be derived from it, such as cosine, tangent, etc).

== The sine and cosine functions ==
[[File:Sin-cos-defn-I.png|thumb|right|geometric interpretation of sine and cosine]]
Here we define the sine and cosine functions.
<jh>
term (real (sin real))
term (real (cos real))
</jh>

== Circle constant ==
The circle constant <code>τ</code> is the circumference of a circle divided by its radius.<ref>Landau, Elizabeth (14 March 2011). [http://edition.cnn.com/2011/TECH/innovation/03/14/pi.tau.math/ "On Pi Day, is 'pi' under attack?"]. CNN. Retrieved 15 March 2011</ref>
<jh>
term (real (τ))
</jh>

Some authors instead use a value of <code>τ/2</code>, which they call <code>π</code>.

== Relationship between sine and cosine ==
The sine and the cosine at a given point, squared, add to one, which is the [[w:Pythagorean trigonometric identity|Pythagorean trigonometric identity]].
<jh>
stmt (TrigonometryPythagorean () () ((((sin θ) · (sin θ)) + ((cos θ) · (cos θ))) = (1)))
</jh>

The sine and cosine are the same, shifted by a quarter turn.
<jh>
stmt (SineShift () () ((sin (θ + ((τ) / (4)))) = (cos θ)))
</jh>

== Periodicity ==
The sine and cosine are periodic with period <code>τ</code> (we do not state, here, that <code>τ</code> is the smallest value which is a period, although it is).
<jh>
stmt (SinePeriod () () ((sin (θ + (τ))) = (sin θ)))
</jh>

== Negation ==
<jh>
stmt (SineNegation () () ((sin (- θ)) = (- (sin θ))))
</jh>

== Addition ==
There are expressions for taking the sine or cosine of a sum or difference.

<jh>
stmt (SineAddition () () ((sin (α + β)) = (((sin α) · (cos β)) + ((cos α) · (sin β)))))
stmt (CosineAddition () () ((cos (α + β)) = (((cos α) · (cos β)) − ((cos α) · (sin β)))))
stmt (SineSubtraction () () ((sin (α − β)) = (((sin α) · (cos β)) − ((cos α) · (sin β)))))
stmt (CosineSubtraction () () ((cos (α − β)) = (((cos α) · (cos β)) + ((cos α) · (sin β)))))
</jh>

== Trigonometry functions at particular points ==
We provide values of sine at zero; the values of the trigonometric functions at many points (for example, any multiple of <code>τ / 120</code> radians) can be derived from the theorems in this file.

<jh>
stmt (Sin0 () () ((sin (0)) = (0)))
</jh>

== See also ==
This file is based on [[Interface:Complex numbers]] and [[Interface:Trigonometry]]. The most fundamental difference is that it is a first-order theory (that is, a variable is a real number directly, rather than a set, which has consequences for how much of the real numbers are described here).

{{unproven}}

== References ==
<references/>

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Exponential and trigonometric functions]]
