This is an interface to hold the various substitution results, so I can play with them and figure out what should go into [[Interface:First-order logic]].

<jh>
param (CLASSICAL Interface:Classical_propositional_calculus () ())
param (FIRSTORDER Interface:First-order_logic (CLASSICAL) ())
param (PEANO Interface:Peano_axioms (CLASSICAL FIRSTORDER) ())

var (formula φ ψ χ θ)
var (object x y z n m k n0 m0 n1 m1 x0 x1 y0 y1)

stmt (SubstitutionEquality () () (subst y x (x = y)))

stmt (sbie () 
  ((x is-not-free-in ψ) ((x = y) → (φ ↔ ψ)))
  ((subst y x φ) ↔ ψ)
)

stmt (sbt ()
  (φ)
  (subst y x φ)
)

stmt (buildAddition () ((n0 = n1) (m0 = m1)) ((n0 + m0) = (n1 + m1)))
stmt (AdditionBuilder () () (((n0 = n1) ∧ (m0 = m1)) → ((n0 + m0) = (n1 + m1))))
stmt (buildEquality () ((x0 = x1) (y0 = y1)) ((x0 = y0) ↔ (x1 = y1)))
stmt (EqualityBuilder () () (((x0 = x1) ∧ (y0 = y1)) → ((x0 = y0) ↔ (x1 = y1))))

stmt (followImplication () ((subst y x φ) (φ → ψ)) (subst y x ψ)) # consequence of sbimi

stmt (buildSubstitutedAddition () ((subst y x (n0 = n1)) (subst y x (m0 = m1))) (subst y x ((n0 + m0) = (n1 + m1))))
# buildSubstitutedAddition is a consequence of AdditionBuilder and followImplication, I think
stmt (buildSubstitutedEquality () ((subst y x (x0 = x1)) (subst y x (y0 = y1))) (subst y x ((x0 = y0) ↔ (x1 = y1))))
</jh>