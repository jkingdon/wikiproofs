{{header
 | title    = Convenience theorems of
 | subtitle = propositional logic
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = This page proves those statments of [[Interface:Classical propositional calculus]] which aren't in [[Interface:Principia Mathematica propositional logic theorems]].  This includes chiefly additional builders (which aren't necessarily in most textbook treatments as they take substitution for granted), additional variants on modus ponens and related theorems, and the like. Some of them are significant aids to making proofs concise and readable, but some of them are more arguable and are here to ease translating proofs from other systems or so that people writing proofs can make their own decisions.
}}
{{interfaces
| imports = [[Interface:Principia Mathematica propositional logic theorems]]
| exports = [[Interface:Classical propositional calculus]]
}}

We first import [[Interface:Principia Mathematica propositional logic theorems]]:
<jh>
import (PRINCIPIA Interface:Principia_Mathematica_propositional_logic_theorems () ())
</jh>

As usual, <code>p</code>, <code>q</code>, and <code>r</code> are formulas:
<jh>
var (formula p q r)
</jh>

== Detachment ==
We have already encountered our first detachment rule, <code>applyModusPonens</code>, which takes a proposition and an implication with that proposition as antecedent.  The following are variants in which the implication has several antecedents (that is, the antecedent is a conjunction of two or more propositions) and we detach one or more of the antecedents.

<jh>
thm (detach2of2 () ((H q) (HIMP ((p ∧ q) → r))) (p → r) (
        H

        q p ConjunctionCommutativity eliminateBiconditionalReverse
        HIMP
        applySyllogism

        export
        applyModusPonens
))
</jh>

== Transforming parts of formula ==
By "transforming", we mean applying a biconditional to replace part of a formula.
<jh>
thm (transformAntecedent () ((HIMP (p → q)) (HEQ (p ↔ r))) (r → q) (
        HEQ eliminateBiconditionalForward
        HIMP
        applySyllogism
))
</jh>

== More relationships between connectives ==
The following relationships between conjunction and implication parallel those between disjunction and implication (and in fact follow easily from them and DeMorgan's laws).<ref>ConjunctionImplication is *4.63 in ''Principia'', with the two sides of the biconditional commuted</ref>
<jh>
thm (ConjunctionImplication () () ((p ∧ q) ↔ (¬ (p → (¬ q)))) (
        p q DeMorganNDN swapBiconditional

        p (¬ q) ImplicationDisjunction swapBiconditional
        addNegation

        applyBiconditionalTransitivity
))

thm (ImplicationConjunction () () ((p → q) ↔ (¬ (p ∧ (¬ q)))) (
        p q ImplicationDisjunction

        p q DeMorganPCN swapBiconditional

        applyBiconditionalTransitivity
))
</jh>

== Additional builders ==
The builders in [[Interface:Principia Mathematica propositional logic theorems]] for the various connectives often have a theorem form (e.g. <code>ConjunctionFunction</code>) and a rule form (e.g. <code>buildConjunction</code>). They may have a version for the implication rather than the biconditional (e.g. <code>DisjunctionSummation</code>, although sometimes only the biconditionalized version holds) and variants which add a common formula to one side or the other (e.g. <code>DisjunctionSummationLL</code> and <code>DisjunctionSummationRR</code>). Here we prove some of those variations which we haven't proved yet. The LR and RL variations (analogous to <code>DisjunctionSummationLR</code> and <code>DisjunctionSummationRL</code>) haven't as often been needed, but they could go here too, if there is a need.
<jh>
thm (buildConjunctionLL () ((H (p ↔ q))) ((r ∧ p) ↔ (r ∧ q)) (
        r BiconditionalReflexivity
        H
        buildConjunction
))

var (formula antecedent common)
thm (buildConjunctionRRInConsequent ()
  ((H (antecedent → (p ↔ q))))
  (antecedent → ((p ∧ common) ↔ (q ∧ common))) (
        H
        common BiconditionalReflexivity
        p q common common ConjunctionFunction detach2of2
        applySyllogism
))
</jh>

== Done ==
We now export [[Interface:Classical propositional calculus]].
<jh>
export (CLASSICAL Interface:Classical_propositional_calculus () ())
</jh>

== Footnotes ==
<references/>

[[Category:Classical propositional logic]]

