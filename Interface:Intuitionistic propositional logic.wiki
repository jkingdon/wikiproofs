{{header
 | title    = Intuitionistic propositional logic
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = [[w:Intuitionistic logic|Intuitionistic logic]] is a subset of [[Interface:Classical propositional calculus]] (subset in the sense that every theorem of intuitionistic logic is also a theorem of classical logic). It differs in omitting the [[w:law of the excluded middle]]. This interface collects theorems of intuitionistic logic, with a particular emphasis on constrasting it with classical logic.
}}
{{modules
| parameters = ''None''
| importedby = none yet
| exportedby = [[Intuitionistic propositional logic]]
}}

[[Image:Zeichen 123.svg|50px]] This page is not yet done.  In particular, parts are copied from [[Interface:Classical propositional calculus]] and although I've tried to find things which don't hold here (or where I'm not sure), I might have missed some.  Until we prove everything here, we won't be sure.

== Well-formed formulas ==

We first introduce the kind of [[w:well-formed formulas|well-formed formulas]] and a few variables for this kind.
<jh>
kind (formula)
var (formula p q r s)
</jh>

== Logical connectives ==

There are five standard [[w:logical connective|logical connective]]s in the propositional calculus, [[w:negation|negation]],
<jh>
term (formula (¬ formula))
</jh>
[[w:material conditional|implication]],
<jh>
term (formula (→ formula formula))
</jh>
[[w:logical disjunction|disjunction]],
<jh>
term (formula (∨ formula formula))
</jh>
[[w:logical conjunction|conjunction]],
<jh>
term (formula (∧ formula formula))
</jh>
and, finally, the [[w:logical biconditional|biconditional]],
<jh>
term (formula (↔ formula formula))
</jh>
In addition, one can also consider the constant formulas (or [[w:nullary#Nullary|nullary]] connectives) "the true",
<jh>
term (formula (⊤))
</jh>
and "the false",
<jh>
term (formula (⊥))
</jh>

== Simple statements ==

Here are the statements which do not require any hypotheses.

=== Negation and implication ===

[[w:double negative elimination|Double negation]] can be introduced but not eliminated, but triple negation is equivalent to single negation.<ref>Heyting, 1966, page 100</ref>
<jh>
stmt (DoubleNegationIntroduction () () (p → (¬ (¬ p))))
stmt (TripleNegation () () ((¬ (¬ (¬ p))) ↔ (¬ p)))
</jh>
Double negation is of great importance partly due to a metatheorem which states that <code>¬ ¬ p</code> is provable in intuitionistic logic if and only if <code>p</code> is provable in classical logic.  Here are two theorems relating to double negation; the converse of <code>DoubleNegatedDisjunction</code> does not hold.<ref>Heyting, 1966, page 101</ref>
<jh>
stmt (DoubleNegatedConjunction () () (((¬ (¬ p)) ∧ (¬ (¬ q))) ↔ (¬ (¬ (p ∧ q)))))
stmt (DoubleNegatedDisjunction () () (((¬ (¬ p)) ∨ (¬ (¬ q))) → (¬ (¬ (p ∨ q)))))
</jh>
Implication is [[w:reflexive relation|reflexive]]. Sometimes, this is called "Identity" or "Tautology".
<jh>
stmt (ImplicationReflexivity () () (p → p))
</jh>
Introduction of an [[w:antecedent (logic)|antecedent]]. Whitehead and Russell call this "Simplification"<ref>{{sc|A. Whitehead, B. Russell}}, Principia Mathematica, ''Cambridge University Press'', 1910.</ref>:
<jh>
stmt (AntecedentIntroduction () () (p → (q → p)))
</jh>
[[w:Syllogism|Syllogism]] can be stated in several ways, all of which hold in intuitionistic logic. This form is perhaps the most familiar:
<jh>
stmt (ImplicationTransitivity () () (((p → q) ∧ (q → r)) → (p → r)))
</jh>
If the [[w:consequent|consequent]] of an implication is an implication itself, its antecedent can be distributed over antecedent and consequent of the consequent, and vice versa.
<jh>
stmt (AntecedentDistribution () () ((p → (q → r)) ↔ ((p → q) → (p → r))))
</jh>
[[w:Transposition_(logic)|Transposition]] merely holds in one direction, not as a biconditional.<ref>Heyting, 1966, page 100</ref>
<jh>
stmt (TranspositionIntroduction () () ((p → q) → ((¬ q) → (¬ p))))
</jh>

=== Disjunction and conjunction ===

[[w:Idempotence|Idempotence]]:
<jh>
stmt (DisjunctionIdempotence () () (p ↔ (p ∨ p)))
stmt (ConjunctionIdempotence () () (p ↔ (p ∧ p)))
</jh>

[[w:Associativity|Associativity]]:
<jh>
stmt (DisjunctionAssociativity () () (((p ∨ q) ∨ r) ↔ (p ∨ (q ∨ r))))
stmt (ConjunctionAssociativity () () (((p ∧ q) ∧ r) ↔ (p ∧ (q ∧ r))))
</jh>

[[w:Commutativity|Commutativity]]:
<jh>
stmt (DisjunctionCommutativity () () ((p ∨ q) ↔ (q ∨ p)))
stmt (ConjunctionCommutativity () () ((p ∧ q) ↔ (q ∧ p)))
</jh>

[[w:Distributivity|Distributivity]]:
<jh>
stmt (DisjunctionLeftDistribution () () ((p ∨ (q ∧ r)) ↔ ((p ∨ q) ∧ (p ∨ r))))
stmt (DisjunctionRightDistribution () () (((p ∧ q) ∨ r) ↔ ((p ∨ r) ∧ (q ∨ r))))
stmt (ConjunctionLeftDistribution () () ((p ∧ (q ∨ r)) ↔ ((p ∧ q) ∨ (p ∧ r))))
stmt (ConjunctionRightDistribution () () (((p ∨ q) ∧ r) ↔ ((p ∧ r) ∨ (q ∧ r))))
</jh>

=== De Morgan's laws ===

[[w:De Morgan's laws|De Morgan's laws]] do not hold, in general, but some of them are available, often as implications rather than biconditionals.<ref>DeMorganPCPReverse and DeMorganPDPSwapped can be found on page 100 of Heyting, 1966</ref> The naming convention makes more sense if you look at [[Interface:Classical propositional calculus]] first. The letters (<code>P</code> for non-negated, <code>N</code> for negated, <code>D</code> for disjunction, and <code>C</code> for conjunction) refer to a disjunction/conjunction which is itself negated, and is thought of as being on the left side of a biconditional.  If it is really on the right side of a biconditional, our naming convention is to add <code>Swapped</code>; if it is really a consequent of an implication, the naming convention is to add <code>Reverse</code>.
<jh>
stmt (DeMorganNDNReverse () () ((p ∧ q) → (¬ ((¬ p) ∨ (¬ q)))))
stmt (DeMorganNCNReverse () () ((p ∨ q) → (¬ ((¬ p) ∧ (¬ q)))))
stmt (DeMorganPCPReverse () () (((¬ p) ∨ (¬ q)) → (¬ (p ∧ q))))
stmt (DeMorganPDPSwapped () () (((¬ p) ∧ (¬ q)) ↔ (¬ (p ∨ q))))
</jh>

=== Other statements containing negation, implication, disjunction and conjunction ===

The following importation/exportation principle applies as in classical logic:
<jh>
stmt (Transportation () () ((p → (q → r)) ↔ ((p ∧ q) → r)))
</jh>
[[w:Modus ponens|Modus ponens]] holds and the ability to introduce transposition also gives us [[w:modus tollens|modus tollens]].
<jh>
stmt (ModusPonens () () ((p ∧ (p → q)) → q))
stmt (ModusTollens () () (((¬ q) ∧ (p → q)) → (¬ p)))
</jh>
Introduction principle for disjunction:
<jh>
stmt (DisjunctionLeftIntroduction () () (p → (q ∨ p)))
stmt (DisjunctionRightIntroduction () () (p → (p ∨ q)))
</jh>
Introduction and elimination principles for conjunction:
<jh>
stmt (ConjunctionLeftIntroduction () () (p → (q → (q ∧ p))))
stmt (ConjunctionRightIntroduction () () (p → (q → (p ∧ q))))
stmt (ConjunctionLeftElimination () () ((p ∧ q) → q))
stmt (ConjunctionRightElimination () () ((p ∧ q) → p))
</jh>
Case by case elimination. We provide a version with disjunctions, but this is rather weaker than the classical version.
<jh>
stmt (DisjunctiveCaseElimination () () (((p ∨ q) ∧ ((¬ p) ∨ q)) → q))
</jh>
Composition for disjunction and conjunction:
<jh>
stmt (DisjunctionComposition () () (((p → r) ∧ (q → r)) ↔ ((p ∨ q) → r)))
stmt (ConjunctionComposition () () (((p → q) ∧ (p → r)) ↔ (p → (q ∧ r))))
</jh>
Summation for disjunction. We use the suffixes <code>LL</code>, <code>LR</code>, <code>RL</code> and <code>RR</code> to indicate if the summands were added to the left or the right of antecedent or consequent, respectively.
<jh>
stmt (DisjunctionSummationLL () () ((p → q) → ((r ∨ p) → (r ∨ q))))
stmt (DisjunctionSummationLR () () ((p → q) → ((r ∨ p) → (q ∨ r))))
stmt (DisjunctionSummationRL () () ((p → q) → ((p ∨ r) → (r ∨ q))))
stmt (DisjunctionSummationRR () () ((p → q) → ((p ∨ r) → (q ∨ r))))
stmt (DisjunctionSummation () () (((p → q) ∧ (r → s)) → ((p ∨ r) → (q ∨ s))))
</jh>
Multiplication for conjunction, with the same suffixes as above.
<jh>
stmt (ConjunctionMultiplicationLL () () ((p → q) → ((r ∧ p) → (r ∧ q))))
stmt (ConjunctionMultiplicationLR () () ((p → q) → ((r ∧ p) → (q ∧ r))))
stmt (ConjunctionMultiplicationRL () () ((p → q) → ((p ∧ r) → (r ∧ q))))
stmt (ConjunctionMultiplicationRR () () ((p → q) → ((p ∧ r) → (q ∧ r))))
stmt (ConjunctionMultiplication () () (((p → q) ∧ (r → s)) → ((p ∧ r) → (q ∧ s))))
</jh>
Adding a common antecedent to an implication, or adding a common consequent and reversing the direction of the implication:
<jh>
stmt (CommonAntecedentAddition () () ((q → r) → ((p → q) → (p → r))))
stmt (CommonConsequentAddition () () ((p → q) → ((q → r) → (p → r))))
</jh>

=== Biconditional ===

==== Equivalence relation ====

As in classical logic, the biconditional can be thought of as creating an [[w:equivalence relation|equivalence relation]] among formulas.
<jh>
stmt (BiconditionalReflexivity () () (p ↔ p))
stmt (BiconditionalSymmetry () () ((p ↔ q) ↔ (q ↔ p)))
stmt (BiconditionalTransitivity () () (((p ↔ q) ∧ (q ↔ r)) → (p ↔ r)))
</jh>
The <code>TertiumNonDatur</code> (law of excluded middle) does not hold. We can have <code>Tautology</code> and <code>Contradiction</code> from [[Interface:Classical propositional calculus]], as long as we rephrase the former to refer to another theorem rather than the <code>TertiumNonDatur</code>.
<jh>
stmt (TautologyId () () ((p → p) ↔ (⊤)))
stmt (Contradiction () () ((p ∧ (¬ p)) ↔ (⊥)))
</jh>

In intuitionistic logic, the following theorems from [[Interface:Classical propositional calculus]] might be better termed "proved" and "disproved" (or "valid" and "invalid", or some such terminology) rather than <code>True</code> and <code>NotFalse</code>, but they do hold as stated.
<jh>
stmt (True () () (⊤))
stmt (NotFalse () () (¬ (⊥)))
</jh>

==== Weakenings ====

A biconditional makes a strong statement. Often, we only need a weaker statement. For introductions, see the section on [[#Truth function interdependencies|truth function interdependencies]].

The naming convention here is that when we think of <code>p ↔ q</code> as consisting of two implications, we call <code>p → q</code> the ''forward'' one and <code>q → p</code> the ''reverse'' one.
<jh>
stmt (BiconditionalForwardElimination () () ((p ↔ q) → (q → p)))
stmt (BiconditionalReverseElimination () () ((p ↔ q) → (p → q)))
</jh>

[[Interface:Classical propositional calculus]] has a similar set of weakenings to disjunctions, but they do not apply in intuitionistic logic.

==== Builders ====

We are able to build formulas as in classical logic. We give them different names than in [[Interface:Classical propositional calculus]] to reflect the lack of a simple notion of "true" and "false" in intuitionistic logic, and because <code>NegationBuilder</code> is only an implication (rather than the biconditional in classical logic).
<jh>
stmt (NegationBuilder () () ((p ↔ q) → ((¬ p) ↔ (¬ q))))
stmt (ImplicationBuilder () () (((p ↔ q) ∧ (r ↔ s)) → ((p → r) ↔ (q → s))))
stmt (DisjunctionBuilder () () (((p ↔ q) ∧ (r ↔ s)) → ((p ∨ r) ↔ (q ∨ s))))
stmt (ConjunctionBuilder () () (((p ↔ q) ∧ (r ↔ s)) → ((p ∧ r) ↔ (q ∧ s))))
stmt (BiconditionalBuilder () () (((p ↔ q) ∧ (r ↔ s)) → ((p ↔ r) ↔ (q ↔ s))))
</jh>

==== Connective interdependencies ====

Although the connectives are interrelated in intuitionistic logic, most of the classical theorems expressing those relationships only hold as implications, rather than biconditionals. We have already seen that for De Morgan's laws. Here are some more.

The biconditional is related to implication and conjunction as in classical logic.
<jh>
stmt (BiconditionalImplication () () ((p ↔ q) ↔ ((p → q) ∧ (q → p))))
</jh>

In a nutshell, disjunction makes a stronger statement than implication, but the details depend on where the negations are placed. In classical logic, by contrast, <code>p → q</code> is equivalent to <code>¬ p ∨ q</code> and likewise for other placements of the negations.
<jh>
stmt (DisjunctionImplicationForward () () ((p ∨ q) → ((¬ p) → q)))
stmt (ImplicationDisjunctionReverse () () (((¬ p) ∨ q) → (p → q)))
stmt (NotImplicationDisjunction () () ((¬ (p → q)) → (¬ ((¬ p) ∨ q))))
stmt (NotDisjunctionImplication () () ((¬ (p ∨ q)) ↔ (¬ ((¬ p) → q))))
</jh>

We do not have <code>BiconditionalDisjunction</code> from [[Interface:Classical propositional calculus]], and <code>BiconditionalConjunction</code> only in one direction.
<jh>
stmt (BiconditionalConjunctionReverse () () ((((¬ p) ∨ q) ∧ (p ∨ (¬ q))) → (p ↔ q)))
</jh>

Negation as implication.  This one holds as in classical logic.
<jh>
stmt (NegationImplication () () ((¬ p) ↔ (p → (⊥))))
</jh>

== Rules ==

For the moment, we have just one rule. By the time this file is fleshed out, we'll probably have rules for pretty much all the theorems above.

<jh>
stmt (applyModusPonens () (p (p → q)) q)
</jh>

== Footnotes ==

<references />

== Cited works ==
* Heyting, A. (1966), ''Intuitionism: An introduction'', second edition, North-Holland publishing company, Amsterdam

[[Category:Subsystems of classical logic|!]]

