{{header
 | title    = Axioms of first-order logic
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = Predicate logic builds on [[Interface:Classical propositional calculus|propositional logic]] by adding quantifiers ("for all" and "there exists") and equality. More specifically, the kind of predicate logic we define here is known as first-order logic, which is a common basis for theories such as set theory or arithmetic.

The axioms of first-order logic are usually stated in terms of substitution of one variable or constant for another, [[w:free variable|free variables]] and [[w:bound variable|bound variables]]. JHilbert or metamath do not have the ability to perform this kind of substitution or recognize free variables syntactically, so the version of the axioms here is not based on those concepts. JHilbert does have distinct variable constraints, although whether to use them in this context is somewhat a matter of taste; the metamath archive contains versions of many of these axioms either with distinct variable constraints or with other conditions which also make them correct. The axioms as presented here are adapted from metamath (which in turn got many of the ideas from a 1965 paper by Tarski).<ref>[http://us.metamath.org/mpeuni/mmset.html#pcaxioms Predicate calculus], accessed February 24, 2010</ref>
}}

== Formulas and objects ==
We build on [[Interface:Classical propositional calculus]]:
<jh>
param (CLASSICAL Interface:Classical_propositional_calculus () ())
</jh>

By convention we use φ, ψ, χ, and θ to represent formulas:
<jh>
var (formula φ ψ χ θ)
</jh>

We use the word ''object'' to refer to something which is subject to equality (or, indirectly, via <code>variable</code>, quantification). We define a kind called <code>object</code>, which corresponds to a [[w:First-order_logic#Terms|term]] in more conventional terminology. Theories built on first-order logic, like [[w:Zermelo–Fraenkel set theory|ZFC set theory]] or [[Interface:Peano axioms|Peano arithmetic]], will define additional kinds of terms such as <code>+</code> (addition) or <code>∪</code> (union).

<jh>
kind (object)
var (object s t u s0 s1 t0 t1)
</jh>

A ''variable'' is something we can quantify over.

<jh>
kind (variable)
var (variable x y z x0 x1 y0 y1)
</jh>

A variable can be used where an object is expected, although it needs to be converted via the following explicit conversion.  When we are writing informally (rather than in JHilbert proofs themselves), we may omit the conversion (it should be understood whereever we use a variable in a context where an object is expected).
<jh>
term (object (value variable))
</jh>

The reverse is not possible.  Examples of objects which are not variables might be <code>s + t</code> for Peano arithmetic, or <code>s ∪ t</code> for set theory.

== Quantification ==
We extend the available formulas with [[w:Universal quantification|universal quantification]]:
<jh>
term (formula (∀ variable formula))

stmt (QuantifiedImplication () () ( (∀ x (φ → ψ)) → ((∀ x φ) → (∀ x ψ)) ) )
stmt (QuantifiedNegation () () ( (¬ (∀ x φ)) → (∀ x (¬ (∀ x φ))) ) )
stmt (QuantifierCommutation () () ( (∀ x (∀ y φ)) → (∀ y (∀ x φ)) ) )
</jh>

[[w:Generalization (logic)|Generalization]]:
<jh>
stmt (Generalization ((x φ)) () (φ → (∀ x φ)))
stmt (generalize () (φ) (∀ x φ))
</jh>

Although a usable theory of predicate logic will generally have at least one more quantifier (∃ for "there exists"), it can be defined in terms of ∀, so we have avoided it in the above axioms and do not need to define it here.

== Equality ==

=== Reflexive, symmetry, and transitive ===

We introduce equality, which is reflexive, symmetry, and transitive.  For simplicity, we simply adopt these three properties as axioms, rather than a smaller set of axioms which imply them.

<jh>
term (formula (= object object))

stmt (EqualityReflexivity () () (s = s))
stmt (EqualitySymmetry () () ((s = t) ↔ (t = s)))
stmt (EqualityTransitivity () () (((s = t) ∧ (t = u)) → (s = u)))
</jh>

=== Axioms combining equality and quantification ===

The <code>Existence</code> axiom asserts that there is at least one object:
<jh>
stmt (Existence () () (¬ (∀ x (¬ ((value x) = (value y))))) )
stmt (QuantifierSubstitution () () ((∀ x ((value x) = (value y))) → (∀ y ((value y) = (value x)))) )
</jh>

The <code>VariableSubstitution</code> axiom converts a statement about one variable to a statement about another. In most uses, <code>φ</code> will contain <code>x</code> as a free variable.  Then the axiom allows one to deduce <code>∀x(x = y → φ)</code>, a statement where <code>x</code> is not free, but where <code>y</code> is free.  <code>∀x(x = y → φ)</code> means (in some sense), <code>φ</code> with <code>y</code> substituted for <code>x</code>. Metamath contains several equivalent variations of this axiom;<ref>[http://us.metamath.org/mpeuni/ax11v.html ax11v], [http://us.metamath.org/mpeuni/ax-11.html ax-11], and [http://us.metamath.org/mpeuni/ax-11o.html ax-11o] in metamath's set.mm, accessed March 14, 2010</ref> we pick ax11v, which is the most convenient one for us.
<jh>
stmt (VariableSubstitution ((x y)) () 
  (((value x) = (value y)) → (φ → (∀ x (((value x) = (value y)) → φ)))) )
</jh>

The <code>QuantifierIntroduction</code> axiom is related to <code>Generalization</code> in that it adds a universal quantifier to a proposition (in this case, <code>s = t</code>). In fact, if <code>z</code> were distinct from <code>s</code> and <code>t</code>, <code>Generalization</code> would give us <code>s = t → ∀ z s = t</code>. The antecedents here, however, are weaker. The proposition <code>¬ ∀ z z = s</code> allows <code>z</code> to appear in <code>s</code>, but just requires that <code>z</code> is not always equal to <code>s</code>.
<jh>
stmt (QuantifierIntroduction () () ( 
  (¬ (∀ z ((value z) = s))) 
  → ( (¬ (∀ z ((value z) = t))) 
      → ( (s = t) → (∀ z (s = t)) ) ) )
)
</jh>

There is also the principle of "equals can be substituted for equals". In our system, there is no way to express this generally, and it must be provided separately for each kind of expression which exists in the theory (for example, <code>∈</code> (is an element of), for set theory, or <code>S</code> (successor) or <code>+</code> (addition) for Peano arithmetic). Such a statement for equals itself, <code>(s0 = s1 ∧ t0 = t1) → (s0 = t0 ↔ s1 = t1)</code>, can be proved from the above axioms, so an additional axiom is not needed here.

== Axiom of quantifiability ==
In the axioms as shown above, we do not preclude the possibility of a term which cannot be equal to any variable (this will be true of [[w:proper class|proper classes]] in some formulations of set theory, for example). If this generality is not needed, assuming the [[Interface:Axiom of quantifiability]] may make life easier.

== References ==
<references/>

== External links ==
*[[w:First-order logic]]

[[Category:Classical first-order logic|{{PAGENAME}}]]

