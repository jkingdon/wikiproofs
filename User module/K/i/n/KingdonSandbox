This page is to help me figure out how induction might work (in terms of the substitution).
[[Interface:Classical propositional calculus]], [[Interface:First-order logic]], [[Interface:Peano axioms]], [[User interface:Kingdon/Sandbox]].

<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic (CLASSICAL) ())
import (PEANO Interface:Peano_axioms (CLASSICAL FIRSTORDER) ())
import (SANDBOX User_interface:Kingdon/Sandbox (CLASSICAL FIRSTORDER PEANO) ())

var (formula p q φ ψ)
var (nat k n m n0 n1 m0 m1)
</jh>

== Some first order logic theorems ==
These, or something like them, probably should be in [[Interface:First-order logic]], once we have a clearer grasp on what will be most helpful.
<jh>
var (object x y x0 y0 x1 y1)
thm (distributeSubstImplication () ((H (subst y x (φ → ψ)))) ((subst y x φ) → (subst y x ψ)) (
        H
        y x φ ψ SubstImplication eliminateBiconditionalReverse
        applyModusPonens
))

thm (distributeSubstBiconditional () ((H (subst y x (φ ↔ ψ)))) ((subst y x φ) ↔ (subst y x ψ)) (
        H
        y x φ ψ SubstBiconditional eliminateBiconditionalReverse
        applyModusPonens
))

thm (introduceSubstConjunction () ((HPHI (subst y x φ)) (HPSI (subst y x ψ))) (subst y x (φ ∧ ψ)) (
        HPHI
        HPSI
        introduceConjunction

        y x φ ψ SubstConjunction eliminateBiconditionalForward
        applyModusPonens
))

thm (buildSubstitutedEquality () 
  ((HX (subst y x (x0 = x1))) (HY (subst y x (y0 = y1))))
  (subst y x ((x0 = y0) ↔ (x1 = y1))) (
        HX HY introduceSubstConjunction

        x0 x1 y0 y1 EqualityBuilder
        y x introduceSubst
        distributeSubstImplication

        applyModusPonens
))

thm (followImplication () ((H1 (subst y x φ)) (H2 (φ → ψ))) (subst y x ψ) (
        H1

        H2
        y x introduceSubst
        distributeSubstImplication

        applyModusPonens
))

thm (reverseModusPonensInsideSubst ()
  ((HEQ (subst y x (φ ↔ ψ)))
   (H2 ψ)
  )
  (subst y x φ) (
        H2
        y x introduceSubst

        HEQ
        y x φ ψ SubstBiconditional eliminateBiconditionalReverse
        applyModusPonens

        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

=== Arithmetic-specific ===
<jh>
thm (buildSubstitutedAddition ()
  ((HN (subst y x (n0 = n1)))
   (HM (subst y x (m0 = m1))))
  (subst y x ((n0 + m0) = (n1 + m1))) (
        HN
        HM
        introduceSubstConjunction

        n0 n1 m0 m1 AdditionBuilder
        y x introduceSubst
        distributeSubstImplication

        applyModusPonens
))
</jh>

== Via sbie ==
This builds up implicit substitution and converts it to subst at the end.

<jh>
thm (ViaSbieStepOne () () ((n = (0)) → (((0) + n) = ((0) + (0)))) (
        (0) EqualityReflexivity
        ((0) = (0)) (n = (0)) ConjunctionRightIntroduction
        applyModusPonens

        (0) (0) n (0) AdditionBuilder

        applySyllogism
))

thm (ViaSbieStepTwo () () ((n = (0)) → ((((0) + n) = n) ↔ (((0) + (0)) = (0)))) (
        n ViaSbieStepOne
        (n = (0)) ImplicationReflexivity
        composeConjunction

        ((0) + n) ((0) + (0)) n (0) EqualityBuilder
        applySyllogism
))

thm (BaseCaseViaSbie () () (subst (0) n (((0) + n) = n)) (
        (0) AdditiveIdentity
        n (((0) + (0)) = (0)) DistinctNotFree
        n ViaSbieStepTwo
        buildSubstFromEquality
))
</jh>

=== via follow implication ===
Slight variant of the previous.

<jh>
thm (ViaFollowImplicationStepOne () () (subst (0) n (((0) + n) = ((0) + (0)))) (
        (0) n SubstitutionEquality

        n ViaSbieStepOne
        followImplication
))
</jh>

== Via builders ==

=== Base case ===
<jh>
thm (ViaBuilderStepOne () () (subst (0) n (((0) + n) = ((0) + (0)))) (
        (0) EqualityReflexivity
        (0) n introduceSubst

        (0) n SubstitutionEquality

        buildSubstitutedAddition
))

thm (ViaBuilderStepTwo () () (subst (0) n ((((0) + n) = n) ↔ (((0) + (0)) = (0)))) (
        n ViaBuilderStepOne
        (0) n SubstitutionEquality
        buildSubstitutedEquality
))

thm (BaseCaseViaBuilder () () (subst (0) n (((0) + n) = n)) (
        n ViaBuilderStepTwo
        (0) AdditiveIdentity
        reverseModusPonensInsideSubst
))

# Not sure what this is telling us, but it sure looks strange:
thm (Paradox1 () () (subst (succ n) n (n = (succ n))) (
        (succ n) n SubstitutionEquality
))

# This approach seems like a dead end (in that I don't see any way to handle the induction step)

#thm (Sample () () (((0) + n) = n) (
#))

</jh>

== Induction5 ==
Here we provide a new induction theorem, <code>Induction5</code>.  It has five hypotheses, which despite the large number turns out to be easier to handle than expressing base cases and induction steps via <code>subst</code>. The first three hypotheses handle the substitution machinery.  The last two express the base case and induction step, and because the substitution has already been taken care of, tend to contain more mathematically interesting content and less substitution machinery.

<jh>
var (formula φ0 φk φSk)

# thm (buildSubst1 ((x ψ))
#  ((HEQ ((x = y) → (φ ↔ ψ))) )
#  ((subst y x φ) ↔ ψ) (
#        .... to be provided
# ))

thm (Induction5 ((φ0 n) (φk n) (φSk n) (φ k))
  ((HSUB0 ((n = (0)) → (φ ↔ φ0)))
   (HSUBK ((n = k) → (φ ↔ φk)))
   (HSUBSK ((n = (succ k)) → (φ ↔ φSk)))
   (HBASE φ0)
   (HIND (φk → φSk))
  )
  (∀ n φ) (
</jh>
The main difference between this and <code>Induction</code> is that the latter uses <code>subst</code> and we use implicit substitutions. The theorem linking the two is <code>substEquality</code>. We first show the base case, <code>(subst (0) n φ)</code>.
<jh>
        HBASE
        HSUB0 substEquality eliminateBiconditionalForward
        applyModusPonens
</jh>
The induction step is similar.
<jh>
        HSUBK substEquality eliminateBiconditionalReverse
        HIND
        applySyllogism
        HSUBSK substEquality eliminateBiconditionalForward
        applySyllogism
        k generalize
</jh>
Now we combine the two and apply <code>Induction</code>.
<jh>
        introduceConjunction
        n φ k Induction
        applyModusPonens
))
</jh>

=== Convenience theorems/rules (first-order logic) ===
<jh>
thm (specialize () ((H (∀ x φ))) φ (
        H
        x φ Specialization
        applyModusPonens
))

thm (swapEquality () ((H (x = y))) (y = x) (
        H
        x y EqualitySymmetry eliminateBiconditionalReverse
        applyModusPonens
))

thm (buildEqualityRR () ((H (x0 = x1))) ((x0 = y) ↔ (x1 = y)) (
        H
        y EqualityReflexivity
        introduceConjunction

        x0 x1 y y EqualityBuilder

        applyModusPonens
))
</jh>

=== Convenience builders (arithmetic) ===
<jh>
thm (AdditionBuilderLL () () ((m0 = m1) → ((n + m0) = (n + m1))) (
        n EqualityReflexivity
        (n = n) (m0 = m1) ConjunctionRightIntroduction
        applyModusPonens

        n n m0 m1 AdditionBuilder
        applySyllogism
))

thm (buildAddition () ((HN (n0 = n1)) (HM (m0 = m1))) ((n0 + m0) = (n1 + m1)) (
        HN
        HM
        introduceConjunction
        n0 n1 m0 m1 AdditionBuilder
        applyModusPonens
))
</jh>

=== Sample via Induction5 ===
<jh>
thm (Sample ((n k)) () (((0) + n) = n) (
</jh>
The substitution for the base case is <code>n = 0 → (0 + n = n ↔ 0 + 0 = 0)</code>.
<jh>
        n (0) (0) AdditionBuilderLL
        (n = (0)) ImplicationReflexivity
        composeConjunction
        ((0) + n) ((0) + (0)) n (0) EqualityBuilder
        applySyllogism
</jh>
The substitution for the induction step antecedent is <code>n = k → (0 + n = n ↔ 0 + k = k)</code>.
<jh>
        n k (0) AdditionBuilderLL
        (n = k) ImplicationReflexivity
        composeConjunction
        ((0) + n) ((0) + k) n k EqualityBuilder
        applySyllogism
</jh>
The substitution for the induction step consequent is similar.
<jh>
        n (succ k) (0) AdditionBuilderLL
        (n = (succ k)) ImplicationReflexivity
        composeConjunction
        ((0) + n) ((0) + (succ k)) n (succ k) EqualityBuilder
        applySyllogism
</jh>
The base case, <code>0 + 0 = 0</code>, follows from the AdditiveIdentity axiom.
<jh>
        (0) AdditiveIdentity
</jh>
The induction step, <code>0 + k = k → 0 + Sk = Sk</code>, follows from the Addition axiom.
<jh>
        ((0) + k) k Successor eliminateBiconditionalForward

        (0) k Addition swapEquality
        (succ k) buildEqualityRR eliminateBiconditionalReverse

        applySyllogism

        Induction5
</jh>
Now, we remove the ∀n which Induction5 provides.
<jh>
        specialize
))
</jh>