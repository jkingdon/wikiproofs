[[Interface:Classical propositional calculus]], [[Interface:First-order logic]], [[Interface:Peano axioms]], [[User interface:Kingdon/Sandbox]], [[Interface:Basic arithmetic]].

<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic (CLASSICAL) ())
#import (PEANO Interface:Peano_axioms (CLASSICAL FIRSTORDER) ())
#import (SANDBOX User_interface:Kingdon/Sandbox (CLASSICAL FIRSTORDER PEANO) ())
import (ARITHMETIC Interface:Basic_arithmetic (CLASSICAL FIRSTORDER) ())

var (formula p q φ ψ)
var (variable x y x0 y0 x1 y1 k n)
var (object s t u)

var (nat a b c)

#thm (Paradox1 () () (subst (succ (value x)) x ((value x) = (succ (value x)))) (
#        (succ (value x)) x SubstitutionEquality
#))
</jh>

=== Convert from implicit substitution ===
:''not sure how close this is, but stash it here until I have time to work on it more''

A statement of the form <code>x = s → (φ ↔ ψ)</code>, where <code>x</code> is not free in <code>ψ</code>, can be thought of as an ''implicit substitution'', as it can be used to relate a formula about <code>x</code> to a formula about <code>s</code>. It also provides one of the ways to construct a statement using <code>subst</code>.

<jh>
thm (lemma1 ()
  ((HEQ (((value x) = s) → (φ ↔ ψ))))
  (((((value y) = s) ∧ ((value x) = (value y))) ∧ φ) → ψ) (
        ((value y) = s) ((value x) = (value y)) ConjunctionCommutativity eliminateBiconditionalReverse
        (value x) (value y) s EqualityTransitivity
        applySyllogism

        HEQ
        φ ψ BiconditionalReverseElimination
        applySyllogism

        applySyllogism

        import
))

thm (sbie2-forward ((y x) (y s)) 
  ((HFREE (x is-not-free-in ψ))
   (HEQ (((value x) = s) → (φ ↔ ψ)))
  )
  ((subst s x φ) → ψ) (
</jh>
We start with the hypothesis <code>x = s → (φ ↔ ψ)</code>, and turn that into <code>(y = s ∧ x = y ∧ φ) → ψ)</code>:
<jh>
        HEQ y lemma1
</jh>
Now we add <code>∃x</code> to the front and move it past the <code>y = s</code>
<jh>
        ((value y) = s) ((value x) = (value y)) φ ConjunctionAssociativity 
        eliminateBiconditionalForward
        applySyllogism
        x introduceThereExists
        
))
</jh>

=== Convert from implicit substitution ===
:''Mistaken attempt #2: this one has a distinct variable constraint on x and s, to get the quantifier on x past y = s (sigh)''
A statement of the form <code>x = s → (φ ↔ ψ)</code>, where <code>x</code> is not free in <code>ψ</code>, can be thought of as an ''implicit substitution'', as it can be used to relate a formula about <code>x</code> to a formula about <code>s</code>.

<jh>
thm (convertImplicitToSubst2 () 
  ((HFREE (x is-not-free-in ψ))
   (HEQ (((value x) = s) → (φ ↔ ψ)))
  )
  ((subst2 s x φ) ↔ ψ) (
</jh>
The proof will basically consist of two applications of <code>ImplicitSubstitutionThereExists</code>.

First we rewrite <code>x = s → (φ ↔ ψ)</code> as <code>y = s → (x = y → (φ ↔ ψ))</code>
<jh>
        ((value y) = s) ((value x) = (value y)) ConjunctionCommutativity eliminateBiconditionalReverse
        (value x) (value y) s EqualityTransitivity
        applySyllogism

        HEQ
        applySyllogism

        export
</jh>
Now we add ∀x to the consequent:
<jh>
        x generalize
        x ((value y) = s) DistinctNotFree
        moveAntecedentOutOfForAll
</jh>
The first application of <code>ImplicitSubstitutionThereExists</code> turns <code>∀x(x = y → (φ ↔ ψ))</code> into <code>(∃x x = y ∧ φ) ↔ ψ</code>:
<jh>
        y ψ DistinctNotFree
        ImplicitSubstitutionThereExists
))

thm (makeSubst2Explicit ((x ψ))
  ((H (((value x) = s) → (φ ↔ ψ))))
  ((subst s x φ) ↔ ψ) (
        x ψ DistinctNotFree
        H
        convertImplicitToSubst2
))
</jh>

== Inequality ==
We define an order on natural numbers:

<jh>
def ((≤ a b) (∃ n ((a + (value n)) = b)))
</jh>

<jh>
#thm (ZeroSmallest () () ((0) ≤ a) (
#        a AdditiveIdentityLeft
#))
</jh>

Here's roughly where this is going next:
 n = b → (0 + n = b ↔ 0 + b = b)
 (subst b n (0 + n = b)) ↔ 0 + b = b
The missing theorem from [[Interface:First-order logic]] is <code>(subst s x φ) → (∃ x φ)</code>

We'll show that it has the [[w:Total order|expected properties of an order]].

    If a ≤ b and b ≤ a then a = b (antisymmetry);
    If a ≤ b and b ≤ c then a ≤ c (transitivity);
    a ≤ b or b ≤ a (totality). 
(probably reflexivity too, although that is a consequence of totality)

</jh>