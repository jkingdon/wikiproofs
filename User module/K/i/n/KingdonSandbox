[[Interface:Classical propositional calculus]], [[Interface:First-order logic]], [[Interface:Peano axioms]], [[User interface:Kingdon/Sandbox]], [[Interface:Basic arithmetic]].

<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic (CLASSICAL) ())
#import (PEANO Interface:Peano_axioms (CLASSICAL FIRSTORDER) ())
#import (SANDBOX User_interface:Kingdon/Sandbox (CLASSICAL FIRSTORDER PEANO) ())
#import (ARITHMETIC Interface:Basic_arithmetic (CLASSICAL FIRSTORDER) ())

var (formula p q φ ψ)
var (variable x y x0 y0 x1 y1 k n)
var (object s t u)

var (nat a b c)

thm (warmup ((y φ)) () (φ → (∀ y φ)) (
        φ y Generalization
))

def ((constx) x)

# blows up with "Required distinct variable constraints are not a subset of actual distinct variable constraints":
#thm (badth () () (φ → (∀ (constx) φ)) (
#        φ (constx) Generalization
#))
</jh>

== what's up with the distinct variables in this? ==
We are now ready to prove <code>a ≤ b ∧ b ≤ c → a ≤ c</code>.
<jh>
thm (debug1 (
  (vab vbc) (vab a) (vab b) (vab c)
  (vbc a) (vbc b) (vbc c)
  ) () (((a ≤ b) ∧ (b ≤ c)) → (∃ vab (∃ vbc (((a + (value vab)) = b) ∧ ((b + (value vbc)) = c))))) (
        a b vab LessEqual
        b c vbc LessEqual
        buildConjunction
        eliminateBiconditionalReverse

        vab vbc ((a + (value vab)) = b) ((b + (value vbc)) = c) ThereExistsScattering
        eliminateBiconditionalForward
        applySyllogism
))

thm (LessEqualTransitivity (
  (vab vbc) (vab a) (vab b) (vab c)
  (vbc a) (vbc b) (vbc c)
  ) () 
  (((a ≤ b) ∧ (b ≤ c)) → (a ≤ c)) (
</jh>
We start by expanding <code>a ≤ b</code> and <code>b ≤ c</code> according to the definition and gathering the quantifiers at the start of the formula.
<jh>
        a b vab LessEqual
        b c vbc LessEqual
        buildConjunction
        eliminateBiconditionalReverse

        vab vbc ((a + (value vab)) = b) ((b + (value vbc)) = c) ThereExistsScattering
        eliminateBiconditionalForward
        applySyllogism
</jh>
That gives us <code>∃ ab ∃ bc a + ab = b ∧ b + bc = c</code>.

The <code>a + ab = b ∧ b + bc = c</code> part of this implies first <code>a + (ab + bc) = c</code>,
<jh>
        a (value vab) b (value vbc) c LessEqualTransitivity-1
</jh>
and then <code>a ≤ c</code>.
<jh>
        a ((value vab) + (value vbc)) c LessEqualObject
        applySyllogism
</jh>
Adding back the quantifiers gives us <code>a ≤ b ∧ b ≤ c → ∃ ab ∃ bc a ≤ c</code>.
<jh>
        vbc addThereExists
        vab addThereExists
        applySyllogism
</jh>
and then we can remove the quantifiers because the variables they quantify over are gone.
<jh>
        vab (∃ vbc (a ≤ c)) NullThereExists eliminateBiconditionalReverse
        applySyllogism

        vbc (a ≤ c) NullThereExists eliminateBiconditionalReverse
        applySyllogism
))
</jh>