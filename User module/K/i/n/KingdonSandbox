This page is to help me figure out how induction might work (in terms of the substitution).
[[Interface:Classical propositional calculus]], [[Interface:First-order logic]], [[Interface:Peano axioms]].

<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic (CLASSICAL) ())
import (PEANO Interface:Peano_axioms (CLASSICAL FIRSTORDER) ())
import (SANDBOX User_interface:Kingdon/Sandbox (CLASSICAL FIRSTORDER PEANO) ())

var (formula p q φ ψ)
var (nat k n m n0 n1 m0 m1)
</jh>

== Some first order logic theorems ==
These, or something like them, probably should be in [[Interface:First-order logic]], once we have a clearer grasp on what will be most helpful.
<jh>
var (object x y x0 y0 x1 y1)
thm (distributeSubstImplication () ((H (subst y x (φ → ψ)))) ((subst y x φ) → (subst y x ψ)) (
        H
        y x φ ψ SubstImplication eliminateBiconditionalReverse
        applyModusPonens
))

thm (distributeSubstBiconditional () ((H (subst y x (φ ↔ ψ)))) ((subst y x φ) ↔ (subst y x ψ)) (
        H
        y x φ ψ SubstBiconditional eliminateBiconditionalReverse
        applyModusPonens
))

thm (introduceSubstConjunction () ((HPHI (subst y x φ)) (HPSI (subst y x ψ))) (subst y x (φ ∧ ψ)) (
        HPHI
        HPSI
        introduceConjunction

        y x φ ψ SubstConjunction eliminateBiconditionalForward
        applyModusPonens
))

thm (buildSubstitutedEquality () 
  ((HX (subst y x (x0 = x1))) (HY (subst y x (y0 = y1))))
  (subst y x ((x0 = y0) ↔ (x1 = y1))) (
        HX HY introduceSubstConjunction

        x0 x1 y0 y1 EqualityBuilder
        y x introduceSubst
        distributeSubstImplication

        applyModusPonens
))

thm (followImplication () ((H1 (subst y x φ)) (H2 (φ → ψ))) (subst y x ψ) (
        H1

        H2
        y x introduceSubst
        distributeSubstImplication

        applyModusPonens
))

thm (reverseModusPonensInsideSubst ()
  ((HEQ (subst y x (φ ↔ ψ)))
   (H2 ψ)
  )
  (subst y x φ) (
        H2
        y x introduceSubst

        HEQ
        y x φ ψ SubstBiconditional eliminateBiconditionalReverse
        applyModusPonens

        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

=== Arithmetic-specific ===
<jh>
thm (buildSubstitutedAddition ()
  ((HN (subst y x (n0 = n1)))
   (HM (subst y x (m0 = m1))))
  (subst y x ((n0 + m0) = (n1 + m1))) (
        HN
        HM
        introduceSubstConjunction

        n0 n1 m0 m1 AdditionBuilder
        y x introduceSubst
        distributeSubstImplication

        applyModusPonens
))
</jh>

== Via sbie ==
This builds up implicit substitution and converts it to subst at the end.

<jh>
thm (ViaSbieStepOne () () ((n = (0)) → (((0) + n) = ((0) + (0)))) (
        (0) EqualityReflexivity
        ((0) = (0)) (n = (0)) ConjunctionRightIntroduction
        applyModusPonens

        (0) (0) n (0) AdditionBuilder

        applySyllogism
))

thm (ViaSbieStepTwo () () ((n = (0)) → ((((0) + n) = n) ↔ (((0) + (0)) = (0)))) (
        n ViaSbieStepOne
        (n = (0)) ImplicationReflexivity
        composeConjunction

        ((0) + n) ((0) + (0)) n (0) EqualityBuilder
        applySyllogism
))

thm (BaseCaseViaSbie () () (subst (0) n (((0) + n) = n)) (
        (0) AdditiveIdentity
        n (((0) + (0)) = (0)) DistinctNotFree
        n ViaSbieStepTwo
        buildSubstFromEquality
))
</jh>

=== via follow implication ===
Slight variant of the previous.

<jh>
thm (ViaFollowImplicationStepOne () () (subst (0) n (((0) + n) = ((0) + (0)))) (
        (0) n SubstitutionEquality

        n ViaSbieStepOne
        followImplication
))
</jh>

== Via builders ==

=== Base case ===
<jh>
thm (ViaBuilderStepOne () () (subst (0) n (((0) + n) = ((0) + (0)))) (
        (0) EqualityReflexivity
        (0) n introduceSubst

        (0) n SubstitutionEquality

        buildSubstitutedAddition
))

thm (ViaBuilderStepTwo () () (subst (0) n ((((0) + n) = n) ↔ (((0) + (0)) = (0)))) (
        n ViaBuilderStepOne
        (0) n SubstitutionEquality
        buildSubstitutedEquality
))

thm (BaseCaseViaBuilder () () (subst (0) n (((0) + n) = n)) (
        n ViaBuilderStepTwo
        (0) AdditiveIdentity
        reverseModusPonensInsideSubst
))

# Not sure what this is telling us, but it sure looks strange:
thm (Paradox1 () () (subst (succ n) n (n = (succ n))) (
        (succ n) n SubstitutionEquality
))

# This approach seems like a dead end (in that I don't see any way to handle the induction step)

#thm (Sample () () (((0) + n) = n) (
#))

</jh>

== Finds ==
Here we provide a new induction theorem, <code>Induction5</code>.  It has five hypotheses, which despite the large number turns out to be easier to handle than expressing base cases and induction steps via <code>subst</code>. The first three hypotheses handle the substitution machinery.  The last two express the base case and induction step, and because the substitution has already been taken care of, tend to contain more mathematically interesting content and less substitution machinery.

 var (formula φ0 φk φSk)

 thm (buildSubst1 ((x ψ))
  ((HEQ ((x = y) → (φ ↔ ψ))) )
  ((subst y x φ) ↔ ψ) (
        .... to be provided
 ))
 
 thm (Induction5 ()
  ((HSUB0 ((n = (0)) → (φ ↔ φ0)))
   (HSUBK ((n = k) → (φ ↔ φk)))
   (HSUBSK ((n = (succ k)) → (φ ↔ φSk)))
   (HBASE φ0)
   (HIND (φk → φSk))
  )
  (∀ n φ) (
        .... proof is fairly straightforward, from buildSubst1        
 ))