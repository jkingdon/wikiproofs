This page is to help me figure out how induction might work (in terms of the substitution).

<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic (CLASSICAL) ())
import (PEANO Interface:Peano_axioms (CLASSICAL FIRSTORDER) ())
import (SANDBOX User_interface:Kingdon/Sandbox (CLASSICAL FIRSTORDER PEANO) ())

var (formula p q φ ψ)
var (object x y)
var (nat n m)

thm (buildSubstFromEquality ()
  ((HPSI ψ) (HFREE (x is-not-free-in ψ)) (HEQ ((x = y) → (φ ↔ ψ))) )
  (subst y x φ) (
        HPSI

        HFREE HEQ sbie
        eliminateBiconditionalForward

        applyModusPonens
))

thm (ViaSbieStepOne () () ((n = (0)) → (((0) + n) = ((0) + (0)))) (
        (0) EqualityReflexivity
        ((0) = (0)) (n = (0)) ConjunctionRightIntroduction
        applyModusPonens

        (0) (0) n (0) AdditionBuilder

        applySyllogism
))

thm (ViaSbieStepTwo () () ((n = (0)) → ((((0) + n) = n) ↔ (((0) + (0)) = (0)))) (
        n ViaSbieStepOne
        (n = (0)) ImplicationReflexivity
        composeConjunction

        ((0) + n) ((0) + (0)) n (0) EqualityBuilder
        applySyllogism
))

thm (BaseCaseViaSbie () () (subst (0) n (((0) + n) = n)) (
        (0) AdditiveIdentity
        n (((0) + (0)) = (0)) DistinctNotFree
        n ViaSbieStepTwo
        buildSubstFromEquality
))

thm (ViaFollowImplicationStepOne () () (subst (0) n (((0) + n) = ((0) + (0)))) (
        (0) n SubstitutionEquality

        n ViaSbieStepOne
        followImplication
))

thm (ViaBuilderStepOne () () (subst (0) n (((0) + n) = ((0) + (0)))) (
        (0) EqualityReflexivity
        (0) n sbt

        (0) n SubstitutionEquality

        buildSubstitutedAddition
))

#thm (ViaBuilderStepTwo () () (subst (0) n ((((0) + n) = n) ↔ (((0) + (0)) = (0)))) (
#))

#thm (Sample () () (((0) + n) = n) (
#))

</jh>