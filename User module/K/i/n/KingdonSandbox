[[Interface:Classical propositional calculus]], [[Interface:First-order logic with quantifiability]], [[Interface:Peano axioms]], [[User interface:Kingdon/Sandbox]], [[Interface:Basic arithmetic]]. [[Interface:Tarski's geometry axioms]], [[User interface:Kingdon/Logic]], [[Interface:Set theory]].

<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (QUANTIFY_OVER_SETS Interface:First-order_logic_with_quantifiability (CLASSICAL) set.)
#import (QUANTIFY_OVER_NUMBERS Interface:First-order_logic_with_quantifiability (CLASSICAL) number.)
import (SETS Interface:Set_theory (CLASSICAL QUANTIFY_OVER_SETS) set.)

import (QUANTIFY_OVER_NUMBERS User_interface:Kingdon/Logic (CLASSICAL QUANTIFY_OVER_SETS SETS) ())
#import (TARSKI Interface:Tarski's_geometry_axioms (CLASSICAL FIRSTORDER) ())
#import (PEANO Interface:Peano_axioms (CLASSICAL FIRSTORDER) ())
#import (ARITHMETIC Interface:Basic_arithmetic (CLASSICAL FIRSTORDER) ())
#import (BASIC Interface:Basic_operations_of_general_set_theory (CLASSICAL FIRSTORDER) ())
#import (ZF Interface:Zermelo–Fraenkel_set_theory (CLASSICAL FIRSTORDER) ())

var (formula p q φ ψ)
#var (variable x y x0 y0 x1 y1 z k n)
#var (object s t u)
#var (variable result x′)
#var (object A B C D)

var (set.variable a)
var (set.object A)
var (variable x)
var (object X Y Z)

def ((0) (asNumber (set.∅)))
def ((1) (asNumber (set.singleton (set.∅))))
def ((< X Y) ((asSet X) set.∈ (asSet Y)))

thm (SetEmptyIsElement () () ((set.∅) set.∈ (set.singleton (set.∅))) (
        (set.∅) set.SingletonMembership
))

thm (SetEmptyIsElementWithSubst () ()
  (set.subst (set.singleton (set.∅)) a ((set.∅) set.∈ (set.value a))) (
        SetEmptyIsElement

</jh>
The substitution is <code>a = { ∅ } → (∅ ∈ a ↔ ∅ ∈ { ∅ })</code>.
<jh>
        (set.value a) (set.singleton (set.∅)) (set.∅) set.IsElementBuilderLL
        set.makeSubstExplicit

        eliminateBiconditionalForward
        applyModusPonens
))

thm (SetNotOne () () (set.∃ a ((set.∅) set.∈ (set.value a))) (
        a SetEmptyIsElementWithSubst
        set.introduceThereExistsFromObject
))

#thm (NotOne () () (∃ x ((0) < (value x))) (
#))

export (RESULT User_interface:Kingdon/Sandbox (CLASSICAL QUANTIFY_OVER_NUMBERS) ())
</jh>