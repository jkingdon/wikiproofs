Items which may be doable without a network connection:

* implicit variant of sb8e
* definitions versus dummies (LessThan), once sb8e done

* more intuitionistic logic
  - DisjunctionSummation*, other ConjunctionMultiplication* - perhaps can prove these as I need them
  - DeMorganNDNReverse - maybe from double negation introduction and DeMorganPDPSwapped?
  - DeMorganNCNReverse - a similar trick might work
  - NegationBuilder follows easily from TranspositionIntroduction
  - DisjunctionLeftDistribution - both directions seem to be straightforward from composeConjunction or composeDisjunction, and the usual suspects
  - DisjunctionRightDistribution - from commutativity, I think, but we'd likely need to do builders first
  - ModusTollens - seems easy
  - biconditional (should mostly be copy-paste from Principia, I think)
* convenience theorems of propositional logic
  - any more in Basic Arithmetic?
* look at whether Raph's proof of ceqsex simplifies our development
  (I think it might enable omitting a bunch of strange little
  theorems).
* naming convention for implication builders
  a. addImplicationAntecedent (from addCommonAntecedent)
     ImplicationConsequentAddition (from CommonConsequentAddition)
     ImplicationConsequentBuilder (from ImplicationBuilderRR)
     ImplicationConsequentBuilderInConsequent
     buildImplicationAntecedent
     buildImplication
     buildImplicationConsequentInConsequent (from buildCommonConsequentInConsequent)

To do with network:

Maybe todo (without network):

Proof of sbf; seems like we are ready for this one.
Step	Hyp	Ref 	Expression
1	 	sb1 1239	. . . 4 ⊢ ([y / x]φ → ∃x(x = y ⋀ φ))
2	 	sbf.1	. . . . 5 ⊢ (φ → ∀xφ)
3	2	19.41 1157	. . . 4 ⊢ (∃x(x = y ⋀ φ) ↔ (∃x x = y ⋀ φ))
4	1, 3	sylib 204	. . 3 ⊢ ([y / x]φ → (∃x x = y ⋀ φ))
5	4	pm3.27d 333	. 2 ⊢ ([y / x]φ → φ)
6	 	stdpc4 1248	. . 3 ⊢ (∀xφ → [y / x]φ)
7	2, 6	syl 11	. 2 ⊢ (φ → [y / x]φ)
8	5, 7	impbii 163	1 ⊢ ([y / x]φ ↔ φ)

Ref 	Expression
sbco	⊢ ([y / x][x / y]φ ↔ [y / x]φ)
Proof of Theorem sbco Step	Hyp	Ref 	Expression
1	 	equsb2 1257	. . 3 ⊢ [y / x]y = x
2	 	sbequ12 1244	. . . . 5 ⊢ (y = x → (φ ↔ [x / y]φ))
3	2	bicomd 544	. . . 4 ⊢ (y = x → ([x / y]φ ↔ φ))
4	3	sbimi 1236	. . 3 ⊢ ([y / x]y = x → [y / x]([x / y]φ ↔ φ))
5	1, 4	ax-mp 7	. 2 ⊢ [y / x]([x / y]φ ↔ φ)
6	 	sbbi 1302	. 2 ⊢ ([y / x]([x / y]φ ↔ φ) ↔ ([y / x][x / y]φ ↔ [y / x]φ))
7	5, 6	mpbi 195	1 ⊢ ([y / x][x / y]φ ↔ [y / x]φ)

Draft of essay:

What is the difference between an unsound definition like constx (def ((constx) x) from [[User:GrafZahl/unsound-def.gh]]) and a sound one like ⊤ or ⊥ in [[Principia Mathematica propositional logic]], or ≤ in [[Basic arithmetic]]? It is that the sound ones do not depend on the choice of the dummy variable.  For example, for ⊥, p ∧ ¬ p is equivalent to q ∧ ¬ q.  This is not just a metalogical argument; it is a theorem we can prove within the system (and indeed the relevant proofs are Tautology and Contradiction in[[Principia Mathematica propositional logic]] and LessEqual in [[Basic arithmetic]]).  No such proof is forthcoming with constx.  In other words, noone can expect to get safe definitions (which include dummy variables) for free; the safety of a definition must be proved.

How does this help us design a definition mechanism?  The most straightforward way is relatively simple.  Every time a definition gets applied, dummy variables are expanded to fresh variables. In some very limited circumstances, these can be unified with named variables, but only if all instances of a particular named variable unify. The goal here is that the definition can be used (a) freely if it has no dummy variables, or (b) if it has dummy variables, mainly in order to prove a theorem similar to LessEqual. I'm not sure I can be completely precise about "all instances of a particular named variable unify", but it might be equivalent to saying that dummy variables (including a variable any one of them unifies with) are considered to have a disjoint variable constraint with everything else in the statement where the definition appears.

Examples: in [[User:GrafZahl/Definitions_in_JHilbert]], the folding of (bar a b b) to (foo a b) is not legitimate because the dummy variable c can fold only to a variable which appears nowhere else, and b appears elsewhere here. In unsound-def.gh, <not sure>.

