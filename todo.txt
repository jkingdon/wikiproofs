Items which may be doable without a network connection:

* convenience theorems of propositional logic
  - joinConsequents (do without, probably)
* look at whether Raph's proof of ceqsex simplifies our development
  (I think it might enable omitting a bunch of strange little
  theorems).
  - the proof does need Quantifiability but nothing else we don't have.
  - ceqsex is ImplicitThereExists.
    - ImplicitSubstitutionThereExists
      - ImplicitSubstitutionForAll
        - ax9oc (see also equs4c)
          - ax6o (see also NegationNotFree, ax9o)
        - a5i
  - ceqsex also has the distinct variable constraint x s.

  * ax9o is only used by equs4.

* General set theory
  - definitions and consequences: union?,
    intersection, difference (e.g. eldifi and similar), subset
  - do both directions of A = B â†” { A } = { B } hold? (think so)
  - indexed union or intersection? (if needed for functions)
  - prove Peano axioms from them
    - suc11
  - finite induction (e.g. peano5 in set.mm)
  - functions and relations (e.g. cxp and following in set.mm)
    - binary relations.
      - releq
      (mkrelation a A b B Ï†) (A, B object; a, b variable; Ï† formula)
        â‰ {ã€ˆa, bã€‰| a âˆˆ A âˆ§ b âˆˆ B âˆ§ Ï† }
        e.g. (mkrelation a â„• b â„• (âˆƒ n âˆˆ â„• a + n = b))
      - (relates s (mkrelation a A b B Ï†) t) â†” [s / a][t / b]Ï†  (probably some distinct)
    - domain and range: dfdm3 and dfrn2 or some such (need to prove existence)
      - dmeq
      - breldm, brelrn
      - (domain (mkrelation a A b B Ï†)) âŠ† A
      - (range (mkrelation a A b B Ï†)) âŠ† B
    - functions
      - dffun2 (how to deal with the distinct variables?), funrel
      (lambda x t)
        e.g. (lambda x A ã€ˆx, 1ã€‰)
        â‰ {ã€ˆx, resultã€‰| x âˆˆ A âˆ§ result = Ï† }
      - [s / x](apply (lambda x A t) s) = t
        this reads oddly, because [/] only applies to formulas, not terms
        (metamath has underlined [/] for terms; do we want that?)
    - cross products, e.g. cxp, df-xp, elxp, opelxp1, opelxp
      xpexg regarding existence of cross products
        relies on xpsspw
        Also note dependence on defn of ordered pair.
      A Ã— B â‰ {z âˆˆ ğ’«ğ’«(A âˆª B) | z = ã€ˆa, bã€‰ âˆ§ a âˆˆ A âˆ§ b âˆˆ B}
        then the interesting part is proving opelxp, elxp, or something else useful
        a âˆˆ A â†” {a} âŠ† A
        a0 âˆˆ A âˆ§ a1 âˆˆ A â†” {a0, a1} âŠ† A
        A âˆˆ B â†’ A âˆˆ B 
        perhaps something like z = ã€ˆa, bã€‰ âˆ§ a âˆˆ A âˆ§ b âˆˆ B â†’ z âˆˆ ğ’«ğ’«(A âˆª B) is one step
        (Ï† â†’ z âˆˆ A) â†’ (y âˆˆ {z âˆˆ A | Ï†} â†” [y / z]Ï†)  (could be helpful but has the subst)
          then next step is y âˆˆ A Ã— B â†” [y / z](z = ã€ˆa, bã€‰ âˆ§ a âˆˆ A âˆ§ b âˆˆ B)
          then y âˆˆ A Ã— B â†” y = ã€ˆa, bã€‰ âˆ§ a âˆˆ A âˆ§ b âˆˆ B
          and/or ã€ˆa, bã€‰ âˆˆ A Ã— B â†” a âˆˆ A âˆ§ b âˆˆ B
      - (relation A) â†” âˆƒ x âˆƒ y A âŠ† x Ã— y
    - note dmex depends on ax-pow and ax-un, but doesn't need replacement.
  - recursion theorem (see downloaded wikipedia page, Joedit)
    = frfnom and friends in set.mm
      - e.g. http://us.metamath.org/mpeuni/df-rdg.html

* Needed to derive geometry axioms from reals (page 201 of Givant1999)
  - cartesian products
  - subtraction
  - â‰¤ for reals (defined in terms of <)
  - (x - y) Â· (x - y) = (y - x) Â· (y - x) (needed to prove CongruenceReflexivityAxiom)
  - builders for +, Â·
  - For CongruenceIdentity
    â€¢ x - x = 0
    â€¢ x - y = 0 â†’ x = y
    â€¢ x âˆˆ â„ â†’ 0 â‰¤ x Â· x
    â€¢ 0 â‰¤ x âˆ§ 0 â‰¤ y âˆ§ x + y = 0 â†’ x = 0 (or some such)
  - For Indivisibility
    â€¢ (x - y) Â· (y - x) â‰¤ 0
    â€¢ antisymmetry
    â€¢ (x - y) Â· (y - x) = 0 â†’ x = y (follows from x Â· y = 0 â†’ x = 0 or y = 0)

* How much do we use ThereExistsConjunctionRightMovement? Is there room
  for a convenience theorem or is it something which often has another
  quantifier outside?

== Separation ==
[this is an attempt which writes Ï† as [ x / x ] Ï† but that, while arguably nicer,
doesn't solve the problem which makes the proof not work, which is that Ï† can contain
the variable. Maybe we need to be using *NotFree rather than distinct variables?]

Here we provide the ability to form a set containing those elements of a given set which satisfy an arbitrary formula. In other words, we can form the set of all <code>x</code> in <code>A</code> such that <code>Ï†</code>, which is commonly notated as <code>{x âˆˆ A | Ï† }</code>. We will use that notation in discussion but JHilbert's syntax is not that flexible, so for JHilbert we will call it <code>(separate x A Ï†)</code>. ''Restricted set abstraction'' is one term for this (contrasted with the ''unrestricted set abstraction'' of <code>{x | Ï†}</code>).<ref>Michael R. Genesereth and Richard E. Fikes (1994), "[http://logic.stanford.edu/kif/Hypertext/node25.html Paradoxes]", Knowledge Interchange Format Version 3.0 Reference Manual, also available as Stanford Logic Group Technical Report Logic-92-1.</ref>

Introducing this notation follows much the process as for the other existence theorems/axioms, in this case working from <code>SeparationThereExists</code>. We are trying to prove <code>y âˆˆ {x âˆˆ A | Ï† } â†” y âˆˆ A âˆ§ [y / x] Ï†</code>.

First we provide a version of <code>SeparationThereExists</code> where we turn the variable <code>z</code> into the object <code>A</code>
<jh>
thm (SeparationThereExistsObject ((x y A) (Ï† y A)  (z x y A) (z Ï†)) ()
  (âˆƒ y (âˆ€ x (((value x) âˆˆ (value y)) â†” (((value x) âˆˆ A) âˆ§ Ï†)))) (
        (value z) A (value x) IsElementBuilderLL
        Ï† buildConjunctionRRInConsequent
        ((value x) âˆˆ (value y)) buildBiconditionalLLInConsequent
        x buildForAllInConsequent
        y buildThereExistsInConsequent

        y x z Ï† SeparationThereExists

        VariableToObject
))
</jh>

What we'll actually need is a version of this in which <code>Ï†</code> is rewritten as <code>[ x / x ] Ï†</code>.
<jh>
thm (SeparationThereExistsSubst ((x y A) (Ï† y A)  (z x y A) (z Ï†)) ()
  (âˆƒ y (âˆ€ x (((value x) âˆˆ (value y)) â†” (((value x) âˆˆ A) âˆ§ (subst (value x) x Ï†))))) (
        y x A Ï† SeparationThereExistsObject

        x Ï† SubstItself
        ((value x) âˆˆ A) buildConjunctionLL
        ((value x) âˆˆ (value y)) buildBiconditionalLL
        x buildForAll
        y buildThereExists

        eliminateBiconditionalForward

        applyModusPonens
))
</jh>

From here we apply <code>SetObject</code> in much the usual way.
<jh>
thm (Separation-sub () () ((C = D) â†’ (((C âˆˆ A) âˆ§ (subst C x Ï†)) â†” ((D âˆˆ A) âˆ§ (subst D x Ï†)))) (
        C D A IsElementBuilderRR
        C D x Ï† SubstBuilderReplacement
        buildConjunctionInConsequent
))

thm (SeparationObject ((y C) (result y A z) (result y Ï† z) (result y x z)) ()
  ((C âˆˆ (abstract z (((value z) âˆˆ A) âˆ§ (subst (value z) x Ï†)))) â†” ((C âˆˆ A) âˆ§ (subst C x Ï†))) (
        (value z) (value y) A x Ï† Separation-sub
        (value y) C A x Ï† Separation-sub
        result y A x Ï† SeparationThereExistsSubst
        SetObject
))

def ((separate x A Ï†) (abstract y (((value y) âˆˆ A) âˆ§ (subst (value y) x Ï†))))

thm (Separation ((z A) (z B)) () ((C âˆˆ (separate x A Ï†)) â†” ((C âˆˆ A) âˆ§ (subst C x Ï†))) (
        C z A x Ï† SeparationObject
))
</jh>

To do with network:

* download:
  Collinearity
  Interface:Triangle congruence.wiki
  Triangle congruence.wiki

* See whether "I might have missed some" text is still present
  at Interface:Intuitionistic propositional logic and if not
  download new copy.
  Likewise, at Intuitionistic propositional logic there's still
    at least one reference to DeMorganPDPForward

* rename BetweenBuilder to BetweennessBuilder
    BetweenABB to BetweennessABB
    BetweenAAB to BetweennessAAB
  rename eliminateRightConjunctionInConsequent to eliminateRightConjunctInConsequent (I think, and maybe likewise for whatever is in Classical propositional calculus).

* try to find out more about School Mathematics Study Group geometry postulates? Like Euclid's?

* notation for congruent angles. Convention is âˆ ABC â‰… âˆ DEF, right?  Then maybe (A B C âˆ â‰… D E F) for us?

* rename IndivisibilityBidirectional to IndivisibilityBiconditional, I think. Or rename the unidirectional one to IndivisibilityImplication.

* - chapter 5: cite Narboux paper (not just coq) for the two lemmas
  - when we get to Connectivity for betweenness, cite section 5.2 of
  Narboux paper.

* Look up 
  Quaife, A.: Automated development of Tarskiâ€™s geometry. Journal of Automated Reasoning 5(1), 97â€“118 (1989)

* constructive geometry?
  - von Plato, J.: The axioms of constructive geometry. Annals of Pure and Applied Logic 76, 169â€“200 (1995)
  - Kahn, G.: Constructive geometry according to Jan von Plato. Coq contribution, Coq V5.10 (1995)
  - presumably depends on constructive first-order logic

