==Experimental pages==
*[[Interface:Sandbox]]
*[[Sandbox]]
*[[User interface:Kingdon/Sandbox]]
*[[User module:Kingdon/Sandbox]]

== First order logic todos ==

[[First-order logic]], [[Interface:First-order logic]]

=== sb8e ===
We need sb8e for LessThan.  Here's what it depends on in metamath:
* [http://us.metamath.org/mpeuni/sb8e.html sb8e]
:* [http://us.metamath.org/mpeuni/sbn.html sbn]
::* sb4 and others (probably can't use metamath as-is, given our differing definition of subst)
:* [http://us.metamath.org/mpeuni/sb8.html sb8]
::* [http://us.metamath.org/mpeuni/stdpc4.html stdpc4] (see peano_thms a4sbc which is for object not variable)
:::* [http://us.metamath.org/mpeuni/sb2.html sb2]. Compare this with convertImplicitToSubst
::* [http://us.metamath.org/mpeuni/hbsb3.html hbsb3]
::* [http://us.metamath.org/mpeuni/sbid2.html sbid2] - in metamath proved via [http://us.metamath.org/mpeuni/sbco.html sbco] and [http://us.metamath.org/mpeuni/sbf.html sbf]; could also perhaps be proved via [http://us.metamath.org/mpeuni/sbco2.html sbco2] if that could be proved independently of sbid2. See sbcco in peano_thms.

=== Worth proving? ===

* Not sure whether these are the most salient subst theorems (perhaps better to see what we end up needing), but some interesting-looking ones are:
:*[http://us.metamath.org/mpeuni/stdpc4.html stdpc4]
:*[http://us.metamath.org/mpeuni/sbequ.html sbequ]
:*[http://us.metamath.org/mpeuni/sbcom2.html sbcom2]
:*[http://us.metamath.org/mpeuni/sbid2v.html sbid2v]
:*[http://us.metamath.org/mpeuni/sbf.html sbf]
:*[http://us.metamath.org/mpeuni/hbs1f.html hbs1f]
:*[http://us.metamath.org/mpeuni/hbsb2a.html hbsb2a]
:*[http://us.metamath.org/mpeuni/sbco2.html sbco2]

intro for sb56:
--- Two ways to express substitution when variables are distinct ---
In the previous two sections, we have seen that <code>∃x(x = s ∧ φ)</code> and <code>∀x(x = s → φ)</code> behave similarly.  In fact, as long as <code>x</code> and <code>s</code> are distinct, they are completely equivalent.


=== Object version of the VariableSubstitution axiom ===
The <code>VariableSubstitution</code> axiom is a way to, in some sense, substitute one variable for another. The corresponding result which substitutes an object for a variable also holds.

First, a propositional logic rule, rotate3Antecedents, similar to applyComm:
<jh>
thm (Comm () () ((φ → (ψ → χ)) → (ψ → (φ → χ))) (
        φ ψ χ Transportation eliminateBiconditionalReverse

        ψ φ ConjunctionCommutativity eliminateBiconditionalReverse
        χ addCommonConsequent
        applySyllogism

        ψ φ χ Transportation eliminateBiconditionalForward
        applySyllogism
))

thm (rotate3Antecedents () ((H (φ → (ψ → (χ → θ))))) (ψ → (χ → (φ → θ))) (
        H
        applyComm

</jh>
That gives us <code>ψ → (φ → (χ → θ))</code>. We need one more invocation of Comm to be done.
<jh>
        φ χ θ Comm
        ψ addCommonAntecedent
        applyModusPonens
))
</jh>

<jh>
thm (ObjectSubstitution ((x s) (x y)) () 
  (((value x) = s) → (φ → (∀ x (((value x) = s) → φ)))) (
</jh>
The general idea of the proof is to "substitute" <code>s</code> for <code>y</code> using a formula of the form <code>y = s → (''a formula with s in it'' ↔ ''much the same formula, but with y'')</code>.

More specifically, we start by building that formula, <code>y = s → ((x = s → (φ → ∀ x (x = s → φ))) ↔ (x = y → (φ → ∀ x (x = y → φ))))
<jh>
        φ BiconditionalReflexivity

        (value y) s EqualitySymmetry eliminateBiconditionalReverse

        (value y) s (value x) EqualityBuilderLL

        φ BiconditionalReflexivity
        ImplicationFunction
        applyBiconditionalTransitivity

        x buildForAll

        buildImplication




</jh>
Everything below here is probably a dead end, but retained for the moment just in case.
<jh>
        x y VariableSubstitution
        ((value y) = s) introduceAntecedent
        rotate3Antecedents
        ((value y) = s) introduceAntecedent
</jh>
We now have <code>y = s → (x = y → (φ → (y = s → ∀ x (x = y → φ))))</code>.

Looking at the <code>y = s → ∀ x (x = y → φ)</code> portion, we move the <code>y = s</code> inside the quantifier:
<jh>
        x ((value y) = s) DistinctNotFree
        (∀ x (((value x) = (value y)) → φ)) ForAllImplicationAntecedentMovement eliminateBiconditionalForward
</jh>
Now we massage <code>y = s → (x = y → φ)</code> into <code>x = s → φ</code>.
<jh>
        ((value y) = s) ((value x) = (value y)) φ Transportation eliminateBiconditionalReverse
        ((value y) = s) ((value x) = (value y)) ConjunctionCommutativity eliminateBiconditionalReverse
        applySyllogism

        (value x) (value y) s EqualityTransitivity
))
</jh>

=== More moving formulas where quantified variable is not free ===
*These two similar: [http://us.metamath.org/mpeuni/19.28.html 19.28] [http://us.metamath.org/mpeuni/19.45.html 19.45]

* Follow up on Foo -> FooNotFree rename per [[Interface talk:First-order logic]].

=== Others? ===
[http://us.metamath.org/mpeuni/19.29.html 19.29]
[http://us.metamath.org/mpeuni/19.2.html 19.2]

In general, stretch from 19.12 (currently at [http://us.metamath.org/mpeuni/mmtheorems11.html]) to qexmid (next page), but I don't know what is important and what isn't.

[http://us.metamath.org/mpeuni/eeanv.html eeanv]

== Peano arithmetic ==
=== Theorems ===
Sample theorems from Hirst &amp; Hirst:
 4. Strict inequality is transitive: x < y → (y < z → x < z)
 5. Inequality is preserved by addition: x ≤ y → x + z ≤ y + z
 6. Strict inequality is preserved by addition: x < y → x + z < y + z
 7. Inequality is preserved by multiplication: x ≤ y → x · z ≤ y · z
 8. Strict inequality is preserved by nonzero multiplication:
    z ≠ 0 → (x < y → x · z < y · z)
 9. Inequalities can be added: (w ≤ x ∧ y ≤ z) → w + y ≤ x + z
 10. Inequalities can be multiplied: (w ≤ x ∧ y ≤ z) → w · y ≤ x · z

No zero divisors: a · b = 0 → (a = 0 ∨ b = 0)

Some definitions:

* x < y ↔ x ≤ y ∧ x ≠ y
* x > y ↔ y < x
* x ≥ y ↔ y ≤ x

More theorems:

* x ≠ 0 ↔ x > 0

We'll show that it has the [[w:Total order|expected properties of an order]].
* If a ≤ b and b ≤ a then a = b (antisymmetry);
* If a ≤ b and b ≤ c then a ≤ c (transitivity);
* a ≤ b or b ≤ a (totality). 
* (probably reflexivity too, although that is a consequence of totality)

Probably can base some of these on [http://code.google.com/p/ghilbert/source/browse/trunk/peano/peano_thms.gh peano_thms.gh]

=== Basic arithmetic ===
[[Interface:Basic arithmetic]] does not currently have anything which needs to be proved with the ZeroNotSuccessor axiom (in fact, I'm pretty sure that modular arithmetic can model it). We should have one or more such. There is no largest number (e.g. <code>¬ ∃N ∀a a < N</code>)? Something about lack of cycles (can't keep adding one and get back where you started)? The total order properties would seem to suffice, and are more natural (the above are not aesthetically appealing, as they just restate ZeroNotSuccessor and are not, on the face of it, useful in algebra and the like).

== More axiomizations of propositional logic ==
Reducing the Principia axioms from 5 to 4 (unless I missed something, the change is to omit Assoc and change Add from <code>q → (p ∨ q)</code> to <code>q → (q ∨ p)</code>).  This is the axiomization used by [http://qedeq.org/0_03_11/doc/math/qedeq_logic_v1_en.pdf Elements of Mathematical Logic], Michael Meyling, August 2, 2008.

Stanley Burris (1997), [http://www.math.uwaterloo.ca/~snburris/htdocs/scav/hilbert/hilbert.html Hilbert and Ackermann's 1928 Logic Book], describing work by [[w:Paul Bernays|Bernays]] in 1926 and adopted by, for example, D. Hilbert and W. Ackermann, Grundzüge der theoretischen Logik. Springer-Verlag, 1928.