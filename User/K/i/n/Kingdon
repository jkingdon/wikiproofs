==Experimental pages==
*[[Interface:Sandbox]]
*[[Sandbox]]
*[[User interface:Kingdon/Sandbox]]
*[[User module:Kingdon/Sandbox]]

== First order logic todos ==

[[First-order logic]], [[Interface:First-order logic]]

* Not sure whether these are the most salient subst theorems, but some interesting-looking ones are:
:*[http://us.metamath.org/mpeuni/stdpc4.html stdpc4]
:*[http://us.metamath.org/mpeuni/sbequ.html sbequ]
:*[http://us.metamath.org/mpeuni/sbcom2.html sbcom2]
:*[http://us.metamath.org/mpeuni/sbid2v.html sbid2v]
:*[http://us.metamath.org/mpeuni/sbf.html sbf]
:*[http://us.metamath.org/mpeuni/hbs1f.html hbs1f]
:*[http://us.metamath.org/mpeuni/hbsb2a.html hbsb2a]
:*[http://us.metamath.org/mpeuni/sbco2.html sbco2]

intro for sb56:
--- Two ways to express substitution when variables are distinct ---
In the previous two sections, we have seen that <code>∃x(x = s ∧ φ)</code> and <code>∀x(x = s → φ)</code> behave similarly.  In fact, as long as <code>x</code> and <code>s</code> are distinct, they are completely equivalent.


=== Object version of the VariableSubstitution axiom ===
The <code>VariableSubstitution</code> axiom is a way to, in some sense, substitute one variable for another. The corresponding result which substitutes an object for a variable also holds.

First, a propositional logic rule, rotate3Antecedents, similar to applyComm:
<jh>
thm (Comm () () ((φ → (ψ → χ)) → (ψ → (φ → χ))) (
        φ ψ χ Transportation eliminateBiconditionalReverse

        ψ φ ConjunctionCommutativity eliminateBiconditionalReverse
        χ addCommonConsequent
        applySyllogism

        ψ φ χ Transportation eliminateBiconditionalForward
        applySyllogism
))

thm (rotate3Antecedents () ((H (φ → (ψ → (χ → θ))))) (ψ → (χ → (φ → θ))) (
        H
        applyComm

</jh>
That gives us <code>ψ → (φ → (χ → θ))</code>. We need one more invocation of Comm to be done.
<jh>
        φ χ θ Comm
        ψ addCommonAntecedent
        applyModusPonens
))
</jh>

<jh>
thm (ObjectSubstitution ((x s) (x y)) () 
  (((value x) = s) → (φ → (∀ x (((value x) = s) → φ)))) (
</jh>
The general idea of the proof is to "substitute" <code>s</code> for <code>y</code> using a formula of the form <code>y = s → (''a formula with s in it'' ↔ ''much the same formula, but with y'')</code>.

More specifically, we start by building that formula, <code>y = s → ((x = s → (φ → ∀ x (x = s → φ))) ↔ (x = y → (φ → ∀ x (x = y → φ))))
<jh>
        φ BiconditionalReflexivity

        (value y) s EqualitySymmetry eliminateBiconditionalReverse

        (value y) s (value x) EqualityBuilderLL

        φ BiconditionalReflexivity
        ImplicationFunction
        applyBiconditionalTransitivity

        x buildForAll

        buildImplication




</jh>
Everything below here is probably a dead end, but retained for the moment just in case.
<jh>
        x y VariableSubstitution
        ((value y) = s) introduceAntecedent
        rotate3Antecedents
        ((value y) = s) introduceAntecedent
</jh>
We now have <code>y = s → (x = y → (φ → (y = s → ∀ x (x = y → φ))))</code>.

Looking at the <code>y = s → ∀ x (x = y → φ)</code> portion, we move the <code>y = s</code> inside the quantifier:
<jh>
        x ((value y) = s) DistinctNotFree
        (∀ x (((value x) = (value y)) → φ)) ForAllImplicationAntecedentMovement eliminateBiconditionalForward
</jh>
Now we massage <code>y = s → (x = y → φ)</code> into <code>x = s → φ</code>.
<jh>
        ((value y) = s) ((value x) = (value y)) φ Transportation eliminateBiconditionalReverse
        ((value y) = s) ((value x) = (value y)) ConjunctionCommutativity eliminateBiconditionalReverse
        applySyllogism

        (value x) (value y) s EqualityTransitivity
))
</jh>

=== More moving formulas where quantified variable is not free ===
*This one on wikipedia list of identities: [http://us.metamath.org/mpeuni/19.42.html 19.42]
*These two similar: [http://us.metamath.org/mpeuni/19.28.html 19.28] [http://us.metamath.org/mpeuni/19.45.html 19.45]

=== Others? ===
[http://us.metamath.org/mpeuni/19.29.html 19.29]
[http://us.metamath.org/mpeuni/19.2.html 19.2]

In general, stretch from 19.12 (currently at [http://us.metamath.org/mpeuni/mmtheorems11.html]) to qexmid (next page), but I don't know what is important and what isn't.

[http://us.metamath.org/mpeuni/eeanv.html eeanv]

== Peano arithmetic ==
=== Theorems ===
Sample theorems from Hirst & Hirst:
 3. Multiplication is distributive over addition: x · (y + z) = x · y + x · z
 4. Strict inequality is transitive: x < y → (y < z → x < z)
 5. Inequality is preserved by addition: x ≤ y → x + z ≤ y + z
 6. Strict inequality is preserved by addition: x < y → x + z < y + z
 7. Inequality is preserved by multiplication: x ≤ y → x · z ≤ y · z
 8. Strict inequality is preserved by nonzero multiplication:
    z ≠ 0 → (x < y → x · z < y · z)
 9. Inequalities can be added: (w ≤ x ∧ y ≤ z) → w + y ≤ x + z
 10. Inequalities can be multiplied: (w ≤ x ∧ y ≤ z) → w · y ≤ x · z

Some definitions:

* x < y ↔ x ≤ y ∧ x ≠ y
* x > y ↔ y < x
* x ≥ y ↔ y ≤ x

More theorems:

* x ≠ 0 ↔ x > 0

We'll show that it has the [[w:Total order|expected properties of an order]].
* If a ≤ b and b ≤ a then a = b (antisymmetry);
* If a ≤ b and b ≤ c then a ≤ c (transitivity);
* a ≤ b or b ≤ a (totality). 
* (probably reflexivity too, although that is a consequence of totality)

== More axiomizations of propositional logic ==
Reducing the Principia axioms from 5 to 4 (unless I missed something, the change is to omit Assoc and change Add from <code>q → (p ∨ q)</code> to <code>q → (q ∨ p)</code>).  This is the axiomization used by [http://qedeq.org/0_03_11/doc/math/qedeq_logic_v1_en.pdf Elements of Mathematical Logic], Michael Meyling, August 2, 2008.

Stanley Burris (1997), [http://www.math.uwaterloo.ca/~snburris/htdocs/scav/hilbert/hilbert.html Hilbert and Ackermann's 1928 Logic Book], describing work by [[w:Paul Bernays|Bernays]] in 1926 and adopted by, for example, D. Hilbert and W. Ackermann, Grundzüge der theoretischen Logik. Springer-Verlag, 1928.

== BiconditionalSymmetry cleanup ==
BiconditionalSymmetry should probably be *4.21 (biconditionalized) rather than the implication it is now.  At least, that's how we're doing DisjunctionCommutativity, ConjunctionCommutativity, and EqualitySymmetry, ForAllCommutation, ThereExistsCommutation, and probably most other theorems in which the implication immediately implies the biconditional and so either one is plausible.