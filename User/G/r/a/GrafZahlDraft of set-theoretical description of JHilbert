{{header
 | title    = Set-theoretical description of JHilbert
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = In this draft, I will try to express the core concepts of JHilbert in informal, set-theoretical language, hopefully in less convoluted form than in the [[User:GrafZahl/Botched attempt to prove JHilbert definition soundness|previous botched attempt]]. I shall also include the [[User:GrafZahl/Definitions in JHilbert|proposed degradation]] of definitions to mere abbreviations (with no dummy variables) as well as the [[User:CarlWitty/Definitions proposal|new definitions scheme]] proposed by [[User:CarlWitty]]. However, I will not include a description of the modularity features of JHilbert (import, export, param, and kindbind) at this point.--[[User:GrafZahl|GrafZahl]]&nbsp;([[User talk:GrafZahl|talk]]) 18:59, 18 February 2010 (UTC)
}}

:''[[Image:Zeichen 123.svg|50px|none]] Work in progress''

== Introduction ==

JHilbert is a Java application based on Ghilbert, which in turn is based on metamath. It allows the collaborative formal verification of proofs. JHilbert has a command line mode, and a server mode (which drives this wiki), making it an application of already medium complexity. Being what it is, however, the small kernel of core concepts, the logic that drives the proof machinery, is of crucial importance. It is only these core concepts, notably without the collaboration features (modularisation) and I/O system, which shall be formally described in this essay in informal, set-theoretical language. (By "formally" I mean that I use actual mathematics for the description, by "informal" I mean that I don't intend to verify the description with a proof verifier, interesting a project as it would be.)

There has been an earlier attempt to describe these core concepts and prove their soundness. Aside from containing some errors, it was at times unnecessarily complicated. I shall attempt to do away with such cruft this time.

== Acknowledgements ==

There are lots of people to acknowledge, most notably Normal Megill for creating metamath, Raph Levien for creating Ghilbert and for discussing the definition mechanism with me, Mel L. o'Cat for discussions during the time JHilbert was made, Carl Witty for the new definition mechanism, and Kingdon for prolonged interest in JHilbert. Bug me if I forgot someone.

== Notation ==

As the title suggests, we shall use [[w:set theory|set theory]] to describe JHilbert concepts. You should have elementary familiarity with set theory before reading this document. The notation used by us is explained in the following table.

{| border="1"
! Notation !! Explanation
|-
| <math>\emptyset</math> || The [[w:empty set|empty set]]
|-
| <math>\mathbb{N}</math> || The set of positive [[w:integer|integer]]s <math>\{1,2,3,\ldots\}</math>
|-
| <math>\mathbb{N}_0</math> || The set of non-negative integers <math>\{0,1,2,3,\ldots\}</math>
|-
| <math>()</math> || The empty [[w:sequence|sequence]]
|-
| <math>(a)</math> || The sequence containing only the element <math>a</math>.
|-
| <math>(a,b)</math> || [[w:Ordered pair|ordered pair]] of elements <math>a</math> and <math>b</math>
|-
| <math>(a,b,c)</math> || Ordered [[w:triple|triple]] or 3-[[w:tuple|tuple]] of elements <math>a</math>, <math>b</math> and <math>c</math>
|-
| <math>(a,b,c,d)</math> || You get the idea
|-
| <math>|s|</math> || The length of the sequence <math>s</math>. For example, if <math>s=(a_1,\ldots,a_n)</math> then <math>|s|=n</math>. In particular, <math>|()|=0</math>.
|-
| <math>a\in A</math> || <math>a</math> is an element of the set <math>A</math>
|-
| <math>A\cup B</math> || The [[w:union (set theory)|union]] of the sets <math>A</math> and <math>B</math>
|-
| <math>A\cap B</math> || The [[w:intersection (set theory)|intersection]] of the sets <math>A</math> and <math>B</math>
|}

== Formal systems ==

The four basic concepts of JHilbert are ''kinds'', ''variables'', ''functors'' and ''statements''. When JHilbert reads source code, it keeps track of these in the form of a ''formal system'' <math>\mathfrak{F}</math>, whose set-theoretical representation will be given here by <math>\mathcal{F}=(KIND,VAR,FUNC,STAT)</math>. Here, the sets <math>KIND</math>, <math>VAR</math>, <math>FUNC</math>, and <math>STAT</math> stand for the currently defined kinds, variables, functors, and statements, respectively. Each time the user defines a new one of these objects, the respective set is increased by one new member in the set-theoretical representation. In the following sections, we shall define the set-theoretical nature of the objects that go into these sets. Initially, all four sets start out empty, that is <math>\mathcal{F}=(\emptyset,\emptyset,\emptyset,\emptyset)</math>.

== Objects and names ==

In the following sections, we shall define the set-theoretical objects that may go into the sets <math>KIND</math>, <math>VAR</math>, <math>FUNC</math>, and <math>STAT</math> as certain [[w:tuple|tuple]]s. The first element of such a tuple will always be a ''name''. This document does not elaborate on the precise nature a name might have. In a JHilbert implementation they would be [[w:Unicode|Unicode]] identifiers. We merely remark that we assume all of our objects to have mutually distinct names. Hence, names serve as sure distinctors where two objects are structurally identical but must be different nevertheless. A typical example would be two different variables of the same kind.

== Kinds ==

Kinds, the elements of <math>KIND</math>, are just names. They are assigned additional data by the fact that we assume the set <math>KIND</math> to be a disjoint union <math>KIND=SKIND\cup VKIND</math> ("disjoint union" means <math>SKIND\cap VKIND=\emptyset</math>), where <math>SKIND</math> is the set of ''substitutable kinds'', while <math>VKIND</math> is the set of ''pure variable kinds''. The difference between those two kinds of kinds will become apparent in the sections on functors and expressions.

In JHilbert, the <code>kindbind</code> command allows to define equivalence classes among kinds. As this is a feature of the modularity system, we shall omit its set-theoretical representation here and merely remark that a substitutable kind and a pure variable kind can never be equivalent.

== Variables ==

Variables, the elements of <math>VAR</math> are defined as tuples <math>(N,K)</math> where <math>N</math> is a name and <math>K\in KIND</math>.

== Functors ==

Functors are the elements of <math>FUNC</math>. Together with the variables, they will be used to build complex expressions in the next section. Functors are abstractly characterised by the following properties:
* A ''result kind'' <math>R\in SKIND</math>. Note that <math>R\in VKIND</math> is not allowed.
* A ''place count'' <math>n\in\mathbb{N}_0</math>. It describes the number of "parameters" a functor takes.
* <math>n</math> ''input kinds'' <math>K_1,\ldots,K_n\in KIND</math>. Note that here, both substitutable and pure variable kinds are permissible. If <math>n=0</math>, the functor has no input kinds at all and is ''constant''.
The set <math>FUNC</math> decomposes into three disjoint subsets <math>FUNC=TERM\cup ABBREV\cup DEF</math>, the elements of each of which will have a different set-theoretical representation, but all elements will have the above abstract properties. In this section, we will only explain the set-theoretical representation of the elements of <math>TERM</math>, leaving <math>ABBREV</math> and <math>DEF</math> for the sections on abbreviations and definitions, respectively.

The elements of <math>TERM</math> are called the ''term functors''. They are triples <math>(N,R,K)</math> where <math>N</math> is a name, <math>R\in SKIND</math> is the result kind and <math>K=(K_1,\ldots,K_n)</math> is a finite, possibly empty, sequence of kinds, that is <math>K_i\in KIND</math>, <math>i=1,\ldots,n</math>. The place count is then given by <math>n=|K|</math>, the length of the sequence <math>K</math>.

== Expressions ==

== Abbreviations ==

== Disjoint variable constraints ==

== Statements ==

== Definitions ==

== Proofs ==

== Translation to metamath ==