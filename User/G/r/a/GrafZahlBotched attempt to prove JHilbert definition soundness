{{header
 | title    = Definition soundness of first-order logic in JHilbert
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = A translation of JHilbert concepts into [[w:Metamath|Metamath]] in order to prove the soundness of definitions.

:''Having put lots of time and mental energy into it, I don't think that coming up with specific cases that might break definitions is really the right way to go about designing a definitional mechanism. A better idea is to formulate the argument clearly why it is sound; then the details and handling of edge cases should follow fairly cleanly from that argument.''
—[[w:Raph Levien|Raph Levien]] in an e-mail.

I had postponed a formal description of JHilbert (and thus a soundness proof) and had taken on a more pragmatic approach instead in order to get things going in the first place. Certain bugs in JHilbert and Raph's e-mail changed my view somewhat, for which I am grateful. Note that the following description contains some concepts which have not yet been implemented in the current version 8 of JHilbert, notably DV constraints on definitions and extended expressions.--[[User:GrafZahl|GrafZahl]]&nbsp;([[User talk:GrafZahl|talk]])
}}

== JHilbert ==

=== Names ===

'''Definition.''' <math>\Sigma</math> is a [[w:finite set|finite]], [[w:empty set|non-empty]] [[w:set (mathematics)|set]], the ''characters''.

'''Definition.''' <math>N:=\Sigma^*\setminus\{\epsilon\}</math>, that is, the set of all non-empty, finite [[w:sequence|sequence]]s of characters is the set of ''names''.

'''Lemma 1.''' The set of names <math>N</math> is [[w:countably infinite|countably infinite]].

{{sc|Proof.}} <math>N</math> is infinite because <math>\Sigma\neq\emptyset</math>, and countable because <math>\Sigma</math> is finite.

=== Kinds ===

'''Definition.''' The ''kinds'' are a [[w:tuple|tuple]] <math>(K,\sim)</math> where <math>K\subseteq N</math> is finite and <math>\sim</math> is an [[w:equivalence relation|equivalence relation]] on <math>K</math>. We denote the set <math>K/\sim</math> of all [[w:equivalence class|equivalence class]]es by <math>\mathcal{K}</math>.

Where no confusion is possible, we shall not distinguish between kinds and equivalence classes of kinds.

'''Explanation.''' <math>K</math> and <math>\sim</math> are user-defined in JHilbert through the <code>kind</code> and <code>kindbind</code> commands. The <code>kind</code> command adds a new name to <math>K</math> which initially is equivalent only to itself. The <code>kindbind</code> command adds a relation between two kinds in <math>K</math> to <math>\sim</math> (possibly after adding a new name to <math>K</math>) and completes <math>\sim</math> by [[w:reflexive closure|reflexive]], [[w:symmetric closure|symmetric]] and [[w:transitive closure|transitive]] [[w:closure (mathematics)|closure]].

=== Variables ===

'''Definition.''' A tuple <math>(n,k)</math> with <math>n\in N</math> and <math>k\in\mathcal{K}</math> is a ''variable''. For each variable <math>v=(n,k)</math> we denote the [[w:projection (set theory)|projection]] <math>(n,k)\mapsto n</math>, the ''name of <math>v</math>'', by <math>N(v)</math>, and the projection <math>(n,k)\mapsto k</math>, the ''kind of <math>v</math>'', by <math>K(v)</math>.

'''Definition.''' A finite set <math>V</math> is called a ''permissible set of variables'' if all elements of <math>V</math> are variables, and the [[w:restriction (mathematics)|restriction]] of the name projection <math>N</math> to <math>V</math> is [[w:injective|injective]].

'''Lemma 2.''' Let <math>V</math> be a permissible set of variables. Then any <math>W\subseteq V</math> is also a permissible set of variables.

{{sc|Proof.}} <math>W</math> is finite since <math>V</math> is finite. <math>W</math> contains only variables since <math>W</math> is contained in <math>V</math>. Finally, the restriction of an injective function remains injective.

'''Theorem 1.''' Let <math>V</math> be a permissible set of variables. Then for any <math>k\in\mathcal{K}</math> there is a <math>n\in N</math> such that <math>(n,k)\notin V</math> and <math>V':=V\cup\{(n,k)\}</math> is a permissible set of variables.

{{sc|Proof.}} Since <math>V</math> is finite, the image <math>N(V)</math> is finite as well. Now, <math>N</math> is infinite by Lemma 1. Therefore, there exists an <math>n\in N\setminus N(V)</math>. Since <math>n\notin (\left.N\right|_V)^{-1}(N)</math>, <math>(n,k)\notin V</math>. <math>V'</math> is finite because <math>V</math> and the singleton <math>\{(n,k)\}</math> are finite, and <math>(n,k)</math> is clearly a variable. Again, since <math>n\notin (\left.N\right|_V)^{-1}(N)</math>, <math>N((n,k))\neq N(v)</math> for all <math>v\in V</math>. Therefore, the name projection is injective on <math>V'</math>.

'''Definition.''' The ''variables'' are a permissible set of variables <math>V</math>. It is [[w:partition of a set|partitioned]] into three subsets, the ''named variables'' <math>V_N</math>, the ''unnamed variables'' <math>V_U</math> and the ''dummy variables'' <math>V_D</math>. By Lemma 2, these subsets are also permissible sets of variables.

'''Explanation.''' The named variables <math>V_N</math> are user-defined in JHilbert through the <code>var</code> command. Unnamed variables and dummy variables are automatically introduced as explained later. Since the empty set is a permissible set of variables, Theorem 1 ensures that such automatic introduction of new variables is always possible. In fact, JHilbert cheats a little by extending <math>\Sigma</math> for this purpose, so the namespace for user-defined variables doesn't become polluted.

=== DV constraints ===

'''Definition.''' Let <math>A</math> be a set and <math>R\subseteq A\times A</math>. Then <math>R</math> is called ''self-avoiding'' if <math>(x,x)\notin R</math> for all <math>x\in A</math>.

'''Definition.''' Let <math>R\subseteq A\times A</math>. Then the set <math>R\setminus\{(x,x):x\in A\}</math> is called the ''self-avoiding aperture'' of <math>R</math>.

'''Lemma 3.''' Let <math>R\subseteq A\times A</math>. Furthermore, let <math>R_1</math> be the symmetric closure of the self-avoiding aperture of <math>R</math> and <math>R_2</math> the self-avoiding aperture of the symmetric closure of <math>R</math>. Then <math>R_1=R_2</math>.

{{sc|Proof.}} Let <math>(x,y)\in R_1</math>. Then <math>(x,y)\in R\setminus\{(x,x):x\in A\}</math> or <math>(y,x)\in R\setminus\{(x,x):x\in A\}</math>. In particular <math>x\neq y</math> and <math>(x,y)\in R</math> or <math>(y,x)\in R</math>. Therefore <math>(x,y)</math> is an element of the symmetric closure of <math>R</math>. Since <math>x\neq y</math>, <math>(x,y)\in R_2</math>. If, on the other hand, <math>(x,y)\in R_2</math>, then <math>x\neq y</math> and <math>(x,y)\in R</math> or <math>(y,x)\in R</math>. Therefore <math>(x,y)\in R_1</math>

'''Definition.''' A symmetric, self-avoiding relation on <math>V</math> is called a ''DV constraint''.

'''Definition.''' Let <math>\Delta</math> be a DV constraint. Then we define the set <math>A(\Delta):=\{v\in V:\exists w\in V:(v,w)\in\Delta\}</math>. If <math>A(\Delta)\subseteq V_N</math>, then <math>\Delta</math> is called a ''named DV constraint'', and if <math>A(\Delta)\subseteq V_U</math>, then <math>\Delta</math> is called an ''unnamed DV constraint''.

'''Lemma 4.''' The union of two DV constraints is again a DV constraint. The same holds for named and unnamed DV constraints, respectively.

{{sc|Proof.}} This follows since the union of two self-avoiding relations is self-avoiding, and likewise the union of two symmetric relations is again symmetric.

=== Functors ===

'''Definition.''' A tuple <math>(n,k,l)</math> with <math>n\in N</math>, <math>k\in\mathcal{K}</math> and <math>l\in\mathcal{K}^*</math> is a ''functor''. For each functor <math>f=(n,k,l)</math>, we denote the projection <math>(n,k,l)\mapsto n</math>, the ''name of <math>f</math>'', by <math>N(f)</math>, and the projection <math>(n,k,l)\mapsto k</math>, the ''kind of <math>f</math>'', by <math>K(f)</math>. Furthermore, we denote the function <math>(n,k,l)\mapsto|l|</math>, where <math>|l|</math> is the length of the sequence <math>l</math>, the ''place count of <math>f</math>'', by <math>PC(f)</math>. For each <math>i=1,\ldots,PC(f)</math>, we denote by <math>IK_i(f)</math> the mapping of <math>(n,k,l)</math> to the <math>i</math>-th projection of <math>l</math>. We call <math>IK_i(f)</math> the ''<math>i</math>-th input kind of <math>f</math>.''

'''Definition.''' A finite set <math>F</math> is called a ''permissible set of functors'' if all elements of <math>F</math> are functors and the restriction of the name projection <math>N</math> to <math>F</math> is injective.

'''Lemma 5.''' Let <math>F</math> be a permissible set of functors. Then any <math>G\subseteq F</math> is also a permissible set of functors.

{{sc|Proof.}} The proof is similar to the proof of Lemma 2.

'''Definition.''' The ''functors'' are a permissible set of functors <math>F</math>.

=== Term functors ===

'''Definition.''' The ''term functors'' are a set <math>F_T\subseteq F</math>. By Lemma 5, term functors are a permissible set of functors.

'''Explanation.''' Term functors are user-defined in JHilbert through the <code>term</code> command. However, they are not the only functors as definitions (see below) give rise to further functors.

=== Expressions ===

'''Definition.''' We define when some element <math>e</math> is an ''expression'', and what the ''kind of <math>e</math>'', <math>K(e)</math>, is, [[w:recursive definition|recursively]] as follows:
# If <math>e\in V</math> then <math>e</math> is an expression. (In this case, <math>K(e)</math> is defined by the definition of the kind of a variable.)
# If <math>e=(f,s)</math> where <math>f\in F</math> and <math>s</math> is a finite sequence of expressions such that <math>PC(f)=|s|</math> and for <math>i=1,\ldots,|s|</math> the <math>i</math>-th element of <math>s</math>, <math>s_i</math>, fulfils the equation <math>IK_i(f)=K(s_i)</math>, then <math>e</math> is an expression.
# Nothing else is an expression.
# If <math>e=(f,s)</math> is an expression, then <math>K(e)=K(f)</math>.
We denote the set of all expressions by <math>E(V,F)</math>.

'''Lemma 6.''' The set <math>E(V,F)</math> is either finite or countably infinite.

{{sc|Proof.}} By using [[w:polish notation|polish notation]] we may consider <math>E(V,F)</math> a subset of <math>(V\cup F)^*</math>. Since both <math>V</math> and <math>F</math> are finite, that set is finite or countably infinite. Hence <math>E(V,F)</math> is finite or countably infinite.

'''Definition.''' Let <math>e\in E(V,F)</math>. Then we define the ''length of <math>e</math>'', <math>|e|</math> recursively as follows:
# If <math>e\in V</math> then <math>|e|=1</math>.
# If <math>e=(f,s)</math> then <math>|e|</math> is the sum of the lengths of the expressions in <math>s</math>, plus one.

'''Lemma 7.''' Let <math>e\in E(V,F)</math>. Then <math>|e|=1</math> if and only if either <math>e\in V</math> or <math>e=(f,s)</math> with <math>PC(f)=0</math> and hence <math>s=\epsilon</math>.

{{sc|Proof.}} If <math>e\in V</math> or <math>e=(f,s)</math> with the stated properties then clearly <math>|e|=1</math>. Now assume <math>e=(f,s)</math> with <math>PC(f)\neq 0</math>. But then surely <math>|e|>1</math> since all expressions in <math>s</math> have length at least one.

'''Definition.''' Let <math>e_1,e_2\in E(V,F)</math>. Then we define when <math>e_2</math> is a ''subexpression'' of <math>e_1</math> recursively as follows.
# If <math>e_1\in V</math> then <math>e_2</math> is a subexpression of <math>e_1</math> if and only if <math>e_1=e_2</math>.
# If <math>e_1=(f,s)</math> then <math>e_2</math> is a subexpression of <math>e_1</math> if and only if either <math>e_1=e_2</math> or <math>e_2</math> is a subexpression of one of the expressions in <math>s</math>.

'''Lemma 8.''' Let <math>e_1\in E(V,F)</math> and let <math>e_2</math> be a subexpression of <math>e_1</math>. Then <math>|e_2|\leq|e_1|</math> and equality holds if and only if <math>e_1=e_2</math>.

{{sc|Proof.}} This follows from the strict [[w:monotonicity|monotonicity]] of the addition of [[w:positive integer|positive integer]]s.

'''Definition.''' Let <math>e\in E(V,F)</math> and <math>f\in F</math>. We define when <math>f</math> is ''apparent'' in <math>e</math> recursively as follows:
# If <math>e=(f',\epsilon)</math> then <math>f</math> is apparent in <math>e</math> if and only if <math>f=f'</math>.
# If <math>e=(f',s)</math> then <math>f</math> is apparent in <math>e</math> if and only if either <math>f=f'</math> or <math>f</math> is apparent in at least one of the expressions in <math>s</math>.
# In no other case is <math>f</math> apparent in <math>e</math>.

'''Definition.''' Let <math>e\in E(V,F)</math> and <math>v\in V</math>. We define when <math>v</math> is ''apparent'' in <math>e</math> recursively as follows:
# If <math>e\in V</math> then <math>v</math> is apparent in <math>e</math> if and only if <math>e=v</math>.
# If <math>e=(f,s)</math> then <math>v</math> is apparent in <math>e</math> if and only if it is apparent in at least one of the expressions in <math>s</math>.
We denote the set of apparent variables of <math>e</math> by <math>A(e)</math>.

'''Definition.''' Let <math>W\subseteq V</math> and <math>u\colon W\to E(V,F)</math> a map such that all <math>w\in W</math> fulfil the equation <math>K(w)=K(u(w))</math>. Then <math>u</math> is called a ''proper substitution map''. We also define the ''extension'' <math>\tilde{u}</math> of <math>u</math> on <math>E(V,F)</math> recursively by
# <math>\tilde{u}(w)=u(w)</math> for all <math>w\in W</math>,
# <math>\tilde{u}(v)=v</math> for all <math>v\in V\setminus W</math>,
# <math>\tilde{u}((f,(e_1,\ldots,e_n)))=(f,(\tilde{u}(e_1),\ldots,\tilde{u}(e_2)))</math> for all <math>(f,(e_1,\ldots,e_n))\in E(V,F)\setminus V</math>.

'''Lemma 9.''' Let <math>u\colon W\to E(V,F)</math> be a proper substitution map. Then the image of the extension <math>\tilde{u}(E(V,F))\subseteq E(V,F)</math> and for all <math>e\in E(V,F)</math> the equation <math>K(e)=K(\tilde{u}(e))</math> holds.

{{sc|Proof.}} Let <math>e\in E(V,F)</math>. We have to show that <math>\tilde{u}(e)\in E(V,F)</math> and <math>K(e)=K(\tilde{u}(e))</math>. We prove this by induction over <math>|e|</math>. First, assume <math>|e|=1</math>. Then either <math>e=(f,\epsilon)</math> in which case <math>\tilde{u}(e)=e</math>, or <math>e\in V</math>. If <math>e\in V\setminus W</math> then again <math>\tilde{u}(e)=e</math>. If <math>e\in W</math> then <math>\tilde{u}(e)=u(e)\in E(V,F)</math> and <math>K(\tilde{u}(e))=K(u(e))=K(e)</math> by the definition of a proper substitution map. This proves the statement for <math>|e|=1</math>. Now assume the statement proven for all expressions of length smaller than <math>|e|>1</math>. Then <math>e=(f,(e_1,\ldots,e_n))</math>. By the induction hypothesis, <math>(\tilde{u}(e_1),\ldots,\tilde{u}(e_n))</math> is a sequence of expressions. Its length is equal to the length of <math>(e_1,\ldots,e_n)</math>. The induction hypothesis also implies that for <math>i=1,\ldots,n</math> we have <math>IK_i(f)=K(e_i)=K(\tilde{u}(e_i))</math>. Therefore <math>\tilde{u}(e)\in E(V,F)</math>. Since <math>K(\tilde{u}(e))=K(f)</math> and <math>K(e)=K(f)</math>, the statement is proven.

'''Lemma 10.''' Let <math>u\colon W\to E(V,F)</math> be a proper substitution map and <math>W'\subseteq W</math>. Then the restriction <math>\left.u\right|_{W'}</math> is also a proper substitution map and <math>\tilde{u}(e)=(\left.u\right|_{W'})^\sim(e)</math> for all <math>e\in E(V,K)</math> with <math>A(e)\subseteq W'</math>.

{{sc|Proof.}} That <math>\left.u\right|_{W'}</math> is also a proper substitution map is clear from the definition. Now let <math>e\in E(V,F)</math> such that <math>A(e)\subseteq W'</math>. We prove the remainder of the statement by induction over <math>|e|</math>. First, assume <math>|e|=1</math>. Then either <math>e=(f,\epsilon)</math> in which case the statement is clear, or <math>e\in V</math>, in which case it follows by <math>e\in W'</math>. Now, for the case <math>|e|>1</math> we have <math>e=(f,(e_1,\ldots,e_n))</math> and since clearly <math>A(e_i)\subseteq A(e)</math> for <math>i=1,\ldots,n</math>, the statement follows in this case also from the induction hypothesis.

'''Definition.''' Let <math>e_1,e_2\in E(V,F)</math>. Then <math>e_2</math> ''arises from <math>e_1</math> by proper substitution'' if there is a proper substitution map <math>u\colon A(e_1)\to E(V,F)</math> such that <math>\tilde{u}(e_1)=e_2</math>.

'''Lemma 11.''' Let <math>e_1=(f_1,(e_{11},\ldots,e_{1n}))</math> and <math>e_2=(f_2,(e_{21},\ldots,e_{2m}))</math> be expressions. Assume furthermore that <math>e_2</math> arises from <math>e_1</math> by proper substitution. Then <math>f_1=f_2</math>, <math>n=m</math> and if <math>u\colon A(e_1)\to E(V,F)</math> is a proper substitution map such that <math>\tilde{u}(e_1)=e_2</math> then <math>(\left. u\right|_{A(e_{1i})})^\sim(e_{1i})=e_{2i}</math> for all <math>i=1,\ldots,n</math>.

{{sc|Proof.}} That <math>f_1=f_2</math> and <math>n=m</math> is clear. The remainder of the statement follows from the definition of a proper substitution map and Lemma 11.

'''Lemma 12.''' Let <math>e_1,e_2\in E(V,F)</math> be such that <math>e_2</math> arises from <math>e_1</math> by proper substitution. Then the proper substitution map <math>u\colon A(e_1)\to E(V,F)</math> such that <math>\tilde{u}(e_1)=e_2</math> is [[w:unique|unique]].

{{sc|Proof.}} Assume there are two such maps <math>u_1,u_2\colon A(e_1)\to E(V,F)</math> which are different. Then there is a <math>v\in A(e_1)</math> such that <math>u_1(v)\neq u_2(v)</math>. We proceed with an induction over <math>|e_1|</math>. If <math>|e_1|=1</math>, then either <math>e_1=(f,\epsilon)</math> in which case <math>A(e_1)=\emptyset</math>, so <math>u_1,u_2</math> cannot be distinct, or <math>e_1\in V</math>. In this case, <math>e_1=v</math> since <math>v</math> is apparent in <math>e_1</math>. But then <math>u_1(e_1)\neq u_2(e_1)</math>, which is [[w:reductio ad absurdum|absurd]]. Now assume the statement proven for all expressions of length smaller than <math>|e_1|>1</math>. Then <math>e_1=(f,(e_{11},\ldots,e_{1n}))</math>, so there must be a positive integer <math>1\leq i\leq n</math> such that <math>\tilde{u}_1(e_{1i})\neq\tilde{u}_2(e_{1i})</math> since <math>v</math> must be apparent in one of the <math>e_{1i}</math>. But this contradicts the induction hypothesis in combination with Lemma 11.

'''Definition.''' Let <math>(f,s)</math> be an expression. Then <math>f</math> is called the ''head functor'' of <math>(f,s)</math>.

=== Definitions ===

'''Definition.''' We define the ''definition functors'' as <math>F_D:=F\setminus F_T</math>.

'''Definition.''' Let <math>l\in V^*</math>. Write <math>l=(v_1,\ldots,v_n)</math>. Then we set <math>K(l):=(K(v_1),\ldots,K(v_n))\in\mathcal{K}^*</math>.

'''Definition.''' Let <math>d=(n,\Delta,l,e)</math> with <math>n\in N</math>, <math>\Delta</math> a DV constraint, <math>l\in V_U^*</math> and <math>e\in E(V,K)</math> with <math>A(\Delta)\subseteq A(e)</math> such that <math>F(d):=(n,K(e),K(l))\in F_D</math>. Assume furthermore that for all <math>v\in A(e)</math> either <math>v</math> occurs in <math>l</math> or <math>v\in V_D</math>. Then <math>d</math> is called a ''definition-like tuple''.

'''Definition.''' Let <math>D</math> be a set of definition-like tuples such that <math>F\colon D\to F_D</math> is [[w:bijective|bijective]]. Assume furthermore that there exists a function <math>\beta</math>, the ''depth'', defined on <math>F</math> and <math>E(V,F)</math>, with values in <math>\mathbb{Z}_{\geq 0}</math> such that all of the following properties hold:
# <math>\beta(f)=0</math> for all <math>f\in F_T</math>.
# <math>\beta(v)=0</math> for all <math>v\in V</math>.
# For all <math>(f,s)\in E(V,F)\setminus V</math>, <math>\beta((f,s))=\beta(f)</math>.
# For all <math>f\in F_D</math> the definition-like tuple <math>F^{-1}(f)=(n,\Delta,l,e)</math> fulfils the property that <math>\beta(f)>\beta(e')</math> for all subexpressions <math>e'</math> of <math>e</math>. Specifically, <math>\beta(f)=\beta(e)+1</math>.
# For each <math>v\in V_D</math> there is exactly one <math>f\in F_D</math> such that for the definition-like tuple <math>F^{-1}(f)=(n,l,e)</math> the property <math>v\in A(e)</math> holds.
Then <math>D</math> is called a ''valid set of definitions'' for <math>F_D</math>.

'''Explanation.''' The definitions of JHilbert, user-defined via the <code>def</code> command fulfil the above properties of a valid set of definitions. When new <code>def</code> commands are evaluated, <math>F_D</math>, <math>V_U</math> and <math>V_D</math> are grown accordingly. Theorem 1 ensures that this is always possible. There are, of course, many valid sets of definitions. From now on, we shall assume <math>D</math> to be one arbitrary such set.

'''Lemma 13.''' The set <math>D</math> is finite.

{{sc|Proof.}} Since <math>F</math> is finite, so is <math>F_D</math>. The finiteness of <math>D</math> now follows from the bijectivity of <math>F\colon D\to F_D</math>.

'''Lemma 14.''' If <math>f\in F_D</math> then <math>\beta(f)>0</math>.

{{sc|Proof.}} This follows from the definition of <math>\beta</math>.

'''Definition.''' Let <math>e\in E(V,F)</math>. Then we define the ''maximum depth'' of <math>e</math> as <math>\hat{\beta}(e):=\max\beta(e')</math>, where <math>e'</math> runs over all subexpressions of <math>e</math>.

'''Definition.''' Let <math>e=(f,(e_1,\ldots,e_m))\in E(V,F)\setminus V</math> be an expression such that <math>f\in F_D</math> and let <math>(n,\Delta,(v_1,\ldots,v_m),e')=F^{-1}(f)</math>. Define the proper substitution map <math>u</math> by setting <math>u(v_i)=e_i</math> for <math>i=1,\ldots,m</math>. Then <math>\tilde{u}(e')</math> is called the ''unfolding'' of <math>e</math>.

'''Lemma 15.''' Let <math>e=(f,(e_1,\ldots,e_m))\in E(V,F)\setminus V</math> be an expression such that <math>f\in F_D</math> and let <math>e'</math> be the unfolding of <math>e</math>. Then <math>K(e)=K(e')</math>.

{{sc|Proof.}} By definition, there is a proper substitution map such that <math>\tilde{u}(e')=e</math>. The claim now follows from lemma 9.

'''Lemma 16.''' Let <math>e_1,e_2\in E(V,F)</math>. If <math>e_2</math> is the unfolding of <math>e_1</math> then <math>\beta(e_1)=\beta(e_2)+1</math> and <math>\hat{\beta}(e_1)\geq\hat{\beta}(e_2)</math>.

{{sc|Proof.}} Since <math>e_1</math> has an unfolding, it has a head functor which is a definition functor. The first claim now results from the definition of <math>\beta</math>. The second claim follows since by the definition of <math>D</math>, all apparent functors of <math>e_2</math> which are not apparent functors of <math>e_1</math> have lower depth than <math>e_1</math>.

'''Definition.''' Let <math>e\in E(V,F)</math>. Then we define the ''complete unfolding'' of <math>e</math>, <math>CUF(e)</math> recursively as follows.
# If <math>e\in V</math> then <math>CUF(e)=e</math>.
# If <math>e=(f,(e_1,\ldots,e_m))</math> with <math>f\in F_T</math> then <math>CUF(e)=(f,(CUF(e_1),\ldots,CUF(e_m)))</math> (see lemma 17 for justification of this definition).
# If the head functor of <math>e</math> is a definition functor and <math>e'</math> is the unfolding of <math>e</math> then <math>CUF(e)=CUF(e')</math>.
Lemma 16 ensures that the recursion in this definition terminates.

'''Lemma 17.''' Let <math>e\in E(V,F)</math>. Then <math>K(e)=K(CUF(e))</math>.

{{sc|Proof.}} If <math>e\in V</math> this is clear. If <math>e=(f,(e_1,\ldots,e_m))</math> with <math>f\in F_T</math>, then <math>K(CUF(e_i))=K(e_i)</math> for <math>i=1,\ldots,m</math> implies <math>K(CUF(e))=K((f,(CUF(e_1),\ldots,CUF(e_m))))=K(f)=K(e)</math>. If the head functor of <math>e</math> is a definition functor and <math>e'</math> is the unfolding of <math>e</math>, then <math>K(CUF(e'))=K(e')</math> and lemma 16 together imply that <math>K(CUF(e))=K(e)</math>. The whole statement now follows by induction as suggested by lemma 16.

'''Lemma 18.''' Let <math>e\in E(V,F)</math>. Then all apparent functors of <math>CUF(e)</math> are term functors. In other words, <math>\hat{\beta}(e)=0</math>.

{{sc|Proof.}} Due to the definition of <math>CUF</math>, <math>\beta(f)=0</math> for all apparent functors of <math>e</math>. Hence the claim follows from Lemma 14.

'''Definition.''' We denote the subset of <math>E(V,F)</math> of expressions all of whose apparent functors are term functors by <math>E(V,F_T)</math>.

'''Lemma 19.''' <math>CUF</math> is an [[w:idempotent|idempotent]] operation.

{{sc|Proof.}} Let <math>e\in E(V,F_T)</math>. By Lemma 18 it is sufficient to show that <math>CUF(e)=e</math>. If <math>|e|=1</math>, this follows by direct calculation. Assume the statement proven for expressions of length smaller than <math>|e|>1</math>. Then <math>e=(f,(e_1,\ldots,e_m))</math> and <math>CUF(e)=CUF((f,(e_1,\ldots,e_m)))=(f,CUF(e_1),\ldots,CUF(e_m))=(f,(e_1,\ldots,e_m))=e</math> by induction hypothesis.

'''Definition.''' Let <math>e\in E(V,F)</math>. Then a variable <math>v\in V</math> ''occurs'' in <math>e</math> if <math>v\in A(CUF(e))</math>. We denote the set of all variables occurring in <math>e</math> by <math>O(e)</math>.

'''Lemma 20.''' Let <math>e\in E(V,F)</math>. Then <math>O(e)\setminus V_D\subseteq A(e)</math>.

{{sc|Proof.}} By the definition of <math>D</math>, the only new variables an unfolding of a subexpression of <math>e</math> can incur are dummy variables.

'''Definition.''' Let <math>u</math> be a proper substitution map and <math>R\subseteq V\times V</math>. Then we extend <math>\tilde{u}</math> to <math>R</math> by <math>\tilde{u}(R):=\bigcup\limits_{(v,w)\in R}O(\tilde{u}(v))\times O(\tilde{u}(w))</math>.

'''Lemma 21.''' Let <math>R\subseteq V\times V</math> be a symmetric relation and <math>u</math> a proper substitution map. Then <math>\tilde{u}(R)</math> is also a symmetric relation.

{{sc|Proof.}} Let <math>(v,w)\in \tilde{u}(R)</math>, then there is a <math>(v',w')\in R</math> such that <math>(v,w)\in O(\tilde{u}(v'))\times O(\tilde{u}(w'))</math>. Now, <math>R</math> is symmetric, so <math>(w',v')\in R</math> and thus <math>O(\tilde{u}(w'))\times O(\tilde{u}(v'))\subseteq\tilde{u}(R)</math>. This proves the lemma.

Note that the application of a proper substitution map to a DV constraint does not necessarily yield a DV constraint.

'''Lemma 22.''' Let <math>u_1,u_2</math> be proper substitution maps. Then <math>u\colon V\to E(V,F)</math>, <math>u(v):=\tilde{u}_1(CUF(\tilde{u}_2(v)))</math> is also a proper substitution map with <math>CUF\circ\tilde{u}=CUF\circ\tilde{u}_1\circ CUF\circ\tilde{u}_2\circ CUF</math> on <math>E(V,F)</math> and <math>\tilde{u}=\tilde{u}_1\circ\tilde{u}_2</math> on <math>R\subseteq V\times V</math>.

{{sc|Proof.}} Let <math>v\in V</math>, then we have <math>K(u(v))=K(\tilde{u}_1(CUF(\tilde{u}_2(v))))</math>, by lemma 9, <math>=K(CUF(\tilde{u}_2(v)))</math>, by lemma 18, <math>=K(\tilde{u}_2(v))</math>, again by lemma 9, <math>=K(v)</math>. By definition, <math>\tilde{u}=\tilde{u}_1\circ CUF\circ\tilde{u}_2\circ CUF</math> on <math>V</math>. If <math>e=(f,(e_1,\ldots,e_m))</math> with <math>f\in F_T</math>, and if the statement is already proven for <math>e_1,\ldots,e_m</math>, then <math>CUF(\tilde{u}(e))=(f,(CUF(\tilde{u}(e_1)),\ldots,CUF(\tilde{u}(e_m))))=(f,(CUF(\tilde{u}_1(CUF(\tilde{u}_2(CUF(e_1))))),\ldots,CUF(\tilde{u}_1(CUF(\tilde{u}_2(CUF(e_m))))))=CUF(\tilde{u}_1(CUF(\tilde{u}_2(CUF(e)))))</math>. Lastly, if the statement has already been proven for <math>CUF(e)</math>, then the statement follows by idempotence. The whole statement now follows for <math>E(V,F)</math> by induction as suggested by lemma 16. Now finally, due to the definition of an occurring variable, <math>O(CUF(\tilde{u}_2(CUF(v))))=O(\tilde{u}_2(v))</math>. This implies the statement for <math>R\subseteq V\times V</math>.

'''Definition.''' Let <math>\Delta</math> be a symmetric relation on <math>V</math> and <math>e</math> an expression. Then <math>(\Delta,e)</math> is called an ''extended expression.'' For an extended expression <math>(\Delta,e)</math> we define <math>DV((\Delta,e)):=\Delta</math> and <math>EXP((\Delta,e)):=e</math>.

'''Definition.''' Let <math>e\in E(V,F)</math>. Then we define the ''extended complete unfolding'' <math>ECUF(e)</math> recursively as follows.
# If <math>e\in V</math> then <math>ECUF(e)=(\emptyset,e)</math>.
# If <math>e=(f,(e_1,\ldots,e_m))</math> with <math>f\in F_T</math> then <math>ECUF(e):=(\Delta,(f,(CUF(e_1),\ldots,CUF(e_m)))</math>, where <math>\Delta=\bigcup\limits_{i=1}^mDV(ECUF(e_i))</math>.
# If <math>e=(f,(e_1,\ldots,e_m))</math> with <math>f\in F_D</math> and <math>e'</math> is the unfolding of <math>e</math> with unfolding map <math>u</math>, then <math>ECUF(e)=(\Delta,CUF(e'))</math>, where <math>\Delta=\tilde{u}(DV(F^{-1}(f)))\cup DV(ECUF(e'))</math>.
Again, lemma 16 guarantees that the recursion in this definition terminates.

'''Lemma 23.''' Let <math>e\in E(V,F)</math>, then <math>EXP(ECUF(e))=CUF(e)\in E(V,F_T)</math>.

{{sc|Proof.}} This follows from the definition and lemma 17.

=== Statements ===

'''Definition.''' A tuple <math>s=(n,\Delta,h,e)</math> with <math>n\in N</math>, <math>\Delta</math> a DV constraint, <math>h\subseteq E(V,F)</math> a finite set, and <math>e\in E(V,F)</math> is a ''generalised statement'' if the following additional properties are fulfilled:
* <math>A(e)\subseteq V</math> and <math>A(e')\subseteq V</math> for all <math>e'\in h</math>. In other words, <math>A(s)\subseteq V</math>, where we define <math>A(s):=A(e)\cup\bigcup A(h)</math>,
* <math>A(\Delta)\subseteq A(s)</math>.
We define the ''name'', <math>A(s):=n</math>, the ''DV constraints'' <math>DV(s):=\Delta</math>, the ''hypotheses'' <math>H(s):=h</math>, the ''number of hypotheses'' <math>NH(s):=|h|</math>, and the ''consequent'' <math>C(s):=e</math>. We also define the ''mandatory variables'' of <math>s</math> to be <math>M(s):=A(s)\setminus\bigcup A(h)</math> and the ''occurring variables'' <math>O(s):=O(e)\cup\bigcup O(h)</math>.
If <math>s</math> fulfils precisely the same properties except that <math>V</math> is replaced by <math>V_U</math>, then <math>s</math> is a ''statement'', if by <math>V_N</math>, then <math>s</math> is called a ''pending statement''.

'''Definition.''' A finite set <math>S</math> is called a ''permissible set of statements'' if all elements of <math>S</math> are statements and the restriction of the name projection <math>N</math> to <math>S</math> is injective.

'''Lemma 24.''' Let <math>S</math> be a permissible set of statements. Then any <math>S'\subseteq S</math> is also a permissible set of statements.

{{sc|Proof.}} The proof is similar to the proof of Lemma 2.

'''Definition.''' Let <math>s</math> be a generalised statement. Then we set <math>CUF(s):=(N(s),DV(s)\cup\bigcup\limits_{h\in H(s)}DV(ECUF(h))\cup DV(ECUF(C(s)),CUF(H(s)),CUF(C(s)))</math>. Let <math>u</math> be a proper substitution map. Now define
* <math>n':=N(s)</math>,
* <math>\Delta':=\tilde{u}(DV(s))</math>,
* <math>h':=\tilde{u}(H(s))</math>,
* <math>c':=\tilde{u}(C(s))</math>.
We extend <math>\tilde{u}</math> to <math>s</math> by setting <math>\tilde{u}(s):=s':=(n',\Delta',h',c')</math>.

'''Lemma 25.''' Let <math>s</math> be a pending statement and let <math>u\colon A(s)\to V_U</math> be an injective proper substitution map. Then <math>\tilde{u}(s)</math> is a statement. We call such a statement an ''anonymisation'' of <math>s</math>.

{{sc|Proof.}} Since <math>u</math> is injective, <math>\tilde{u}(DV(s))</math> is self-avoiding and therefore a DV constraint by lemma 21. The remainder of the lemma is clear.

'''Explanation.''' First, statements are user-defined in JHilbert using the <code>stmt</code> and <code>thm</code> commands (where the <code>thm</code> statements have first to be derived as defined below). The user writes the statements as pending statements which are subsequently anonymised by introducing new unnamed variables that replace the named ones in the pending statement. Note that by theorem 1, it is always possible to introduce new unnamed variables if necessary for the anonymisation.

'''Definition.''' Let <math>S</math> be a permissible set of statements, <math>s</math> be a pending statement and <math>u_D\colon V_N\setminus O(s)\to V_D</math> an injective proper substitution map. Assume <math>\Delta^s:=DV(s)\cup\bigcup\limits_{h\in H(s)}DV(ECUF(h))\cup DV(ECUF(C(s)))</math> is a DV constraint. Then we define the sets <math>Cl(S,s,u_D)_k\subseteq\wp(V\times V)\times E(V,F_T)</math> for <math>k\in\mathbb{Z}_{\geq 0}</math> recursively as follows.
# <math>Cl(S,s,u_D)_0:=ECUF(H(s))</math>.
# For all <math>s'\in S</math>, all proper substitution maps <math>u</math> and all DV constraints <math>\Delta</math>, <math>(\Delta,CUF(\tilde{u}(CUF(C(s')))))\in Cl(S,s,u_D)_k</math> whenever all of the following are true:
:* <math>\tilde{u}(DV(s')\cup DV(ECUF(C(s'))))\subseteq\Delta</math>.
:* <math>A(\tilde{u}(v))\subseteq V_N</math> for all <math>v\in M(s')</math>.
:* For all <math>h\in H(s')</math>, some <math>(\Delta',CUF(\tilde{u}(CUF(h))))\in\bigcup\limits_{j=0}^{k-1}Cl(S,s,u_D)_j</math>, where <math>\tilde{u}(DV(ECUF(h)))\subseteq\Delta'\subseteq\Delta</math>.
:* <math>\tilde{u}_D(\Delta)\subseteq\Delta^s</math>.
We call the [[w:union (set theory)|union]] <math>Cl(S,s,u_D):=\bigcup\limits_{k\in\mathbb{Z}_{\geq 0}}Cl(S,s,u_D)_k</math> the (preliminary definition of) ''closure'' of <math>s</math> with respect to <math>S</math> and <math>u_D</math>. The statement <math>s</math> is called ''provable'' from <math>S</math> if there exists a <math>u_D</math> and an <math>e\in Cl(S,s,u_D)</math> such that <math>\tilde{u}_D(EXP(e))=CUF(C(s))</math>.

'''Lemma 26.''' Let <math>S</math> be a permissible set of statements, <math>s</math> be a pending statement and <math>u_D\colon V_N\setminus O(s)\to V_D</math> an injective proper substitution map. Then for all <math>(\Delta,e)\in Cl(S,s,u_D)</math>, <math>\tilde{u}_D(\Delta)\subseteq\Delta^s</math>.

{{sc|Proof.}} The only case where this is not clear is when <math>(\Delta,e)\in Cl(S,s,u_D)_0</math>. But since the domain of <math>u_D</math> excludes <math>O(s)</math>, <math>\tilde{u}_D</math> acts identically on <math>ECUF(H(s))</math>. Hence the lemma follows.

'''Lemma 27.''' Let <math>S</math> be a permissible set of statements, <math>s</math> be a pending statement and <math>u_1,u_2\colon V_N\setminus O(s)\to V_D</math> proper substitution maps whose images coincide. Then <math>(\Delta,e)\in Cl(S,s,u_1)</math> if and only if <math>((u_2^{-1}\circ u_1)^\sim(\Delta)),(u_2^{-1}\circ u_1)^\sim(e))\in Cl(S,s,u_2)</math>.

{{sc|Proof.}} This follows since <math>u_1,u_2</math> map variables to variables and are injective.

'''Lemma 28.''' Let <math>S</math> be a permissible set of statements and <math>s</math> a pending statement which is provable from <math>S</math> via <math>u_1\colon V_N\setminus O(s)\to V_D</math>. Then <math>s</math> is provable from <math>s</math> via any <math>u_D\colon V_N\setminus O(s)\to V_D</math> whose image coincides with <math>u_1</math>.

{{sc|Proof.}} So we have some <math>(\Delta,e)\in Cl(S,s,u_1)</math> such that <math>\tilde{u}_1(e)=CUF(C(s))</math>. Now, <math>\tilde{u}_D((u_D^{-1}\circ u_1)^\sim(e))=\tilde{u}_1(e)</math>. The statement now follows from lemma 27.

This lemma shows that the map <math>u_D</math> is rather immaterial as far as provability is concerned. It merely irons out some choice of named variables which serve as placeholders for dummy variables. A JHilbert user could obviate the need for different <math>u_D</math> altogether by maintaining a batch of named variables in one-to-one correspondence with dummy variables such that this batch never occurs in any statement (though in reality such bookkeeping would be rather cumbersome). Therefore we can make the following simplified definition for provability.

'''Definition.''' Let <math>S</math> be a permissible set of statements and <math>s</math> a generalised statement. Assume <math>\Delta^s:=DV(s)\cup\bigcup\limits_{h\in H(s)}DV(ECUF(h))\cup DV(ECUF(C(s)))</math> is a DV constraint. Then we define the sets <math>Cl_S(s)_k\subseteq\wp(V\times V)\times E(V,F_T)</math> for <math>k\in\mathbb{Z}_{\geq 0}</math> recursively as follows.
# <math>Cl_S(s)_0:=ECUF(H(s))</math>.
# For all <math>s'\in S</math>, all proper substitution maps <math>u</math> and all DV constraints <math>\Delta\subseteq\Delta^s</math>, <math>(\Delta,CUF(\tilde{u}(CUF(C(s')))))\in Cl_S(s)_k</math> whenever all of the following are true:
:* <math>\tilde{u}(DV(s')\cup DV(ECUF(C(s'))))\subseteq\Delta</math>.
:* For all <math>h\in H(s')</math>, some <math>(\Delta',CUF(\tilde{u}(CUF(h))))\in\bigcup\limits_{j=0}^{k-1}Cl_S(s)_j</math>, where <math>\tilde{u}(DV(ECUF(h)))\subseteq\Delta'\subseteq\Delta</math>.
We call the [[w:union (set theory)|union]] <math>Cl_S(s):=\bigcup\limits_{k\in\mathbb{Z}_{\geq 0}}Cl_S(s)_k</math> the (final definition of) ''closure'' of <math>s</math> with respect to <math>S</math> and <math>u_D</math>. The statement <math>s</math> is called ''provable'' from <math>S</math> if there exists an <math>e\in Cl_S(s)</math> such that <math>EXP(e)=CUF(C(s))</math>.

'''Lemma 29.''' Let <math>S</math> be a permissible set of statements, <math>s</math> a generalised statement and <math>u</math> a proper substitution map such that <math>\tilde{u}(CUF(s))</math> is also a generalised statement. Then if <math>s</math> is provable from <math>S</math>, so is <math>\tilde{u}(CUF(s))</math>.

{{sc|Proof.}} Let <math>s</math> be provable from <math>S</math>, then there is a <math>(\Delta,e)\in Cl_S(s)</math> such that <math>e=CUF(C(s))</math>. Assume first that <math>(\Delta,e)\in Cl_S(s)_0</math>. Then <math>(\Delta,e)\in ECUF(H(s))</math>, and hence <math>(\tilde{u}(\Delta),CUF(\tilde{u}(e)))\in ECUF(H(\tilde{u}(CUF(s))))=Cl_S(\tilde{u}(CUF(s)))_0</math>. Now let <math>k\in\mathbb{Z}_{>0}</math> and assume that <math>(\Delta',e')\in Cl_S(s)_j</math> implies <math>(\tilde{u}(\Delta'),CUF(\tilde{u}(e')))\in Cl_S(\tilde{u}(CUF(s)))_j</math> for <math>j=0,\ldots,k-1</math>. Let <math>(\Delta,e)\in Cl_S(s)_k</math>. Let <math>s'\in S</math> be the statement and <math>u'</math> be the proper substitution map giving rise to <math>(\Delta,e)</math>. Then <math>\tilde{u}'(DV(s')\cup DV(ECUF(C(s'))))\subseteq\Delta</math> and thus <math>\tilde{u}(\tilde{u}'(DV(s')\cup DV(ECUF(C(s')))))\subseteq\tilde{u}(\Delta)</math>. Furthermore, for each <math>h\in H(s')</math> there is a <math>\Delta'</math> such that <math>\tilde{u}'(DV(ECUF(h)))\subseteq\Delta'\subseteq\Delta</math> and <math>(\Delta',CUF(\tilde{u}'(CUF(h))))\in\bigcup\limits_{j=0}^{k-1}Cl_S(s)_j</math>. Hence <math>\tilde{u}(\tilde{u}'(DV(ECUF(h)))\subseteq\tilde{u}(\Delta')\subseteq\tilde{u}(\Delta)</math> and, by induction hypothesis, <math>(\tilde{u}(\Delta'),CUF(\tilde{u}(CUF(\tilde{u}'(CUF(h))))))\in\bigcup\limits_{j=0}^{k-1}Cl_S(\tilde{u}(CUF(s)))_j</math>. Since <math>CUF\circ\tilde{u}\circ CUF\circ\tilde{u}'\circ CUF</math> arises from a proper substitution map by lemma 22 and <math>CUF</math> is idempotent, it follows that <math>(\tilde{u}(\Delta),CUF(\tilde{u}(e)))=(\tilde{u}(\Delta),CUF(\tilde{u}(CUF(\tilde{u}'(CUF(C(s')))))))\in Cl_S(\tilde{u}(CUF(s)))_k</math>.

'''Lemma 30.''' Let <math>S_1</math> be a permissible set of statements, <math>s_1\in S_1</math>, and set <math>S_2:=S_1\setminus\{s_1\}</math>. Assume <math>s_1</math> is an anonymisation of <math>s_2</math> such that <math>s_2</math> is provable from <math>S_2</math>. Then all pending statements <math>s</math> which are provable from <math>S_1</math> are also provable from <math>S_2</math>.

{{sc|Proof.}} Let <math>u_A</math> be an anonymisation map which transports <math>s_2</math> to <math>s_1</math>. Let <math>s</math> be a pending statement which is provable from <math>S_1</math>. Let <math>(\Delta,e)\in Cl_{S_1}(s)</math> be such that <math>e=CUF(C(s))</math>. Now, assume first that <math>(\Delta,e)\in Cl_{S_1}(s)_0</math>. Then <math>(\Delta,e)\in ECUF(H(s))=Cl_{S_2}(s)_0\subseteq Cl_{S_2}(s)</math>. Next, let <math>k\in\mathbb{Z}_{>0}</math> and assume that <math>\bigcup\limits_{j=0}^{k-1}Cl_{S_1}(s)_j\subseteq Cl_{S_2}(s)</math> and <math>(\Delta,e)\in Cl_{S_1}(s)_k</math>. Let <math>s'\in S</math> and <math>u</math> be a proper substitution map such that <math>e=CUF(\tilde{u}(CUF(C(s'))))</math>. Then <math>\Delta\subseteq\Delta^s</math>, <math>\tilde{u}(DV(s')\cup DV(ECUF(C(s'))))\subseteq\Delta</math>, and for all <math>h\in H(s')</math> there is a <math>\Delta'\subseteq\Delta</math> such that <math>(\Delta',CUF(\tilde{u}(CUF(h))))\in\bigcup\limits_{j=0}^{k-1}Cl_{S_1}(s)</math> and <math>\tilde{u}(DV(ECUF(h)))\subseteq\Delta'</math>. Now, <math>(\Delta',CUF(\tilde{u}(CUF(h))))\in Cl_{S_2}(s)</math> by induction hypothesis. So if <math>s'\in S_2</math>, it follows that <math>(\Delta,e)\in Cl_{S_2}(s)</math>. Otherwise, <math>s'=s_1</math>. In this case, <math>CUF(s)=\tilde{u}(CUF(s_1))</math> is a generalised statement. Since <math>u_A</math> is injective with domain <math>A(s_2)</math>, <math>\tilde{u}(CUF(s_1))=\tilde{u}(CUF(\tilde{u}_A(s_2)))=\tilde{u}(\tilde{u}_A(CUF(s_2)))</math>. Hence <math>s</math> is provable from <math>S_2</math> by lemma 29.

Due to this lemma, we need only consider closures <math>Cl_S(s)</math> where <math>S</math> is a set of axioms, presumably [[w:logically independent|logically independent]].

== Implementation of Metamath first order logic in JHilbert ==

In this section we implement the first order logic part of the Metamath proof explorer <ref name="megill">{{sc|N. Megill}}, Metamath Proof Explorer, http://us.metamath.org/mpegif/mmset.html</ref> in JHilbert. Our interface is as follows:
 kind (set)
 kind (class)
 kind (wff)
 
 var (set x y z)
 var (wff φ χ ψ)
 
 term (class (cv set))
 term (wff (= class class))
 term (wff (∈ class class))
 term (wff (¬ wff))
 term (wff (→ wff wff))
 term (wff (∀ set wff))
 
 stmt (ax-mp () (φ (φ → χ)) χ)
 stmt (ax-gen () (φ) (∀ x φ))
 stmt (ax-1 () () (φ → (χ → φ)))
 stmt (ax-2 () () ((φ → (χ → ψ)) → ((φ → χ) → (φ → ψ))))
 stmt (ax-3 () () (((¬ φ) → (¬ χ)) → (χ → φ)))
 stmt (ax-4 () () ((∀ x φ) → φ))
 stmt (ax-5 () () ((∀ x (φ → χ)) → ((∀ x φ) → (∀ x χ))))
 stmt (ax-6 () () ((¬ (∀ x φ)) → (∀ x (¬ (∀ x φ)))))
 stmt (ax-7 () () ((∀ x (∀ y φ)) → (∀ y (∀ x φ))))
 stmt (ax-8 () () (((cv x) = (cv y)) → (((cv x) = (cv z)) → ((cv y) = (cv z)))))
 stmt (ax-9 () () (¬ (∀ x (¬ ((cv x) = (cv y))))))
 stmt (ax-10 () () ((∀ x ((cv x) = (cv y))) → (∀ y ((cv y) = (cv x)))))
 stmt (ax-11 () () (((cv x) = (cv y)) → ((∀ x φ) → (∀ x (((cv x) = (cv y)) → φ)))))
 stmt (ax-12 () () ((¬ (∀ z ((cv z) = (cv x)))) → ((¬ (∀ z ((cv z) = (cv y)))) →
  (((cv x) = (cv y)) → (∀ z ((cv x) = (cv y)))))))
 stmt (ax-13 () () (((cv x) = (cv y)) → (((cv x) ∈ (cv z)) → ((cv y) ∈ (cv z)))))
 stmt (ax-14 () () (((cv x) = (cv y)) → (((cv z) ∈ (cv x)) → ((cv z) ∈ (cv y)))))
 stmt (ax-15 () () ((¬ (∀ z ((cv z) = (cv x)))) → ((¬ (∀ z ((cv z) = (cv y)))) →
  (((cv x) ∈ (cv y)) → (∀ z ((cv x) ∈ (cv y)))))))
 stmt (ax-17 ((φ x)) () (φ → (∀ x φ)))
Note that we do not need <code>ax-16</code> due to <code>ax-17</code> [http://us.metamath.org/mpegif/ax-16.html]. Also note that we do not need any variables of kind <code>class</code>.

From now on we consider some JHilbert proof module which imports only the above interface but otherwise has arbitrary valid content. In what follows we shall make frequent references to the formalisation of Metamath as done in Appendix C of the Metamath book<ref name="metamath">{{sc|N. Megill}}, The Metamath Book, http://us.metamath.org/downloads/metamath.pdf</ref>.

Note that the above interface serves only an exemplary purpose. Our methodology is sufficiently general to work with any valid representation of a Metamath database, for the correct meaning of "valid". We shall now describe the translation of certain JHilbert data structures to Metamath.

'''Definition.''' Let <math>CN:=\{(,),\mathrm{set},\mathrm{class},\mathrm{wff},=,\in,\neg,\rightarrow,\forall,\vdash\}</math>, <math>VR:=V</math> and <math>T:=\{(t,v):v\in VR, t=K(v)\}</math> (in particular, the first component of all elementf of <math>T</math> is one of <math>\mathrm{set},\mathrm{class},\mathrm{wff}</math>).

'''Definition.''' We define the mapping <math>MM</math> from JHilbert expressions to Metamath expressions recursively as follows:
# For all <math>\texttt{v}\in V</math>, <math>MM(\texttt{(cv~v)})=MM(\texttt{v})=\texttt{v}</math>.
# For expressions <math>A,B</math> of type <code>class</code>, <math>MM(\texttt{(}A\texttt{=}B\texttt{)})=MM(A)\texttt{=}MM(B)</math>.
# For expressions <math>A,B</math> of type <code>class</code>, <math>MM(\texttt{(}A\in B\texttt{)})=MM(A)\texttt{e.}MM(B)</math>.
# For an expression <math>A</math> of type <code>wff</code>, <math>MM(\texttt{(}\neg A\texttt{)})=\texttt{-.}MM(A)</math>.
# For expressions <math>A,B</math> of type <code>wff</code>, <math>MM(\texttt{(}A\rightarrow B\texttt{)})=\texttt{(}MM(A)\texttt{->}MM(B)\texttt{)}</math>.
# For expressions <math>A,B</math> of type <code>var</code> and <code>wff</code> respectively, <math>MM(\texttt{(}\forall A B\texttt{)})=\texttt{A.}MM(A) MM(B)</math>.
# For all <math>e\in E(V,F)</math>, set <math>MM(e)=MM(CUF(e))</math>.
# Prepend a turnstile symbol <math>\texttt{|-}</math> if necessary.

'''Definition.''' We extend <math>MM</math> to relations <math>R\subseteq V\times V</math> by <math>MM(R):=\{\{v,w\}:(v,w)\in R\wedge (w,v)\in R\}</math>.

'''Definition.''' We extend <math>MM</math> to map generalised JHilbert statements <math>s</math> to Metamath pre-statements <math>PS:=(D,T,H,A)</math> as follows:
# Set <math>D:=MM(DV(s)\cup\bigcup\limits_{h\in H(s)}DV(ECUF(h))\cup DV(ECUF(C(s)))</math>.
# Set <math>H:=MM(H(s))</math>.
# Set <math>A:=MM(C(s))</math>.
Then <math>MM(s):=PS</math>.

'''Definition.''' Let <math>\Gamma</math> be the set of Metamath statements representing the functors and axioms given above (note that <code>cv</code> is rendered as an "invisible" functor in Metamath[http://us.metamath.org/mpegif/cv.html]). We shall then consider the ''Metamath formal system'' <math>\mathfrak{F}:=(CN,VR,\Gamma)</math>. We denote the Metamath universe of <math>\mathfrak{F}</math> by <math>\mathfrak{U}</math>.

'''Example.''' The Metamath reduct of <math>MM(\texttt{ax-11})</math> is <math>(\emptyset,\{(\mathrm{set},x),(\mathrm{set},y),(\mathrm{wff},\varphi)\},\emptyset,\vdash (x=y\rightarrow(\forall x\varphi\rightarrow\forall x(x=y\rightarrow\varphi))))</math>.

'''Lemma 31.''' There is a unique map <math>JH</math> from Metamath expressions to <math>E(V,F_T)</math> such that for all Metamath expressions <math>E</math> which are valid with respect to <math>\mathfrak{F}</math>, <math>MM(JH(E))=E</math>, and for all <math>e\in E(V,F)</math>, <math>JH(MM(e))=CUF(e)</math>.

{{sc|Proof.}} We have <math>VR=V</math>, and the only JHilbert functor not appearing in <math>CN</math> is <code>cv</code>. However, whether to use <code>cv</code> or not can be determined by the relevant functor's input kinds.

'''Definition.''' Let <math>u</math> be a JHilbert proper substitution map. Then we define <math>MM(u)</math>, defined on valid Metamath expressions, by <math>(MM(u))(E):=MM(\tilde{u}(JH(E)))</math>.

== Soundness of JHilbert ==

In order to prove the soundness of JHilbert, we must show that each pending JHilbert statement for which a JHilbert proof exists, is provable in Metamath as well (this proves soundness under the assumption that Metamath is sound as well). This means that for each provable JHilbert statement <math>s</math> we must show that the reduct of <math>MM(s)</math> is in <math>\mathfrak{U}</math>. Essentially, we show this by induction over the minimum number of steps a proof must have. According to lemma 30, it is sufficient to consider the permissible set of JHilbert statements <math>S</math> defined by <code>ax-mp</code>, <code>ax-gen</code>, <code>ax-1</code> through <code>ax-15</code> and <code>ax-17</code>.

'''Lemma 32.''' Let <math>s</math> be a pending JHilbert statement. Let <math>(\Delta,e)\in Cl_S(s)</math>. Then <math>MM(e)\in Cl(MM(s))</math>.

{{sc|Proof.}} If <math>(\Delta,e)\in Cl_S(s)_0</math>, then <math>e\in CUF(H(s))</math> and thus <math>MM(e)\in MM(CUF(H(s))=MM(H(s)))</math>. Let <math>k\in\mathbb{Z}_{>0}</math> and assume the statement proven for <math>(\Delta,e)\in\bigcup\limits_{j=0}^{k-1}Cl_S(s)_j</math>. Let <math>(\Delta,e)\in Cl_S(s)_k</math>. Then <math>\Delta\subseteq\Delta^s</math> and hence <math>MM(\Delta)\subseteq D</math>. Let <math>s'\in S</math> be the statement and <math>u</math> be the proper substitution map giving rise to <math>(\Delta,e)</math>. Let <math>(D_M',T_M',H',A'):=MM(s')</math>. Then <math>(MM(u))(T_M')\subseteq Cl(MM(s))</math> by the properness of <math>u</math>. Furthermore, <math>(MM(u))(H')=MM(\tilde{u}(JH(H')))=MM(\tilde{u}(JH(MM(H(s')))))=MM(\tilde{u}(CUF(H(s'))))=MM(CUF(\tilde{u}(CUF(H(s')))))</math>, by induction hypothesis, <math>\subseteq Cl(MM(s))</math>. Finally, let <math>\{v,w\}\in D_M'</math>. Then <math>(v,w)\in DV(s')\cup\bigcup\limits_{h\in H(s')}DV(ECUF(h))\cup DV(ECUF(C(s')))</math>. Assume first that <math>(v,w)\in DV(s')\cup DV(ECUF(C(s')))</math>. Then <math>MM(\tilde{u}(\{(v,w)\}))\subseteq MM(\tilde{u}(DV(s')\cup DV(ECUF(C(s')))))\subseteq MM(\Delta)\subseteq D</math>. Otherwise, there is an <math>h\in H(s')</math> such that <math>(v,w)\in DV(ECUF(h))</math>. By definition, there is a <math>\Delta'\subseteq\Delta</math> for this <math>h</math> such that <math>\tilde{u}(DV(ECUF(h)))\subseteq\Delta'</math>. This implies <math>MM(\tilde{u}(\{(v,w)\}))\subseteq MM(\Delta)\subseteq D</math>. Hence, by definition of Metamath closure, <math>MM(e)=MM(CUF(\tilde{u}(CUF(C(s')))))=MM(\tilde{u}(CUF(C(s'))))=(MM(u))(MM(C(s')))=(MM(u))(A')\in Cl(MM(s))</math>.

'''Theorem 2.''' Let <math>s</math> be a pending JHilbert statement provable from <math>S</math>. Then the reduct of <math>MM(s)</math> is in <math>\mathfrak{U}</math>, that is <math>MM(s)</math> is provable in Metamath.

{{sc|Proof.}} Let <math>(\Delta,e)\in Cl_S(s)</math> be such that <math>e=CUF(C(s))</math>. By lemma 32, <math>MM(e)\in Cl(MM(s))</math>. Now the assertion of <math>MM(s)</math> is <math>MM(C(s))=MM(CUF(C(s)))=MM(e)</math>. Hence, <math>MM(s)</math> is a provable pre-statement, so its reduct belongs to <math>\mathfrak{U}</math>.

== References ==

<references />

[[Category:JHilbert|Definition soundness]]