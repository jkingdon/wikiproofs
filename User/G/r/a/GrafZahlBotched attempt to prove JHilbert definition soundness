{{header
 | title    = Definition soundness of first-order logic in JHilbert
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = Attempt at a formal proof of soundness of first-order logic in JHilbert.
}}

== JHilbert related stuff ==

=== Names ===

'''Definition.''' <math>\Sigma</math> is a [[w:finite set|finite]], [[w:empty set|non-empty]] [[w:set (mathematics)|set]], the ''characters''.

'''Definition.''' <math>N:=\Sigma^*\setminus\{\epsilon\}</math>, that is, the set of all non-empty, finite [[w:sequence|sequence]]s of characters is the set of ''names''.

'''Lemma 1.''' The set of names <math>N</math> is [[w:countably infinite|countably infinite]].

{{sc|Proof.}} <math>N</math> is infinite because <math>\Sigma\neq\emptyset</math>, and countable because <math>\Sigma</math> is finite.

=== Kinds ===

'''Definition.''' The ''kinds'' are a [[w:tuple|tuple]] <math>(K,\sim)</math> where <math>K\subseteq N</math> is finite and <math>\sim</math> is an [[w:equivalence relation|equivalence relation]] on <math>K</math>. We denote the set <math>K/\sim</math> of all [[w:equivalence class|equivalence class]]es by <math>\mathcal{K}</math>.

Where no confusion is possible, we shall not distinguish between kinds and equivalence classes of kinds.

'''Explanation.''' <math>K</math> and <math>\sim</math> are user-defined in JHilbert through the <code>kind</code> and <code>kindbind</code> commands. The <code>kind</code> command adds a new name to <math>K</math> which initially is equivalent only to itself. The <code>kindbind</code> command adds a relation between two kinds in <math>K</math> to <math>\sim</math> (possibly after adding a new name to <math>K</math>) and completes <math>\sim</math> by [[w:reflexive closure|reflexive]], [[w:symmetric closure|symmetric]] and [[w:transitive closure|transitive]] [[w:closure (mathematics)|closure]].

=== Variables ===

'''Definition.''' A tuple <math>(n,k)</math> with <math>n\in N</math> and <math>k\in\mathcal{K}</math> is a ''variable''. For each variable <math>v=(n,k)</math> we denote the [[w:projection (set theory)|projection]] <math>(n,k)\mapsto n</math>, the ''name of <math>v</math>'', by <math>N(v)</math>, and the projection <math>(n,k)\mapsto k</math>, the ''kind of <math>v</math>'', by <math>K(v)</math>.

'''Definition.''' A finite set <math>V</math> is called a ''permissible set of variables'' if all elements of <math>V</math> are variables, and the [[w:restriction (mathematics)|restriction]] of the name projection <math>N</math> to <math>V</math> is [[w:injective|injective]].

'''Lemma 2.''' Let <math>V</math> be a permissible set of variables. Then any <math>W\subseteq V</math> is also a permissible set of variables.

{{sc|Proof.}} <math>W</math> is finite since <math>V</math> is finite. <math>W</math> contains only variables since <math>W</math> is contained in <math>V</math>. Finally, the restriction of an injective function remains injective.

'''Theorem 1.''' Let <math>V</math> be a permissible set of variables. Then for any <math>k\in\mathcal{K}</math> there is a <math>n\in N</math> such that <math>(n,k)\notin V</math> and <math>V':=V\cup\{(n,k)\}</math> is a permissible set of variables.

{{sc|Proof.}} Since <math>V</math> is finite, the image <math>N(V)</math> is finite as well. Now, <math>N</math> is infinite by Lemma 1. Therefore, there exists an <math>n\in N\setminus N(V)</math>. Since <math>n\notin (\left.N\right|_V)^{-1}(N)</math>, <math>(n,k)\notin V</math>. <math>V'</math> is finite because <math>V</math> and the singleton <math>\{(n,k)\}</math> are finite, and <math>(n,k)</math> is clearly a variable. Again, since <math>n\notin (\left.N\right|_V)^{-1}(N)</math>, <math>N((n,k))\neq N(v)</math> for all <math>v\in V</math>. Therefore, the name projection is injective on <math>V'</math>.

'''Definition.''' The ''variables'' are a permissible set of variables <math>V</math>. It is [[w:partition of a set|partitioned]] into three subsets, the ''named variables'' <math>V_N</math>, the ''unnamed variables'' <math>V_U</math> and the ''dummy variables'' <math>V_D</math>. By Lemma 2, these subsets are also permissible sets of variables.

'''Explanation.''' The named variables <math>V_N</math> are user-defined in JHilbert through the <code>var</code> command. Unnamed variables and dummy variables are automatically introduced as explained later. Since the empty set is a permissible set of variables, Theorem 1 ensures that such automatic introduction of new variables is always possible. In fact, JHilbert cheats a little by extending <math>\Sigma</math> for this purpose, so the namespace for user-defined variables doesn't become polluted.

=== Functors ===

'''Definition.''' A tuple <math>(n,k,l)</math> with <math>n\in N</math>, <math>k\in\mathcal{K}</math> and <math>l\in\mathcal{K}^*</math> is a ''functor''. For each functor <math>f=(n,k,l)</math>, we denote the projection <math>(n,k,l)\mapsto n</math>, the ''name of <math>f</math>'', by <math>N(f)</math>, and the projection <math>(n,k,l)\mapsto k</math>, the ''kind of <math>f</math>'', by <math>K(f)</math>. Furthermore, we denote the function <math>(n,k,l)\mapsto|l|</math>, where <math>|l|</math> is the length of the sequence <math>l</math>, the ''place count of <math>f</math>'', by <math>PC(f)</math>. For each <math>i\in\mathbb{N}</math>, <math>1\leq i\leq PC(f)</math>, we denote by <math>IK_i(f)</math> the mapping of <math>(n,k,l)</math> to the <math>i</math>-th projection of <math>l</math>. We call <math>IK_i(f)</math> the ''<math>i</math>-th input kind of <math>f</math>.''

'''Definition.''' A finite set <math>F</math> is called a ''permissible set of functors'' if all elements of <math>F</math> are functors and the restriction of the name projection <math>N</math> to <math>F</math> is injective.

'''Lemma 3.''' Let <math>F</math> be a permissible set of functors. Then any <math>G\subseteq F</math> is also a permissible set of functors.

{{sc|Proof.}} The proof is similar to the proof of Lemma 2.

'''Definition.''' The ''functors'' are a permissible set of functors <math>F</math>.

=== Term functors ===

'''Definition.''' The ''term functors'' are a set <math>F_T\subseteq F</math>. By Lemma 3, term functors are a permissible set of functors.

'''Explanation.''' Term functors are user-defined in JHilbert through the <code>term</code> command. However, they are not the only functors as definitions (see below) give rise to further functors.

=== Expressions ===

'''Definition.''' We define when some element <math>e</math> is an ''expression'', and what the ''kind of <math>e</math>'', <math>K(e)</math>, is, [[w:recursive definition|recursively]] as follows:
# If <math>e\in V</math> then <math>e</math> is an expression. (In this case, <math>K(e)</math> is defined by the definition of the kind of a variable.)
# If <math>e=(f,s)</math> where <math>f\in F</math> and <math>s</math> is a finite sequence of expressions such that <math>PC(f)=|s|</math> and for <math>i=1,\ldots,|s|</math> the <math>i</math>-th element of <math>s</math>, <math>s_i</math>, fulfils the equation <math>IK_i(f)=K(s_i)</math>, then <math>e</math> is an expression.
# Nothing else is an expression.
# If <math>e=(f,s)</math> is an expression, then <math>K(e)=K(f)</math>.
We denote the set of all expressions by <math>E(V,F)</math>.

'''Lemma 4.''' The set <math>E(V,F)</math> is either finite or countably infinite.

{{sc|Proof.}} By using [[w:polish notation|polish notation]] we may consider <math>E(V,F)</math> a subset of <math>(V\cup F)^*</math>. Since both <math>V</math> and <math>F</math> are finite, that set is finite or countably infinite. Hence <math>E(V,F)</math> is finite or countably infinite.

'''Definition.''' Let <math>e\in E(V,F)</math>. Then we define the ''length of <math>e</math>'', <math>|e|</math> recursively as follows:
# If <math>e\in V</math> then <math>|e|=1</math>.
# If <math>e=(f,s)</math> then <math>|e|</math> is the sum of the lengths of the expressions in <math>s</math>, plus one.

'''Lemma 5.''' Let <math>e\in E(V,F)</math>. Then <math>|e|=1</math> if and only if either <math>e\in V</math> or <math>e=(f,s)</math> with <math>PC(f)=0</math> and hence <math>s=\epsilon</math>.

{{sc|Proof.}} If <math>e\in V</math> or <math>e=(f,s)</math> with the stated properties then clearly <math>|e|=1</math>. Now assume <math>e=(f,s)</math> with <math>PC(f)\neq 0</math>. But then surely <math>|e|>1</math> since all expressions in <math>s</math> have length at least one.

'''Definition.''' Let <math>e_1,e_2\in E(V,F)</math>. Then we define when <math>e_2</math> is a ''subexpression'' of <math>e_1</math> recursively as follows.
# If <math>e_1\in V</math> then <math>e_2</math> is a subexpression of <math>e_1</math> if and only if <math>e_1=e_2</math>.
# If <math>e_1=(f,s)</math> then <math>e_2</math> is a subexpression of <math>e_1</math> if and only if either <math>e_1=e_2</math> or <math>e_2</math> is a subexpression of one of the expressions in <math>s</math>.

'''Lemma 6.''' Let <math>e_1\in E(V,F)</math> and let <math>e_2</math> be a subexpression of <math>e_1</math>. Then <math>|e_2|\leq|e_1|</math> and equality holds if and only if <math>e_1=e_2</math>.

{{sc|Proof.}} This follows from the strict [[w:monotonicity|monotonicity]] of the addition of [[w:positive integer|positive integer]]s.

'''Definition.''' Let <math>e\in E(V,F)</math> and <math>v\in V</math>. We define when <math>v</math> is ''apparent'' in <math>e</math> recursively as follows:
# If <math>e\in V</math> then <math>v</math> is apparent in <math>e</math> if and only if <math>e=v</math>.
# If <math>e=(f,s)</math> then <math>v</math> is apparent in <math>e</math> if and only if it is apparent in at least one of the expressions in <math>s</math>.
We denote the set of apparent variables of <math>e</math> by <math>A(e)</math>.

'''Definition.''' Let <math>e\in E(V,F)</math> and let <math>v_1,v_2\in A(e)</math>. We define when <math>v_1\leq_e v_2</math> recursively as follows:
# If <math>e\in V</math> then <math>v_1\leq_e v_2</math>.
# If <math>e=(f,s)</math> and there is an expression <math>e_1</math> in <math>s</math> such that
#:* <math>v_1\in A(e_1)</math>,
#:* <math>v_2\notin A(e')</math> for all expressions <math>e'</math> before <math>e_1</math> in <math>s</math>,
#:* <math>v_2\notin A(e_1)</math> or <math>v_1\leq_{e_1} v_2</math>,
#:then <math>v_1\leq_e v_2</math>.
# <math>v_1\leq_e v_2</math> in no other case.