{{header
 | title    = First-order logic
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = The purpose of this page is to prove the statements of [[Interface:First-order logic with quantifiability]] from [[Interface:First-order logic]] and the [[Interface:Axiom of quantifiability]]. In particular, it adds substitution of an object (term) for a variable.

{{under construction}}
}}
{{interfaces
| imports = [[Interface:First-order logic]] [[Interface:Axiom of quantifiability]]
| exports = [[Interface:First-order logic with quantifiability]]
}}

We start with [[Interface:Classical propositional calculus]] and [[Interface:First-order logic]]. We don't import the [[Interface:Axiom of quantifiability]] yet.

<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (WITHOUT_QUANTIFIABILITY Interface:First-order_logic (CLASSICAL) ())
</jh>

As usual, φ, ψ, χ, and θ are formulas, x, y, and z are variables, and s, t, and u are objects:

<jh>
var (formula φ ψ χ θ)
var (object s t u s0 s1 t0 t1)
var (variable x y z x0 x1 y0 y1)
</jh>

== Substitution of objects ==
We now turn to substitution of an object for a variable.

In some formulations of predicate logic, this kind of substitution (known as ''proper substitution'' as there are some rules about what kinds of substitution are valid) is performed syntactically and the rules governing it are expressed in English or a meta-theory.  JHilbert does not have a feature to do syntactic proper substitution, but we are able to build up equivalent mechanisms from equality. The theorems in [[Interface:First-order logic with quantifiability]] could be proven from either the syntactic definition or ours.

We define a formula <code>(subst s x φ)</code> which means, roughly, that <code>φ</code> is true if ocurrences of <code>x</code> are replaced by <code>s</code> ("roughly" because we have not tried to define proper substitution precisely). In dicussion, we also use the notation <code>[ s / x ] φ</code> (which is not legal JHilbert syntax) for the same thing. The definition is <code>[ s / x ] φ ≝ ∃ y (y = s ∧ ∃ x (x = y ∧ φ))</code>. The definition contains a dummy variable <code>y</code> to give the expected results if <code>x</code> and <code>s</code> are not distinct.<ref>It resembles [http://us.metamath.org/mpeuni/dfsb7.html dfsb7] in metamath's set.mm, accessed March 8, 2010, except that <code>s</code> (the replacement) is an <code>object</code> rather than a <code>variable</code>.</ref>

Currently, the definition of <code>subst</code> is an axiom in [[Interface:Axiom of quantifiability]].  Therefore, we import that interface now, even though we aren't going to use the axiom of quantifiability itself for a little while.
<jh>
import (QUANTIFIABILITY_AXIOM Interface:Axiom_of_quantifiability (CLASSICAL WITHOUT_QUANTIFIABILITY) ())
</jh>

This section contains a few of the preliminary results, which we can prove without the axiom of quantifiability.

=== Builders ===
We can build up formulas based on equivalences or equalities of the the substituted proposition or the replacement (that is, <code>φ</code> or <code>s</code> in <code>(subst s x φ)</code>, respectively).

==== Based on replacement ====
In this section we will prove <code>s = t → ((subst s x φ) ↔ (subst t x φ))</code>. This is like dfsbcq in set.mm.<ref>[http://us.metamath.org/mpeuni/dfsbcq.html dfsbcq] in metamath's set.mm, accessed March 7, 2010</ref> The set.mm analogue for substituting a <code>variable</code> (rather than an <code>object</code>) is sbequ.<ref>[http://us.metamath.org/mpeuni/sbequ.html sbequ] in metamath's set.mm, accessed June 20, 2010</ref>

<jh>
thm (SubstBuilderReplacement ((s y) (t y)) ()
  ((s = t) → ((subst s x φ) ↔ (subst t x φ))) (
        s t (value y) EqualityBuilderLL
        (∃ x (((value x) = (value y)) ∧ φ)) buildConjunctionRRInConsequent
        y buildThereExistsInConsequent

</jh>
Now we just need to apply the definition of <code>subst</code> and we are done:
<jh>
        s x φ y Subst
        t x φ y Subst
        buildBiconditional

        eliminateBiconditionalForward
        applySyllogism
))

thm (buildSubstReplacement () ((H (s = t))) 
  ((subst s x φ) ↔ (subst t x φ)) (
        H
        s t x φ SubstBuilderReplacement
        applyModusPonens
))
</jh>

==== Implication builder ====
Analogous to our other implication builders, this theorem takes an implication and lets us add <code>subst</code> to both sides. The proof is just a straightforward application of the existing builders for conjunction and ∃.
<jh>
thm (addSubst () ((H (φ → ψ))) ((subst s x φ) → (subst s x ψ)) (
        H
        ((value x) = (value y)) conjoinLL
        x addThereExists
        ((value y) = s) conjoinLL
        y addThereExists
</jh>
Now we just need to apply the definition of <code>subst</code> and we are done:
<jh>
        s x φ y Subst
        swapBiconditional transformAntecedent

        s x ψ y Subst
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

==== Biconditional builder ====
The builder for the biconditional is very similar to the implication builder.  It could be proved much the way we proved the implication builder, but we derive it from the implication builder.<ref>Similar to [http://us.metamath.org/mpeuni/sbbii.html sbbii] in metamath's set.mm, accessed February 24, 2010, except that <code>s</code> is an <code>object</code> not a <code>variable</code></ref>

<jh>
thm (buildSubst () ((H (φ ↔ ψ))) ((subst s x φ) ↔ (subst s x ψ)) (
        H eliminateBiconditionalReverse
        s x addSubst
        H eliminateBiconditionalForward
        s x addSubst
        introduceBiconditionalFromImplications
))
</jh>

=== Proving there-exists ===
One way to prove a formula of the form <code>∃xφ</code> is to demonstrate a particular <code>x</code> for which <code>φ</code> holds.  In [[w:Intuitionistic logic|constructive logic]] any theorem <code>∃xφ</code> can be proved this way (because of the [[w:Existence property|existence property]]), but even in classical (non-constructive) logic this is one of the most common ways of proving <code>∃xφ</code>.

In our notation, this idea is expressed via <code>subst</code>:
<jh>
thm (ThereExistsIntroduction ((y φ) (y x)) () ((subst s x φ) → (∃ x φ)) (
</jh>
The proof takes the definition of <code>subst</code>, <code>(∃ y (y = s ∧ (∃ x (x = y ∧ φ))))</code> and pares it down by eliminating the parts we don't need.

We start with <code>(y = s ∧ ∃ x (x = y ∧ φ)) → ∃ x (x = y ∧ φ)</code>
<jh>
        ((value y) = s) (∃ x (((value x) = (value y)) ∧ φ)) ConjunctionLeftElimination

</jh>
and <code>∃ x (x = y ∧ φ) → ∃ x φ</code>:
<jh>
        ((value x) = (value y)) φ ConjunctionLeftElimination
        x addThereExists
</jh>
which by syllogism gives us <code>(y = s ∧ ∃ x (x = y ∧ φ)) → ∃ x φ</code>
<jh>
        applySyllogism
</jh>
We add <code>∃ y</code> to both sides and simplify <code>∃ y ∃ x φ</code> to <code>∃ x φ</code>:
<jh>
        y addThereExists

        y (∃ x φ) DistinctNotFree
        ThereExistsAddRemove eliminateBiconditionalReverse
        applySyllogism
</jh>
Now we just need to apply the definition of <code>subst</code> and we are done:
<jh>
        s x φ y Subst
        swapBiconditional transformAntecedent
))

thm (introduceThereExists () ((H (subst s x φ))) (∃ x φ) (
        H
        s x φ ThereExistsIntroduction
        applyModusPonens
))
</jh>

== Free variables and substitution ==
A substitution acts like a quantifier in the sense that it binds the variable being substituted. So this variable is not free in the substituted formula (provided it is not free in the object being substituted for the variable).
<jh>
thm (SubstNotFree ((x s) (x y)) () (x is-not-free-in (subst s x φ)) (
</jh>
The proof consists of just applying our not-free theorems to each piece of the definition of <code>subst</code>
<jh>
        x ((value y) = s) DistinctNotFree
        x (((value x) = (value y)) ∧ φ) BoundThereExistsNotFree
        conjunctionNotFree
        y addThereExistsNotFree

        s x φ y Subst
        x buildNotFree
        eliminateBiconditionalForward

        applyModusPonens
))
</jh>

== Axiom of quantifiability ==
Having gotten about as far as we're going to get without the [[Interface:Axiom of quantifiability]], we now start proving some consequences of it (because that file also contains the definition of subst, we have already imported it).

== Specialization with substitution ==
The version of <code>Specialization</code> from [[Interface:First-order logic]] is not the one most often presented as a theorem (or axiom) of predicate logic.  The standard version also contains a substitution, and is often worded something like "if a formula holds for all values of a variable, it also holds when a particular term is properly substituted for that variable" or in symbols <code>∀ x φ → [ s / x ] φ)</code>.<ref>[http://us.metamath.org/mpeuni/stdpc4.html stdpc4] in metamath's set.mm, accessed June 9, 2010</ref><ref>a5sbc in Raph Levien's [http://levien.com/garden/ghnew/peano/ Peano], accessed June 9, 2010</ref><ref>Hirst and Hirst, axiom 4 on page 51</ref>
<jh>
thm (SpecializationToObject ((y s) (y x) (y φ)) () ((∀ x φ) → (subst s x φ)) (
</jh>
We start with <code>∀ x φ ∧ ∃ x x = y → ∃ x (φ ∧ x = y)</code> and eliminate the second antecedent (because it is an instance of <code>Quantifiability</code>).
<jh>
        x (value y) Quantifiability
        x φ ((value x) = (value y)) ThereExistsConjunctionCombining
        detach2of2
</jh>
Commuting the conjunction in the consequent gives <code>∀ x φ → ∃ x (x = y ∧ φ)</code>
<jh>
        φ ((value x) = (value y)) ConjunctionCommutativity
        x buildThereExists
        eliminateBiconditionalReverse
        applySyllogism
</jh>
We are heading towards the definition of <code>[ s / x ] φ</code>, which has two quantifiers: an outer one on <code>y</code> and an inner one on <code>x</code>.  So far we have the quantifier for <code>x</code> and a similar set of steps to the ones we just took will give us a similar expression with a quantifier for <code>y</code>.
<jh>
        y addForAllToConsequent
</jh>
We add <code>∃ y y = s</code> (a theorem) to the consequent:
<jh>
        y s Quantifiability
        (∀ x φ) introduceAntecedent
        composeConjunction
</jh>
The consequent is <code>∀ y ∃ x (x = y ∧ φ) ∧ ∃ y y = s)</code>, which we first turn into <code>∃ y (∃ x (x = y ∧ φ) ∧ y = s)</code>,
<jh>
        y (∃ x (((value x) = (value y)) ∧ φ)) ((value y) = s) ThereExistsConjunctionCombining
        applySyllogism
</jh>
And then into <code>∃ y (y = s ∧ ∃ x (x = y ∧ φ))</code>.
<jh>
        (∃ x (((value x) = (value y)) ∧ φ)) ((value y) = s) ConjunctionCommutativity
        y buildThereExists
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Now we just need to apply the definition of <code>subst</code> and we are done:
<jh>
        s x φ y Subst
        eliminateBiconditionalForward
        applySyllogism))
</jh>

== Quantifiers and equality ==

Here we prove a number of results involving equality and quantifiers. Many of them will pave the way for results involving explicit (subst) substitution.

=== ax9oc ===
First is a consequence of the <code>Quantifiability</code> axiom:<ref>like [http://us.metamath.org/mpeuni/ax9o.html ax9o] in metamath's set.mm, accessed February 22, 2010, but for an object not a variable</ref>

<jh>
thm (ax9oc () () ((∀ x (((value x) = s) → (∀ x φ))) → φ) (
        x s Quantifiability
        x ((value x) = s) (∀ x φ) ForAllImplicationThereExists
</jh>
This gives us <code>∀x(x = s → ∀xφ) → (∃x x = s → ∃x∀xφ)</code>, which can be simplified to our desired result.  The first step is to note that <code>∃x x = s</code> is just the <code>Quantifiability</code> axiom, and can therefore be removed:
<jh>
        detachImplicationImplication
</jh>
Now we need to reduce <code>∃x∀xφ</code> to <code>φ</code>:
<jh>
        x φ ax6o
        applySyllogism
))
</jh>

=== Implicit substitution and ∀ ===
A statement of the form <code>x = s → (φ ↔ ψ)</code>, where <code>x</code> is not free in <code>ψ</code>, can be thought of as an ''implicit substitution'', as it can be used to relate a formula about <code>x</code> to a formula about <code>s</code>. Here we relate such a statement to <code>∀x(x = s → φ)</code> (which is one of the formulas we'll be using in manipulating substitutions).<ref>[http://us.metamath.org/mpeuni/equsal.html equsal] in metamath's set.mm, accessed May 11, 2010, but for an object not a variable</ref>

First, a propositional logic theorem:<ref>*5.74 from A. Whitehead, B. Russell, Principia Mathematica, Cambridge University Press, 1910.</ref>
<jh>
thm (ImplicationDistributionOverBiconditional () () ((φ → (ψ ↔ χ)) ↔ ((φ → ψ) ↔ (φ → χ))) (
</jh>
We split <code>(φ → ψ) ↔ (φ → χ)</code> into two implications:
<jh>
        (φ → ψ) (φ → χ) BiconditionalImplication
</jh>
Then we apply <code>AntecedentDistribution</code> to each one,
<jh>
        φ ψ χ AntecedentDistribution swapBiconditional
        φ χ ψ AntecedentDistribution swapBiconditional
</jh>
and combine them.
<jh>
        buildConjunction
</jh>
The left hand side from buildConjunction was <code>((φ → ψ) → (φ → χ)) ∧ ((φ → χ) → (φ → ψ))</code>, so we are ready to apply transitivity there.
<jh>
        applyBiconditionalTransitivity
</jh>
The right hand side from buildConjunction was <code>(φ → (ψ → χ)) ∧ (φ → (χ → ψ))</code>, which we first transform to <code>φ → ((ψ → χ) ∧ (χ → ψ))</code>,
<jh>
        φ (ψ → χ) (χ → ψ) ConjunctionComposition
        applyBiconditionalTransitivity
</jh>
and then to <code>φ → (ψ ↔ χ)</code>.
<jh>
        φ BiconditionalReflexivity
        ψ χ BiconditionalImplication swapBiconditional
        buildImplication
        applyBiconditionalTransitivity

</jh>
We now have our desired result except the two sides are interchanged.
<jh>
        swapBiconditional
))

thm (distributeImplicationOverBiconditional () ((H (φ → (ψ ↔ χ)))) ((φ → ψ) ↔ (φ → χ)) (
        H
        φ ψ χ ImplicationDistributionOverBiconditional eliminateBiconditionalReverse
        applyModusPonens
))
</jh>

And our implicit substitution theorem:
<jh>
thm (ImplicitSubstitutionForAll () ((HFREE (x is-not-free-in ψ))) 
  ((∀ x (((value x) = s) → (φ ↔ ψ))) → ((∀ x (((value x) = s) → φ)) ↔ ψ)) (
</jh>
Starting with <code>x = s → (φ ↔ ψ)</code>, we first add <code>∀x</code> in front of the <code>ψ</code>:
<jh>
        HFREE
        ForAllAddRemove swapBiconditional

        φ ψ (∀ x ψ) BiconditionalTransitivity export

        detachImplicationImplication

        ((value x) = s) addCommonAntecedent
</jh>
We now distribute the implication over the biconditional to get <code>(x = s → φ) ↔ (x = s → ∀xψ)</code>.
<jh>
        ((value x) = s) φ (∀ x ψ) ImplicationDistributionOverBiconditional eliminateBiconditionalReverse
        applySyllogism
</jh>
The entire formula we have at this point is <code>(x = s → (φ ↔ ψ)) → ((x = s → φ) ↔ (x = s → ∀xψ))</code>.  We will add <code>∀x</code> to the start of each of the three parts.
<jh>
        x addForAll
        x (((value x) = s) → φ) (((value x) = s) → (∀ x ψ)) ForAllBiconditional
        applySyllogism
</jh>
The left side of that consequent, <code>∀x(x = s → φ)</code>, is the left side of our desired consequent.

We will show that the right side, <code>∀x(x = s → ∀xψ)</code>, is equivalent to <code>ψ</code>. The forward direction is just <code>ax9oc</code>:
<jh>
        x s ψ ax9oc
</jh>
The reverse direction is introducing an antecedent and messing around with quantifiers:
<jh>
        HFREE ForAllAddRemove eliminateBiconditionalForward

        (∀ x ψ) ((value x) = s) AntecedentIntroduction
        a5i
        applySyllogism
</jh>
Now we just need to combine the forward and reverse directions,
<jh>
        introduceBiconditionalFromImplications
</jh>
and reassemble our result.
<jh>
        (∀ x (((value x) = s) → φ)) (∀ x (((value x) = s) → (∀ x ψ))) ψ BiconditionalTransitivity
        export
        detachImplicationImplication

        applySyllogism
))
</jh>

Here's a rule form of basically the same theorem:

<jh>
thm (SubstImplicitForAll () ((HFREE (x is-not-free-in ψ)) (HEQ (((value x) = s) → (φ ↔ ψ))))
  ((∀ x (((value x) = s) → φ)) ↔ ψ) (
        HEQ
        x generalize

        HFREE
        s φ ImplicitSubstitutionForAll

        applyModusPonens
))
</jh>

=== Implicit substitution and ∃ ===
There is a similar result with ∃.<ref>[http://us.metamath.org/mpeuni/equsex.html equsex] in metamath's set.mm, accessed March 9, 2010, with <code>s</code> (the replacement) changed from a <code>variable</code> to an <code>object</code></ref>

Our implicit substitution theorem is:
<jh>
thm (ImplicitSubstitutionThereExists () ((HFREE (x is-not-free-in ψ))) 
  ((∀ x (((value x) = s) → (φ ↔ ψ))) → ((∃ x (((value x) = s) ∧ φ)) ↔ ψ)) (
</jh>
The proof basically consists of massaging negations to derive this result from the corresponding one for ∀. We start by showing that <code>∀x (x = s → (φ ↔ ψ))</code> implies that <code>∀x(x = s → ¬ φ)</code> is equivalent to <code>¬ ψ</code>.
<jh>
        φ ψ NegationFunction eliminateBiconditionalReverse
        ((value x) = s) addCommonAntecedent
        x addForAll

        HFREE
        negateNotFree
        s (¬ φ) ImplicitSubstitutionForAll

        applySyllogism
</jh>
Now we need to show that <code>∀x(x = s → ¬ φ) ↔ (¬ ψ)</code> implies <code>∃x(x = s ∧ φ) ↔ ψ</code>. We first turn the former into <code>ψ ↔ (¬ ∀x(x = s → ¬ φ))</code>:
<jh>
        (∀ x (((value x) = s) → (¬ φ))) ψ BiconditionalTranspositionWithNegatedRight
</jh>
We stick <code>ψ ↔ ψ</code> on the proof stack for later use,
<jh>
        ψ BiconditionalReflexivity
</jh>
and work just with <code>¬ ∀x(x = s → ¬ φ)</code> for now. We move the negation past the quantifier to get <code>∃x ¬ (x = s → ¬ φ)</code>:
<jh>
        x (((value x) = s) → (¬ φ)) NotForAll
</jh>
Now we turn the negations and implication into a conjunction:
<jh>
        ((value x) = s) φ ConjunctionImplication swapBiconditional
        x buildThereExists
        applyBiconditionalTransitivity
</jh>
Bringing back two statements we left on the proof stack, we assemble the formula that <code>∀x(x = s → ¬ φ) ↔ (¬ ψ)</code> is equivalent to <code>ψ ↔ ∃x(x = s ∧ φ)</code>,
<jh>
        buildBiconditional
        applyBiconditionalTransitivity
</jh>
flip the order to get <code>∃x(x = s ∧ φ) ↔ ψ</code>,
<jh>
        eliminateBiconditionalReverse
        ψ (∃ x (((value x) = s) ∧ φ)) BiconditionalSymmetry eliminateBiconditionalReverse
        applySyllogism
</jh>
and combine this with the first part of the proof.
<jh>
        applySyllogism
))
</jh>

The rule form is:
<jh>
thm (ImplicitThereExistsNotFree () ((HFREE (x is-not-free-in ψ)) (HEQ (((value x) = s) → (φ ↔ ψ))))
  ((∃ x (((value x) = s) ∧ φ)) ↔ ψ) (
        HEQ
        x generalize

        HFREE
        s φ ImplicitSubstitutionThereExists

        applyModusPonens
))
</jh>

and a version with distinct variable constraint instead of a freeness hypothesis is:
<jh>
thm (ImplicitThereExists ((x ψ)) ((HEQ (((value x) = s) → (φ ↔ ψ))))
  ((∃ x (((value x) = s) ∧ φ)) ↔ ψ) (
        x ψ DistinctNotFree
        HEQ
        ImplicitThereExistsNotFree
))
</jh>

=== Implicit substitution of an object for a variable ===
Suppose that we have a formula <code>φx</code> and a formula <code>φs</code> which is much the same, but with <code>s</code> in place of <code>x</code>.  Then if <code>φx</code> is a theorem, we can conclude <code>φs</code>.

Before we state this more formally, we prove a lemma.

<jh>
thm (VariableToObjectLemma ((x s) (x φ))
  ((H (((value x) = s) → φ)))
  φ (
        x s Quantifiability
        H
        x addThereExistsToAntecedent
        applyModusPonens
))
</jh>

Our main result can be restated as that <code>φx</code> and <code>x = s → (φx ↔ φs)</code> enable us to conclude <code>φs</code>.

<jh>
var (formula φx φs)
thm (VariableToObject ((x s) (x φs))
  ((HSUB (((value x) = s) → (φx ↔ φs)))
   (Hφx φx)
  )
  φs (
        Hφx HSUB detachImplicationBiconditional
        VariableToObjectLemma
))
</jh>

=== Object version of VariableSubstitution axiom ===
The <code>VariableSubstitution</code> axiom is stated in terms of substitution of one variable for another. The analogue in which an object is substituted for a variable also holds.
<jh>
thm (ObjectSubstitution ((x s) (x y) (φ y) (s y)) () 
  (((value x) = s) → (φ → (∀ x (((value x) = s) → φ)))) (
</jh>
The general idea of the proof is to "substitute" <code>s</code> for <code>y</code> using a formula of the form <code>y = s → (''a formula with y in it'' ↔ ''much the same formula, but with s'')</code>.

We start with our substitution, <code>y = s → ((x = y → (φ → ∀ x (x = y → φ))) ↔ (x = s → (φ → ∀ x (x = s → φ))))</code>
<jh>
        (value y) s (value x) EqualityBuilderLL

        (value y) s (value x) EqualityBuilderLL
        φ buildCommonConsequentInConsequent
        x buildForAllInConsequent
        φ buildCommonAntecedentInConsequent

        buildImplicationInConsequent
</jh>
Now we apply <code>VariableToObject</code> to convert the axiom to our desired result.
<jh>
        x y φ VariableSubstitution
        VariableToObject
))
</jh>

=== Two ways to express substitution when variables are distinct ===
In previous sections, we have seen that <code>∃ x (x = s ∧ φ)</code> and <code>∀ x (x = s → φ)</code> behave similarly.  In fact, as long as <code>x</code> and <code>s</code> are distinct, they are completely equivalent.<ref>[http://us.metamath.org/mpeuni/sb56.html sb56] in metamath's set.mm, accessed June 17, 2010, except that <code>s</code> is an <code>object</code> rather than a <code>variable</code></ref>
<jh>
thm (ThereExistsForAll ((x s)) () ((∃ x (((value x) = s) ∧ φ)) ↔ (∀ x (((value x) = s) → φ))) (
</jh>
First we stick something on the proof stack for later use:
<jh>
        x (((value x) = s) → φ) BoundForAllNotFree
</jh>
The proof consists of first proving <code>x = s → (φ ↔ ∀ x (x = s → φ))</code>,
<jh>
        x s φ ObjectSubstitution

        x (((value x) = s) → φ) Specialization
        applyComm

        introduceBiconditionalFromImplicationsInConsequent
</jh>
and then turning this implicit substitution into its ∃ form.
<jh>
        ImplicitThereExistsNotFree
))
</jh>

== Substitution and ∃ ==
We've already seen that <code>∃ x (x = s ∧ φ)</code> is closely related to substitution.  Here we show that it is equivalent to <code>[ s / x ] φ</code>, as long as <code>x</code> does not appear in <code>s</code>.
<jh>
thm (SubstitutionThereExists ((x s) (s y) (x y) (φ y)) () ( (subst s x φ) ↔ (∃ x (((value x) = s) ∧ φ))) (
</jh>
We start with applying some builders to get <code>y = s → (∃ x (x = y ∧ φ) ↔ ∃ x (x = s ∧ φ))</code>.
<jh>
        (value y) s (value x) EqualityBuilderLL
        φ buildConjunctionRRInConsequent
        x buildThereExistsInConsequent
</jh>
<code>ImplicitThereExists</code> then gives us <code>∃ y (y = s ∧ ∃ x (x = y ∧ φ)) ↔ ∃ x (x = s ∧ φ)</code>, which is our desired result by the definition of <code>subst</code>.
<jh>
        ImplicitThereExists
</jh>
Now we just need to apply the definition of <code>subst</code> and we are done:
<jh>
        swapBiconditional
        s x φ y Subst
        swapBiconditional
        applyBiconditionalTransitivity
        swapBiconditional
))
</jh>

== Substitution of a variable which is not free ==
Substituting a formula with a variable which is not free in that formula has no effect.<ref>[http://us.metamath.org/mpeuni/sbf.html sbf], metamath's set.mm, accessed July 20, 2010, except that the replacement is an object not a variable</ref>

<jh>
thm (NullSubstitution ((s x) (x φ)) () ((subst s x φ) ↔ φ) (
</jh>
We begin with <code>[s / x] φ → ∃ x (x = s ∧ φ)</code>.  The distinct variable constraint between <code>x</code> and <code>s</code> might not be needed.
<jh>
        s x φ SubstitutionThereExists
        eliminateBiconditionalReverse
</jh>
Since <code>x</code> is not free in <code>φ</code>, <code>∃ x (x = s ∧ φ)</code> in turn implies <code>∃ x x = s ∧ φ</code>
<jh>
        x ((value x) = s) φ ThereExistsConjunctionRightMovement
        eliminateBiconditionalReverse
        applySyllogism
</jh>
We can eliminate the left hand side of the consequent to get <code>[s / x] φ → φ</code>, which is the forward half of our desired result.
<jh>
        extractRightConjunction
</jh>
The reverse direction is easier. Generalization gets us <code>φ → ∀ x φ</code>, and <code>SpecializationToObject</code> turns that into <code>[s / x] φ</code>
<jh>
        φ x Generalization
        x φ s SpecializationToObject
        applySyllogism
</jh>
Combining the forward and reverse directions finishes the proof.
<jh>
        introduceBiconditionalFromImplications
))
</jh>

== Substitution can be moved across connectives ==
Substituting a formula consisting of a logical connective is equivalent to substituting each of the operands of that connective.

=== Negation ===
For negation, this is <code>[ s / x ] ¬ φ ↔ ¬ [ s / x ] φ</code>.<ref>[http://us.metamath.org/mpeuni/sbn.html sbn] in metamath's set.mm, accessed 2010, except that <code>s</code> is an <code>object</code> rather than a <code>variable</code></ref>

The proof consists of just moving negation around (via the following lemma) and applying <code>ThereExistsForAll</code>.

<jh>
thm (SubstNegationLemma () () 
  ((∀ x (((value x) = s) → (¬ φ))) ↔ (¬ (∃ x (((value x) = s) ∧ φ)))) (
        x s φ equs3
        transposeBiconditionalWithNegatedRight
))

thm (SubstNegation ((y x) (y s)) () ((subst s x (¬ φ)) ↔ (¬ (subst s x φ))) (
        s x (¬ φ) y Subst

        y s (∃ x (((value x) = (value y)) ∧ (¬ φ))) ThereExistsForAll
        applyBiconditionalTransitivity

        x (value y) (¬ φ) ThereExistsForAll
        ((value y) = s) buildImplicationAntecedent
        y buildForAll
        applyBiconditionalTransitivity

        x (value y) φ SubstNegationLemma
        ((value y) = s) buildImplicationAntecedent
        y buildForAll
        applyBiconditionalTransitivity

        y s (∃ x (((value x) = (value y)) ∧ φ)) SubstNegationLemma
        applyBiconditionalTransitivity

        s x φ y Subst swapBiconditional
        addNegation
        applyBiconditionalTransitivity
))
</jh>

== Composition ==
If we first substitute <code>y</code> for <code>x</code>, and then substitute <code>s</code> for <code>y</code>, the whole process is equivalent to substituting <code>s</code> for <code>x</code> (subject to some distinct variable constraints).<ref>sbcco in Raph Levien's [http://levien.com/garden/ghnew/peano/ Peano], accessed 12 Jun 2010. I don't know why the (x y) distinct variable constraint is missing from that version; the second invocation of sbc5 would seem to require it.</ref>
<jh>
thm (SubstitutionComposition ((φ y) (s y) (x y)) ()
  ((subst s y (subst (value y) x φ)) ↔ (subst s x φ)) (
</jh>
The proof consists of rewriting both of the substitutions on the left hand side via <code>SubstitutionThereExists</code>. First we show <code>[ s / y ] [ y / x ] φ ↔ ∃ y (y = s ∧ [ y / x ] φ)</code>.
<jh>
        s y (subst (value y) x φ) SubstitutionThereExists
</jh>
The second invocation of <code>SubstitutionThereExists</code> shows that the right hand side of that expression is equivalent to <code>∃ y (y = s ∧ ∃ x (x = y ∧ φ))</code>
<jh>
        (value y) x φ SubstitutionThereExists
        ((value y) = s) buildConjunctionLL
        y buildThereExists
        applyBiconditionalTransitivity
</jh>
But <code>∃ y (y = s ∧ ∃ x (x = y ∧ φ))</code> is <code>[ s / x ] φ</code>, by definition.
<jh>
        s x φ y Subst
        swapBiconditional applyBiconditionalTransitivity
))
</jh>

== equs4c ==
This is an analogue to equs4 from [[First-order logic]] but for objects not variables:

<jh>
thm (equs4c () () ((∀ x (((value x) = s) → φ)) → (∃ x (((value x) = s) ∧ φ))) (
        (∀ x (((value x) = s) → φ)) ((value x) = s) ConjunctionLeftElimination

        x (((value x) = s) → φ) Specialization
        import

        joinConsequents
</jh>
That gives us <code>((∀ x ((x = y) → φ)) ∧ x = y) → (¬ ((x = y) → (¬ φ)))</code>. We transform the consequent to <code>(¬ (∀ x ((x = y) → (¬ φ))))</code>:
<jh>
        x (((value x) = s) → (¬ φ)) Specialization
        introduceTransposition
        applySyllogism
</jh>
And then we add <code>∀x</code> to the front of that consequent:
<jh>
        x (((value x) = s) → (¬ φ)) BoundForAllNotFree
        negateNotFree
        ForAllAddRemove eliminateBiconditionalForward

        applySyllogism
</jh>
We export and add one more ∀x:
<jh>
        export
        a5i
</jh>
which gives us <code>(∀x(x = s → φ) → ∀x(x = s → ∀x ¬ ∀x(x = s → ¬ φ)))</code>.  The consequent of that is just what we need to apply <code>ax9oc</code>:
<jh>
        x s (¬ (∀ x (((value x) = s) → (¬ φ)))) ax9oc
        applySyllogism
</jh>
so we have simplified the consequent to <code>¬ ∀x(x = y → ¬ φ))</code>. We merely apply <code>equs3</code> to that and we're done.
<jh>
        x s φ equs3 eliminateBiconditionalForward
        applySyllogism
))
</jh>

== Substitution of objects, with axiom of quantifiability ==
The axiom of quantifiability allows us to prove more substitution results because we can assume that a variable can take on a value corresponding to any object.

=== Substitution of a theorem remains a theorem ===
If we have a theorem, we can add a variable substitution onto it.

<jh>
thm (introduceSubst () ((H φ)) (subst s x φ) (
        H
        ((value x) = (value y)) introduceAntecedent
        x generalize

        x (value y) φ equs4c
        applyModusPonens

        ((value y) = s) introduceAntecedent
        y generalize

        y s (∃ x (((value x) = (value y)) ∧ φ)) equs4c
        applyModusPonens

        s x φ y Subst
        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

=== Convert from implicit substitution ===
A statement of the form <code>x = s → (φ ↔ ψ)</code>, where <code>x</code> is not free in <code>ψ</code>, can be thought of as an ''implicit substitution'', as it can be used to relate a formula about <code>x</code> to a formula about <code>s</code>.

Although the distinct variable constraint between <code>x</code> and <code>s</code> should not be necessary (if we wanted to require that <code>x</code> and <code>s</code> are distinct we could have a simpler definition of <code>subst</code>), even the version with the constraint can be useful.

<jh>
thm (convertImplicitToSubst ((x s) (y ψ) (x y)) 
  ((HFREE (x is-not-free-in ψ))
   (HEQ (((value x) = s) → (φ ↔ ψ)))
  )
  ((subst s x φ) ↔ ψ) (
</jh>
The proof will basically consist of two applications of <code>ImplicitSubstitutionThereExists</code>.

First we rewrite <code>x = s → (φ ↔ ψ)</code> as <code>y = s → (x = y → (φ ↔ ψ))</code>
<jh>
        ((value y) = s) ((value x) = (value y)) ConjunctionCommutativity eliminateBiconditionalReverse
        (value x) (value y) s EqualityTransitivity
        applySyllogism

        HEQ
        applySyllogism

        export
</jh>
Now we add ∀x to the consequent:
<jh>
        x addForAllToConsequent
</jh>
The first application of <code>ImplicitSubstitutionThereExists</code> turns <code>∀x(x = y → (φ ↔ ψ))</code> into <code>(∃x x = y ∧ φ) ↔ ψ</code>:
<jh>
        HFREE
        (value y) φ ImplicitSubstitutionThereExists
</jh>
Combining these results gets <code>y = s → ((∃x x = y ∧ φ) ↔ ψ)</code>:
<jh>
        applySyllogism
</jh>
We then apply <code>ImplicitSubstitutionThereExists</code> again to get <code>∃ y (y = s ∧ (∃x x = y ∧ φ)) ↔ ψ)</code>, which is our desired result.
<jh>
        y generalize
        y ψ DistinctNotFree
        s (∃ x (((value x) = (value y)) ∧ φ)) ImplicitSubstitutionThereExists
        applyModusPonens
</jh>
Now we just need to apply the definition of <code>subst</code> and we are done:
<jh>
        swapBiconditional
        s x φ y Subst
        swapBiconditional
        applyBiconditionalTransitivity
        swapBiconditional
))

thm (makeSubstExplicit ((x s) (x ψ))
  ((H (((value x) = s) → (φ ↔ ψ))))
  ((subst s x φ) ↔ ψ) (
        x ψ DistinctNotFree
        H
        convertImplicitToSubst
))
</jh>

== Substituting one quantified variable for another ==
If we have a quantified formula, and we substitute the quantified variable for another (using <code>subst</code>), the formula holds with the substituted variable in the quantifier.  In symbols, this is <code>∀ x φ ↔ ∀ y [ y / x ] φ</code> and <code>∃ x φ ↔ ∃ y [ y / x ] φ</code>, where <code>y</code> is not free in <code>φ</code>.<ref>[http://us.metamath.org/mpeuni/sb8.html sb8] and [http://us.metamath.org/mpeuni/sb8e.html sb8e] in metamath's set.mm, accessed June 24, 2010</ref>

For now, we just prove one direction of these.
<jh>
thm (sb8ForwardNotFree () ((HFREE (y is-not-free-in φ))) ((∀ x φ) → (∀ y (subst (value y) x φ))) (
</jh>
An application of <code>SpecializationToObject</code> gives us <code>∀ x φ → [ y / x ] φ</code>; we just need to observe that <code>y</code> is not free in <code>∀ x φ</code>, which enables us to add the missing <code>∀ y</code>.
<jh>
        HFREE
        x addForAllNotFree

        x φ (value y) SpecializationToObject

        addForAllToConsequentNotFree
))

thm (sb8eReverseNotFree () ((HFREE (y is-not-free-in φ))) ((∃ y (subst (value y) x φ)) → (∃ x φ)) (
        HFREE
        negateNotFree
        x sb8ForwardNotFree

        introduceTransposition
</jh>
That gives us <code>¬ ∀ y [ y / x ] ¬ φ → ¬ ∀ x ¬ φ</code>, and we just need to move around the negations to get our desired result.  We start with the consequent.
<jh>
        x (¬ φ) NotForAll
        φ DoubleNegation x buildThereExists swapBiconditional
        applyBiconditionalTransitivity

        eliminateBiconditionalReverse
        applySyllogism
</jh>
The antecedent is similar but has one more step because of the substitution.
<jh>
        y (subst (value y) x (¬ φ)) NotForAll

        (value y) x (¬ φ) SubstNegation swapBiconditional
        y buildThereExists
        applyBiconditionalTransitivity

        φ DoubleNegation swapBiconditional
        (value y) x buildSubst
        y buildThereExists
        applyBiconditionalTransitivity

        transformAntecedent
))
</jh>

Here is a version with implicit substitution. Think of <code>φx</code> and <code>φy</code> as two versions of the same formula, but where <code>x</code> has been changed to <code>y</code>. More formally, <code>y</code> does not appear in <code>φx</code>, <code>x</code> does not appear in <code>φy</code>, and <code>x = y → (φx ↔ φy)</code>. This lets us conclude <code>∃ y φy ↔ ∃ x φx</code>.

The <code>(x y)</code> distinct variable constraint is subject to the same commentary as <code>(x s)</code> in <code>makeSubstExplicit</code> (that is, that it might not be necessary).

We first prove the reverse implication.
<jh>
var (formula φy)
thm (ChangeVariableThereExistsReverse ((y φx) (x φy) (x y)) ((H (((value x) = (value y)) → (φx ↔ φy)))) ((∃ y φy) → (∃ x φx)) (
</jh>
First we show <code>∃ y φy → ∃ y [ y / x ] φx</code>.
<jh>
        H makeSubstExplicit
        eliminateBiconditionalForward
        y addThereExists
</jh>
We then transform the right hand side to <code>∃ x φx</code>, and we are done.
<jh>
        y φx DistinctNotFree
        x sb8eReverseNotFree
        applySyllogism
))
</jh>

The reverse direction is an easy consequence, but to prove it we do need to commute the equality and the biconditional.
<jh>
thm (ChangeVariableThereExistsForward ((y φx) (x φy) (x y)) ((H (((value x) = (value y)) → (φx ↔ φy)))) ((∃ x φx) → (∃ y φy)) (
        H

        (value x) (value y) EqualitySymmetry
        φx φy BiconditionalSymmetry
        buildImplication

        eliminateBiconditionalReverse
        applyModusPonens

        ChangeVariableThereExistsReverse
))

thm (ChangeVariableThereExists ((y φx) (x φy) (x y)) ((H (((value x) = (value y)) → (φx ↔ φy)))) ((∃ x φx) ↔ (∃ y φy)) (
        H
        ChangeVariableThereExistsForward

        H
        ChangeVariableThereExistsReverse

        introduceBiconditionalFromImplications
))
</jh>

== Export ==
That gives us [[Interface:First-order logic with quantifiability]], which we now export.
<jh>
export (WITH_QUANTIFIABILITY Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
</jh>

== Footnotes ==
<references/>

== Cited works ==
Hirst, Holly P. and Hirst, Jeffry L. (2008-2009 Edition), ''[http://www.mathsci.appstate.edu/~jlh/primer/hirst.pdf A Primer for Logic and Proof]'', self-published on the web by [http://www.mathsci.appstate.edu/~jlh/ Jeff Hirst]

[[Category:Classical first-order logic]]

