{{header
 | title    = Relations
 | subtitle = 
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = Here we start with [[Interface:Basic operations of Zermelo–Fraenkel set theory]] and provide ordered pairs, relations, and functions. }}
{{interfaces
| imports = [[Interface:Basic operations of Zermelo–Fraenkel set theory]]
| exports = [[Interface:Set theory]]
}}

We first import [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|first-order logic]].
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
</jh>

We also import [[Interface:Basic operations of Zermelo–Fraenkel set theory]], which is the current home of some of the basic results involving singletons, unordered pairs, and the like. 
<jh>
import (BASIC Interface:Basic_operations_of_Zermelo–Fraenkel_set_theory (CLASSICAL FIRSTORDER) ())
</jh>

As usual, capital letters starting from <code>A</code> are set expressions (that is, objects or "classes") and lowercase letters starting with <code>x</code> are set variables.
<jh>
var (object A B C D A0 A1 B0 B1)
var (variable x y z w x′ y′ z′)
</jh>

== Singletons ==
Logically, these theorems belong with the other singleton theorems in [[First steps in set theory]]. However, until JHilbert changes its handling of dummy variables in definitions, it may be easier to handle them here.

=== A set is an element of its singleton ===
Here we show <code>A ∈ {A}</code>.<ref>[http://us.metamath.org/mpeuni/snid.html snid], metamath's set.mm, accessed August 5, 2010</ref>
<jh>
thm (SingletonMembership () () (A ∈ (singleton A)) (
        A EqualityReflexivity

        A A Singleton
        eliminateBiconditionalForward

        applyModusPonens
))
</jh>

== Unordered pairs ==
Logically, these theorems belong with the other unordered pair theorems in [[First steps in set theory]]. However, until JHilbert changes its handling of dummy variables in definitions, it may be easier to handle them here.

=== An unordered pair contains its first member ===
Here we show that <code>A ∈ {A, B}</code>.<ref>[http://us.metamath.org/mpeuni/prid1.html prid1], metamath's set.mm, accessed August 4, 2010.</ref>
<jh>
thm (UnorderedPairLeftMembership () () (A ∈ (unorderedPair A B)) (
        A EqualityReflexivity
        (A = B) introduceRightDisjunction

        A A B UnorderedPair
        eliminateBiconditionalForward

        applyModusPonens
))
</jh>

=== Unordered pair commutativity ===
Unordered pairs are unordered: <code>{A, B} = {B, A}</code>.
<jh>
thm (UnorderedPairCommutativity ((x A) (x B)) () ((unorderedPair A B) = (unorderedPair B A)) (
        (value x) A B UnorderedPair

        ((value x) = A) ((value x) = B) DisjunctionCommutativity
        applyBiconditionalTransitivity

        (value x) B A UnorderedPair
        swapBiconditional
        applyBiconditionalTransitivity

        x generalize
        x (unorderedPair A B) (unorderedPair B A) ExtensionalityObject

        applyModusPonens
))
</jh>

=== Unordered pair equality can imply equality of members ===
Here we prove <code>{A, C} = {B, C} → A = B</code>.<ref>[http://us.metamath.org/mpeuni/preqr1.html preqr1], metamath's set.mm, accessed August 4, 2010</ref>

First we prove a lemma, <code>{A, C} = {B, C} → A = B ∨ A = C</code>
<jh>
thm (UnorderedPairFirstMembersEqual-1 () () (((unorderedPair A C) = (unorderedPair B C)) → ((A = B) ∨ (A = C))) (
        A C UnorderedPairLeftMembership

        (unorderedPair A C) (unorderedPair B C) A IsElementBuilderLL

        detachImplicationBiconditional
</jh>
That gives us <code>{A, C} = {B, C} → A ∈ {B, C}</code>.
<jh>
        A B C UnorderedPair
        eliminateBiconditionalReverse
        applySyllogism
))

thm (UnorderedPairFirstMembersEqual () () (((unorderedPair A C) = (unorderedPair B C)) → (A = B)) (
</jh>
We apply our lemma once to get <code>{A, C} = {B, C} → A = B ∨ A = C</code>
<jh>
        A C B UnorderedPairFirstMembersEqual-1

</jh>
Applying the lemma a second time, with some commutations, gives us <code>{A, C} = {B, C} → A = B ∨ B = C</code>
<jh>
        (unorderedPair A C) (unorderedPair B C) EqualitySymmetry
        eliminateBiconditionalReverse
        B C A UnorderedPairFirstMembersEqual-1
        applySyllogism

        B A EqualitySymmetry
        transformImplicationDisjunctionLeft
</jh>
We now combine the two results to get <code>{A, C} = {B, C} → (A = B ∨ A = C) ∧ (A = B ∨ B = C)</code>, and apply distributivity to the right hand side to turn it into <code>A = B ∨ (A = C ∧ B = C)</code>.
<jh>
        composeConjunction
        (A = B) (A = C) (B = C) DisjunctionLeftDistribution
        eliminateBiconditionalForward
        applySyllogism
</jh>
We turn <code>A = C ∧ B = C</code> into <code>A = B</code>, and after a bit more rearrangement, we are done.
<jh>
        B C EqualitySymmetry
        eliminateBiconditionalReverse
        (A = C) conjoinLL
        A C B EqualityTransitivity
        applySyllogism

        (A = B) disjoinLL
        applySyllogism

        (A = B) DisjunctionIdempotence
        eliminateBiconditionalForward
        applySyllogism
))
</jh>

Here is a commuted version: <code>{C, A} = {C, B} → A = B</code>.<ref>[http://us.metamath.org/mpeuni/preqr2.html preqr2], metamath's set.mm, accessed August 4, 2010</ref>
<jh>
thm (UnorderedPairSecondMembersEqual () () (((unorderedPair C A) = (unorderedPair C B)) → (A = B)) (
        C A UnorderedPairCommutativity
        C B UnorderedPairCommutativity
        buildEquality
        eliminateBiconditionalReverse

        A C B UnorderedPairFirstMembersEqual
        applySyllogism
))
</jh>

== Ordered pair ==
The ordered pair <code>〈A, B〉</code> can be defined in several ways as long as the definition implies the key ordered pair theorem <code>〈A0, B0〉=〈A1, B1〉↔ A0 = A1 ∧ B0 = B1</code>. The most widely adopted definition is <code>〈A, B〉≝ { {A}, {A, B} }</code>, which is the one we use. Because the notation <code>〈A, B〉</code> is not available in JHilbert, we call it <code>(orderedPair A B)</code>.
<jh>
def ((orderedPair A B) (unorderedPair (singleton A) (unorderedPair A B)))
</jh>

=== Ordered pair builder ===
Equals can be substituted for equals in ordered pairs, that is, <code>A0 = A1 ∧ B0 = B1 →〈A0, B0〉=〈A1, B1〉</code>. This forms one direction of the ordered pair theorem (it is the less interesting of the two, as it holds for a wide variety of operations, not just ordered pairs).
<jh>
thm (OrderedPairBuilder () () (((A0 = A1) ∧ (B0 = B1)) → ((orderedPair A0 B0) = (orderedPair A1 B1))) (
        (A0 = A1) (B0 = B1) ConjunctionRightElimination
        A0 A1 SingletonBuilder
        applySyllogism

        A0 A1 B0 B1 UnorderedPairBuilder

        composeConjunction

        (singleton A0) (singleton A1) (unorderedPair A0 B0) (unorderedPair A1 B1) UnorderedPairBuilder
        applySyllogism
))
</jh>

We also provide the usual convenience builders.
<jh>
thm (OrderedPairBuilderLL () () ((B0 = B1) → ((orderedPair A B0) = (orderedPair A B1))) (
        A EqualityReflexivity
        A A B0 B1 OrderedPairBuilder
        export
        applyModusPonens
))

thm (OrderedPairBuilderRR () () ((A0 = A1) → ((orderedPair A0 B) = (orderedPair A1 B))) (
        B EqualityReflexivity
        A0 A1 B B OrderedPairBuilder
        export
        applyComm
        applyModusPonens
))
</jh>

=== First half of the ordered pair theorem ===
In this section we prove <code>〈A0, B0〉=〈A1, B1〉→ A0 = A1</code>.

Our first lemma is <code>{A} ∈ 〈A, B〉</code>a simple consequence of our definition of ordered pair.<ref>[http://us.metamath.org/mpeuni/opi1.html opi1], metamath's set.mm, accessed August 5, 2010.</ref>
<jh>
thm (OrderedPairTheoremForwardFirst-1 () () ((singleton A) ∈ (orderedPair A B)) (
        (singleton A) (unorderedPair A B) UnorderedPairLeftMembership
))
</jh>

The next lemma, <code>A ∈ 〈B, C〉 ↔ A = {B} ∨ A = {B, C}</code>, also follows directly from our definition of ordered pair.<ref>[http://us.metamath.org/mpeuni/elop.html elop], metamath's set.mm, accessed August 5, 2010.</ref>
<jh>
thm (OrderedPairTheoremForwardFirst-2 () () ((A ∈ (orderedPair B C)) ↔ ((A = (singleton B)) ∨ (A = (unorderedPair B C)))) (
         A (singleton B) (unorderedPair B C) UnorderedPair
))
</jh>

We're ready for <code>〈A0, B0〉=〈A1, B1〉→ A0 = A1</code>. We rename the variables in an effort to make the proof easier to read: <code>〈A, B〉=〈C, D〉→ A = C</code><ref>[http://us.metamath.org/mpeuni/opth1.html opth1], metamath's set.mm, accessed August 5, 2010.</ref>
<jh>
thm (OrderedPairTheoremForwardFirst () () (((orderedPair A B) = (orderedPair C D)) → (A = C)) (
</jh>
The first step is <code>〈A, B〉=〈C, D〉 → ({C} ∈ 〈A, B〉 ↔ {C} ∈ 〈C, D〉)</code>, from our builder for <code>∈</code>.

But <code>{C} ∈ 〈C, D〉</code> is true unconditionally, so this formula reduces to <code>〈A, B〉=〈C, D〉 → {C} ∈ 〈A, B〉</code>.
<jh>
        C D OrderedPairTheoremForwardFirst-1
        (orderedPair A B) (orderedPair C D) (singleton C) IsElementBuilderLL
        detachImplicationBiconditionalRight
</jh>
We now apply our other lemma to turn <code>{C} ∈ 〈A, B〉</code> into <code>{C} = {A} ∨ {C} = {A, B}</code>.
<jh>
        (singleton C) A B OrderedPairTheoremForwardFirst-2
        eliminateBiconditionalReverse
        applySyllogism
</jh>
We'll show that each half of <code>{C} = {A} ∨ {C} = {A, B}</code> implies <code>A ∈ {C}</code>.  The left half follows from <code>{C} = {A} → (A ∈ {C} ↔ A ∈ {A})</code> once we detach the theorem <code>A ∈ {A}</code>.
<jh>
        A SingletonMembership
        (singleton C) (singleton A) A IsElementBuilderLL
        detachImplicationBiconditionalRight
</jh>
The right half is similar: the builder gives us <code>{C} = {A, B} → (A ∈ {C} ↔ A ∈ {A, B})</code> and we can detach <code>A ∈ {A, B}</code>.
<jh>
        A B UnorderedPairLeftMembership
        (singleton C) (unorderedPair A B) A IsElementBuilderLL
        detachImplicationBiconditionalRight
</jh>
We now compose the two and combine with our earlier result to get <code>〈A, B〉=〈C, D〉 → A ∈ {C}</code>
<jh>
        composeDisjunction
        applySyllogism
</jh>
Transforming <code>A ∈ {C}</code> to <code>A = C</code> finishes the proof.
<jh>
        A C Singleton
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

=== Second half of the ordered pair theorem ===
In this section we prove <code>〈A0, B0〉=〈A1, B1〉→ B0 = B1</code>.

Our first lemma is <code>〈C, D〉=〈C, B〉→ D = B</code>.<ref>Taken from a portion of the proof of [http://us.metamath.org/mpeuni/opth.html opth], metamath's set.mm, accessed August 6, 2010.</ref>
<jh>
thm (OrderedPairTheoremForwardSecond-1 () () (((orderedPair C D) = (orderedPair C B)) → (D = B)) (
</jh>
The definition of ordered pair gives us <code>{{C}, {C, D}} = {{C}, {C, B}}</code> and two applications of <code>UnorderedPairSecondMembersEqual</code> give us <code>D = B</code>.
<jh>
        (singleton C) (unorderedPair C D) (unorderedPair C B) UnorderedPairSecondMembersEqual
        C D B UnorderedPairSecondMembersEqual
        applySyllogism
))
</jh>

The next lemma is most of the work. It is <code>〈A, B〉=〈C, D〉→ (A = C → D = B)</code>.
<jh>
thm (OrderedPairTheoremForwardSecond-2 () () (((orderedPair A B) = (orderedPair C D)) → ((A = C) → (D = B))) (
</jh>
We start with <code>〈A, B〉=〈C, D〉→ (〈A, B〉=〈C, B〉 ↔ 〈C, D〉=〈C, B〉)</code>.
<jh>
        (orderedPair A B) (orderedPair C D) (orderedPair C B) EqualityBuilderRR
</jh>
The ordered pair builder and a bit of rearrangment turns that into <code>〈A, B〉=〈C, D〉→ (A = C → 〈C, D〉=〈C, B〉)</code>.
<jh>
        ((orderedPair A B) = (orderedPair C B)) ((orderedPair C D) = (orderedPair C B)) BiconditionalReverseElimination
        applySyllogism

        A C B OrderedPairBuilderRR
        ((orderedPair C D) = (orderedPair C B)) addCommonConsequent
        applySyllogism
</jh>
Applying the lemma <code>OrderedPairTheoremForwardSecond-1</code> turns this into <code>〈A, B〉=〈C, D〉→ (A = C → D = B)</code>, our desired result.
<jh>
        C D B OrderedPairTheoremForwardSecond-1
        (A = C) addCommonAntecedent
        applySyllogism
))
</jh>

We now combine <code>〈A, B〉=〈C, D〉→ A = C</code> and <code>〈A, B〉=〈C, D〉→ (A = C → D = B)</code> to get <code>〈A, B〉=〈C, D〉→ B = D</code>.
<jh>
thm (OrderedPairTheoremForwardSecond () () (((orderedPair A B) = (orderedPair C D)) → (B = D)) (
        A B C D OrderedPairTheoremForwardFirst
        A B C D OrderedPairTheoremForwardSecond-2
        applyModusPonensInConsequent

        D B EqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

=== Ordered pair theorem ===
We are now ready to combine these results to prove the ordered pair theorem <code>〈A0, B0〉=〈A1, B1〉↔ A0 = A1 ∧ B0 = B1</code>. We prove the forward implication,
<jh>
thm (OrderedPairTheoremForward () () (((orderedPair A0 B0) = (orderedPair A1 B1)) → ((A0 = A1) ∧ (B0 = B1))) (
        A0 B0 A1 B1 OrderedPairTheoremForwardFirst
        A0 B0 A1 B1 OrderedPairTheoremForwardSecond
        composeConjunction
))
</jh>

and the biconditionalized theorem.
<jh>
thm (OrderedPairTheorem () () (((orderedPair A0 B0) = (orderedPair A1 B1)) ↔ ((A0 = A1) ∧ (B0 = B1))) (
        A0 B0 A1 B1 OrderedPairTheoremForward
        A0 A1 B0 B1 OrderedPairBuilder
        introduceBiconditionalFromImplications
))
</jh>

== Relations ==
A relation is a set of ordered pairs. We typically use the letters R, S, T, and U for relations.
<jh>
def ((relation A) (∀ z (((value z) ∈ A) → (∃ x (∃ y ((value z) = (orderedPair (value x) (value y))))))))
var (object R S T U)
</jh>

Here we prove a theorem form of the definition. The distinct variable constraints are needed for soundness (analogous to the distinct variable constraints in, for example, metamath's dfss2<ref>[http://us.metamath.org/mpeuni/dfss2.html dfss2], metamath's set.mm, accessed 1 Oct 2010</ref>).
<jh>
thm (Relation ((x y z A) (x′ y′ z′ x y z A)) ()
  ((relation A) ↔ (∀ z (((value z) ∈ A) → (∃ x (∃ y ((value z) = (orderedPair (value x) (value y)))))))) (
</jh>
To prove this we need to prove that the truth of the formula doesn't depend on the choice of variables for <code>x</code>, <code>y</code>, and <code>z</code>. In other words, <code>∀ z′ (z′ ∈ A → ∃ x′ ∃ y′ z′ = 〈x′, y′〉) ↔ ∀ z (z ∈ A → ∃ x ∃ y z = 〈x, y〉)</code>

We'll first worry about the explicit substitutions and getting them in the right place relative to the quantifiers. We work from the outside in, so the first step is <code>∀ z (z ∈ A → ∃ x ∃ y z = 〈x, y〉) ↔ ∀ z′ [z′ / z] (z ∈ A → ∃ x ∃ y z = 〈x, y〉)</code>
<jh>
        z (((value z) ∈ A) → (∃ x (∃ y ((value z) = (orderedPair (value x) (value y)))))) z′ ChangeVariableExplicitForAll
</jh>
We now move the substitution inside all quantifiers.
<jh>
        (value z′) z ((value z) ∈ A) (∃ x (∃ y ((value z) = (orderedPair (value x) (value y))))) SubstImplication
        z′ buildForAll
        applyBiconditionalTransitivity

        (value z′) z x (∃ y ((value z) = (orderedPair (value x) (value y)))) SubstThereExists
        (subst (value z′) z ((value z) ∈ A)) buildImplicationAntecedent
        z′ buildForAll
        applyBiconditionalTransitivity

        (value z′) z y ((value z) = (orderedPair (value x) (value y))) SubstThereExists
        x buildThereExists
        (subst (value z′) z ((value z) ∈ A)) buildImplicationAntecedent
        z′ buildForAll
        applyBiconditionalTransitivity
</jh>
That gives us <code>∀ z (z ∈ A → ∃ x ∃ y z = 〈x, y〉) ↔ ∀ z′ ([z′ / z] z ∈ A → ∃ x ∃ y [z′ / z] z = 〈x, y〉)</code>. The next step is to add the substitution for <code>x′</code>.
<jh>
        x (∃ y (subst (value z′) z ((value z) = (orderedPair (value x) (value y))))) x′ ChangeVariableExplicitThereExists
        (subst (value z′) z ((value z) ∈ A)) buildImplicationAntecedent
        z′ buildForAll
        applyBiconditionalTransitivity

        (value x′) x y (subst (value z′) z ((value z) = (orderedPair (value x) (value y)))) SubstThereExists
        x′ buildThereExists
        (subst (value z′) z ((value z) ∈ A)) buildImplicationAntecedent
        z′ buildForAll
        applyBiconditionalTransitivity
</jh>
That gives us <code>∀ z (z ∈ A → ∃ x ∃ y z = 〈x, y〉) ↔ ∀ z′ ([z′ / z] z ∈ A → ∃ x′ ∃ y [x′ / x] [z′ / z] z = 〈x, y〉)</code>. The next step is to add the substitution for <code>y′</code>.
<jh>
        y (subst (value x′) x (subst (value z′) z ((value z) = (orderedPair (value x) (value y))))) y′ ChangeVariableExplicitThereExists
        x′ buildThereExists
        (subst (value z′) z ((value z) ∈ A)) buildImplicationAntecedent
        z′ buildForAll
        applyBiconditionalTransitivity
</jh>
Now we perform the substitutions. The first one is <code>[z′ / z] z ∈ A ↔ z′ ∈ A</code>.
<jh>
        (value z) (value z′) A IsElementBuilderRR
        makeSubstExplicit
</jh>
The next is <code>[z′ / z] z = 〈x, y〉 ↔ z′ = 〈x, y〉</code>.
<jh>
        (value z) (value z′) (orderedPair (value x) (value y)) EqualityBuilderRR
        makeSubstExplicit

        (value x′) x buildSubst
</jh>
The next is <code>[x′ / x] z′ = 〈x, y〉 ↔ z′ = 〈x′, y〉</code>.
<jh>
        (value x) (value x′) (value y) OrderedPairBuilderRR
        (value z′) buildEqualityLLInConsequent
        makeSubstExplicit
        applyBiconditionalTransitivity

        (value y′) y buildSubst
</jh>
The next is <code>[y′ / y] z′ = 〈x′, y〉 ↔ z′ = 〈x′, y′〉</code>.
<jh>
        (value y) (value y′) (value x′) OrderedPairBuilderLL
        (value z′) buildEqualityLLInConsequent
        makeSubstExplicit
        applyBiconditionalTransitivity
</jh>
We combine with the <code>z ∈ A</code> substitution.
<jh>
        y′ buildThereExists
        x′ buildThereExists

        buildImplication
        z′ buildForAll
        applyBiconditionalTransitivity
</jh>
We have proved <code>∀ z (z ∈ A → ∃ x ∃ y z = 〈x, y〉) ↔ ∀ z′ (z′ ∈ A → ∃ x′ ∃ y′ z′ = 〈x′, y′〉)</code>. JHilbert will unify the one with the primes with <code>(relation A)</code>, if we just put it on the left hand side.
<jh>
        swapBiconditional
))
</jh>

A relation for two objects holds if and only if the corresponding ordered pair is an element of the relation. A more conventional notation would just write this as <code>A R B</code> rather than <code>relates A R B</code>,<ref>[http://us.metamath.org/mpeuni/wbr.html wbr], metamath's set.mm, accessed September 18, 2010</ref> but JHilbert does not offer that option.
<jh>
def ((relates A R B) ((orderedPair A B) ∈ R))
</jh>

== To be added ==
Either here or in other set theory files: induction, recursion, ordinal successors. some kinds of unions, intersection, set difference, and so on.

== Export ==
When we've proved everything in it, we'll export to [[Interface:Set theory]].
<jh>
#export (SETS Interface:Set_theory (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>

[[Category:Other classical set theory]]

