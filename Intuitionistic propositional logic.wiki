{{header
 | title    = Intuitionistic propositional logic
 | subtitle =
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = The purpose of this page is to prove the statements of [[Interface:Intuitionistic propositional logic]] from the [[Interface:Axioms of intuitionistic propositional logic]].
}}
{{interfaces
| imports = [[Interface:Axioms of intuitionistic propositional logic]]
| exports = eventually [[Interface:Intuitionistic propositional logic]]
}}

{{under construction}}
<jh>
import (AXIOMS Interface:Axioms_of_intuitionistic_propositional_logic () ())
</jh>
We define some variables for [[w:well-formed formula|well-formed formula]]s:
<jh>
var (formula p q r s)
</jh>

Some of the proofs here are adapted, or even entirely copy-pasted, from pages such as [[Principia Mathematica propositional logic]] or [[Standard axioms imply Principia Mathematica axioms]]. It would be possible to reduce this duplication by having some of the other pages build on [[Interface:Intuitionistic propositional logic]], but the presentation might become less clear in other ways (certainly it would less closely track the way things are developed in ''Principia''), so we do not currently have the intuitionistic tail wag the classical dog.

Some proofs are taken from metamath's set.mm.  In particular, metamath's section "Logical implication" makes use only of the two axioms <code>Simp</code> and <code>Frege</code>, and thus is entirely valid in an intuitionistic context.<ref>[http://us.metamath.org/mpeuni/mmtheorems.html#mm2b Propositional calculus], from Metamath Proof Explorer, accessed February 26, 2010</ref>

== Implication ==

=== Rule for antecedent distribution ===

It will be convenient to have the ''Frege'' axiom as a rule:
<jh>
thm (distributeAntecedent () ((H (p → (q → r)))) ((p → q) → (p → r)) (
        H
        p q r Frege
        applyModusPonens
))
</jh>

=== Syllogism ===

Next we derive the syllogism, which allows us to combine several implications.
<jh>
thm (applySyllogism () ((H1 (p → q)) (H2 (q → r))) (p → r) (
        H1

</jh>
First we turn <code>q → r</code> into <code>p → (q → r)</code>:
<jh>
        H2
        (q → r) p Simp
        applyModusPonens

</jh>
Then we turn that into <code>(p → q) → (p → r)</code>:
<jh>
        distributeAntecedent

</jh>
Now we can apply modus ponens to get our desired result:
<jh>
        applyModusPonens
))
</jh>

=== Implication reflexivity ===

Any proposition implies itself:
<jh>
thm (Id () () (p → p) (
        p p Simp

        p (p → p) Simp
        p (p → p) p Frege
        applyModusPonens

        applyModusPonens
))

# Alternate name for the same theorem:
thm (ImplicationReflexivity () () (p → p) (
        p Id
))
</jh>

=== More common operations ===
Given a nested implication we often want to exchange the two antecedents:
<jh>
thm (applyComm () ((H (p → (q → r)))) (q → (p → r)) (
        q p Simp

        H
        distributeAntecedent

        applySyllogism
))
</jh>

If we have an implication, adding a common term to the antecedent and the consequent yields a new theorem:
<jh>
thm (CommonAntecedentAddition () () ((p → q) → ((r → p) → (r → q))) (
        (p → q) r Simp
        r p q Frege
        applySyllogism
))

thm (addCommonAntecedent () ((H (p → q))) ((r → p) → (r → q)) (
        H
        (p → q) r Simp
        applyModusPonens

        distributeAntecedent
))
</jh>

The analogous operation adding consequents swaps the initial antecedent and consequent:
<jh>
thm (CommonConsequentAddition () () 
  ((p → q) → ((q → r) → (p → r))) (
        q r p CommonAntecedentAddition
        applyComm
))

thm (addCommonConsequent () ((H (p → q))) ((q → r) → (p → r)) (
        H

        p q r CommonConsequentAddition

        applyModusPonens
))
</jh>

Here's a theorem form of <code>applyComm</code>:
<jh>
thm (Comm () () ((p → (q → r)) → (q → (p → r))) (
        p q r Frege

        q p Simp
        (p → r) addCommonConsequent

        applySyllogism
))
</jh>

=== Absorb redundant antecedent ===

We can absorb a redundant antecedent:
<jh>
thm (RedundantAntecedentAbsorption () ()
  ((p → (p → q)) → (p → q)) (
        p Id

        p p q Frege
        applyComm

        applyModusPonens
))

thm (absorbRedundantAntecedent () ((H (p → (p → q)))) (p → q) (
        p Id

        H
        distributeAntecedent

        applyModusPonens
))
</jh>

=== Antecedent introduction ===
We provide another name and a rule form for the <code>Simp</code> axiom:
<jh>
thm (AntecedentIntroduction () () (p → (q → p)) (
        p q Simp
))

thm (introduceAntecedent () ((H p)) (q → p) (
        H
        p q AntecedentIntroduction
        applyModusPonens
))
</jh>

=== Converse of antecedent distribution ===
The converse of the <code>Frege</code> axiom also holds.<ref>[http://us.metamath.org/mpeuni/pm2.86.html pm2.86] in metamath's set.mm, accessed May 14, 2010</ref>
<jh>
thm (FregeConverse () () (((p → q) → (p → r)) → (p → (q → r))) (
</jh>
We start with <code>q → (p → q)</code>:
<jh>
        q p Simp
</jh>
Adding a common consequent gets us most of the way, to <code>((p → q) → (p → r)) → (q → (p → r))</code>:
<jh>
        (p → r) addCommonConsequent
</jh>
Now we just switch <code>p</code> and <code>q</code> in <code>q → (p → r)</code> and we're done:
<jh>
        q p r Comm
        applySyllogism
))
</jh>

=== Syllogism in the consequent ===
This theorem is similar to syllogism, but where each piece has a common antecedent.
<jh>
thm (SyllogismInConsequent () () ((p → (q → r)) → ((p → (r → s)) → (p → (q → s)))) (
        q r s CommonConsequentAddition
        p addCommonAntecedent

        p (r → s) (q → s) Frege
        applySyllogism
))

thm (applySyllogismInConsequent () ((H1 (p → (q → r))) (H2 (p → (r → s)))) (p → (q → s)) (
        H2
        H1
        p q r s SyllogismInConsequent
        applyModusPonens
        applyModusPonens
))
</jh>

== Conjunction ==

=== Rules ===
If we can prove two propositions, the conjunction of the two follows (this is just a rule form of the <code>ConjunctionRightIntroduction</code> axiom):
<jh>
thm (introduceConjunction ()
  ((HLEFT p) (HRIGHT q))
  (p ∧ q) (
        HRIGHT
        HLEFT
        p q ConjunctionRightIntroduction
        applyModusPonens
        applyModusPonens
))
</jh>

Here are rules for the <code>ConjunctionLeftElimination</code> and <code>ConjunctionRightElimination</code> axioms:
<jh>
thm (eliminateLeftConjunction () ((H (p ∧ q))) q (
        H
        p q ConjunctionLeftElimination
        applyModusPonens
))

thm (eliminateRightConjunction () ((H (p ∧ q))) p (
        H
        p q ConjunctionRightElimination
        applyModusPonens
))
</jh>

=== Left introduction ===
Most of the introduction and elimination statements we need to provide are axioms, but this one is a simple consequence of the axioms:
<jh>
thm (ConjunctionLeftIntroduction () () (p → (q → (q ∧ p))) (
        q p ConjunctionRightIntroduction
        applyComm
))
</jh>

=== Conjunction composition ===
Our first major theorem relating conjunction to implication is composition: from <code>p → q</code> and <code>p → r</code>, we can conclude <code>p → (q ∧ r)</code>.
<jh>
thm (ConjunctionComposition1 () () ((p → q) → ((p → r) → (p → (q ∧ r)))) (
</jh>
The proof starts with <code>q → (r → (q ∧ r))</code>:
<jh>
        q r ConjunctionRightIntroduction
</jh>
and then adds <code>p</code> as an antecedent to each of <code>q</code>, <code>r</code>, and <code>q ∧ r</code>:
<jh>
        p addCommonAntecedent

        p r (q ∧ r) Frege
        applySyllogism
))

thm (composeConjunction () ((HQ (p → q)) (HR (p → r))) (p → (q ∧ r)) (
        HR
        HQ
        p q r ConjunctionComposition1
        applyModusPonens
        applyModusPonens
))
</jh>

We also prove a version of the converse:
<jh>
thm (ConjunctionCompositionReverse () () ((p → (q ∧ r)) → ((p → q) ∧ (p → r))) (
</jh>
We start with <code>(p → (q ∧ r)) → (p → q)</code>:
<jh>
        q r ConjunctionRightElimination
        p addCommonAntecedent
</jh>
And the analogue for <code>r</code>, <code>(p → (q ∧ r)) → (p → r)</code>:
<jh>
        q r ConjunctionLeftElimination
        p addCommonAntecedent
</jh>
Combining the two gives us our result:
<jh>
        composeConjunction
))
</jh>

=== Export and import ===
The import and export theorems from classical propositional logic also hold in intuitionistic logic. We start with export, <code>(p ∧ q → r) → (p → (q → r))</code>. The proof is based around a variant of CommonConsequentAddition which has two antecedents, rather than one.

<jh>
var (formula common)
thm (CommonConsequentAdditionToNestedImplication () ()
  ((p → (q → r)) → ((r → common) → (p → (q → common)))) (
        r common q CommonAntecedentAddition
        (q → r) (q → common) p CommonAntecedentAddition
        applySyllogism

        applyComm
))

thm (Exportation () () (((p ∧ q) → r) → (p → (q → r))) (
        p q ConjunctionRightIntroduction
        p q (p ∧ q) r CommonConsequentAdditionToNestedImplication
        applyModusPonens
))

thm (export () ((H ((p ∧ q) → r))) (p → (q → r)) (
        H
        p q r Exportation
        applyModusPonens
))
</jh>

The proof of export was based around having a conjunction as a consequent, that is <code>p → (q → p ∧ q)</code>.  The proof of import is based around <code>p ∧ q → p</code> (and likewise for <code>q</code>). The following lemma is what we'll use to glue together the different parts of the proof, and is basically a gussied up variant of applySyllogism:

<jh>
var (formula P Q R)
thm (ImportLemma () 
  ((H1 (P → (Q → R))) (H2 (R → (Q → r))))
  (P → (Q → r)) (
        H1

        H2
        Q addCommonAntecedent

        applySyllogism
</jh>
Now we have <code>P → (Q → (Q → r))</code>, and just need to remove the extra <code>Q</code>:
<jh>
        Q r RedundantAntecedentAbsorption
        applySyllogism
))

thm (Importation () () ((p → (q → r)) → ((p ∧ q) → r)) (
        p q ConjunctionRightElimination
        (q → r) addCommonConsequent

        p q ConjunctionLeftElimination
        r addCommonConsequent

        ImportLemma
))

thm (import () ((H (p → (q → r)))) ((p ∧ q) → r) (
        H
        p q r Importation
        applyModusPonens
))
</jh>

=== Implication transitivity and other consequences of import ====
The form of the syllogism in [[Interface:Intuitionistic propositional logic]] is easy now that we have import:

<jh>
thm (ImplicationTransitivity () () 
  (((p → q) ∧ (q → r)) → (p → r)) (
        p q r CommonConsequentAddition
        import
))
</jh>

Likewise, we restate <code>ConjunctionComposition1</code> using the new tool:
<jh>
thm (ConjunctionCompositionForward () () (((p → q) ∧ (p → r)) → (p → (q ∧ r))) (
        p q r ConjunctionComposition1
        import
))
</jh>

=== Commutativity ===
<jh>
thm (ConjunctionCommutativityImplication () () ((p ∧ q) → (q ∧ p)) (
        p q ConjunctionLeftElimination
        p q ConjunctionRightElimination
        composeConjunction
))
</jh>

=== Builders ===

==== ConjunctionMultiplicationRR ====

Our first major builder lets us add a common conjunct to both sides of an implication.  We start with a few lemmas, and then prove the main theorem.

<jh>
thm (ConjunctionMultiplicationRX-q () () ((p → q) → ((p ∧ common) → q)) (
        p common ConjunctionRightElimination
        q addCommonConsequent
))

thm (ConjunctionMultiplicationRX-common () () ((p → q) → ((p ∧ common) → common)) (
        p common ConjunctionLeftElimination
        (p → q) introduceAntecedent
))

thm (ConjunctionMultiplicationRR () () ((p → q) → ((p ∧ common) → (q ∧ common))) (
        p q common ConjunctionMultiplicationRX-q
        p q common ConjunctionMultiplicationRX-common
        composeConjunction

        (p ∧ common) q common ConjunctionCompositionForward
        applySyllogism
))

thm (conjoinRR () ((H (p → q))) ((p ∧ r) → (q ∧ r)) (
        H
        p q r ConjunctionMultiplicationRR
        applyModusPonens
))
</jh>

==== Other builders ====
The rest of the <code>ConjunctionMultiplication</code> variants follow from the first one, just like in [[Principia Mathematica propositional logic]].

<jh>
thm (ConjunctionMultiplication () () (((p → r) ∧ (q → s)) → ((p ∧ q) → (r ∧ s))) (
        (p → r) (q → s) ConjunctionRightElimination
        p r q ConjunctionMultiplicationRR
        applySyllogism
        r q ConjunctionCommutativityImplication
        (p ∧ q) introduceAntecedent distributeAntecedent
        applySyllogism

        (p → r) (q → s) ConjunctionLeftElimination
        q s r ConjunctionMultiplicationRR
        applySyllogism
        s r ConjunctionCommutativityImplication
        (q ∧ r) introduceAntecedent distributeAntecedent
        applySyllogism
        applySyllogismInConsequent
))

thm (conjoin () ((H1 (p → r)) (H2 (q → s))) ((p ∧ q) → (r ∧ s)) (
        H1 H2 introduceConjunction
        p r q s ConjunctionMultiplication
        applyModusPonens
))

thm (ConjunctionMultiplicationLL () () ((p → q) → ((r ∧ p) → (r ∧ q))) (
        r ImplicationReflexivity

        r r p q ConjunctionMultiplication
        export

        applyModusPonens
))

thm (ConjunctionMultiplicationLR () () ((p → q) → ((r ∧ p) → (q ∧ r))) (
        p q r ConjunctionMultiplicationLL

        r q ConjunctionCommutativityImplication
        (p → q) introduceAntecedent

        applySyllogismInConsequent
))

thm (ConjunctionMultiplicationRL () () ((p → q) → ((p ∧ r) → (r ∧ q))) (
        p q r ConjunctionMultiplicationRR

        q r ConjunctionCommutativityImplication
        (p → q) introduceAntecedent

        applySyllogismInConsequent
))

thm (conjoinLL () ((H (p → q))) ((r ∧ p) → (r ∧ q)) (
        H
        p q r ConjunctionMultiplicationLL
        applyModusPonens
))

thm (conjoinLR () ((H (p → q))) ((r ∧ p) → (q ∧ r)) (
        H
        p q r ConjunctionMultiplicationLR
        applyModusPonens
))

thm (conjoinRL () ((H (p → q))) ((p ∧ r) → (r ∧ q)) (
        H
        p q r ConjunctionMultiplicationRL
        applyModusPonens
))
</jh>

== Disjunction ==
We provide a variation of the disjunction composition axiom, and a rule form:
<jh>
thm (DisjunctionCompositionReverse () () (((p ∨ q) → r) → ((p → r) ∧ (q → r))) (
        p q DisjunctionRightIntroduction
        r addCommonConsequent

        q p DisjunctionLeftIntroduction
        r addCommonConsequent

        composeConjunction
))

thm (composeDisjunction () ((HP (p → r)) (HQ (q → r))) ((p ∨ q) → r) (
        HQ
        HP
        p r q DisjunctionCompositionAxiom
        applyModusPonens
        applyModusPonens
))
</jh>

=== Commutativity ===
<jh>
thm (DisjunctionCommutativityImplication () () ((p ∨ q) → (q ∨ p)) (
        q p DisjunctionRightIntroduction
        p q DisjunctionLeftIntroduction
        p (q ∨ p) q DisjunctionCompositionAxiom
        applyModusPonens
        applyModusPonens
))
</jh>

=== Builders ===

==== DisjunctionSummationRL ====

Our first disjunction builder is proved analogously to <code>ConjunctionMultiplicationRR</code>.

<jh>
thm (DisjunctionSummationXL-p () () ((p → q) → (p → (common ∨ q))) (
        q common DisjunctionLeftIntroduction
        p addCommonAntecedent
))

thm (DisjunctionSummationXL-common () () ((p → q) → (common → (common ∨ q))) (
        common q DisjunctionRightIntroduction
        (p → q) introduceAntecedent
))

thm (DisjunctionSummationRL () () ((p → q) → ((p ∨ common) → (common ∨ q))) (
        p q common DisjunctionSummationXL-p
        p q common DisjunctionSummationXL-common
        composeConjunction

        p (common ∨ q) common DisjunctionCompositionAxiom
        import
        applySyllogism
))

thm (disjoinRL () ((H (p → q))) ((p ∨ r) → (r ∨ q)) (
        H
        p q r DisjunctionSummationRL
        applyModusPonens
))
</jh>

==== DisjunctionSummation ====

This theorem follows exactly as <code>ConjunctionMultiplication</code>, except that we use <code>DisjunctionSummationRL</code> instead of <code>ConjunctionMultiplicationRR</code> and <code>ConjunctionCommutativity</code>.

<jh>
thm (DisjunctionSummation () () (((p → r) ∧ (q → s)) → ((p ∨ q) → (r ∨ s))) (
        (p → r) (q → s) ConjunctionRightElimination
        p r q DisjunctionSummationRL
        applySyllogism
        (p → r) (q → s) ConjunctionLeftElimination
        q s r DisjunctionSummationRL
        applySyllogism
        applySyllogismInConsequent
))

thm (disjoin () ((H1 (p → r)) (H2 (q → s))) ((p ∨ q) → (r ∨ s)) (
        H1 H2 introduceConjunction
        p r q s DisjunctionSummation
        applyModusPonens
))
</jh>

==== DisjunctionSummation variations ====
We could prove the <code>DisjunctionSummationLL</code>, <code>DisjunctionSummationRR</code>, and <code>DisjunctionSummationLR</code> the same way that we proved <code>DisjunctionSummationRL</code>, but here we prove them as special cases of <code>DisjunctionSummation</code>.

<jh>
thm (DisjunctionSummationLL () () ((p → q) → ((r ∨ p) → (r ∨ q))) (
        r ImplicationReflexivity

        r r p q DisjunctionSummation
        export

        applyModusPonens
))

thm (DisjunctionSummationLR () () ((p → q) → ((r ∨ p) → (q ∨ r))) (
        p q r DisjunctionSummationLL

        r q DisjunctionCommutativityImplication
        (p → q) introduceAntecedent

        applySyllogismInConsequent
))

thm (DisjunctionSummationRR () () ((p → q) → ((p ∨ r) → (q ∨ r))) (
        r ImplicationReflexivity

        p q r r DisjunctionSummation
        export
        applyComm

        applyModusPonens
))

thm (disjoinLL () ((H (p → q))) ((r ∨ p) → (r ∨ q)) (
        H
        p q r DisjunctionSummationLL
        applyModusPonens
))

thm (disjoinLR () ((H (p → q))) ((r ∨ p) → (q ∨ r)) (
        H
        p q r DisjunctionSummationLR
        applyModusPonens
))

thm (disjoinRR () ((H (p → q))) ((p ∨ r) → (q ∨ r)) (
        H
        p q r DisjunctionSummationRR
        applyModusPonens
))
</jh>

== Biconditional ==

We define the biconditional as the conjunction of two implications:
<jh>
def ((↔ p q) ((p → q) ∧ (q → p)))
</jh>

And one way to prove a biconditional is to prove both of the implications:
<jh>
thm (introduceBiconditionalFromImplications () 
  ((HFORWARD (p → q)) (HREVERSE (q → p))) 
  (p ↔ q) (
        HFORWARD
        HREVERSE
        introduceConjunction
))
</jh>

We can eliminate one of the implications of a biconditional:
<jh>
thm (BiconditionalForwardElimination () () ((p ↔ q) → (q → p)) (
        (p → q) (q → p) ConjunctionLeftElimination
))

thm (BiconditionalReverseElimination () () ((p ↔ q) → (p → q)) (
        (p → q) (q → p) ConjunctionRightElimination
))

thm (eliminateBiconditionalForward () ((H (p ↔ q))) (q → p) (
        H eliminateLeftConjunction
))

thm (eliminateBiconditionalReverse () ((H (p ↔ q))) (p → q) (
        H eliminateRightConjunction
))
</jh>

=== Biconditionalized versions of some theorems we've already proved ===
We've proved both directions of each of the following theorems, so the biconditional immediately follows:
<jh>
thm (AntecedentDistribution () () ((p → (q → r)) ↔ ((p → q) → (p → r))) (
        p q r Frege
        p q r FregeConverse
        introduceBiconditionalFromImplications
))

thm (Transportation () () ((p → (q → r)) ↔ ((p ∧ q) → r)) (
        p q r Importation
        p q r Exportation
        introduceBiconditionalFromImplications
))

thm (ConjunctionComposition () () (((p → q) ∧ (p → r)) ↔ (p → (q ∧ r))) (
        p q r ConjunctionComposition1
        import

        p q r ConjunctionCompositionReverse

        introduceBiconditionalFromImplications
))

thm (DisjunctionComposition () () (((p → r) ∧ (q → r)) ↔ ((p ∨ q) → r)) (
        p r q DisjunctionCompositionAxiom
        import

        p q r DisjunctionCompositionReverse
        introduceBiconditionalFromImplications
))
</jh>

=== Reflexive, symmetric, and transitive ===

The biconditional has these three properties (which correspond to those defining an [[w:equivalence relation|equivalence relation]]). The proofs here are taken directly from [[Principia Mathematica propositional logic]], as they are also valid in intuitionistic logic.

<jh>
thm (BiconditionalReflexivity () () (p ↔ p) (
        p Id
        p Id
        introduceBiconditionalFromImplications
))

thm (BiconditionalSymmetryImplication () () ((p ↔ q) → (q ↔ p)) (
        (p → q) (q → p) ConjunctionCommutativityImplication
))

thm (BiconditionalSymmetry () () ((p ↔ q) ↔ (q ↔ p)) (
        p q BiconditionalSymmetryImplication
        q p BiconditionalSymmetryImplication
        introduceBiconditionalFromImplications
))

thm (swapBiconditional () ((H (p ↔ q))) (q ↔ p) (
        H
        p q BiconditionalSymmetryImplication
        applyModusPonens
))

thm (BiconditionalTransitivity () () (((p ↔ q) ∧ (q ↔ r)) → (p ↔ r)) (
        (p ↔ q) (q ↔ r) ConjunctionRightElimination
        (p → q) (q → p) ConjunctionRightElimination
        applySyllogism

        (p ↔ q) (q ↔ r) ConjunctionLeftElimination
        (q → r) (r → q) ConjunctionRightElimination
        applySyllogism
        applySyllogismInConsequent

        (p ↔ q) (q ↔ r) ConjunctionLeftElimination
        (q → r) (r → q) ConjunctionLeftElimination
        applySyllogism

        (p ↔ q) (q ↔ r) ConjunctionRightElimination
        (p → q) (q → p) ConjunctionLeftElimination
        applySyllogism
        applySyllogismInConsequent
        composeConjunction
))

thm (applyBiconditionalTransitivity () ((H1 (p ↔ q)) (H2 (q ↔ r))) (p ↔ r) (
        H1 H2 introduceConjunction
        p q r BiconditionalTransitivity
        applyModusPonens
))
</jh>

=== Algebraic laws for disjunction and conjunction ===
Most of the theorems of the propositional calculus which are analagous to those of other [[w:Abstract algebra|algebras]], showing properties such as commutivity and associativity, also hold for intuitionistic logic.

==== Conjunction idempotence ====
<jh>
thm (ConjunctionIdempotenceForward () () (p → (p ∧ p)) (
        p p ConjunctionRightIntroduction
        absorbRedundantAntecedent
))

thm (ConjunctionIdempotenceReverse () () ((p ∧ p) → p) (
        p p ConjunctionLeftElimination
))

thm (ConjunctionIdempotence () () (p ↔ (p ∧ p)) (
        p ConjunctionIdempotenceForward
        p ConjunctionIdempotenceReverse
        introduceBiconditionalFromImplications
))
</jh>

==== Conjunction commutativity ====
<jh>
thm (ConjunctionCommutativity () () ((p ∧ q) ↔ (q ∧ p)) (
        p q ConjunctionCommutativityImplication
        q p ConjunctionCommutativityImplication
        introduceBiconditionalFromImplications
))
</jh>

==== Conjunction associativity ====
To prove associativity for conjunctions, <code>(p ∧ q) ∧ r → p ∧ (q ∧ r)</code>, we first put onto the proof stack the statements that the left hand side implies each of <code>p</code>, <code>q</code>, and <code>r</code>.
<jh>
thm (ConjunctionRightAssociation () () (((p ∧ q) ∧ r) → (p ∧ (q ∧ r))) (
</jh>
<code>p</code>:
<jh>
        (p ∧ q) r ConjunctionRightElimination
        p q ConjunctionRightElimination
        applySyllogism
</jh>
<code>q</code>:
<jh>
        (p ∧ q) r ConjunctionRightElimination
        p q ConjunctionLeftElimination
        applySyllogism
</jh>
<code>r</code>:
<jh>
        (p ∧ q) r ConjunctionLeftElimination
</jh>
Now we compose <code>q ∧ r</code>:
<jh>
        composeConjunction
</jh>
And <code>p ∧ (q ∧ r)</code>:
<jh>
        composeConjunction
))
</jh>

The proof for associating left is similar.
<jh>
thm (ConjunctionLeftAssociation () () ((p ∧ (q ∧ r)) → ((p ∧ q) ∧ r)) (
</jh>
<code>p</code>:
<jh>
        p (q ∧ r) ConjunctionRightElimination
</jh>
<code>q</code>:
<jh>
        p (q ∧ r) ConjunctionLeftElimination
        q r ConjunctionRightElimination
        applySyllogism
</jh>
Composing <code>p ∧ q</code>:
<jh>
        composeConjunction
</jh>
<code>r</code>:
<jh>
        p (q ∧ r) ConjunctionLeftElimination
        q r ConjunctionLeftElimination
        applySyllogism
</jh>
Composing <code>(p ∧ q) ∧ r</code>:
<jh>
        composeConjunction
))
</jh>

<jh>
thm (ConjunctionAssociativity () () (((p ∧ q) ∧ r) ↔ (p ∧ (q ∧ r))) (
        p q r ConjunctionRightAssociation
        p q r ConjunctionLeftAssociation
        introduceBiconditionalFromImplications
))
</jh>

==== Disjunction idempotence ====
<jh>
thm (DisjunctionIdempotenceForward () () (p → (p ∨ p)) (
        p p DisjunctionRightIntroduction
))

thm (DisjunctionIdempotenceReverse () () ((p ∨ p) → p) (
        p ImplicationReflexivity
        p ImplicationReflexivity
        p p p DisjunctionCompositionAxiom
        applyModusPonens
        applyModusPonens
))

thm (DisjunctionIdempotence () () (p ↔ (p ∨ p)) (
        p DisjunctionIdempotenceForward
        p DisjunctionIdempotenceReverse
        introduceBiconditionalFromImplications
))
</jh>

==== Disjunction commutativity ====
<jh>
thm (DisjunctionCommutativity () () ((p ∨ q) ↔ (q ∨ p)) (
        p q DisjunctionCommutativityImplication
        q p DisjunctionCommutativityImplication
        introduceBiconditionalFromImplications
))
</jh>

==== Disjunction associativity ====
Proving associativity for disjunction is very much analogous to conjunction, with conjunction elimination and composition changed to disjunction introduction and composition.
<jh>
thm (DisjunctionRightAssociation () () (((p ∨ q) ∨ r) → (p ∨ (q ∨ r))) (
</jh>
<code>p</code> implies <code>p ∨ (q ∨ r)</code>:
<jh>
        p (q ∨ r) DisjunctionRightIntroduction
</jh>
Likewise for <code>q</code>:
<jh>
        q r DisjunctionRightIntroduction
        (q ∨ r) p DisjunctionLeftIntroduction
        applySyllogism
</jh>
Composing <code>p ∨ q</code>:
<jh>
        composeDisjunction
</jh>
<code>r</code>:
<jh>
        r q DisjunctionLeftIntroduction
        (q ∨ r) p DisjunctionLeftIntroduction
        applySyllogism
</jh>
Composing <code>(p ∨ q) ∨ r</code>:
<jh>
        composeDisjunction
))

thm (DisjunctionLeftAssociation () () ((p ∨ (q ∨ r)) → ((p ∨ q) ∨ r)) (
</jh>
<code>p</code> implies <code>(p ∨ q) ∨ r</code>:
<jh>
        p q DisjunctionRightIntroduction
        (p ∨ q) r DisjunctionRightIntroduction
        applySyllogism
</jh>
<code>q</code>:
<jh>
        q p DisjunctionLeftIntroduction
        (p ∨ q) r DisjunctionRightIntroduction
        applySyllogism
</jh>
<code>r</code>:
<jh>
        r (p ∨ q) DisjunctionLeftIntroduction
</jh>
Composing <code>q ∨ r</code>:
<jh>
        composeDisjunction
</jh>
Composing <code>p ∨ (q ∨ r)</code>:
<jh>
        composeDisjunction
))

thm (DisjunctionAssociativity () () (((p ∨ q) ∨ r) ↔ (p ∨ (q ∨ r))) (
        p q r DisjunctionRightAssociation
        p q r DisjunctionLeftAssociation
        introduceBiconditionalFromImplications
))
</jh>

=== Builders ===

The builders for conjunction and disjunction can be proved using the proofs in [[Principia Mathematica propositional logic]].

==== Conjunction ====

<jh>
thm (ConjunctionFunction-1 () () (((p ∧ q) ∧ (r ∧ s)) → ((p ∧ r) ∧ (q ∧ s))) (
        p q (r ∧ s) ConjunctionAssociativity
        eliminateBiconditionalReverse

        p Id
        q r s ConjunctionAssociativity
        eliminateBiconditionalForward
        conjoin

        applySyllogism

        p Id
        q r ConjunctionCommutativity
        eliminateBiconditionalReverse
        s Id 
        conjoin
        conjoin

        applySyllogism

        p Id
        r q s ConjunctionAssociativity
        eliminateBiconditionalReverse
        conjoin

        applySyllogism

        p r (q ∧ s) ConjunctionAssociativity
        eliminateBiconditionalForward

        applySyllogism
))

thm (ConjunctionFunction () () (((p ↔ q) ∧ (r ↔ s)) → ((p ∧ r) ↔ (q ∧ s))) ( # *4.38
        (p → q) (q → p) (r → s) (s → r) ConjunctionFunction-1
        
        p q r s ConjunctionMultiplication
        q p s r ConjunctionMultiplication
        conjoin

        applySyllogism
))

thm (buildConjunction () (
  (H1 (p ↔ q))
  (H2 (r ↔ s)))
  ((p ∧ r) ↔ (q ∧ s)) (
        H1 H2 introduceConjunction
        p q r s ConjunctionFunction
        applyModusPonens
))
</jh>

==== Disjunction ====
This is just like the theorem for conjunction, except that we build on the partial builder theorem DisjunctionSummation instead of ConjunctionMultiplication:

<jh>
thm (DisjunctionFunction () () (((p ↔ q) ∧ (r ↔ s)) → ((p ∨ r) ↔ (q ∨ s))) ( # *4.39
        (p → q) (q → p) (r → s) (s → r) ConjunctionFunction-1
        
        p q r s DisjunctionSummation
        q p s r DisjunctionSummation
        conjoin

        applySyllogism
))

thm (buildDisjunction () (
  (H1 (p ↔ q))
  (H2 (r ↔ s)))
  ((p ∨ r) ↔ (q ∨ s)) (
        H1 H2 introduceConjunction
        p q r s DisjunctionFunction
        applyModusPonens
))
</jh>

=== Distributivity ===
Here we take up distributivity of disjunction over conjunction, and conjunction over disjunction.  Most of the proofs given in [[Principia Mathematica propositional logic]] apply for intuitionistic logic, as they are fairly straightforward applications of disjunction and conjunction composition.  The tough one is <code>((p ∨ q) ∧ (p ∨ r)) → p ∨ (q ∧ r)</code> (because it has a conjunction in the antecedent and a disjunction in the consequent, it won't yield to straightforward composition tricks).  ''Principia'' proves it from the equivalence of <code>p ∨ q</code> and <code>¬ p → q</code> (which does not hold in both directions in intuitionistic logic).  We prove it from import and builders.

The first step is a lemma which will let us harmlessly apply builders more than once.
<jh>
thm (RedundantDisjunctionAbsorption () () ((p ∨ (p ∨ q)) → (p ∨ q)) (
        p p q DisjunctionAssociativity
        eliminateBiconditionalForward

        p DisjunctionIdempotence
        eliminateBiconditionalForward
        q disjoinRR

        applySyllogism
))
</jh>

Now we are ready for the proof of the tough distributivity case.
<jh>
thm (DisjunctionLeftDistribution-reverse () () (((p ∨ q) ∧ (p ∨ r)) → (p ∨ (q ∧ r))) (
</jh>
We start with <code>r → (q → (q ∧ r))</code>, and disjoin <code>p</code> to both sides of the second implication.
<jh>
        r q ConjunctionLeftIntroduction
        q (q ∧ r) p DisjunctionSummationLL
        applySyllogism
</jh>
That gives us <code>r → (p ∨ q → p ∨ (q ∧ r))</code>. We commute antecedents and disjoin <code>p</code> again.
<jh>
        applyComm
        r (p ∨ (q ∧ r)) p DisjunctionSummationLL
        applySyllogism
</jh>
We now have <code>p ∨ q → (p ∨ r → p ∨ (p ∨ (q ∧ r)))</code>.  We just need to import, remove the redundant <code>p</code>, and we are done.
<jh>
        import
        p (q ∧ r) RedundantDisjunctionAbsorption
        applySyllogism
))
</jh>

The rest of this section contains proofs taken from [[Principia Mathematica propositional logic]].

<jh>
thm (ConjunctionLeftDistribution-forward () () 
  ((p ∧ (q ∨ r)) → ((p ∧ q) ∨ (p ∧ r))) (
        p q ConjunctionRightIntroduction
        p r ConjunctionRightIntroduction
        composeConjunction

        q (p ∧ q) r (p ∧ r) DisjunctionSummation
        applySyllogism

        import
))

thm (ConjunctionLeftDistribution-reverse () ()
  (((p ∧ q) ∨ (p ∧ r)) → (p ∧ (q ∨ r))) (
        p q ConjunctionRightElimination
        p r ConjunctionRightElimination
        composeDisjunction

        p q ConjunctionLeftElimination
        p r ConjunctionLeftElimination
        disjoin

        composeConjunction
))

thm (ConjunctionLeftDistribution () () ((p ∧ (q ∨ r)) ↔ ((p ∧ q) ∨ (p ∧ r))) (
        p q r ConjunctionLeftDistribution-forward
        p q r ConjunctionLeftDistribution-reverse
        introduceBiconditionalFromImplications
))

thm (DisjunctionLeftDistribution-forward () () ((p ∨ (q ∧ r)) → ((p ∨ q) ∧ (p ∨ r))) (
        q r ConjunctionRightElimination
        p disjoinLL

        q r ConjunctionLeftElimination
        p disjoinLL

        composeConjunction
))

thm (DisjunctionLeftDistribution () () ((p ∨ (q ∧ r)) ↔ ((p ∨ q) ∧ (p ∨ r))) (
        p q r DisjunctionLeftDistribution-forward
        p q r DisjunctionLeftDistribution-reverse
        introduceBiconditionalFromImplications
))
</jh>

Also from [[Principia Mathematica propositional logic]] are commuted versions of both laws and some rules:

<jh>
thm (DisjunctionRightDistribution () () (((p ∧ q) ∨ r) ↔ ((p ∨ r) ∧ (q ∨ r))) (
        (p ∧ q) r DisjunctionCommutativity
        r p q DisjunctionLeftDistribution
        applyBiconditionalTransitivity

        r p DisjunctionCommutativity
        r q DisjunctionCommutativity
        buildConjunction

        applyBiconditionalTransitivity
))

thm (ConjunctionRightDistribution () () (((p ∨ q) ∧ r) ↔ ((p ∧ r) ∨ (q ∧ r))) (
        (p ∨ q) r ConjunctionCommutativity
        r p q ConjunctionLeftDistribution
        applyBiconditionalTransitivity

        r p ConjunctionCommutativity
        r q ConjunctionCommutativity
        buildDisjunction

        applyBiconditionalTransitivity
))

thm (distributeLeftDisjunction () ((H (p ∨ (q ∧ r)))) ((p ∨ q) ∧ (p ∨ r)) (
        H
        p q r DisjunctionLeftDistribution
        eliminateBiconditionalReverse
        applyModusPonens
))

thm (collectLeftDisjunction () ((H ((p ∨ q) ∧ (p ∨ r)))) (p ∨ (q ∧ r)) (
        H
        p q r DisjunctionLeftDistribution
        eliminateBiconditionalForward
        applyModusPonens
))

thm (distributeRightDisjunction () ((H ((p ∧ q) ∨ r))) ((p ∨ r) ∧ (q ∨ r)) (
        H
        p q r DisjunctionRightDistribution
        eliminateBiconditionalReverse
        applyModusPonens
))

thm (collectRightDisjunction () ((H ((p ∨ r) ∧ (q ∨ r)))) ((p ∧ q) ∨ r) (
        H
        p q r DisjunctionRightDistribution
        eliminateBiconditionalForward
        applyModusPonens
))

thm (distributeLeftConjunction () ((H (p ∧ (q ∨ r)))) ((p ∧ q) ∨ (p ∧ r)) (
        H
        p q r ConjunctionLeftDistribution
        eliminateBiconditionalReverse
        applyModusPonens
))

thm (collectLeftConjunction () ((H ((p ∧ q) ∨ (p ∧ r)))) (p ∧ (q ∨ r)) (
        H
        p q r ConjunctionLeftDistribution
        eliminateBiconditionalForward
        applyModusPonens
))

thm (distributeRightConjunction () ((H ((p ∨ q) ∧ r))) ((p ∧ r) ∨ (q ∧ r)) (
        H
        p q r ConjunctionRightDistribution
        eliminateBiconditionalReverse
        applyModusPonens
))

thm (collectRightConjunction () ((H ((p ∧ r) ∨ (q ∧ r)))) ((p ∨ q) ∧ r) (
        H
        p q r ConjunctionRightDistribution
        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

== Modus Ponens ==
This is just an implication corresponding to the modus ponens rule:
<jh>
thm (ModusPonens () () ((p ∧ (p → q)) → q) (
        (p → q) ImplicationReflexivity
        applyComm
        import
))
</jh>

== Negation ==

=== Transposition ===
Although intuitionistic logic does not allow removing transposition, it does allow introducing it.
<jh>
thm (TranspositionIntroduction () () ((p → q) → ((¬ q) → (¬ p))) (
</jh>
The <code>ProofByContradiction</code> axiom is <code>(p → q) → ((p → ¬ q) → ¬ p)</code>.  That is, if <code>p</code> implies both <code>q</code> and its negation, <code>p</code> cannot be true. What we are trying to prove can be thought of as a weaker form of this, which is that if <code>p</code> implies <code>q</code>, and the negation of q holds (without worrying about <code>p</code>), then <code>p</code> cannot be true, or in symbols <code>(p → q) → (¬ q → ¬ p)</code>.
<jh>
        p q ProofByContradiction

        (¬ q) p AntecedentIntroduction
        (¬ p) addCommonConsequent
        (p → q) addCommonAntecedent

        applyModusPonens
))

thm (introduceTransposition () ((H (p → q))) ((¬ q) → (¬ p)) (
        H
        p q TranspositionIntroduction
        applyModusPonens
))
</jh>

Modus tollens is an easy consequence of transposition introduction.

<jh>
thm (ModusTollens () () (((¬ q) ∧ (p → q)) → (¬ p)) (
        p q TranspositionIntroduction
        (¬ q) conjoinLL

        (¬ q) (¬ p) ModusPonens
        applySyllogism
))

thm (applyModusTollens () ((H (¬ q)) (HIMP (p → q))) (¬ p) (
        H
        HIMP
        introduceConjunction

        q p ModusTollens

        applyModusPonens
))
</jh>

=== Double Negation ===
Double negation introduction follows fairly directly from our first negation axiom.
<jh>
thm (DoubleNegation () () (p → (¬ (¬ p))) (
</jh>
The key step in the proof will be <code>(¬p → p) ∧ (¬p → ¬p) → ¬¬p</code> (which follows from the <code>ProofByContradiction</code> axiom). Taking the pieces of that formula one at a time, <code>p</code> implies <code>¬p → p</code>
<jh>
        p (¬ p) AntecedentIntroduction
</jh>
and <code>¬p → ¬p</code> is a theorem.
<jh>
         (¬ p) ImplicationReflexivity
         p introduceAntecedent
</jh>
Now we assemble the result.
<jh>
        composeConjunction

        (¬ p) p ProofByContradiction
        import
        applySyllogism
))
</jh>

=== Triple negation ===
In intuitionistic logic, <code>¬ ¬ p</code> is not equivalent to <code>p</code> itself. Triple negation, however, is equivalent to single negation, so one merely needs to worry about formulas without negation, with single negation, or with double negation, not greater amounts of negation.
<jh>
thm (TripleNegation () () ((¬ (¬ (¬ p))) ↔ (¬ p)) (
</jh>
We prove the forward direction by taking <code>p → ¬ ¬ p</code> and transposing it.
<jh>
        p DoubleNegation
        introduceTransposition
</jh>
The reverse direction is even easier, as <code>¬ p → ¬ ¬ ¬ p</code> is an instance of the <code>DoubleNegation</code> theorem.
<jh>
        (¬ p) DoubleNegation

        introduceBiconditionalFromImplications
))
</jh>

=== Disjunctive syllogism ===
[[w:Disjunctive syllogism|Disjunctive syllogism]]:
<jh>
thm (DisjunctiveSyllogismLemma () () ((p → q) → ((p ∨ q) → q)) (
</jh>
The key to the proof of this lemma is <code>(p → q) → ((q → q) → (p ∨ q → q))</code>, which holds by disjunction composition. Once we have that, we just need to remove the <code>q → q</code>.
<jh>
        q ImplicationReflexivity

        p q q DisjunctionCompositionAxiom
        applyComm

        applyModusPonens
))

thm (DisjunctiveSyllogism () () (((¬ p) ∧ (p ∨ q)) → q) (
        p q Explosion
        applyComm

        p q DisjunctiveSyllogismLemma
        applySyllogism

        import
))
</jh>

=== DeMorgan's laws ===

The first two of DeMorgan's laws are straightforward:
<jh>
thm (DeMorganPDPForward () () ((¬ (p ∨ q)) → ((¬ p) ∧ (¬ q))) (
        p q DisjunctionRightIntroduction
        introduceTransposition

        q p DisjunctionLeftIntroduction
        introduceTransposition

        composeConjunction
))

thm (DeMorganPCPReverse () () (((¬ p) ∨ (¬ q)) → (¬ (p ∧ q))) (
        p q ConjunctionRightElimination
        introduceTransposition

        p q ConjunctionLeftElimination
        introduceTransposition

        composeDisjunction
))
</jh>

To prove the converse of <code>DeMorganPDPForward</code>, we start with a lemma which is a rearrangement of <code>DisjunctiveSyllogism</code> plus transposition.
<jh>
thm (DeMorganPDPReverseLemma () () ((¬ p) → ((¬ q) → (¬ (p ∨ q)))) (
        p q DisjunctiveSyllogism
        export

        (p ∨ q) q TranspositionIntroduction
        applySyllogism
))
</jh>

This lemma is, however, just an import away from the desired result.
<jh>
thm (DeMorganPDPReverse () () (((¬ p) ∧ (¬ q)) → (¬ (p ∨ q))) (
        p q DeMorganPDPReverseLemma
        import
))
</jh>

Combining the forward and reverse directions we get <code>DeMorganPDPSwapped</code>:
<jh>
thm (DeMorganPDPSwapped () () (((¬ p) ∧ (¬ q)) ↔ (¬ (p ∨ q))) (
        p q DeMorganPDPReverse
        p q DeMorganPDPForward
        introduceBiconditionalFromImplications
))
</jh>

The following result follows from double negation introduction and <code>DeMorganPDPSwapped</code>.
<jh>
thm (DeMorganNDNReverse () () ((p ∧ q) → (¬ ((¬ p) ∨ (¬ q)))) (
        p DoubleNegation
        q DoubleNegation
        conjoin

        (¬ p) (¬ q) DeMorganPDPSwapped
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

We can pull the same trick for disjunction to get our final version of DeMorgan's law.
<jh>
thm (DeMorganNCNReverse () () ((p ∨ q) → (¬ ((¬ p) ∧ (¬ q)))) (
        p DoubleNegation
        q DoubleNegation
        disjoin

        (¬ p) (¬ q) DeMorganPCPReverse
        applySyllogism
))
</jh>

=== Double negation and connectives ===
The first two of these relationships between double negation and conjunction or disjunction are easy consequences of transposition.
<jh>
thm (DoubleNegatedConjunctionReverse () () ((¬ (¬ (p ∧ q))) → ((¬ (¬ p)) ∧ (¬ (¬ q)))) (
        p q ConjunctionRightElimination
        introduceTransposition
        introduceTransposition

        p q ConjunctionLeftElimination
        introduceTransposition
        introduceTransposition

        composeConjunction
))

thm (DoubleNegatedDisjunction () () (((¬ (¬ p)) ∨ (¬ (¬ q))) → (¬ (¬ (p ∨ q)))) (
        p q DisjunctionRightIntroduction
        introduceTransposition
        introduceTransposition

        q p DisjunctionLeftIntroduction
        introduceTransposition
        introduceTransposition

        composeDisjunction
))
</jh>

The converse of <code>DoubleNegatedConjunctionReverse</code> we can prove via the following lemma which introduces double negation to all three formulas of a nested implication.
<jh>
thm (addDoubleNegationImplicationImplication () ((H (p → (q → r))))
  ((¬ (¬ p)) → ((¬ (¬ q)) → (¬ (¬ r)))) (
        H
        q r TranspositionIntroduction
        applySyllogism

        applyComm
        p (¬ q) TranspositionIntroduction
        applySyllogism

        applyComm
        (¬ r) (¬ p) TranspositionIntroduction
        applySyllogism

        applyComm
))

thm (DoubleNegatedConjunctionForward () () (((¬ (¬ p)) ∧ (¬ (¬ q))) → (¬ (¬ (p ∧ q)))) (
        p q ConjunctionRightIntroduction
        addDoubleNegationImplicationImplication
        import
))

thm (DoubleNegatedConjunction () () (((¬ (¬ p)) ∧ (¬ (¬ q))) ↔ (¬ (¬ (p ∧ q)))) (
        p q DoubleNegatedConjunctionForward
        p q DoubleNegatedConjunctionReverse
        introduceBiconditionalFromImplications
))
</jh>

=== No contradictions ===
The <code>Explosion</code> axiom amounts to denying that a proposition and its negation can both hold. Here we express this idea as a theorem (which is also found as *3.24 in [[Principia Mathematica propositional logic]]).
<jh>
thm (NoContradiction () () (¬ (p ∧ (¬ p))) (
</jh>
The proof is based on <code>¬ q → ¬ (p ∧ ¬ p)</code>, which is a rearrangment of <code>Explosion</code>.  To apply this we just need a theorem (any theorem) which starts with a negation, to plug in for <code>¬ q</code>.  The double negation of <code>Id</code> will do.
<jh>
        r Id
        (r → r) DoubleNegationIntroduction
        applyModusPonens

        p (¬ (r → r)) Explosion
        import
        introduceTransposition

        applyModusPonens
))
</jh>

== Case elimination ==
Proving a theorem by cases, as in <code>CaseElimination</code> of [[Interface:Classical propositional calculus]], is not, in general, allowed in intuitionism/constructivism. For example, there is a clever non-constructive proof of (TODO: allude to that example about the irrational/rational exponentiation).  We do note that <code>p ∨ q</code>, which is stronger than <code>¬ p → q</code> in intuitionistic logic, can be used for case elimination.
<jh>
thm (DisjunctiveCaseElimination () () (((p ∨ q) ∧ ((¬ p) ∨ q)) → q) (
</jh>
We start by collecting the <code>q</code> from the left side to get <code>(p ∧ ¬ p) ∨ q</code>.
<jh>
        p q (¬ p) DisjunctionRightDistribution
        eliminateBiconditionalForward
</jh>
Because <code>¬ (p ∧ ¬ p)</code> is a theorem, disjunctive syllogism gives us <code>(p ∧ ¬ p) ∨ q → q</code>.
<jh>
        p NoContradiction
        (p ∧ (¬ p)) q DisjunctiveSyllogism
        export
        applyModusPonens
</jh>
And this is just a syllogism away from our desired result.
<jh>
        applySyllogism
))
</jh>

== True and false connectives ==
We define true (⊤) as a theorem (any theorem would do), and false (⊥) as a statement whose negation is a theorem.

<jh>
def ((⊤) (¬ (p ∧ (¬ p))))
def ((⊥) (p ∧ (¬ p)))
</jh>

Proving <code>TautologyId</code> is straightforward; the proof from [[Principia Mathematica propositional logic]] works with only the obvious changes for the difference between <code>Tautology</code> and <code>TautologyId</code>.

thm (*3.4 () () ((p ∧ q) → (p → q)) (
        p q ConjunctionLeftElimination
        q p AntecedentIntroduction
        applySyllogism
))

thm (*5.1 () () ((p ∧ q) → (p ↔ q)) (
        p q *3.4

        p q *3.22
        q p *3.4
        applySyllogism

        composeConjunction
))

thm (TautologyId () () ((p → p) ↔ (⊤)))
        p Id
        q NoContradiction
        introduceConjunction

        (p → p) (¬ (q ∧ (¬ q))) *5.1
        applyModusPonens
))
</jh>

The <code>Contradiction</code> theorem also holds.  To prove it the same way as <code>TautologyId</code> would require <code>¬ p ∧ ¬ q → (p ↔ q)</code> (*5.21 in [[Principia Mathematica propositional logic]]). Since we don't have that, we can prove it in an even more direct way: a contradiction implies anything, including the consequent of each of the implications in this theorem.
<jh>
thm (ContradictionLemma () () ((p ∧ (¬ p)) → (q ∧ (¬ q))) (
        p (q ∧ (¬ q)) Explosion
        import
))

thm (Contradiction () () ((p ∧ (¬ p)) ↔ (⊥)) (
        p q ContradictionLemma
        q p ContradictionLemma
        introduceBiconditionalFromImplications
))
</jh>

The next two are trivial.
<jh>
thm (True () () (⊤) (
        p NoContradiction
))

thm (NotFalse () () (¬ (⊥)) (
        p NoContradiction
))
</jh>

== Export ==
Once this file is complete, we'll be ready to export to [[Interface:Intuitionistic propositional logic]].
<jh>
#export (INTUITIONISTIC Interface:Intuitionistic_propositional_logic () ())
</jh>

== References ==

<references />

[[Category:Subsystems of classical logic|{{PAGENAME}}]]

