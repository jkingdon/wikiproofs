{{interfaces
| imports = [[Interface:Triangle congruence]]
| exports = [[Interface:Collinearity]]
}}

This is part of a series of modules which prove a variety of geometrical theorems starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Triangle congruence|geometry results so far]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (START Interface:Triangle_congruence (CLASSICAL FIRSTORDER) ())

var (formula φ)
var (point x y z w u v A B C D E P Q A′ B′ C′ D′ B″ C″)
var (point x′ y′ z′ w′ u′)
var (variable a b b′ c c′ d′ q q′ ww ww′ b″ c″)
</jh>

== Collinearity ==
To say that three points are collinear is just to say that one of them is between the other two (in any order).<ref>Definition Col in Narboux</ref>
<jh>
def ((collinear x y z) (((between x y z) ∨ (between y z x)) ∨ (between z x y)))

thm (BetweennessCollinearity () () ((between x y z) → (collinear x y z)) (
        (between x y z) (between y z x) DisjunctionRightIntroduction
        ((between x y z) ∨ (between y z x))
          (between z x y)
          DisjunctionRightIntroduction
        applySyllogism
))
</jh>

=== Permutations ===
One way to express the "in any order" concept is to provide permutation theorems. The first is rotation: <code>collinear x y z ↔ collinear y z x</code>.<ref>col_permutation_1 and col_permutation_2 in Narboux</ref>
<jh>
thm (CollinearityRotation () () ((collinear x y z) ↔ (collinear y z x)) (
        (between x y z) (between y z x) (between z x y) DisjunctionAssociativity

        (between x y z) ((between y z x) ∨ (between z x y)) DisjunctionCommutativity

        applyBiconditionalTransitivity
))
</jh>

The next permutation swaps the second and third points.<ref>col_permutation_5 in Narboux, biconditionalized</ref>
<jh>
thm (Collinearity23 () () ((collinear x y z) ↔ (collinear x z y)) (
</jh>
The proof starts with <code>between x y z ↔ between z y x</code> and <code>between y z x ↔ between x z y</code>.
<jh>
        x y z BetweennessSymmetry
        y z x BetweennessSymmetry
</jh>
We combine those and switch the order to get <code>between x y z ∨ between y z x ↔ between x z y ∨ between z y x</code>.
<jh>
        buildDisjunction

        (between z y x) (between x z y) DisjunctionCommutativity
        applyBiconditionalTransitivity
</jh>
Combining that with <code>between z x y ↔ between y x z</code> finishes the task.
<jh>
        z x y BetweennessSymmetry
        buildDisjunction
))
</jh>

To swap the first and second points, we rotate and then swap the second and third points.<ref>col_permutation_4 in Narboux, biconditionalized</ref>
<jh>
thm (Collinearity12 () () ((collinear x y z) ↔ (collinear y x z)) (
        x y z CollinearityRotation
        y z x Collinearity23
        applyBiconditionalTransitivity
))
</jh>

To swap the first and third points, we rotate and then swap the first and second points.<ref>col_permutation_3 in Narboux, biconditionalized</ref>
<jh>
thm (Collinearity13 () () ((collinear x y z) ↔ (collinear z y x)) (
        x y z CollinearityRotation
        y z x Collinearity12
        applyBiconditionalTransitivity
))
</jh>

=== Collinearity of a point, itself, and another point ===
A point is collinear with itself and any second point. That is, <code>collinear A A B</code>, and likewise for any other order of the three points.<ref>col_trivial_1, col_trivial_2, and col_trivial_3 in Narboux</ref>
<jh>
thm (CollinearityAAB () () (collinear A A B) (
        B A BetweenABB
        ((between A A B) ∨ (between A B A)) introduceLeftDisjunction
))

thm (CollinearityABB () () (collinear A B B) (
        B A CollinearityAAB

        B B A Collinearity13
        eliminateBiconditionalReverse
        applyModusPonens
))

thm (CollinearityABA () () (collinear A B A) (
        A B CollinearityAAB

        A A B Collinearity23
        eliminateBiconditionalReverse
        applyModusPonens
))
</jh>

=== Collinearity and degenerate congruent triangles ===
The analogue to <code>BetweennessDegenerateTriangle</code> also holds for collinearity.<ref>l4_13 in Narboux</ref>
<jh>
thm (CollinearityDegenerateTriangle () ()
  (((collinear A B C) ∧ (A B C ≅ A′ B′ C′)) → (collinear A′ B′ C′)) (
</jh>
The proof just consists of expanding <code>collinear A B C</code> into a disjunction of three betweenness formulas, and applying <code>BetweennessDegenerateTriangle</code> three times.

We start with <code>between A B C → (A B C ≅ A′ B′ C′ → collinear A′ B′ C′)<code>.
<jh>
        A B C A′ B′ C′ BetweennessDegenerateTriangle

        A′ B′ C′ BetweennessCollinearity
        applySyllogism

        export
</jh>
Next is <code>between B C A → (A B C ≅ A′ B′ C′ → collinear A′ B′ C′)<code>. The proof is similar, but involves some additional rotation of both the congruence and the collinearity.
<jh>
        A B C A′ B′ C′ CongruenceRotation
        eliminateBiconditionalReverse
        (between B C A) conjoinLL

        B C A B′ C′ A′ BetweennessDegenerateTriangle
        applySyllogism

        B′ C′ A′ BetweennessCollinearity
        applySyllogism

        A′ B′ C′ CollinearityRotation
        eliminateBiconditionalForward
        applySyllogism

        export
</jh>
We combine the <code>between A B C</code> and <code>between B C A</code> cases.
<jh>
        composeDisjunction
</jh>
The proof of the <code>between C A B</code> case, <code>between C A B → (A B C ≅ A′ B′ C′ → collinear A′ B′ C′)<code>, is similar.
<jh>
        C A B C′ A′ B′ CongruenceRotation
        eliminateBiconditionalForward
        (between C A B) conjoinLL

        C A B C′ A′ B′ BetweennessDegenerateTriangle
        applySyllogism

        C′ A′ B′ BetweennessCollinearity
        applySyllogism

        C′ A′ B′ CollinearityRotation
        eliminateBiconditionalReverse
        applySyllogism

        export

        composeDisjunction
        import
))
</jh>

== Constructing congruent degenerate triangles from collinear points ==
Given a (degenerate) triangle and a line segment congruent to one of the sides of the triangle, we can construct a second triangle on the line segment which is congruent to the given triangle. Here we prove a degenerate case, in which the points of the given triangle are collinear. In symbols, <code>collinear A B C ∧ A B ≡ A′ B′ → ∃ c′ A B C ≅ A′ B′ c′</code>.<ref>l4_14 in Narboux</ref> This is an analogue to <code>InnerDegenerateTriangle</code> but for collinearity rather than betweenness.

There are three cases, corresponding to the three betweenness predicates which make up the definition of <code>collinear</code>.

The first lemma is basically predicate logic. It enables us to move the two antecedents inside the quantifier.
<jh>
thm (CollinearityConstructDegenerateTriangle-1
  ((c′ x) (c′ y) (c′ z) (c′ A) (c′ B) (c′ A′) (c′ B′))
  ((H (∃ c′ φ)))
  (((between x y z) ∧ (A B ≡ A′ B′)) → (∃ c′ ((between x y z) ∧ ((A B ≡ A′ B′) ∧ φ)))) (
        (A B ≡ A′ B′) ImplicationReflexivity
        H
        (A B ≡ A′ B′) introduceAntecedent
        composeConjunction

        c′ (A B ≡ A′ B′) φ ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        applySyllogism
</jh>
That gives us <code>A B ≡ A′ B′ → ∃ c′ (A B ≡ A′ B′ ∧ φ)</code>. We now need to apply a similar process to <code>between x y z</code>
<jh>
        (between x y z) conjoinLL

        c′ (between x y z) ((A B ≡ A′ B′) ∧ φ)ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        applySyllogism
))
</jh>
The next few lemmas form the bulk of the <code>between A B C</code> case. Extend <code>A′ B′</code> to a point <code>C′</code> such that <code>B′ C′ ≡ B C</code>. Between that congruence and <code>A B ≡ A′ B′</code>, we can conclude <code>A C ≡ A′ C′</code>. Those three congruences are what we need for <code>A B C ≅ A′ B′ C′</code>.
<jh>
thm (CollinearityConstructDegenerateTriangle-abc-bc () ()
  (((between A B C) ∧ ((A B ≡ A′ B′) ∧ ((between A′ B′ C′) ∧ (B′ C′ ≡ B C)))) → (B C ≡ B′ C′)) (
        (between A B C) ((A B ≡ A′ B′) ∧ ((between A′ B′ C′) ∧ (B′ C′ ≡ B C))) ConjunctionLeftElimination
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        B′ C′ B C CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism
))

thm (CollinearityConstructDegenerateTriangle-abc-ac () ()
  (((between A B C) ∧ ((A B ≡ A′ B′) ∧ ((between A′ B′ C′) ∧ (B′ C′ ≡ B C)))) → (A C ≡ A′ C′)) (
</jh>
The proof is an application of <code>OuterThreeSegment</code>. First we need <code>between A B C</code>.
<jh>
        (between A B C) ((A B ≡ A′ B′) ∧ ((between A′ B′ C′) ∧ (B′ C′ ≡ B C))) ConjunctionRightElimination
</jh>
Next, <code>between A′ B′ C′</code>.
<jh>
        (between A B C) ((A B ≡ A′ B′) ∧ ((between A′ B′ C′) ∧ (B′ C′ ≡ B C))) ConjunctionLeftElimination
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        composeConjunction
</jh>
We need two congruences. The first is <code>A B ≡ A′ B′</code>.
<jh>
        (between A B C) ((A B ≡ A′ B′) ∧ ((between A′ B′ C′) ∧ (B′ C′ ≡ B C))) ConjunctionLeftElimination
        eliminateRightConjunctionInConsequent

        composeConjunction
</jh>
The other is <code>B C ≡ B′ C′</code>.
<jh>
        A B C A′ B′ C′ CollinearityConstructDegenerateTriangle-abc-bc

        composeConjunction
</jh>
We can now apply outer three segment.
<jh>
        A B C A′ B′ C′ OuterThreeSegment
        applySyllogism
))

thm (CollinearityConstructDegenerateTriangle-abc-core () ()
  (((between A B C) ∧ ((A B ≡ A′ B′) ∧ ((between A′ B′ C′) ∧ (B′ C′ ≡ B C)))) → (A B C ≅ A′ B′ C′)) (
        (between A B C) ((A B ≡ A′ B′) ∧ ((between A′ B′ C′) ∧ (B′ C′ ≡ B C))) ConjunctionLeftElimination
        eliminateRightConjunctionInConsequent

        A B C A′ B′ C′ CollinearityConstructDegenerateTriangle-abc-ac
        composeConjunction

        A B C A′ B′ C′ CollinearityConstructDegenerateTriangle-abc-bc
        composeConjunction
))

thm (CollinearityConstructDegenerateTriangle-abc
  ((c′ A) (c′ B) (c′ C) (c′ A′) (c′ B′)) ()
  ((between A B C) → ((A B ≡ A′ B′) → (∃ c′ (A B C ≅ A′ B′ (value c′))))) (
        c′ A′ B′ B C SegmentConstruction
        A B C A B A′ B′ CollinearityConstructDegenerateTriangle-1

        A B C A′ B′ (value c′) CollinearityConstructDegenerateTriangle-abc-core
        c′ addThereExists
        applySyllogism

        export
))

</jh>
The second case, <code>between C A B</code>, is similar. Extend <code>B′ A′</code> to a point <code>C′</code> such that <code>A′ C′ ≡ A C</code>. Between that congruence and <code>A B ≡ A′ B′</code>, we can conclude <code>B C ≡ B′ C′</code>. Those three congruences are what we need for <code>A B C ≅ A′ B′ C′</code>.
<jh>
thm (CollinearityConstructDegenerateTriangle-cab-ac () ()
  (((between C A B) ∧ ((A B ≡ A′ B′) ∧ ((between B′ A′ C′) ∧ (A′ C′ ≡ A C)))) → (A C ≡ A′ C′)) (
        (between C A B) ((A B ≡ A′ B′) ∧ ((between B′ A′ C′) ∧ (A′ C′ ≡ A C))) ConjunctionLeftElimination
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        A′ C′ A C CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism
))

thm (CollinearityConstructDegenerateTriangle-cab-bc () ()
  (((between C A B) ∧ ((A B ≡ A′ B′) ∧ ((between B′ A′ C′) ∧ (A′ C′ ≡ A C)))) → (B C ≡ B′ C′)) (
</jh>
The proof is an application of <code>OuterThreeSegment</code>. First we need <code>between C A B</code>.
<jh>
        (between C A B) ((A B ≡ A′ B′) ∧ ((between B′ A′ C′) ∧ (A′ C′ ≡ A C))) ConjunctionRightElimination
</jh>
Next, <code>between C′ A′ B′</code>.
<jh>
        (between C A B) ((A B ≡ A′ B′) ∧ ((between B′ A′ C′) ∧ (A′ C′ ≡ A C))) ConjunctionLeftElimination
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        B′ A′ C′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
We need two congruences. The first is <code>C A ≡ C′ A′</code>.
<jh>
        C A B A′ B′ C′ CollinearityConstructDegenerateTriangle-cab-ac

        A C A′ C′ CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
The other is <code>A B ≡ A′ B′</code>.
<jh>
        (between C A B) ((A B ≡ A′ B′) ∧ ((between B′ A′ C′) ∧ (A′ C′ ≡ A C))) ConjunctionLeftElimination
        eliminateRightConjunctionInConsequent

        composeConjunction
</jh>
We can now apply outer three segment.
<jh>
        C A B C′ A′ B′ OuterThreeSegment
        applySyllogism

        C B C′ B′ CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism
))

thm (CollinearityConstructDegenerateTriangle-cab-core () ()
  (((between C A B) ∧ ((A B ≡ A′ B′) ∧ ((between B′ A′ C′) ∧ (A′ C′ ≡ A C)))) → (A B C ≅ A′ B′ C′)) (
        (between C A B) ((A B ≡ A′ B′) ∧ ((between B′ A′ C′) ∧ (A′ C′ ≡ A C))) ConjunctionLeftElimination
        eliminateRightConjunctionInConsequent

        C A B A′ B′ C′ CollinearityConstructDegenerateTriangle-cab-ac
        composeConjunction

        C A B A′ B′ C′ CollinearityConstructDegenerateTriangle-cab-bc
        composeConjunction
))

thm (CollinearityConstructDegenerateTriangle-cab
  ((c′ A) (c′ B) (c′ C) (c′ A′) (c′ B′)) ()
  ((between C A B) → ((A B ≡ A′ B′) → (∃ c′ (A B C ≅ A′ B′ (value c′))))) (
        c′ B′ A′ A C SegmentConstruction
        C A B A B A′ B′ CollinearityConstructDegenerateTriangle-1

        C A B A′ B′ (value c′) CollinearityConstructDegenerateTriangle-cab-core
        c′ addThereExists
        applySyllogism

        export
))
</jh>
The <code>between B C A</code> case is a consequence of <code>InnerDegenerateTriangle</code>.
<jh>
thm (CollinearityConstructDegenerateTriangle-bca
  ((c′ A) (c′ B) (c′ C) (c′ A′) (c′ B′)) ()
  ((between B C A) → ((A B ≡ A′ B′) → (∃ c′ (A B C ≅ A′ B′ (value c′))))) (
        A B A′ B′ CongruenceCommutativity
        eliminateBiconditionalReverse
        (between B C A) conjoinLL

        B C A B′ A′ c′ InnerDegenerateTriangle
        applySyllogism

        (between B′ (value c′) A′) (B C A ≅ B′ (value c′) A′) ConjunctionLeftElimination
        c′ addThereExists
        applySyllogism

        A B C A′ B′ (value c′) CongruenceRotation
        eliminateBiconditionalForward
        c′ addThereExists
        applySyllogism

        export
))

thm (CollinearityConstructDegenerateTriangle ((c′ A) (c′ B) (c′ C) (c′ A′) (c′ B′)) () (((collinear A B C) ∧ (A B ≡ A′ B′)) → (∃ c′ (A B C ≅ A′ B′ (value c′)))) (
        A B C A′ B′ c′ CollinearityConstructDegenerateTriangle-abc
        B C A A′ B′ c′ CollinearityConstructDegenerateTriangle-bca
        composeDisjunction

        C A B A′ B′ c′ CollinearityConstructDegenerateTriangle-cab
        composeDisjunction

        import
))
</jh>

== Export ==
We now export to [[Interface:Collinearity]].
<jh>
export (RESULTS Interface:Collinearity (CLASSICAL FIRSTORDER) ())
</jh>

Also, since this page is currently the last in the (in-progress) series on basic geometry, we export to [[Interface:Basic geometry]].
<jh>
export (GEOMETRY Interface:Basic_geometry (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]

