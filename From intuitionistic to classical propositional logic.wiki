{{header
 | title    = From intuitionistic to classical
 | subtitle = propositional logic
 | left     = 
 | right    = 
 | shortcut = 
 | notes    = Adding the [[Interface:Law of the excluded middle]] to [[Interface:Intuitionistic propositional logic]] gives classical propositional logic.
}}
{{interfaces
| imports = *[[Interface:Intuitionistic propositional logic]]
*[[Interface:Law of the excluded middle]]
| exports = [[Interface:Principia Mathematica propositional logic theorems]]
}}

Instead of proving the axioms of classical propositional logic (for example, [[Interface:Standard axioms of propositional logic]]), we prove the [[Interface:Principia Mathematica propositional logic theorems]].  This is for two reasons.  The first is to show that all the connectives, not just those mentioned in the axioms, have the same meanings (this could alternately be achieved by including all the definitions in the interface with the axioms, as in [[Interface:Principia Mathematica propositional logic]]). The second is to present an alternative proof of the [[Interface:Principia Mathematica propositional logic theorems]].  In some cases the way we prove the theorems is very similar, but in others it is quite different.  The proofs in [[Principia Mathematica propositional logic]] rely heavily on the relationships between the connectives (especially implication and disjunction), and the proofs via intuitionistic logic rely more heavily on theorems such as disjunction composition and conjunction composition.

{{under construction}}
<jh>
import (INTUITIONISTIC Interface:Intuitionistic_propositional_logic () ())
import (EXCLUDED_MIDDLE Interface:Law_of_the_excluded_middle () ())
</jh>
We define some variables:
<jh>
var (formula p q r s)
</jh>

== Double negation elimination ==
<jh>
thm (DoubleNegationElimination () () ((¬ (¬ p)) → p) (
        p TertiumNonDatur
        swapDisjunction

        (¬ p) p DisjunctionImplicationForward
        applyModusPonens
))

thm (eliminateDoubleNegation () ((H (¬ (¬ p)))) p (
        H
        p DoubleNegationElimination
        applyModusPonens
))

thm (DoubleNegation () () (p ↔ (¬ (¬ p))) (
        p DoubleNegationIntroduction
        p DoubleNegationElimination
        introduceBiconditionalFromImplications
))
</jh>

== Transposition elimination ==
<jh>
thm (TranspositionElimination () () (((¬ q) → (¬ p)) → (p → q)) (
        (¬ q) (¬ p) TranspositionIntroduction

        p DoubleNegation
        q DoubleNegation
        buildImplication
        eliminateBiconditionalForward

        applySyllogism
))

thm (eliminateTransposition () ((H ((¬ q) → (¬ p)))) (p → q) (
        H
        q p TranspositionElimination
        applyModusPonens
))

thm (Transposition () () ((p → q) ↔ ((¬ q) → (¬ p))) (
        p q TranspositionIntroduction
        p q TranspositionElimination
        introduceBiconditionalFromImplications
))
</jh>

<jh>
thm (TranspositionWithNegatedAntecedent () () (((¬ p) → q) ↔ ((¬ q) → p)) (
        (¬ p) q Transposition

        (¬ q) BiconditionalReflexivity
        p DoubleNegation
        buildImplication
        swapBiconditional

        applyBiconditionalTransitivity
))

thm (TranspositionWithNegatedConsequent () () ((p → (¬ q)) ↔ (q → (¬ p))) (
        p DoubleNegation
        (¬ q) BiconditionalReflexivity
        buildImplication

        q (¬ p) Transposition
        swapBiconditional

        applyBiconditionalTransitivity
))
</jh>

=== Transposition for the biconditional ===

To prove this biconditional transposition law, we write the biconditional on the left and right side as a pair of implications, and then apply transposition to each of them.

<jh>
thm (NegationFunction () () ((p ↔ q) ↔ ((¬ p) ↔ (¬ q))) (
        p q BiconditionalImplication

        p q Transposition
        q p Transposition
        buildConjunction
        applyBiconditionalTransitivity

        ((¬ q) → (¬ p)) ((¬ p) → (¬ q)) ConjunctionCommutativity
        applyBiconditionalTransitivity

        (¬ p) (¬ q) BiconditionalImplication
        swapBiconditional
        applyBiconditionalTransitivity
))

thm (removeNegation () ((H ((¬ p) ↔ (¬ q)))) (p ↔ q) (
        H
        p q NegationFunction
        eliminateBiconditionalForward
        applyModusPonens
))
</jh>

The following version is similar, but with the negation placed differently.  The proof is similar, but is based on different variants of transposition for implications.

<jh>
thm (BiconditionalTranspositionWithNegatedRight () () ((p ↔ (¬ q)) ↔ (q ↔ (¬ p))) (
        p (¬ q) BiconditionalImplication

        p q TranspositionWithNegatedConsequent
        q p TranspositionWithNegatedAntecedent
        buildConjunction
        applyBiconditionalTransitivity

        (¬ p) q BiconditionalImplication
        swapBiconditional
        applyBiconditionalTransitivity
))

thm (transposeBiconditionalWithNegatedRight () ((H (p ↔ (¬ q)))) (q ↔ (¬ p)) (
        H
        p q BiconditionalTranspositionWithNegatedRight
        applyModusPonens
))
</jh>

It will also be convenient to have a commuted version of this theorem.
<jh>
thm (BiconditionalTranspositionWithNegatedLeft () () (((¬ p) ↔ q) ↔ ((¬ q) ↔ p)) (
        (¬ p) q BiconditionalSymmetry

        q p BiconditionalTranspositionWithNegatedRight
        applyBiconditionalTransitivity

        p (¬ q) BiconditionalSymmetry
        applyBiconditionalTransitivity
))

thm (transposeBiconditionalWithNegatedLeft () ((H ((¬ p) ↔ q))) ((¬ q) ↔ p) (
        H
        p q BiconditionalTranspositionWithNegatedLeft
        applyModusPonens
))
</jh>

== DeMorgan's laws ==
One of DeMorgan's laws holds (in both directions) intuitionistically.

<jh>
thm (DeMorganPDP () () ((¬ (p ∨ q)) ↔ ((¬ p) ∧ (¬ q))) (
        p q NegationCollectionNCNDistributionPDP
        swapBiconditional
))
</jh>

Double negation elimination turns that one into the other three which distribute negation across disjunction.

<jh>
thm (DeMorganPDN () () ((¬ (p ∨ (¬ q))) ↔ ((¬ p) ∧ q)) (
        p (¬ q) DeMorganPDP

        (¬ p) BiconditionalReflexivity
        q DoubleNegation swapBiconditional
        buildConjunction

        applyBiconditionalTransitivity
))

thm (DeMorganNDP () () ((¬ ((¬ p) ∨ q)) ↔ (p ∧ (¬ q))) (
        (¬ p) q DeMorganPDP

        p DoubleNegation swapBiconditional
        (¬ q) BiconditionalReflexivity
        buildConjunction

        applyBiconditionalTransitivity
))

thm (DeMorganNDN () () ((¬ ((¬ p) ∨ (¬ q))) ↔ (p ∧ q)) (
        (¬ p) (¬ q) DeMorganPDP

        p DoubleNegation
        q DoubleNegation
        buildConjunction
        swapBiconditional

        applyBiconditionalTransitivity
))
</jh>

The versions which distribute negation across a conjunction follow from the above versions and transposition.
<jh>
thm (DeMorganPCP () () ((¬ (p ∧ q)) ↔ ((¬ p) ∨ (¬ q))) (
        p q DeMorganNDN
        transposeBiconditionalWithNegatedLeft
))

thm (DeMorganPCN () () ((¬ (p ∧ (¬ q))) ↔ ((¬ p) ∨ q)) (
        p q DeMorganNDP
        transposeBiconditionalWithNegatedLeft
))

thm (DeMorganNCP () () ((¬ ((¬ p) ∧ q)) ↔ (p ∨ (¬ q))) (
        p q DeMorganPDN
        transposeBiconditionalWithNegatedLeft
))

thm (DeMorganNCN () () ((¬ ((¬ p) ∧ (¬ q))) ↔ (p ∨ q)) (
        p q DeMorganPDP
        transposeBiconditionalWithNegatedLeft
))
</jh>

== Case elimination ==
<jh>
#stmt (CaseElimination () () (((p → q) ∧ ((¬ p) → q)) → q))
</jh>

== Tautology ==
The intention of this theorem is similar to the intuitionistic <code>TautologyId</code>, but it is stated in terms of the law of the excluded middle.

<jh>
thm (Tautology () () ((p ∨ (¬ p)) ↔ (⊤)) (
        True (p ∨ (¬ p)) introduceAntecedent
        p TertiumNonDatur (⊤) introduceAntecedent
        introduceBiconditionalFromImplications
))
</jh>

== Relationships between connectives ==

=== Biconditional and two disjunctions ===
<jh>
#stmt (BiconditionalDisjunctionLeftElimination () () ((p ↔ q) → (p ∨ (¬ q))))
#stmt (BiconditionalDisjunctionRightElimination () () ((p ↔ q) → ((¬ p) ∨ q)))
#stmt (BiconditionalConjunction () () ((p ↔ q) ↔ (((¬ p) ∨ q) ∧ (p ∨ (¬ q)))))
</jh>

=== Biconditional as the disjunction of two equivalence classes ===

<jh>
#stmt (BiconditionalDisjunction () () ((p ↔ q) ↔ ((p ∧ q) ∨ ((¬ p) ∧ (¬ q)))))
</jh>

=== Implication and disjunction ===

Intuitionistic logic does have one equivalence relating disjunction to implication, <code>¬ (p ∨ q) ↔ ¬ (¬ p → q)</code>. That and transposition gets us one of the classical equivalences,
<jh>
thm (DisjunctionImplication () () ((p ∨ q) ↔ ((¬ p) → q)) (
        p q NotDisjunctionImplication
        removeNegation
))
</jh>
and throwing in a little double negation elimination gets us the other.
<jh>
thm (ImplicationDisjunction () () ((p → q) ↔ ((¬ p) ∨ q)) (
        (¬ p) q DisjunctionImplication

        p DoubleNegation swapBiconditional
        q BiconditionalReflexivity
        buildImplication

        applyBiconditionalTransitivity

        swapBiconditional
))
</jh>

== Export ==
When this file is done, we'll be ready to export to [[Interface:Principia Mathematica propositional logic theorems]].

<jh>
kindbind (wff formula)
export (CLASSICAL Interface:Principia_Mathematica_propositional_logic_theorems () ())
</jh>

[[Category:Subsystems of classical logic|{{PAGENAME}}]]

