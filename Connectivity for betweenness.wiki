{{interfaces
| imports = [[Interface:Collinearity]]
| exports = [[Interface:Connectivity for betweenness]]
}}

This is part of a series of modules which prove a variety of geometrical theorems starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

This page is primarily devoted to the proof of one theorem, <code>A ≠ B ∧ between A B C ∧ between A B D → between A C D ∨ between A D C</code>. This is called outer connectivity for betweenness by Narboux<ref>Narboux (2007), page 144</ref> and Givant.<ref>Tarski and Givant (1999), page 186</ref> It was once considered an axiom of Tarski's system, but was proved from the other axioms by Gupta in 1965<ref>Tarski and Givant (1999), page 190</ref><ref>Narboux (2007), citing Gupta, H.N.: Contributions to the axiomatic foundations of geometry. PhD thesis, University of California, Berkley (1965)</ref>

The proof is not simple; Givant calls it "rather involved" and Narboux devotes two and a half pages to an informal proof (and an explanation of part of the formal proof).<ref>Narboux (2007), pages 151-153</ref>

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Collinearity|geometry results so far]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (START Interface:Collinearity (CLASSICAL FIRSTORDER) ())

var (point A B C D E P Q R A′ B′ C′ D′ B″ C″)
var (variable a b b′ c c′ d′ e p q r b″ c″)
</jh>

== Summary ==
[[File:outer connectivity for betweenness 1.svg|thumb|right|construction of C′, D′, B′, and B″]]

Here's an outline of the proof, illustrating which points we construct but leaving most of the detailed line segment congruences for the detailed formal proof.

We first construct <code>C′ and D′</code> extending the line segments <code>A D</code> and <code>A C</code> by a distance of <code>C D</code> in both cases. Eventually, the proof will show that <code>C = C′</code> or <code>D = D′</code>.

Then extend the line segments <code>A C′</code> and <code>A D′</code> to points <code>B′</code> and <code>B″</code> by distances of <code>C B</code> and <code>D B</code>. The result of this construction is that the distance from <code>B</code> is the same to either <code>B′</code> or <code>B″</code> and thus we can conclude that <code>B′ = B″</code>.

[[File:outer connectivity for betweenness 2.svg|thumb|right|construction of E]]
The point <code>E</code> lies at the intersection of <code>C C′</code> and <code>D D′</code>.

At this point we assume <code>C ≠ C′</code> and will deduce from that <code>D = D′</code>.

[[File:outer connectivity for betweenness 3.svg|thumb|right|construction of P, Q, and R]]
Extend <code>C′ C</code> by the distance <code>C D′</code> to a point <code>P</code>. Extend <code>D′ C</code> by the distance <code>C E</code> to a point <code>R</code>. Extend <code>P R</code> by the distance <code>R P</code> to a point <code>Q</code>.

[[File:outer connectivity for betweenness 4.svg|thumb|right|D′ D ≡ P Q and C P ≡ C Q]]
By some congruences we can show first <code>D′ D ≡ P Q</code>, which we'll need at the end of the proof, and <code>C P ≡ C Q</code>, which leads to the next step.

[[File:outer connectivity for betweenness 5.svg|thumb|right|B P ≡ B Q and B′ P ≡ B′ Q]]
We can now show that <code>B</code> and <code>B′</code> are each equidistant from <code>P</code> and <code>Q</code>.

TODO: can we expand on the motivation for this, or how it leads to the next step?

[[File:outer connectivity for betweenness 6.svg|thumb|right|C′ P ≡ C′ Q]]
Similarly, C′ is also equidistant from <code>P</code> and <code>Q</code>.

{{under construction}}
TODO: What is the picture and the brief summary of the last steps (P P ≡ P Q, P = Q, and D = D′)?

== Construction of C′, D′, B′, and B″ ==
[[File:outer connectivity for betweenness 1.svg|thumb|right|construction of C′, D′, B′, and B″]]
We construct <code>c′</code> such that <code>between A D c′ ∧ D c′ ≡ C D</code> and <code>d′</code> such that <code>between A C d′ ∧ C d′ ≡ C D</code>.

Then we construct <code>b′</code> such that <code>between A c′ b′ ∧ c′ b′ ≡ C B</code> and <code>b″</code> such that <code>between A d′ b″ ∧ d′ b″ ≡ D B</code>.

The following lemma embodies these constructions, and a bit of rearrangement of the quantifiers.
<jh>
thm (BetweennessOuterConnectivity-cdbb
  ((A c′ d′ b′ b″) (B c′ d′ b′ b″) (C c′ d′ b′ b″) (D c′ d′ b′ b″)) ()
  ((((A ≠ B) ∧ (between A B C)) ∧ (between A B D)) →
    (∃ c′ (∃ d′ (∃ b′ (∃ b″
      ((((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
      ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
      ((between A (value c′) (value b′)) ∧ ((value c′) (value b′) ≡ C B))) ∧
      ((between A (value d′) (value b″)) ∧ ((value d′) (value b″) ≡ D B))) ∧
      (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))))))) (
        c′ A D C D SegmentConstruction
        d′ A C C D SegmentConstruction
        introduceConjunction

        c′ d′ ((between A D (value c′)) ∧ (D (value c′) ≡ C D))
          ((between A C (value d′)) ∧ (C (value d′) ≡ C D))
          ThereExistsScattering
        eliminateBiconditionalForward

        applyModusPonens
</jh>
So far we have the construction of <code>c′</code> and <code>d′</code>, specifically <code>∃ c′ ∃ d′ ((between A D c′ ∧ D c′ ≡ C D) ∧ (between A C d′ ∧ C d′ ≡ C D))</code>. We now turn to <code>b′</code>.
<jh>
        b′ A (value c′) C B SegmentConstruction
        d′ generalize
        c′ generalize

        introduceConjunction

        c′
          (∃ d′ (((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D))))
          (∀ d′ (∃ b′ ((between A (value c′) (value b′))
            ∧ ((value c′) (value b′) ≡ C B))))
          ThereExistsConjunctionRightCombining
        applyModusPonens

        d′
          (((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D)))
          (∃ b′ ((between A (value c′) (value b′))
            ∧ ((value c′) (value b′) ≡ C B)))
          ThereExistsConjunctionRightCombining
        c′ addThereExists
        applyModusPonens
</jh>
That gives us <code>∃ c′ ∃ d′ ((between A D c′ ∧ D c′ ≡ C D) ∧ (between A C d′ ∧ C d′ ≡ C D) ∧ ∃ b′ (between A c′ b′ ∧ c′ b′ ≡ C B))</code>. The next step is to move <code>∃ b′</code> to the front.
<jh>
        b′
          (((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D)))
          ((between A (value c′) (value b′))
            ∧ ((value c′) (value b′) ≡ C B))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        d′ addThereExists
        c′ addThereExists
        applyModusPonens
</jh>
Now we construct <code>b″</code>, which starts with <code>∃ b″ (between A d′ b″ ∧ d′ b″ ≡ D B)</code> and then moves the quantifiers to the front.
<jh>
        b″ A (value d′) D B SegmentConstruction
        d′ generalize

        introduceConjunction

        c′
          (∃ d′ (∃ b′
            ((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
              ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
              ((between A (value c′) (value b′))
                ∧ ((value c′) (value b′) ≡ C B)))
          ))
          (∀ d′ (∃ b″ ((between A (value d′) (value b″)) ∧ ((value d′) (value b″) ≡ D B))))
          ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applyModusPonens

        d′
          (∃ b′
            ((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
              ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
              ((between A (value c′) (value b′))
                ∧ ((value c′) (value b′) ≡ C B)))
          )
          (∃ b″ ((between A (value d′) (value b″)) ∧ ((value d′) (value b″) ≡ D B)))
          ThereExistsConjunctionRightCombining
        c′ addThereExists
        applyModusPonens

        b′ b″
          ((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
            ((between A (value c′) (value b′))
              ∧ ((value c′) (value b′) ≡ C B)))
          ((between A (value d′) (value b″)) ∧ ((value d′) (value b″) ≡ D B))
          ThereExistsScattering
        eliminateBiconditionalForward
        d′ addThereExists
        c′ addThereExists
        applyModusPonens
</jh>
Now we need to add in <code>A ≠ B ∧ between A B C ∧ between A B D</code>, and move it inside all four quantifiers.
<jh>
        (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)) introduceAntecedent

        (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)) ImplicationReflexivity
        composeConjunction

        c′
          (∃ d′ (∃ b′ (∃ b″
            (((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
            ((between A (value c′) (value b′))
              ∧ ((value c′) (value b′) ≡ C B))) ∧
            ((between A (value d′) (value b″))
              ∧ ((value d′) (value b″) ≡ D B)))
          )))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
        ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applySyllogism

        d′
          (∃ b′ (∃ b″
            (((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
            ((between A (value c′) (value b′))
              ∧ ((value c′) (value b′) ≡ C B))) ∧
            ((between A (value d′) (value b″))
              ∧ ((value d′) (value b″) ≡ D B)))
          ))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
        ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        c′ addThereExists
        applySyllogism

        b′
          (∃ b″
            (((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
            ((between A (value c′) (value b′))
              ∧ ((value c′) (value b′) ≡ C B))) ∧
            ((between A (value d′) (value b″))
              ∧ ((value d′) (value b″) ≡ D B)))
          )
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
        ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        d′ addThereExists
        c′ addThereExists
        applySyllogism

        b″
          (((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
            ((between A (value c′) (value b′))
              ∧ ((value c′) (value b′) ≡ C B))) ∧
            ((between A (value d′) (value b″))
              ∧ ((value d′) (value b″) ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
        ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        b′ addThereExists
        d′ addThereExists
        c′ addThereExists
        applySyllogism
))
</jh>

== B′ is equal to B″ ==
[[File:outer connectivity for betweenness 1.svg|thumb|right|B′ = B″]]
In this section we'll show that <code>B′ = B″</code>. The idea of the proof is simple: to get from <code>B</code> to <code>B′</code> we go through <code>D</code> and <code>C′</code>, and to get from <code>B</code> to <code>B″</code> we go through <code>C</code> and <code>D′</code>. As can be seen from the way we constructed the points, the three segments in the one case are congruent to the three segments in the other (although in reverse order), so the distance from <code>B</code> to either <code>B′</code> or <code>B″</code> is the same. Because <code>A ≠ B</code>, this implies that <code>B′ = B″</code> by the uniqueness of segment construction (applied to <code>A B B′</code> and <code>A B B″</code>).

=== B C′ ≡ B″ C ===
[[File:outer connectivity for betweenness 1.svg|thumb|right|B C′ ≡ B″ C]]
Here we prove <code>B C′ ≡ B″ C</code>, starting with a few lemmas which we'll need.
<jh>
thm (b-d-cprime
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between B D C′)) (
</jh>
First is <code>between A B D</code>.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionLeftElimination
        eliminateLeftConjunctionInConsequent
</jh>
Second is <code>between A D C′</code>
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent


        composeConjunction
</jh>
The result follows from transitivity.
<jh>
        A B D C′ BetweennessInnerTransitivityFlipped
        applySyllogism
))

thm (bdoubleprime-dprime-c
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between B″ D′ C)) (
</jh>
This is another application of transitivity, starting with <code>between B″ D′ A</code>.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        A D′ B″ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
The other thing we need is <code>between D′ C A</code>.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        A C D′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        B″ D′ A C BetweennessInnerTransitivity
        applySyllogism
))

thm (d-cprime-dprime-c
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (D C′ ≡ D′ C)) (
</jh>
Each of the segments <code>D C′</code> and <code>D′ C</code> is congruent to <code>C D</code>, so we just need to apply symmetry and transitivity.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        C D′ C D CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        D C′ C D C D′ CongruenceTransitivity
        applySyllogism

        D C′ C D′ CongruenceRightCommutativity
        eliminateBiconditionalReverse
        applySyllogism
))

thm (b-cprime-bdoubleprime-c
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (B C′ ≡ B″ C)) (
</jh>
We prove this theorem by applying <code>OuterThreeSegment</code> to <code>B D C′</code> and <code>B″ D′ C</code>. The first step is <code>between B D C′</code>.
<jh>
        A D C′ C D′ B′ B B″ b-d-cprime
</jh>
The next is <code>between B″ D′ C</code>.
<jh>
        A D C′ C D′ B′ B B″ bdoubleprime-dprime-c
        composeConjunction
</jh>
The next is <code>B D ≡ B″ D′</code>.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        D′ B″ D B CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        D B D′ B″ CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
The last is <code>D C′ D′ C</code>
<jh>
        A D C′ C D′ B′ B B″ d-cprime-dprime-c
        composeConjunction
</jh>
Three segment gives us <code>B C′ B″ C</code>, the desired result.
<jh>
        B D C′ B″ D′ C OuterThreeSegment
        applySyllogism
))
</jh>

=== B B′ ≡ B″ B ===
[[File:outer connectivity for betweenness 1.svg|thumb|right|B B′ ≡ B″ B]]
Here we extend the congruence from the previous section one more point. This is also an application of <code>OuterThreeSegment</code>, and we again break out some of the pieces into lemmas.
<jh>
thm (a-b-cprime
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between A B C′)) (
</jh>
This is an application of transitivity to <code>between A B D</code>
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionLeftElimination
        eliminateLeftConjunctionInConsequent
</jh>
and <code>between A D C′</code>.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        composeConjunction

        A B D C′ BetweennessMiddleTransitivityFlipped
        applySyllogism
))

thm (b-cprime-bprime
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between B C′ B′)) (
</jh>
Here we apply transitivity to <code>between A B C′</code>.
<jh>
        A D C′ C D′ B′ B B″ a-b-cprime
</jh>
and <code>between A C′ B′</code>.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        composeConjunction

        A B C′ B′ BetweennessInnerTransitivityFlipped
        applySyllogism
))

thm (a-c-bdoubleprime
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between A C B″)) (
</jh>
Here we apply transitivity to <code>between A C D′</code>
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent
</jh>
and <code>between A D′ B″</code>
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        composeConjunction

        A C D′ B″ BetweennessMiddleTransitivityFlipped
        applySyllogism
))

thm (bdoubleprime-c-b
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between B″ C B)) (
</jh>
Here we apply transitivity to <code>A B C</code>
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionLeftElimination
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
</jh>
and the previous lemma (<code>between A C B″</code>)
<jh>
        A D C′ C D′ B′ B B″ a-c-bdoubleprime
        composeConjunction
</jh>
to produce <code>B C B″</code>. Then we just need to switch the order of the endpoints.
<jh>
        A B C B″ BetweennessInnerTransitivityFlipped
        applySyllogism

        B C B″ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
))

thm (b-bprime-bdoubleprime-b
  () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (B B′ ≡ B″ B)) (
</jh>
First we need <code>between B C′ B′</code>.
<jh>
        A D C′ C D′ B′ B B″ b-cprime-bprime
</jh>
Next we need <code>between B″ C B</code>.
<jh>
        A D C′ C D′ B′ B B″ bdoubleprime-c-b
        composeConjunction
</jh>
<code>B C′ ≡ B″ C</code>:
<jh>
        A D C′ C D′ B′ B B″ b-cprime-bdoubleprime-c
        composeConjunction
</jh>
<code>C′ B′ ≡ C B</code>:
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        composeConjunction

        B C′ B′ B″ C B OuterThreeSegment
        applySyllogism
))
</jh>

=== B″ = B′ ===
In this section we apply <code>SegmentConstructionUniqueness</code> to prove that <code>B′</code> and <code>B″</code> are in fact the same point. We start with some more betweenness transitivity lemmas.
<jh>
thm (a-b-dprime () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between A B D′)) (
</jh>
<code>between A B C</code>:
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionLeftElimination
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

</jh>
<code>between A C D′</code>:
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        composeConjunction

        A B C D′ BetweennessMiddleTransitivityFlipped
        applySyllogism
))

thm (bdoubleprime-bprime () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (B″ = B′)) (
</jh>
We'll prove <code>B′ = B″</code> (and flip the order later). We first need <code>A ≠ B</code>.
<jh>
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionLeftElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
</jh>
Next is <code>between A B B′</code>, which follows from <code>between A B C′</code> and <code>between A C′ B′</code> by betweenness transitivity.
<jh>
        A D C′ C D′ B′ B B″ a-b-cprime

        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        composeConjunction

        A B C′ B′ BetweennessMiddleTransitivityFlipped
        applySyllogism

        composeConjunction
</jh>
Next is <code>between B B′ ≡ B″ B</code>.
<jh>
        A D C′ C D′ B′ B B″ b-bprime-bdoubleprime-b
        composeConjunction
</jh>
Next is <code>between A B B″</code>, which follows from <code>between A B D′</code> and <code>between A D′ B″</code> by betweenness transitivity.
<jh>
        A D C′ C D′ B′ B B″ a-b-dprime

        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        composeConjunction

        A B D′ B″ BetweennessMiddleTransitivityFlipped
        applySyllogism

        composeConjunction
</jh>
Finally we need <code>B B″ ≡ B″ B</code>.
<jh>
        B B″ CongruenceReflexivity

        B B″ B B″ CongruenceRightCommutativity
        eliminateBiconditionalReverse
        applyModusPonens

        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          introduceAntecedent
        composeConjunction
</jh>
Applying segment construction uniqueness, and then flipping the order of the equality, we are done.
<jh>
        A B B′ B″ B B″ SegmentConstructionUniqueness
        applySyllogism

        B′ B″ EqualitySymmetry
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

== Construction of E ==
[[File:outer connectivity for betweenness 2.svg|thumb|right|C′ D′ ≡ C D, construction of E, E C ≡ E C′, and E D ≡ E D′]]
In this section we construct the point <code>E</code> and also prove a number of congruences. First (even before we construct E), we can apply outer five segment to the line segments <code>B C D′</code> and <code>B′ C′ D</code> with points <code>C′</code> and <code>C</code> to give us <code>C′ D′ ≡ C D</code>. Then we construct <code>E</code> as the intersection of <code>C C′</code> and <code>D D′</code> (the axiom of Pasch ensures its existence).

The congruences <code>E C ≡ E C′</code> and <code>E D ≡ E D′</code> may remind us of the familiar theorem that the diagonals of a rhombus bisect each other, but of course to say it that way would get ahead of ourselves. We can readily prove each of those two congruences, however, from a simple invocation of inner five segment.

=== C′ D′ ≡ C D ===
[[File:outer connectivity for betweenness 1a.svg|thumb|right|C′ D′ ≡ C D]]
We just said that this follows from inner five segment, but that's a slight oversimplification. That's true for the <code>B ≠ C</code> case (which we'll prove first), but there's a separate <code>B = C</code> case. We'll start with the <code>B ≠ C</code> case, and before the case itself we'll prove a few lemmas which represent the various antecedents of <code>OuterFiveSegment</code>.
<jh>
thm (b-c-dprime () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between B C D′)) (
</jh>
We prove this via betweenness transitivity from <code>between B C B″</code>
<jh>
        A D C′ C D′ B′ B B″ bdoubleprime-c-b

        B″ C B BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
and <code>between C D′ B″</code>.
<jh>
        A D C′ C D′ B′ B B″ bdoubleprime-dprime-c

        B″ D′ C BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        B C B″ D′ BetweennessInnerTransitivity
        applySyllogism
))

thm (bprime-cprime-d () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (between B′ C′ D)) (
</jh>
This follows by betweenness transitivity from <code>B′ C′ B</code>
<jh>
        A D C′ C D′ B′ B B″ b-cprime-bprime

        B C′ B′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism
</jh>
and <code>C′ D B</code>
<jh>
        A D C′ C D′ B′ B B″ b-d-cprime

        B D C′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        B′ C′ B D BetweennessInnerTransitivity
        applySyllogism
))

</jh>
The next two lemmas just apply a substitution to turn <code>B C′ ≡ B″ C</code>, which we have already proved, into <code>B C′ ≡ B′ C</code>.
<jh>
thm (b-cprime-bprime-c-lemma () ()
  (((B″ = B′) ∧ (B C′ ≡ B″ C)) → (B C′ ≡ B′ C)) (
        B EqualityReflexivity
        C′ EqualityReflexivity
        C EqualityReflexivity
        B B C′ C′ B″ B′ C C CongruenceBuilder
        detach2of2
        detach2of3
        detach1of2

        eliminateBiconditionalReverseInConsequent

        import
))

thm (b-cprime-bprime-c () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (B C′ ≡ B′ C)) (
        A D C′ C D′ B′ B B″ bdoubleprime-bprime
        A D C′ C D′ B′ B B″ b-cprime-bdoubleprime-c
        composeConjunction

        B″ B′ B C′ C b-cprime-bprime-c-lemma
        applySyllogism
))

thm (cprime-dprime-c-d-case-bnotc () ()
  (((B ≠ C) ∧
    ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))) →
  (C′ D′ ≡ C D)) (
</jh>
For outer five segment, we first need <code>B ≠ C</code>.
<jh>
        (B ≠ C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionRightElimination
</jh>
Next is <code>between B C D′</code>.
<jh>
        (B ≠ C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionLeftElimination

        A D C′ C D′ B′ B B″ b-c-dprime
        applySyllogism

        composeConjunction
</jh>
Next is <code>between B′ C′ D</code>.
<jh>
        (B ≠ C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionLeftElimination

        A D C′ C D′ B′ B B″ bprime-cprime-d
        applySyllogism

        composeConjunction
</jh>
Next is <code>B C ≡ B′ C′</code>.
<jh>
        (B ≠ C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionLeftElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        C′ B′ C B CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        C B C′ B′ CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Next is <code>C D′ ≡ C′ D</code>.
<jh>
        (B ≠ C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionLeftElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        (B ≠ C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionLeftElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        D C′ C D CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        C D D C′ CongruenceRightCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        C D′ C D C′ D CongruenceTransitivity
        applySyllogism

        composeConjunction
</jh>
Next is <code>B C′ ≡ B′ C</code>.
<jh>
        (B ≠ C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionLeftElimination

        A D C′ C D′ B′ B B″ b-cprime-bprime-c
        applySyllogism

        composeConjunction
</jh>
Last is <code>C C′ ≡ C′ C</code>.
<jh>
        C C′ CongruenceReflexivity

        C C′ C C′ CongruenceRightCommutativity
        eliminateBiconditionalReverse
        applyModusPonens

        ((B ≠ C) ∧
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))))
          introduceAntecedent

        composeConjunction
</jh>
Applying outer five segment gives us <code>D′ C′ ≡ D C</code>. We flip the order of the points to turn that into <code>C′ D′ ≡ C D</code>.
<jh>
        B C D′ B′ C′ D C′ C OuterFiveSegment
        applySyllogism

        D′ C′ D C CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism
))
</jh>

We now turn to the <code>B = C</code> case. We first note that in this case <code>C′ B′ ≡ C B</code> implies <code>B′ = C′</code>
<jh>
thm (bprime-cprime () ()
  (((B = C) ∧
    ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))) →
  (B′ = C′)) (
        (B = C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionRightElimination

        (B = C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionLeftElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        C′ B′ C B CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        C B C′ B′ CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        B C B′ C′ CongruenceIdentityFromEquality
        import
        applySyllogism
))

thm (cprime-dprime-c-d-case-bc-1 () ()
  ((((B″ = B′) ∧ (B′ = C′)) ∧ (D′ B″ ≡ D B)) → (C′ D′ ≡ B D)) (
        B″ B′ C′ EqualityTransitivity

        D′ EqualityReflexivity
        D EqualityReflexivity
        B EqualityReflexivity
        D′ D′ B″ C′ D D B B CongruenceBuilder
        detach2of2
        detach2of2
        detach1of2

        eliminateBiconditionalReverseInConsequent
</jh>
The top thing on the proof stack is now <code>B″ = C′ → (D′ B″ ≡ D B → D′ C′ ≡ D B</code>. We just need to combine it with the other thing on the proof stack, import, and adjust the consequent.
<jh>
        applySyllogism

        import

        D′ C′ D B CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism
))

thm (cprime-dprime-c-d-case-bc-2 () ()
  (((((B″ = B′) ∧ (B′ = C′)) ∧ (D′ B″ ≡ D B)) ∧ (B = C))
    → (C′ D′ ≡ C D)) (
        (((B″ = B′) ∧ (B′ = C′)) ∧ (D′ B″ ≡ D B)) (B = C)
          ConjunctionRightElimination
        B″ B′ C′ D′ D B cprime-dprime-c-d-case-bc-1
        applySyllogism

        (((B″ = B′) ∧ (B′ = C′)) ∧ (D′ B″ ≡ D B)) (B = C)
          ConjunctionLeftElimination
        C′ EqualityReflexivity
        D′ EqualityReflexivity
        D EqualityReflexivity
        C′ C′ D′ D′ B C D D CongruenceBuilder
        detach2of2
        detach2of3
        detach1of2
        applySyllogism

        eliminateBiconditionalReverseInConsequent

        composeConjunction

        (C′ D′ ≡ B D) (C′ D′ ≡ C D) ModusPonens
        applySyllogism
))

thm (cprime-dprime-c-d-case-bc () ()
  (((B = C) ∧
    ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))) →
  (C′ D′ ≡ C D)) (
</jh>
We've proved all the interesting parts. We just need to pick out the various antecedents for <code>cprime-dprime-c-d-case-bc-2</code>. <code>B″ = B′</code>:
<jh>
        (B = C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionLeftElimination
        A D C′ C D′ B′ B B″ bdoubleprime-bprime
        applySyllogism
</jh>
<code>B′ = C′</code>
<jh>
        B C A D C′ D′ B′ B″ bprime-cprime
        composeConjunction
</jh>
<code>D′ B″ ≡ D B</code>
<jh>
        (B = C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionLeftElimination
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        composeConjunction
</jh>
<code>B = C</code>:
<jh>
        (B = C)
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ConjunctionRightElimination
        composeConjunction

        B″ B′ C′ D′ D B C cprime-dprime-c-d-case-bc-2
        applySyllogism
))
</jh>

Finishing the proof of <code>C′ D′ ≡ C D</code> just involves assembling the two cases.

<jh>
thm (cprime-dprime-c-d () ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (C′ D′ ≡ C D)) (
        B C A D C′ D′ B′ B″ cprime-dprime-c-d-case-bc
        export

        B C A D C′ D′ B′ B″ cprime-dprime-c-d-case-bnotc
        export

        eliminateCases
))
</jh>

=== Construction of E ===
We're now ready to construct the point <code>E</code>. We already have the betweenness relationships we need for the axiom of Pasch, <code>between D′ C A</code> and <code>between C′ D A</code>. Applying <code>Pasch</code>, we get <code>C E C′</code> and <code>D E D′</code>.
<jh>
thm (e-exists-1
  ((e A) (e D) (e C′) (e C) (e D′) (e B′) (e B) (e B″)) ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (∃ e ((between C (value e) C′) ∧ (between D (value e) D′)))) (
        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        A C D′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        (((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B)))
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        A D C′ BetweennessSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        D′ C A C′ D e Pasch
        applySyllogism
))
</jh>

Here's a variant of the previous theorem with the antecedent repeated inside the quantifier.
<jh>
thm (e-exists
  ((e A) (e D) (e C′) (e C) (e D′) (e B′) (e B) (e B″)) ()
  (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) →
  (∃ e
    (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
      ((between A C D′) ∧ (C D′ ≡ C D))) ∧
      ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
      ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
      (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
      ((between C (value e) C′) ∧ (between D (value e) D′))))) (
        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ImplicationReflexivity

        A D C′ C D′ B′ B B″ e e-exists-1

        composeConjunction

        e
          ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ((between C (value e) C′) ∧ (between D (value e) D′))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward

        applySyllogism
))
</jh>

=== E C ≡ E C′ ===
[[File:outer connectivity for betweenness 2.svg|thumb|right|E C ≡ E C′ and E D ≡ E D′]]
Here we apply inner five segment to prove <code>E C ≡ E C′</code>. We are applying inner five segment to the line segments <code>D E D′</code> and <code>D E D′</code> and points <code>C</code> and <code>C′</code>.
<jh>
thm (e-c-e-cprime () ()
  ((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) →
  (E C ≡ E C′)) (
</jh>
First we need <code>between D E D′</code>, which is one of our antecedents.
<jh>
        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ((between C E C′) ∧ (between D E D′))
          ConjunctionLeftElimination
        eliminateLeftConjunctionInConsequent
</jh>
Secondly we need a second copy of <code>between D E D′</code>.
<jh>
        (between D E D′) ConjunctionIdempotence
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Thirdly we need <code>D D′ ≡ D D′</code>, which is an identity.
<jh>
        D D′ CongruenceReflexivity
        (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′)))
          introduceAntecedent
        composeConjunction
</jh>
Fourth we need <code>E D′ ≡ E D′</code>, which is an identity.
<jh>
        E D′ CongruenceReflexivity
        (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′)))
          introduceAntecedent
        composeConjunction
</jh>
Next we need <code>D C ≡ D C′</code>, which is one of our antecedents (slightly rearranged).
<jh>
        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ((between C E C′) ∧ (between D E D′))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        D C′ C D CongruenceRightCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        D C′ D C CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Finally we need <code>D′ C ≡ D′ C′</code>, which follows from the antecedent <code>C D′ ≡ C D</code> and <code>C′ D′ ≡ C D</code>, which we proved previously.
<jh>
        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ((between C E C′) ∧ (between D E D′))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ((between C E C′) ∧ (between D E D′))
          ConjunctionRightElimination
        A D C′ C D′ B′ B B″ cprime-dprime-c-d
        applySyllogism

        C′ D′ C D CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        C D′ C D C′ D′ CongruenceTransitivity
        applySyllogism

        C D′ C′ D′ CongruenceCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Applying inner five segment we get <code>E C ≡ E C′</code>
<jh>
        D E D′ D E D′ C C′ InnerFiveSegment
        applySyllogism
))
</jh>

=== E D ≡ E D′ ===
The proof that <code>E D ≡ E D′</code> is exactly analogous, but applies inner five segment to the line segments <code>C E C′</code> and <code>C E C′</code> and points <code>D</code> and <code>D′</code>.
<jh>
thm (e-d-e-dprime () ()
  ((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) →
  (E D ≡ E D′)) (
</jh>
First we need <code>between C E C′</code>, which is one of our antecedents.
<jh>
        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ((between C E C′) ∧ (between D E D′))
          ConjunctionLeftElimination
        eliminateRightConjunctionInConsequent
</jh>
Secondly we need a second copy of <code>between C E C′</code>.
<jh>
        (between C E C′) ConjunctionIdempotence
        eliminateBiconditionalReverse
        applySyllogism
</jh>
Thirdly we need <code>C C′ ≡ C C′</code>, which is an identity.
<jh>
        C C′ CongruenceReflexivity
        (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′)))
          introduceAntecedent
        composeConjunction
</jh>
Fourth we need <code>E C′ ≡ E C′</code>, which is an identity.
<jh>
        E C′ CongruenceReflexivity
        (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′)))
          introduceAntecedent
        composeConjunction
</jh>
Next we need <code>C D ≡ C D′</code>, which is one of our antecedents (slightly rearranged).
<jh>
        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ((between C E C′) ∧ (between D E D′))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        C D′ C D CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Finally we need <code>C′ D ≡ C′ D′</code>, which follows from the antecedent <code>D C′ ≡ C D</code> and <code>C′ D′ ≡ C D</code>, which we proved previously.
<jh>
        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ((between C E C′) ∧ (between D E D′))
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        ((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))
          ((between C E C′) ∧ (between D E D′))
          ConjunctionRightElimination
        A D C′ C D′ B′ B B″ cprime-dprime-c-d
        applySyllogism

        C′ D′ C D CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction

        D C′ C D C′ D′ CongruenceTransitivity
        applySyllogism

        D C′ C′ D′ CongruenceLeftCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Applying inner five segment we get <code>E D ≡ E D′</code>
<jh>
        C E C′ C E C′ D D′ InnerFiveSegment
        applySyllogism
))
</jh>

== Construction of P, Q, and R ==
[[File:outer connectivity for betweenness 3.svg|thumb|right|construction of P, Q, and R]]
Extend <code>C′ C</code> by the distance <code>C D′</code> to a point <code>P</code>. Extend <code>D′ C</code> by the distance <code>C E</code> to a point <code>R</code>. Extend <code>P R</code> by the distance <code>R P</code> to a point <code>Q</code>.

In other words, we are adding <code>(between C′ C P ∧ C P ≡ C D′) ∧ (between D′ C R ∧ C R ≡ C E) ∧ (between P R Q ∧ R Q ≡ R P)</code>
<jh>
thm (p-q-r-exist
  ((p q r A) (p q r D) (p q r C′) (p q r C) (p q r D′) (p q r B′) (p q r B) (p q r B″) (p q r E)) ()
  ((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) →
  (∃ r (∃ p (∃ q (
    (((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    ((between C′ C (value p)) ∧ (C (value p) ≡ C D′))) ∧
    ((between D′ C (value r)) ∧ (C (value r) ≡ C E))) ∧
    ((between (value p) (value r) (value q)) ∧ ((value r) (value q) ≡ (value r) (value p)))
  ))))) (
        (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′)))
          ImplicationReflexivity
</jh>
We're ready to construct <code>p</code>.
<jh>
        p C′ C C D′ SegmentConstruction
        introduceRightConjunctToConsequent

        p
          (((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
            ((between C E C′) ∧ (between D E D′)))
          ((between C′ C (value p)) ∧ (C (value p) ≡ C D′))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        applySyllogism

</jh>
The construction of <code>r</code> is similar.
<jh>
        r D′ C C E SegmentConstruction
        introduceRightConjunctToConsequent

        # TODO: this can be simplified via ThereExistsScattering, right?
        r
          (∃ p 
            ((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
            ((between C E C′) ∧ (between D E D′))) ∧
            ((between C′ C (value p)) ∧ (C (value p) ≡ C D′))))
          ((between D′ C (value r)) ∧ (C (value r) ≡ C E))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        applySyllogism

        p
          ((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
            ((between C E C′) ∧ (between D E D′))) ∧
            ((between C′ C (value p)) ∧ (C (value p) ≡ C D′)))
          ((between D′ C (value r)) ∧ (C (value r) ≡ C E))
          ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        r addThereExists
        applySyllogism
</jh>
The construction of <code>q</code> is only slightly different (with the most obvious difference in the logic being that it depends on <code>p</code> and <code>r</code>).
<jh>
        q (value p) (value r) (value r) (value p) SegmentConstruction
        p generalize
        r generalize
        introduceRightConjunctToConsequent

        r
          (∃ p (((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
            ((between C E C′) ∧ (between D E D′))) ∧
            ((between C′ C (value p)) ∧ (C (value p) ≡ C D′))) ∧
            ((between D′ C (value r)) ∧ (C (value r) ≡ C E))))
          (∀ p (∃ q ((between (value p) (value r) (value q)) ∧ ((value r) (value q) ≡ (value r) (value p)))))
          ThereExistsConjunctionRightCombining
        applySyllogism

        p
          (((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
            ((between C E C′) ∧ (between D E D′))) ∧
            ((between C′ C (value p)) ∧ (C (value p) ≡ C D′))) ∧
            ((between D′ C (value r)) ∧ (C (value r) ≡ C E)))
          (∃ q ((between (value p) (value r) (value q)) ∧ ((value r) (value q) ≡ (value r) (value p))))
          ThereExistsConjunctionRightCombining
        r addThereExists
        applySyllogism

        q
          (((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
            ((between A C D′) ∧ (C D′ ≡ C D))) ∧
            ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
            ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
            (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
            ((between C E C′) ∧ (between D E D′))) ∧
            ((between C′ C (value p)) ∧ (C (value p) ≡ C D′))) ∧
            ((between D′ C (value r)) ∧ (C (value r) ≡ C E)))
          ((between (value p) (value r) (value q)) ∧ ((value r) (value q) ≡ (value r) (value p)))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        p addThereExists
        r addThereExists
        applySyllogism
))
</jh>

=== C ≠ D′ ===
Our goal is to prove <code>C = C′ ∨ D = D′</code>. We do this by adding <code>C ≠ C′</code> to our antecedent and then showing it implies <code>D = D′</code>. The first step is to show that <code>C ≠ D′</code>. This is a straightforward consequence of <code>C ≠ C′</code> and the congruence of <code>C D′</code> and <code>C′ D′</code>, but it will take a few lemmas to do all the needed arranging.
<jh>
thm (dprime-cprime () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    (between C′ C P ∧ C P ≡ C D′)) ∧
    (between D′ C R ∧ C R ≡ C E)) ∧
    (between P R Q ∧ R Q ≡ R P)) ∧
    (C = D′)) →
  (D′ = C′)) (
</jh>
First we need <code>C = D′</code>.
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          (between C′ C P ∧ C P ≡ C D′)) ∧
          (between D′ C R ∧ C R ≡ C E)) ∧
          (between P R Q ∧ R Q ≡ R P))
          (C = D′)
          ConjunctionLeftElimination
</jh>
Secondly we need <code>C D′ ≡ D′ C′</code> which we derive from <code>C D′ ≡ C D</code> (an antecedent), <code>C′ D′ ≡ C D</code> (previously proved), and a bit of rearrangement.
<jh>
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          (between C′ C P ∧ C P ≡ C D′)) ∧
          (between D′ C R ∧ C R ≡ C E)) ∧
          (between P R Q ∧ R Q ≡ R P))
          (C = D′)
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateLeftConjunctionInConsequent
        eliminateLeftConjunctionInConsequent

        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          (between C′ C P ∧ C P ≡ C D′)) ∧
          (between D′ C R ∧ C R ≡ C E)) ∧
          (between P R Q ∧ R Q ≡ R P))
          (C = D′)
          ConjunctionRightElimination
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent
        eliminateRightConjunctionInConsequent

        A D C′ C D′ B′ B B″ cprime-dprime-c-d
        applySyllogism

        C′ D′ C D CongruenceSymmetry
        eliminateBiconditionalReverse
        applySyllogism

        C D′ C D C′ D′ CongruenceTransitivity
        applySyllogism

        C D′ C′ D′ CongruenceRightCommutativity
        eliminateBiconditionalReverse
        applySyllogism

        composeConjunction
</jh>
Now we can show <code>D′ = C′</code>.
<jh>
        C D′ D′ C′ CongruenceIdentityFromEquality
        import
        applySyllogism
))

thm (c-cprime () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    (between C′ C P ∧ C P ≡ C D′)) ∧
    (between D′ C R ∧ C R ≡ C E)) ∧
    (between P R Q ∧ R Q ≡ R P)) ∧
    (C = D′)) →
  (C = C′)) (
        ((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
          ((between A C D′) ∧ (C D′ ≡ C D))) ∧
          ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
          ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
          (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
          ((between C E C′) ∧ (between D E D′))) ∧
          (between C′ C P ∧ C P ≡ C D′)) ∧
          (between D′ C R ∧ C R ≡ C E)) ∧
          (between P R Q ∧ R Q ≡ R P))
          (C = D′)
          ConjunctionLeftElimination

        A D C′ C D′ B′ B B″ E P R Q cprime-dprime-c-d
        composeConjunction

        C D′ C′ EqualityTransitivity
        applySyllogism
))

thm (c-dprime () ()
  (
    (((((((((((between A D C′) ∧ (D C′ ≡ C D)) ∧
    ((between A C D′) ∧ (C D′ ≡ C D))) ∧
    ((between A C′ B′) ∧ (C′ B′ ≡ C B))) ∧
    ((between A D′ B″) ∧ (D′ B″ ≡ D B))) ∧
    (((A ≠ B) ∧ (between A B C)) ∧ (between A B D))) ∧
    ((between C E C′) ∧ (between D E D′))) ∧
    (between C′ C P ∧ C P ≡ C D′)) ∧
    (between D′ C R ∧ C R ≡ C E)) ∧
    (between P R Q ∧ R Q ≡ R P)) ∧
    (C ≠ C′)) →
  (C ≠ D′)) (
        A D C′ C D′ B′ B B″ E P R Q c-cprime
        export

        (C = D′) (C = C′) Transposition
        eliminateBiconditionalReverse
        applySyllogism

        import
))
</jh>

== Under construction ==
{{under construction}}
A ≠ B ∧ between A B C ∧ between A B D →
  ∃ c′ ∃ d′ ∃ b′ ∃ b″ (stuff1)

(stuff1) → ∃ e (stuff2)
    between C e C′ ∧ between D e D′

(stuff2) ∧ C ≠ C′ → ∃ r ∃ p ∃ q (stuff3)

(stuff3) → D = D′

Want (stuff2) → (C ≠ C′ → D = D′)

== Export ==
We now export to [[Interface:Connectivity for betweenness]].
<jh>
#export (RESULTS Interface:Connectivity_for_betweenness (CLASSICAL FIRSTORDER) ())
</jh>

Also, since this page is currently the last in the (in-progress) series on basic geometry, we export to [[Interface:Basic geometry]].
<jh>
export (GEOMETRY Interface:Basic_geometry (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>
* Tarski, Alfred; Givant, Steven (1999), "Tarski's system of geometry", The Bulletin of Symbolic Logic 5 (2): 175–214, doi:10.2307/421089, MR1791303, ISSN 1079-8986

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]

