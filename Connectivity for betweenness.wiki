{{interfaces
| imports = [[Interface:Triangle congruence]]
| exports = [[Interface:Collinearity]]
}}

This is part of a series of modules which prove a variety of geometrical theorems starting with Tarski's axioms for geometry. We follow the formalization of Julien Narboux<ref>The formal proofs are at [http://www.lix.polytechnique.fr/Labo/Julien.Narboux/tarski.html Formalization of Tarski's geometry in the Coq proof assistant] and are described in Julien Narboux (2007), "[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.158.8614 Mechanical Theorem Proving in Tarski’s Geometry]", F. Botana and T. Recio (Eds.): ADG 2006, LNAI 4869, pp. 139–156</ref> which itself closely follows a treatise by Schwabhäuser, Szmielew, and Tarski.<ref>W. Schwabhäuser, W Szmielew, and A. Tarski (1983), ''Metamathematische Methoden in der Geometrie'', ISBN 0387129588</ref>

This page is primarily devoted to the proof of one theorem, <code>A ≠ B ∧ between A B C ∧ between A B D → between A C D ∨ between A D C</code>. This is called outer connectivity for betweenness by Narboux<ref>Narboux (2007), page 144</ref> and Givant.<ref>Tarski and Givant (1999), page 186</ref> It was once considered an axiom of Tarski's system, but was proved from the other axioms by Gupta in 1965<ref>Tarski and Givant (1999), page 190</ref><ref>Narboux (2007), citing Gupta, H.N.: Contributions to the axiomatic foundations of geometry. PhD thesis, University of California, Berkley (1965)</ref>

The proof is not simple; Givant calls it "rather involved" and Narboux devotes two and a half pages to an informal proof (and an explanation of part of the formal proof).<ref>Narboux (2007), pages 151-153</ref>

We import the theorems of [[Interface:Classical propositional calculus|propositional logic]] and [[Interface:First-order logic with quantifiability|predicate logic]], and the [[Interface:Collinearity|geometry results so far]] and define some variables:
<jh>
import (CLASSICAL Interface:Classical_propositional_calculus () ())
import (FIRSTORDER Interface:First-order_logic_with_quantifiability (CLASSICAL) ())
import (START Interface:Collinearity (CLASSICAL FIRSTORDER) ())

var (point A B C D E P Q R A′ B′ C′ D′ B″ C″)
var (variable a b b′ c c′ d′ e p q r b″ c″)
</jh>

== Summary ==
[[File:outer connectivity for betweenness 1|thumb|right|construction of C′, D′, B′, and B″]]

Here's an outline of the proof, illustrating which points we construct but leaving most of the detailed line segment congruences for the detailed formal proof.

We first construct <code>C′ and D′</code> extending the line segments <code>A D</code> and <code>A C</code> by a distance of <code>C D</code> in both cases. Eventually, the proof will show that <code>C = C′</code> or <code>D = D′</code>.

Then extend the line segments <code>A C′</code> and <code>A D′</code> to points <code>B′</code> and <code>B″</code> by distances of <code>C B</code> and <code>D B</code>. The result of this construction is that the distance from <code>B</code> is the same to either <code>B′</code> or <code>B″</code> and thus we can conclude that <code>B′ = B″</code>.

[[File:outer connectivity for betweenness 2|thumb|right|construction of E]]
The point <code>E</code> lies at the intersection of <code>C C′</code> and <code>D D′</code>.

At this point we assume <code>C ≠ C′</code> and will deduce from that <code>D = D′</code>.

[[File:outer connectivity for betweenness 3|thumb|right|construction of P, Q, and R]]
Extend <code>C′ C</code> by the distance <code>C D′</code> to a point <code>P</code>. Extend <code>D′ C</code> by the distance <code>C E</code> to a point <code>R</code>. Extend <code>P R</code> by the distance <code>R P</code> to a point <code>Q</code>.

[[File:outer connectivity for betweenness 4|thumb|right|D′ D ≡ P Q and C P ≡ C Q]]
By some congruences we can show first <code>D′ D ≡ P Q</code>, which we'll need at the end of the proof, and <code>C P ≡ C Q</code>, which leads to the next step.

[[File:outer connectivity for betweenness 5|thumb|right|B P ≡ B Q and B′ P ≡ B′ Q]]
We can now show that <code>B</code> and <code>B′</code> are each equidistant from <code>P</code> and <code>Q</code>.

TODO: can we expand on the motivation for this, or how it leads to the next step?

[[File:outer connectivity for betweenness 6|thumb|right|C′ P ≡ C′ Q]]
Similarly, C′ is also equidistant from <code>P</code> and <code>Q</code>.

{{under construction}}
TODO: What is the picture and the brief summary of the last steps (P P ≡ P Q, P = Q, and D = D′)?

== Construction of C′, D′, B′, and B″ ==
[[File:outer connectivity for betweenness 1|thumb|right|construction of C′, D′, B′, and B″]]
We construct <code>c′</code> such that <code>between A D c′ ∧ D c′ ≡ C D</code> and <code>d′</code> such that <code>between A C d′ ∧ C d′ ≡ C D</code>.

Then we construct <code>b′</code> such that <code>between A c′ b′ ∧ c′ b′ ≡ C B</code> and <code>b″</code> such that <code>between A d′ b″ ∧ d′ b″ ≡ D B</code>.

The following lemma embodies these constructions, and a bit of rearrangement of the quantifiers.
<jh>
thm (BetweennessOuterConnectivity-cdbb
  ((A c′ d′ b′ b″) (B c′ d′ b′ b″) (C c′ d′ b′ b″) (D c′ d′ b′ b″)) ()
  ((((A ≠ B) ∧ (between A B C)) ∧ (between A B D)) →
    (∃ c′ (∃ d′ (∃ b′ (∃ b″
      ((((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
      ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
      ((between A (value c′) (value b′)) ∧ ((value c′) (value b′) ≡ C B))) ∧
      ((between A (value d′) (value b″)) ∧ ((value d′) (value b″) ≡ D B))) ∧
      (((A ≠ B) ∧ (between A B C)) ∧ (between A B D)))))))) (
        c′ A D C D SegmentConstruction
        d′ A C C D SegmentConstruction
        introduceConjunction

        c′ d′ ((between A D (value c′)) ∧ (D (value c′) ≡ C D))
          ((between A C (value d′)) ∧ (C (value d′) ≡ C D))
          ThereExistsScattering
        eliminateBiconditionalForward

        applyModusPonens
</jh>
So far we have the construction of <code>c′</code> and <code>d′</code>, specifically <code>∃ c′ ∃ d′ ((between A D c′ ∧ D c′ ≡ C D) ∧ (between A C d′ ∧ C d′ ≡ C D))</code>. We now turn to <code>b′</code>.
<jh>
        b′ A (value c′) C B SegmentConstruction
        d′ generalize
        c′ generalize

        introduceConjunction

        c′
          (∃ d′ (((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D))))
          (∀ d′ (∃ b′ ((between A (value c′) (value b′))
            ∧ ((value c′) (value b′) ≡ C B))))
          ThereExistsConjunctionRightCombining
        applyModusPonens

        d′
          (((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D)))
          (∃ b′ ((between A (value c′) (value b′))
            ∧ ((value c′) (value b′) ≡ C B)))
          ThereExistsConjunctionRightCombining
        c′ addThereExists
        applyModusPonens
</jh>
That gives us <code>∃ c′ ∃ d′ ((between A D c′ ∧ D c′ ≡ C D) ∧ (between A C d′ ∧ C d′ ≡ C D) ∧ ∃ b′ (between A c′ b′ ∧ c′ b′ ≡ C B))</code>. The next step is to move <code>∃ b′</code> to the front.
<jh>
        b′
          (((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D)))
          ((between A (value c′) (value b′))
            ∧ ((value c′) (value b′) ≡ C B))
          ThereExistsConjunctionMovement
        eliminateBiconditionalForward
        d′ addThereExists
        c′ addThereExists
        applyModusPonens
</jh>
Now we construct <code>b″</code>, which starts with <code>∃ b″ (between A d′ b″ ∧ A d′ ≡ D B)</code> and then moves the quantifiers to the front.
<jh>
        b″ A (value d′) D B SegmentConstruction

        introduceConjunction

        c′
          (∃ d′ (∃ b′
            ((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
              ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
              ((between A (value c′) (value b′))
                ∧ ((value c′) (value b′) ≡ C B)))
          ))
          (∃ b″ ((between A (value d′) (value b″)) ∧ (A (value d′) ≡ D B)))
          ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        applyModusPonens

        d′
          (∃ b′
            ((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
              ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
              ((between A (value c′) (value b′))
                ∧ ((value c′) (value b′) ≡ C B)))
          )
          (∃ b″ ((between A (value d′) (value b″)) ∧ (A (value d′) ≡ D B)))
          ThereExistsConjunctionRightMovement
        eliminateBiconditionalForward
        c′ addThereExists
        applyModusPonens

        b′ b″
          ((((between A D (value c′)) ∧ (D (value c′) ≡ C D)) ∧
            ((between A C (value d′)) ∧ (C (value d′) ≡ C D))) ∧
            ((between A (value c′) (value b′))
              ∧ ((value c′) (value b′) ≡ C B)))
          ((between A (value d′) (value b″)) ∧ (A (value d′) ≡ D B))
          ThereExistsScattering
        eliminateBiconditionalForward
        c′ addThereExists
        d′ addThereExists
        applyModusPonens
))
</jh>

== Under construction ==
{{under construction}}
A ≠ B ∧ between A B C ∧ between A B D →
  ∃ c′ ∃ d′ ∃ b′ ∃ b″ (stuff1)

(stuff1) → ∃ e (stuff2)
    between C e C′ ∧ between D e D′

(stuff2) ∧ C ≠ C′ → ∃ p ∃ q ∃ r (stuff3)

(stuff3) → D = D′

Want (stuff2) → (C ≠ C′ → D = D′)

== Export ==
We now export to [[Interface:Connectivity for betweenness]].
<jh>
#export (RESULTS Interface:Connectivity_for_betweenness (CLASSICAL FIRSTORDER) ())
</jh>

Also, since this page is currently the last in the (in-progress) series on basic geometry, we export to [[Interface:Basic geometry]].
<jh>
export (GEOMETRY Interface:Basic_geometry (CLASSICAL FIRSTORDER) ())
</jh>

== References ==
<references/>
* Tarski, Alfred; Givant, Steven (1999), "Tarski's system of geometry", The Bulletin of Symbolic Logic 5 (2): 175–214, doi:10.2307/421089, MR1791303, ISSN 1079-8986

{{DEFAULTSORT:{{PAGENAME}}}}
[[Category:Euclidean geometries (general) and generalizations]]
[[Category:Foundations of classical theories (including reverse mathematics)]]

